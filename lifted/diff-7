1c1
< ; ModuleID = 'tcg-llvm'
---
> ; ModuleID = 'lifted.bc'
3c3
< target triple = "x86_64-unknown-linux-gnu"
---
> target triple = "i386-unknown-linux-gnu"
51c51,52
< %union.anon.12 = type { i64 }
---
> %struct.float128 = type { i64, i64 }
> %struct.commonNaNT = type { i8, i64, i64 }
59,61d59
< @.str = private unnamed_addr constant [4 x i8] c"inb\00", align 1
< @.str1 = private unnamed_addr constant [4 x i8] c"inw\00", align 1
< @.str2 = private unnamed_addr constant [4 x i8] c"inl\00", align 1
63d60
< @s2e_do_interrupt_all.count = internal unnamed_addr global i32 0, align 4
65,69d61
< @.str3 = private unnamed_addr constant [65 x i8] c"%6d: v=%02x e=%04x i=%d cpl=%d IP=%04x:%08x pc=%08x SP=%04x:%08x\00", align 1
< @.str4 = private unnamed_addr constant [10 x i8] c" CR2=%08x\00", align 1
< @.str5 = private unnamed_addr constant [10 x i8] c" EAX=%08x\00", align 1
< @.str7 = private unnamed_addr constant [12 x i8] c"SMM: enter\0A\00", align 1
< @.str8 = private unnamed_addr constant [16 x i8] c"SMM: after RSM\0A\00", align 1
71,72d62
< @fcom_ccval = internal unnamed_addr constant [4 x i32] [i32 256, i32 16384, i32 0, i32 17664], align 16
< @fcomi_ccval = internal unnamed_addr constant [4 x i32] [i32 1, i32 64, i32 0, i32 69], align 16
80,88d69
< @.str10 = private unnamed_addr constant [13 x i8] c"vmrun! %08x\0A\00", align 1
< @.str11 = private unnamed_addr constant [18 x i8] c"Injecting(%#hx): \00", align 1
< @.str12 = private unnamed_addr constant [5 x i8] c"INTR\00", align 1
< @.str13 = private unnamed_addr constant [4 x i8] c"NMI\00", align 1
< @.str14 = private unnamed_addr constant [6 x i8] c"EXEPT\00", align 1
< @.str15 = private unnamed_addr constant [5 x i8] c"SOFT\00", align 1
< @.str16 = private unnamed_addr constant [10 x i8] c" %#x %#x\0A\00", align 1
< @.str17 = private unnamed_addr constant [32 x i8] c"vmload! %08x\0AFS: %016lx | %08x\0A\00", align 1
< @.str18 = private unnamed_addr constant [32 x i8] c"vmsave! %08x\0AFS: %016lx | %08x\0A\00", align 1
90,91d70
< @rclb_table = external constant [32 x i8]
< @rclw_table = external constant [32 x i8]
93d71
< @.str20 = private unnamed_addr constant [12 x i8] c"invalid tss\00", align 1
96c74,81
< @switch.table = private unnamed_addr constant [10 x i32] [i32 1, i32 0, i32 1, i32 1, i32 1, i32 1, i32 1, i32 0, i32 0, i32 1]
---
> @float16_default_nan = constant i16 -512, align 2
> @float32_default_nan = constant i32 -4194304, align 4
> @float64_default_nan = constant i64 -2251799813685248, align 8
> @floatx80_default_nan = constant %struct.floatx80 <{ i64 -4611686018427387904, i16 -1 }>, align 1
> @float128_default_nan = constant %struct.float128 { i64 0, i64 -140737488355328 }, align 4
> @float32_exp2_coefficients = internal constant [15 x i64] [i64 4607182418800017408, i64 4602678819172646912, i64 4595172819793696085, i64 4586165620538955093, i64 4575957461383581969, i64 4564047942368979991, i64 4551452160554016794, i64 4537941361671905306, i64 4523617214285662004, i64 4508805057796939612, i64 4493156764026750180, i64 4477122120089393304, i64 4460272573143870729, i64 4443145680587881629, i64 4425604618586929183], align 4
> @estimateSqrt32.sqrtOddAdjustments = internal constant [16 x i16] [i16 4, i16 34, i16 93, i16 177, i16 285, i16 415, i16 566, i16 736, i16 924, i16 1128, i16 1349, i16 1585, i16 1835, i16 2098, i16 2374, i16 2663], align 2
> @estimateSqrt32.sqrtEvenAdjustments = internal constant [16 x i16] [i16 2605, i16 2223, i16 1882, i16 1577, i16 1306, i16 1065, i16 854, i16 670, i16 512, i16 377, i16 265, i16 175, i16 104, i16 52, i16 18, i16 2], align 2
98,155c83
< define void @uint32_to_string(i32 %n, i8* nocapture %str) nounwind uwtable {
<   %1 = lshr i32 %n, 28
<   %2 = zext i32 %1 to i64
<   %3 = getelementptr inbounds [16 x i8]* @hextable, i64 0, i64 %2
<   %4 = load i8* %3, align 1
<   store i8 %4, i8* %str, align 1
<   %5 = lshr i32 %n, 24
<   %6 = and i32 %5, 15
<   %7 = zext i32 %6 to i64
<   %8 = getelementptr inbounds [16 x i8]* @hextable, i64 0, i64 %7
<   %9 = load i8* %8, align 1
<   %10 = getelementptr inbounds i8* %str, i64 1
<   store i8 %9, i8* %10, align 1
<   %11 = lshr i32 %n, 20
<   %12 = and i32 %11, 15
<   %13 = zext i32 %12 to i64
<   %14 = getelementptr inbounds [16 x i8]* @hextable, i64 0, i64 %13
<   %15 = load i8* %14, align 1
<   %16 = getelementptr inbounds i8* %str, i64 2
<   store i8 %15, i8* %16, align 1
<   %17 = lshr i32 %n, 16
<   %18 = and i32 %17, 15
<   %19 = zext i32 %18 to i64
<   %20 = getelementptr inbounds [16 x i8]* @hextable, i64 0, i64 %19
<   %21 = load i8* %20, align 1
<   %22 = getelementptr inbounds i8* %str, i64 3
<   store i8 %21, i8* %22, align 1
<   %23 = lshr i32 %n, 12
<   %24 = and i32 %23, 15
<   %25 = zext i32 %24 to i64
<   %26 = getelementptr inbounds [16 x i8]* @hextable, i64 0, i64 %25
<   %27 = load i8* %26, align 1
<   %28 = getelementptr inbounds i8* %str, i64 4
<   store i8 %27, i8* %28, align 1
<   %29 = lshr i32 %n, 8
<   %30 = and i32 %29, 15
<   %31 = zext i32 %30 to i64
<   %32 = getelementptr inbounds [16 x i8]* @hextable, i64 0, i64 %31
<   %33 = load i8* %32, align 1
<   %34 = getelementptr inbounds i8* %str, i64 5
<   store i8 %33, i8* %34, align 1
<   %35 = lshr i32 %n, 4
<   %36 = and i32 %35, 15
<   %37 = zext i32 %36 to i64
<   %38 = getelementptr inbounds [16 x i8]* @hextable, i64 0, i64 %37
<   %39 = load i8* %38, align 1
<   %40 = getelementptr inbounds i8* %str, i64 6
<   store i8 %39, i8* %40, align 1
<   %41 = and i32 %n, 15
<   %42 = zext i32 %41 to i64
<   %43 = getelementptr inbounds [16 x i8]* @hextable, i64 0, i64 %42
<   %44 = load i8* %43, align 1
<   %45 = getelementptr inbounds i8* %str, i64 7
<   store i8 %44, i8* %45, align 1
<   ret void
< }
< 
< define void @trace_port(i8* nocapture %buf, i8* nocapture %prefix, i32 %port, i32 %pc) nounwind uwtable {
---
> define internal void @trace_port(i8* nocapture %buf, i8* nocapture %prefix, i32 %port, i32 %pc) nounwind uwtable {
287,327c215
< define void @helper_write_eflags(i32 %t0, i32 %update_mask) nounwind uwtable {
<   %1 = and i32 %t0, 2261
<   %2 = load %struct.CPUX86State** @env, align 8
<   %3 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 2
<   store i32 %1, i32* %3, align 4
<   %4 = lshr i32 %t0, 9
<   %5 = and i32 %4, 2
<   %6 = xor i32 %5, 2
<   %7 = add i32 %6, -1
<   %8 = load %struct.CPUX86State** @env, align 8
<   %9 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 6
<   store i32 %7, i32* %9, align 4
<   %10 = load %struct.CPUX86State** @env, align 8
<   %11 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 7
<   %12 = load i32* %11, align 4
<   %13 = xor i32 %update_mask, -1
<   %14 = and i32 %12, %13
<   %15 = and i32 %t0, -3286
<   %16 = and i32 %15, %update_mask
<   %17 = or i32 %14, %16
<   store i32 %17, i32* %11, align 4
<   ret void
< }
< 
< define i32 @helper_read_eflags() nounwind uwtable readonly {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 6
<   %6 = load i32* %5, align 4
<   %7 = and i32 %6, 1024
<   %8 = or i32 %7, %4
<   %9 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 7
<   %10 = load i32* %9, align 4
<   %11 = and i32 %10, -196609
<   %12 = or i32 %8, %11
<   ret i32 %12
< }
< 
< define i32 @helper_cc_compute_all(i32 %op) nounwind uwtable readonly {
---
> define internal i32 @helper_cc_compute_all(i32 %op) nounwind uwtable readonly {
1257,1269c1145
< define void @helper_check_iob(i32 %t0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 3
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, 36608
<   %5 = icmp eq i32 %4, 35072
<   br i1 %5, label %6, label %31
< 
< ; <label>:6                                       ; preds = %0
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 2
<   %8 = load i32* %7, align 4
<   %9 = icmp ult i32 %8, 103
<   br i1 %9, label %31, label %10
---
> declare void @tcg_llvm_get_value(i8*, i32, i1 zeroext)
1271,1294c1147
< ; <label>:10                                      ; preds = %6
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 1
<   %12 = load i32* %11, align 4
<   %13 = add i32 %12, 102
<   %14 = tail call fastcc i32 @lduw_kernel(i32 %13) nounwind
<   %15 = ashr i32 %t0, 3
<   %16 = add nsw i32 %14, %15
<   %17 = add nsw i32 %16, 1
<   %18 = load %struct.CPUX86State** @env, align 8
<   %19 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 12, i32 2
<   %20 = load i32* %19, align 4
<   %21 = icmp ugt i32 %17, %20
<   br i1 %21, label %31, label %22
< 
< ; <label>:22                                      ; preds = %10
<   %23 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 12, i32 1
<   %24 = load i32* %23, align 4
<   %25 = add i32 %24, %16
<   %26 = tail call fastcc i32 @lduw_kernel(i32 %25) nounwind
<   %27 = and i32 %t0, 7
<   %28 = shl i32 1, %27
<   %29 = and i32 %26, %28
<   %30 = icmp eq i32 %29, 0
<   br i1 %30, label %check_io.exit, label %31
---
> declare void @tcg_llvm_make_symbolic(i8*, i32, i8*)
1296,1298c1149
< ; <label>:31                                      ; preds = %22, %10, %6, %0
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn nounwind
<   unreachable
---
> declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture, ...) nounwind
1300,1302c1151
< check_io.exit:                                    ; preds = %22
<   ret void
< }
---
> declare i32 @ldl_phys(i64)
1304,1310c1153
< define void @helper_check_iow(i32 %t0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 3
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, 36608
<   %5 = icmp eq i32 %4, 35072
<   br i1 %5, label %6, label %31
---
> declare void @stl_phys(i64, i32)
1312,1316c1155
< ; <label>:6                                       ; preds = %0
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 2
<   %8 = load i32* %7, align 4
<   %9 = icmp ult i32 %8, 103
<   br i1 %9, label %31, label %10
---
> declare fastcc void @raise_interrupt(i32, i32, i32, i32) noreturn nounwind uwtable
1318,1341c1157
< ; <label>:10                                      ; preds = %6
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 1
<   %12 = load i32* %11, align 4
<   %13 = add i32 %12, 102
<   %14 = tail call fastcc i32 @lduw_kernel(i32 %13) nounwind
<   %15 = ashr i32 %t0, 3
<   %16 = add nsw i32 %14, %15
<   %17 = add nsw i32 %16, 1
<   %18 = load %struct.CPUX86State** @env, align 8
<   %19 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 12, i32 2
<   %20 = load i32* %19, align 4
<   %21 = icmp ugt i32 %17, %20
<   br i1 %21, label %31, label %22
< 
< ; <label>:22                                      ; preds = %10
<   %23 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 12, i32 1
<   %24 = load i32* %23, align 4
<   %25 = add i32 %24, %16
<   %26 = tail call fastcc i32 @lduw_kernel(i32 %25) nounwind
<   %27 = and i32 %t0, 7
<   %28 = ashr i32 %26, %27
<   %29 = and i32 %28, 3
<   %30 = icmp eq i32 %29, 0
<   br i1 %30, label %check_io.exit, label %31
---
> declare void @cpu_x86_update_cr0(%struct.CPUX86State*, i32)
1343,1345c1159
< ; <label>:31                                      ; preds = %22, %10, %6, %0
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn nounwind
<   unreachable
---
> declare void @cpu_x86_update_cr4(%struct.CPUX86State*, i32)
1347,1349c1161
< check_io.exit:                                    ; preds = %22
<   ret void
< }
---
> declare void @cpu_x86_update_cr3(%struct.CPUX86State*, i32)
1351c1163
< define void @helper_check_iol(i32 %t0) nounwind uwtable {
---
> define internal void @helper_svm_check_intercept_param(i32 %type, i64 %param) nounwind uwtable {
1353c1165
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 3
---
>   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
1355,1357c1167,1169
<   %4 = and i32 %3, 36608
<   %5 = icmp eq i32 %4, 35072
<   br i1 %5, label %6, label %31
---
>   %.lobit = and i32 %3, 2097152
>   %4 = icmp eq i32 %.lobit, 0
>   br i1 %4, label %101, label %5, !prof !0
1359,1363c1171,1240
< ; <label>:6                                       ; preds = %0
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 2
<   %8 = load i32* %7, align 4
<   %9 = icmp ult i32 %8, 103
<   br i1 %9, label %31, label %10
---
> ; <label>:5                                       ; preds = %0
>   switch i32 %type, label %92 [
>     i32 0, label %6
>     i32 1, label %6
>     i32 2, label %6
>     i32 3, label %6
>     i32 4, label %6
>     i32 5, label %6
>     i32 6, label %6
>     i32 7, label %6
>     i32 8, label %6
>     i32 16, label %14
>     i32 17, label %14
>     i32 18, label %14
>     i32 19, label %14
>     i32 20, label %14
>     i32 21, label %14
>     i32 22, label %14
>     i32 23, label %14
>     i32 24, label %14
>     i32 32, label %23
>     i32 33, label %23
>     i32 34, label %23
>     i32 35, label %23
>     i32 36, label %23
>     i32 37, label %23
>     i32 38, label %23
>     i32 39, label %23
>     i32 48, label %32
>     i32 49, label %32
>     i32 50, label %32
>     i32 51, label %32
>     i32 52, label %32
>     i32 53, label %32
>     i32 54, label %32
>     i32 55, label %32
>     i32 64, label %41
>     i32 65, label %41
>     i32 66, label %41
>     i32 67, label %41
>     i32 68, label %41
>     i32 69, label %41
>     i32 70, label %41
>     i32 71, label %41
>     i32 72, label %41
>     i32 73, label %41
>     i32 74, label %41
>     i32 75, label %41
>     i32 76, label %41
>     i32 77, label %41
>     i32 78, label %41
>     i32 79, label %41
>     i32 80, label %41
>     i32 81, label %41
>     i32 82, label %41
>     i32 83, label %41
>     i32 84, label %41
>     i32 85, label %41
>     i32 86, label %41
>     i32 87, label %41
>     i32 88, label %41
>     i32 89, label %41
>     i32 90, label %41
>     i32 91, label %41
>     i32 92, label %41
>     i32 93, label %41
>     i32 94, label %41
>     i32 95, label %41
>     i32 124, label %49
>   ]
1365,1388c1242,1249
< ; <label>:10                                      ; preds = %6
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 1
<   %12 = load i32* %11, align 4
<   %13 = add i32 %12, 102
<   %14 = tail call fastcc i32 @lduw_kernel(i32 %13) nounwind
<   %15 = ashr i32 %t0, 3
<   %16 = add nsw i32 %14, %15
<   %17 = add nsw i32 %16, 1
<   %18 = load %struct.CPUX86State** @env, align 8
<   %19 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 12, i32 2
<   %20 = load i32* %19, align 4
<   %21 = icmp ugt i32 %17, %20
<   br i1 %21, label %31, label %22
< 
< ; <label>:22                                      ; preds = %10
<   %23 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 12, i32 1
<   %24 = load i32* %23, align 4
<   %25 = add i32 %24, %16
<   %26 = tail call fastcc i32 @lduw_kernel(i32 %25) nounwind
<   %27 = and i32 %t0, 7
<   %28 = ashr i32 %26, %27
<   %29 = and i32 %28, 15
<   %30 = icmp eq i32 %29, 0
<   br i1 %30, label %check_io.exit, label %31
---
> ; <label>:6                                       ; preds = %5, %5, %5, %5, %5, %5, %5, %5, %5
>   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 42
>   %8 = load i16* %7, align 2
>   %9 = zext i16 %8 to i32
>   %10 = shl i32 1, %type
>   %11 = and i32 %9, %10
>   %12 = icmp eq i32 %11, 0
>   br i1 %12, label %101, label %13
1390,1391c1251,1252
< ; <label>:31                                      ; preds = %22, %10, %6, %0
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn nounwind
---
> ; <label>:13                                      ; preds = %6
>   tail call void @helper_vmexit(i32 %type, i64 %param)
1394,1396c1255,1263
< check_io.exit:                                    ; preds = %22
<   ret void
< }
---
> ; <label>:14                                      ; preds = %5, %5, %5, %5, %5, %5, %5, %5, %5
>   %15 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 43
>   %16 = load i16* %15, align 2
>   %17 = zext i16 %16 to i32
>   %18 = add i32 %type, -16
>   %19 = shl i32 1, %18
>   %20 = and i32 %17, %19
>   %21 = icmp eq i32 %20, 0
>   br i1 %21, label %101, label %22
1398,1405c1265,1267
< define void @helper_outb(i32 %port, i32 %data) nounwind uwtable {
<   %1 = alloca i32, align 4
<   %2 = alloca i32, align 4
<   store i32 %port, i32* %1, align 4
<   store i32 %data, i32* %2, align 4
<   %3 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %4 = icmp eq i32 %3, 0
<   br i1 %4, label %7, label %5
---
> ; <label>:22                                      ; preds = %14
>   tail call void @helper_vmexit(i32 %type, i64 %param)
>   unreachable
1407,1426c1269,1277
< ; <label>:5                                       ; preds = %0
<   %6 = bitcast i32* %1 to i8*
<   call void @tcg_llvm_get_value(i8* %6, i32 4, i1 zeroext false) nounwind
<   %.pre = load i32* %1, align 4
<   %.pre1 = load i32* %2, align 4
<   br label %7
< 
< ; <label>:7                                       ; preds = %5, %0
<   %8 = phi i32 [ %data, %0 ], [ %.pre1, %5 ]
<   %9 = phi i32 [ %port, %0 ], [ %.pre, %5 ]
<   %10 = zext i32 %9 to i64
<   %11 = zext i32 %8 to i64
<   call void @tcg_llvm_trace_port_access(i64 %10, i64 %11, i32 8, i32 1) nounwind
<   %12 = load %struct.S2E** @g_s2e, align 8
<   %13 = load %struct.S2EExecutionState** @g_s2e_state, align 8
<   %14 = load i32* %1, align 4
<   %15 = zext i32 %14 to i64
<   %16 = call i32 @s2e_is_port_symbolic(%struct.S2E* %12, %struct.S2EExecutionState* %13, i64 %15) nounwind
<   %17 = icmp eq i32 %16, 0
<   br i1 %17, label %18, label %28
---
> ; <label>:23                                      ; preds = %5, %5, %5, %5, %5, %5, %5, %5
>   %24 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 44
>   %25 = load i16* %24, align 2
>   %26 = zext i16 %25 to i32
>   %27 = add i32 %type, -32
>   %28 = shl i32 1, %27
>   %29 = and i32 %26, %28
>   %30 = icmp eq i32 %29, 0
>   br i1 %30, label %101, label %31
1428,1431c1279,1281
< ; <label>:18                                      ; preds = %7
<   %19 = load i32* @g_s2e_concretize_io_writes, align 4
<   %20 = icmp eq i32 %19, 0
<   br i1 %20, label %24, label %21
---
> ; <label>:31                                      ; preds = %23
>   tail call void @helper_vmexit(i32 %type, i64 %param)
>   unreachable
1433,1439c1283,1291
< ; <label>:21                                      ; preds = %18
<   %22 = and i32 %8, 255
<   store i32 %22, i32* %2, align 4
<   %23 = bitcast i32* %2 to i8*
<   call void @tcg_llvm_get_value(i8* %23, i32 4, i1 zeroext false) nounwind
<   %.pre2 = load i32* %2, align 4
<   br label %24
---
> ; <label>:32                                      ; preds = %5, %5, %5, %5, %5, %5, %5, %5
>   %33 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 45
>   %34 = load i16* %33, align 2
>   %35 = zext i16 %34 to i32
>   %36 = add i32 %type, -48
>   %37 = shl i32 1, %36
>   %38 = and i32 %35, %37
>   %39 = icmp eq i32 %38, 0
>   br i1 %39, label %101, label %40
1441,1446c1293,1295
< ; <label>:24                                      ; preds = %21, %18
<   %25 = phi i32 [ %8, %18 ], [ %.pre2, %21 ]
<   %26 = load i32* %1, align 4
<   %27 = trunc i32 %25 to i8
<   call void @cpu_outb(i32 %26, i8 zeroext %27) nounwind
<   br label %28
---
> ; <label>:40                                      ; preds = %32
>   tail call void @helper_vmexit(i32 %type, i64 %param)
>   unreachable
1448,1450c1297,1304
< ; <label>:28                                      ; preds = %24, %7
<   ret void
< }
---
> ; <label>:41                                      ; preds = %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5
>   %42 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 46
>   %43 = load i32* %42, align 4
>   %44 = add i32 %type, -64
>   %45 = shl i32 1, %44
>   %46 = and i32 %43, %45
>   %47 = icmp eq i32 %46, 0
>   br i1 %47, label %101, label %48
1452c1306,1308
< declare void @tcg_llvm_get_value(i8*, i32, i1 zeroext)
---
> ; <label>:48                                      ; preds = %41
>   tail call void @helper_vmexit(i32 %type, i64 %param)
>   unreachable
1454c1310,1315
< declare void @tcg_llvm_trace_port_access(i64, i64, i32, i32)
---
> ; <label>:49                                      ; preds = %5
>   %50 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
>   %51 = load i64* %50, align 8
>   %52 = and i64 %51, 268435456
>   %53 = icmp eq i64 %52, 0
>   br i1 %53, label %101, label %54
1456c1317,1327
< declare i32 @s2e_is_port_symbolic(%struct.S2E*, %struct.S2EExecutionState*, i64)
---
> ; <label>:54                                      ; preds = %49
>   %55 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 39
>   %56 = load i64* %55, align 8
>   %57 = add i64 %56, 72
>   %58 = tail call i64 @ldq_phys(i64 %57) nounwind
>   %59 = load %struct.CPUX86State** @env, align 8
>   %60 = getelementptr inbounds %struct.CPUX86State* %59, i64 0, i32 0, i64 1
>   %61 = load i32* %60, align 4
>   %62 = add i32 %61, 1073676288
>   %63 = icmp ult i32 %62, 8192
>   br i1 %63, label %77, label %74
1458c1329,1333
< declare void @cpu_outb(i32, i8 zeroext)
---
> ; <label>:64                                      ; preds = %68
>   %65 = shl i32 %61, 1
>   %66 = lshr i32 %61, 2
>   %67 = and i32 %66, 536870911
>   br label %82
1460,1467c1335,1337
< define i32 @helper_inb(i32 %port) nounwind uwtable {
<   %1 = alloca i32, align 4
<   %label = alloca [64 x i8], align 16
<   %res = alloca i8, align 1
<   store i32 %port, i32* %1, align 4
<   %2 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %3 = icmp eq i32 %2, 0
<   br i1 %3, label %6, label %4
---
> ; <label>:68                                      ; preds = %74
>   %69 = icmp ult i32 %61, 8192
>   br i1 %69, label %64, label %81
1469,1473c1339,1343
< ; <label>:4                                       ; preds = %0
<   %5 = bitcast i32* %1 to i8*
<   call void @tcg_llvm_get_value(i8* %5, i32 4, i1 zeroext false) nounwind
<   %.pre = load i32* %1, align 4
<   br label %6
---
> ; <label>:70                                      ; preds = %74
>   %71 = shl i32 %61, 1
>   %72 = add i32 %71, -2147467264
>   %73 = lshr i32 %72, 3
>   br label %82
1475,1482c1345,1348
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i32 [ %port, %0 ], [ %.pre, %4 ]
<   %8 = load %struct.S2E** @g_s2e, align 8
<   %9 = load %struct.S2EExecutionState** @g_s2e_state, align 8
<   %10 = zext i32 %7 to i64
<   %11 = call i32 @s2e_is_port_symbolic(%struct.S2E* %8, %struct.S2EExecutionState* %9, i64 %10) nounwind
<   %12 = icmp eq i32 %11, 0
<   br i1 %12, label %24, label %13
---
> ; <label>:74                                      ; preds = %54
>   %75 = add i32 %61, 1073741824
>   %76 = icmp ult i32 %75, 8192
>   br i1 %76, label %70, label %68
1484,1517c1350,1354
< ; <label>:13                                      ; preds = %6
<   %14 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %15 = load i32* %1, align 4
<   %16 = load %struct.CPUX86State** @env, align 8
<   %17 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 5
<   %18 = load i32* %17, align 4
<   call void @trace_port(i8* %14, i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %15, i32 %18)
<   call void @tcg_llvm_make_symbolic(i8* %res, i32 1, i8* %14) nounwind
<   %19 = load i32* %1, align 4
<   %20 = zext i32 %19 to i64
<   %21 = load i8* %res, align 1
<   %22 = zext i8 %21 to i64
<   call void @tcg_llvm_trace_port_access(i64 %20, i64 %22, i32 8, i32 0) nounwind
<   %23 = load i8* %res, align 1
<   br label %30
< 
< ; <label>:24                                      ; preds = %6
<   %25 = load i32* %1, align 4
<   %26 = call zeroext i8 @cpu_inb(i32 %25) nounwind
<   %27 = load i32* %1, align 4
<   %28 = zext i32 %27 to i64
<   %29 = zext i8 %26 to i64
<   call void @tcg_llvm_trace_port_access(i64 %28, i64 %29, i32 8, i32 0) nounwind
<   br label %30
< 
< ; <label>:30                                      ; preds = %24, %13
<   %.0.in = phi i8 [ %23, %13 ], [ %26, %24 ]
<   %.0 = zext i8 %.0.in to i32
<   ret i32 %.0
< }
< 
< declare void @tcg_llvm_make_symbolic(i8*, i32, i8*)
< 
< declare zeroext i8 @cpu_inb(i32)
---
> ; <label>:77                                      ; preds = %54
>   %78 = shl i32 %61, 1
>   %79 = add i32 %78, 2147385344
>   %80 = lshr i32 %79, 3
>   br label %82
1519,1526c1356,1358
< define void @helper_outw(i32 %port, i32 %data) nounwind uwtable {
<   %1 = alloca i32, align 4
<   %2 = alloca i32, align 4
<   store i32 %port, i32* %1, align 4
<   store i32 %data, i32* %2, align 4
<   %3 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %4 = icmp eq i32 %3, 0
<   br i1 %4, label %7, label %5
---
> ; <label>:81                                      ; preds = %68
>   tail call void @helper_vmexit(i32 124, i64 %param)
>   unreachable
1528,1547c1360,1372
< ; <label>:5                                       ; preds = %0
<   %6 = bitcast i32* %1 to i8*
<   call void @tcg_llvm_get_value(i8* %6, i32 4, i1 zeroext false) nounwind
<   %.pre = load i32* %1, align 4
<   %.pre1 = load i32* %2, align 4
<   br label %7
< 
< ; <label>:7                                       ; preds = %5, %0
<   %8 = phi i32 [ %data, %0 ], [ %.pre1, %5 ]
<   %9 = phi i32 [ %port, %0 ], [ %.pre, %5 ]
<   %10 = zext i32 %9 to i64
<   %11 = zext i32 %8 to i64
<   call void @tcg_llvm_trace_port_access(i64 %10, i64 %11, i32 16, i32 1) nounwind
<   %12 = load %struct.S2E** @g_s2e, align 8
<   %13 = load %struct.S2EExecutionState** @g_s2e_state, align 8
<   %14 = load i32* %1, align 4
<   %15 = zext i32 %14 to i64
<   %16 = call i32 @s2e_is_port_symbolic(%struct.S2E* %12, %struct.S2EExecutionState* %13, i64 %15) nounwind
<   %17 = icmp eq i32 %16, 0
<   br i1 %17, label %18, label %28
---
> ; <label>:82                                      ; preds = %77, %70, %64
>   %t0.0.in = phi i32 [ %79, %77 ], [ %72, %70 ], [ %65, %64 ]
>   %t1.0 = phi i32 [ %80, %77 ], [ %73, %70 ], [ %67, %64 ]
>   %t0.0 = and i32 %t0.0.in, 6
>   %83 = zext i32 %t1.0 to i64
>   %84 = add i64 %83, %58
>   %85 = tail call i32 @ldub_phys(i64 %84) nounwind
>   %86 = trunc i64 %param to i32
>   %87 = shl i32 1, %86
>   %88 = shl i32 %87, %t0.0
>   %89 = and i32 %85, %88
>   %90 = icmp eq i32 %89, 0
>   br i1 %90, label %101, label %91
1549,1552c1374,1376
< ; <label>:18                                      ; preds = %7
<   %19 = load i32* @g_s2e_concretize_io_writes, align 4
<   %20 = icmp eq i32 %19, 0
<   br i1 %20, label %24, label %21
---
> ; <label>:91                                      ; preds = %82
>   tail call void @helper_vmexit(i32 124, i64 %param)
>   unreachable
1554,1560c1378,1386
< ; <label>:21                                      ; preds = %18
<   %22 = and i32 %8, 65535
<   store i32 %22, i32* %2, align 4
<   %23 = bitcast i32* %2 to i8*
<   call void @tcg_llvm_get_value(i8* %23, i32 4, i1 zeroext false) nounwind
<   %.pre2 = load i32* %2, align 4
<   br label %24
---
> ; <label>:92                                      ; preds = %5
>   %93 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
>   %94 = load i64* %93, align 8
>   %95 = add i32 %type, -96
>   %96 = zext i32 %95 to i64
>   %97 = shl i64 1, %96
>   %98 = and i64 %94, %97
>   %99 = icmp eq i64 %98, 0
>   br i1 %99, label %101, label %100
1562,1567c1388,1390
< ; <label>:24                                      ; preds = %21, %18
<   %25 = phi i32 [ %8, %18 ], [ %.pre2, %21 ]
<   %26 = load i32* %1, align 4
<   %27 = trunc i32 %25 to i16
<   call void @cpu_outw(i32 %26, i16 zeroext %27) nounwind
<   br label %28
---
> ; <label>:100                                     ; preds = %92
>   tail call void @helper_vmexit(i32 %type, i64 %param)
>   unreachable
1569c1392
< ; <label>:28                                      ; preds = %24, %7
---
> ; <label>:101                                     ; preds = %92, %82, %49, %41, %32, %23, %14, %6, %0
1573,1588c1396,1399
< declare void @cpu_outw(i32, i16 zeroext)
< 
< define i32 @helper_inw(i32 %port) nounwind uwtable {
<   %1 = alloca i32, align 4
<   %label = alloca [64 x i8], align 16
<   %res = alloca i16, align 2
<   store i32 %port, i32* %1, align 4
<   %2 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %3 = icmp eq i32 %2, 0
<   br i1 %3, label %6, label %4
< 
< ; <label>:4                                       ; preds = %0
<   %5 = bitcast i32* %1 to i8*
<   call void @tcg_llvm_get_value(i8* %5, i32 4, i1 zeroext false) nounwind
<   %.pre = load i32* %1, align 4
<   br label %6
---
> define internal fastcc void @raise_exception_err(i32 %exception_index, i32 %error_code) noreturn nounwind uwtable {
>   tail call fastcc void @raise_interrupt(i32 %exception_index, i32 0, i32 %error_code, i32 0) noreturn
>   unreachable
> }
1590,1597c1401
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i32 [ %port, %0 ], [ %.pre, %4 ]
<   %8 = load %struct.S2E** @g_s2e, align 8
<   %9 = load %struct.S2EExecutionState** @g_s2e_state, align 8
<   %10 = zext i32 %7 to i64
<   %11 = call i32 @s2e_is_port_symbolic(%struct.S2E* %8, %struct.S2EExecutionState* %9, i64 %10) nounwind
<   %12 = icmp eq i32 %11, 0
<   br i1 %12, label %25, label %13
---
> declare void @cpu_loop_exit(%struct.CPUX86State*) noreturn
1599,1614c1403
< ; <label>:13                                      ; preds = %6
<   %14 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %15 = load i32* %1, align 4
<   %16 = load %struct.CPUX86State** @env, align 8
<   %17 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 5
<   %18 = load i32* %17, align 4
<   call void @trace_port(i8* %14, i8* getelementptr inbounds ([4 x i8]* @.str1, i64 0, i64 0), i32 %15, i32 %18)
<   %19 = bitcast i16* %res to i8*
<   call void @tcg_llvm_make_symbolic(i8* %19, i32 2, i8* %14) nounwind
<   %20 = load i32* %1, align 4
<   %21 = zext i32 %20 to i64
<   %22 = load i16* %res, align 2
<   %23 = zext i16 %22 to i64
<   call void @tcg_llvm_trace_port_access(i64 %21, i64 %23, i32 16, i32 0) nounwind
<   %24 = load i16* %res, align 2
<   br label %31
---
> declare %struct.MemoryRegion* @iotlb_to_region(i64)
1616,1623c1405
< ; <label>:25                                      ; preds = %6
<   %26 = load i32* %1, align 4
<   %27 = call zeroext i16 @cpu_inw(i32 %26) nounwind
<   %28 = load i32* %1, align 4
<   %29 = zext i32 %28 to i64
<   %30 = zext i16 %27 to i64
<   call void @tcg_llvm_trace_port_access(i64 %29, i64 %30, i32 16, i32 0) nounwind
<   br label %31
---
> declare i32 @s2e_is_mmio_symbolic_b(i64)
1625,1629c1407
< ; <label>:31                                      ; preds = %25, %13
<   %.0.in = phi i16 [ %24, %13 ], [ %27, %25 ]
<   %.0 = zext i16 %.0.in to i32
<   ret i32 %.0
< }
---
> declare void @cpu_io_recompile(%struct.CPUX86State*, i8*) noreturn
1631c1409
< declare zeroext i16 @cpu_inw(i32)
---
> declare i32 @s2e_ismemfunc(%struct.MemoryRegion*, i32)
1633,1640c1411
< define void @helper_outl(i32 %port, i32 %data) nounwind uwtable {
<   %1 = alloca i32, align 4
<   %2 = alloca i32, align 4
<   store i32 %port, i32* %1, align 4
<   store i32 %data, i32* %2, align 4
<   %3 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %4 = icmp eq i32 %3, 0
<   br i1 %4, label %7, label %5
---
> declare i64 @s2e_notdirty_mem_write(i64)
1642,1661c1413
< ; <label>:5                                       ; preds = %0
<   %6 = bitcast i32* %1 to i8*
<   call void @tcg_llvm_get_value(i8* %6, i32 4, i1 zeroext false) nounwind
<   %.pre = load i32* %1, align 4
<   %.pre1 = load i32* %2, align 4
<   br label %7
< 
< ; <label>:7                                       ; preds = %5, %0
<   %8 = phi i32 [ %data, %0 ], [ %.pre1, %5 ]
<   %9 = phi i32 [ %port, %0 ], [ %.pre, %5 ]
<   %10 = zext i32 %9 to i64
<   %11 = zext i32 %8 to i64
<   call void @tcg_llvm_trace_port_access(i64 %10, i64 %11, i32 32, i32 1) nounwind
<   %12 = load %struct.S2E** @g_s2e, align 8
<   %13 = load %struct.S2EExecutionState** @g_s2e_state, align 8
<   %14 = load i32* %1, align 4
<   %15 = zext i32 %14 to i64
<   %16 = call i32 @s2e_is_port_symbolic(%struct.S2E* %12, %struct.S2EExecutionState* %13, i64 %15) nounwind
<   %17 = icmp eq i32 %16, 0
<   br i1 %17, label %18, label %26
---
> declare i64 @tcg_llvm_fork_and_concretize(i64, i64, i64)
1663,1666c1415
< ; <label>:18                                      ; preds = %7
<   %19 = load i32* @g_s2e_concretize_io_writes, align 4
<   %20 = icmp eq i32 %19, 0
<   br i1 %20, label %23, label %21
---
> declare void @tcg_llvm_trace_memory_access(i64, i64, i64, i32, i8 zeroext, i8 zeroext)
1668,1672c1417,1425
< ; <label>:21                                      ; preds = %18
<   %22 = bitcast i32* %2 to i8*
<   call void @tcg_llvm_get_value(i8* %22, i32 4, i1 zeroext false) nounwind
<   %.pre2 = load i32* %2, align 4
<   br label %23
---
> define internal void @tlb_fill(%struct.CPUX86State* %env1, i32 %addr, i32 %page_addr, i32 %is_write, i32 %mmu_idx, i8* %retaddr) nounwind uwtable {
>   %1 = load %struct.S2E** @g_s2e, align 8
>   %2 = load %struct.S2EExecutionState** @g_s2e_state, align 8
>   %3 = zext i32 %addr to i64
>   tail call void @s2e_on_tlb_miss(%struct.S2E* %1, %struct.S2EExecutionState* %2, i64 %3, i32 %is_write) nounwind
>   %4 = load %struct.CPUX86State** @env, align 8
>   %5 = tail call i32 @cpu_x86_handle_mmu_fault(%struct.CPUX86State* %4, i32 %page_addr, i32 %is_write, i32 %mmu_idx) nounwind
>   %6 = icmp eq i32 %5, 0
>   br i1 %6, label %39, label %7
1674,1678c1427,1432
< ; <label>:23                                      ; preds = %21, %18
<   %24 = phi i32 [ %8, %18 ], [ %.pre2, %21 ]
<   %25 = load i32* %1, align 4
<   call void @cpu_outl(i32 %25, i32 %24) nounwind
<   br label %26
---
> ; <label>:7                                       ; preds = %0
>   %8 = load %struct.CPUX86State** @env, align 8
>   %9 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 92
>   %10 = load i32* %9, align 4
>   %11 = icmp eq i32 %10, 14
>   br i1 %11, label %12, label %23
1680,1682c1434,1439
< ; <label>:26                                      ; preds = %23, %7
<   ret void
< }
---
> ; <label>:12                                      ; preds = %7
>   %13 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 46
>   %14 = load i32* %13, align 4
>   %15 = and i32 %14, 16384
>   %16 = icmp eq i32 %15, 0
>   br i1 %16, label %21, label %17
1684c1441,1446
< declare void @cpu_outl(i32, i32)
---
> ; <label>:17                                      ; preds = %12
>   %18 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 39
>   %19 = load i64* %18, align 8
>   %20 = add i64 %19, 128
>   tail call void @stq_phys(i64 %20, i64 %3) nounwind
>   br label %23
1686,1693c1448,1451
< define i32 @helper_inl(i32 %port) nounwind uwtable {
<   %1 = alloca i32, align 4
<   %label = alloca [64 x i8], align 16
<   %res = alloca i32, align 4
<   store i32 %port, i32* %1, align 4
<   %2 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %3 = icmp eq i32 %2, 0
<   br i1 %3, label %6, label %4
---
> ; <label>:21                                      ; preds = %12
>   %22 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 15, i64 2
>   store i32 %addr, i32* %22, align 4
>   br label %23
1695,1699c1453,1455
< ; <label>:4                                       ; preds = %0
<   %5 = bitcast i32* %1 to i8*
<   call void @tcg_llvm_get_value(i8* %5, i32 4, i1 zeroext false) nounwind
<   %.pre = load i32* %1, align 4
<   br label %6
---
> ; <label>:23                                      ; preds = %21, %17, %7
>   %24 = icmp eq i8* %retaddr, null
>   br i1 %24, label %31, label %25
1701,1708c1457,1461
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i32 [ %port, %0 ], [ %.pre, %4 ]
<   %8 = load %struct.S2E** @g_s2e, align 8
<   %9 = load %struct.S2EExecutionState** @g_s2e_state, align 8
<   %10 = zext i32 %7 to i64
<   %11 = call i32 @s2e_is_port_symbolic(%struct.S2E* %8, %struct.S2EExecutionState* %9, i64 %10) nounwind
<   %12 = icmp eq i32 %11, 0
<   br i1 %12, label %25, label %13
---
> ; <label>:25                                      ; preds = %23
>   %26 = ptrtoint i8* %retaddr to i64
>   %27 = tail call %struct.TranslationBlock* @tb_find_pc(i64 %26) nounwind
>   %28 = icmp eq %struct.TranslationBlock* %27, null
>   br i1 %28, label %31, label %29
1710,1724c1463,1464
< ; <label>:13                                      ; preds = %6
<   %14 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %15 = load i32* %1, align 4
<   %16 = load %struct.CPUX86State** @env, align 8
<   %17 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 5
<   %18 = load i32* %17, align 4
<   call void @trace_port(i8* %14, i8* getelementptr inbounds ([4 x i8]* @.str2, i64 0, i64 0), i32 %15, i32 %18)
<   %19 = bitcast i32* %res to i8*
<   call void @tcg_llvm_make_symbolic(i8* %19, i32 4, i8* %14) nounwind
<   %20 = load i32* %1, align 4
<   %21 = zext i32 %20 to i64
<   %22 = load i32* %res, align 4
<   %23 = zext i32 %22 to i64
<   call void @tcg_llvm_trace_port_access(i64 %21, i64 %23, i32 32, i32 0) nounwind
<   %24 = load i32* %res, align 4
---
> ; <label>:29                                      ; preds = %25
>   %30 = tail call i32 @cpu_restore_state(%struct.TranslationBlock* %27, %struct.CPUX86State* %env1, i64 %26) nounwind
1727,1734c1467,1477
< ; <label>:25                                      ; preds = %6
<   %26 = load i32* %1, align 4
<   %27 = call i32 @cpu_inl(i32 %26) nounwind
<   %28 = load i32* %1, align 4
<   %29 = zext i32 %28 to i64
<   %30 = zext i32 %27 to i64
<   call void @tcg_llvm_trace_port_access(i64 %29, i64 %30, i32 32, i32 0) nounwind
<   br label %31
---
> ; <label>:31                                      ; preds = %29, %25, %23
>   %32 = load %struct.S2E** @g_s2e, align 8
>   %33 = load %struct.S2EExecutionState** @g_s2e_state, align 8
>   tail call void @s2e_on_page_fault(%struct.S2E* %32, %struct.S2EExecutionState* %33, i64 %3, i32 %is_write) nounwind
>   %34 = load %struct.CPUX86State** @env, align 8
>   %35 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 92
>   %36 = load i32* %35, align 4
>   %37 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 55
>   %38 = load i32* %37, align 4
>   tail call fastcc void @raise_exception_err(i32 %36, i32 %38) noreturn
>   unreachable
1736,1738c1479,1480
< ; <label>:31                                      ; preds = %25, %13
<   %.0 = phi i32 [ %24, %13 ], [ %27, %25 ]
<   ret i32 %.0
---
> ; <label>:39                                      ; preds = %0
>   ret void
1741c1483
< declare i32 @cpu_inl(i32)
---
> declare void @io_writeb_mmu(i64, i8 zeroext, i32, i8*)
1743,1747c1485,1491
< define void @s2e_do_interrupt_all(i32 %intno, i32 %is_int, i32 %error_code, i32 %next_eip, i32 %is_hw) nounwind uwtable {
<   %1 = load i32* @loglevel, align 4
<   %2 = and i32 %1, 16
<   %3 = icmp eq i32 %2, 0
<   br i1 %3, label %._crit_edge, label %4
---
> define internal fastcc void @slow_stb_mmu(i32 %addr, i8 zeroext %val, i32 %mmu_idx) nounwind uwtable {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = load i32* @g_s2e_fork_on_symbolic_address, align 4
>   %4 = icmp eq i32 %3, 0
>   %5 = zext i32 %addr to i64
>   br i1 %4, label %8, label %6
1749,1760c1493,1495
< ; <label>:4                                       ; preds = %0
<   %5 = load %struct.CPUX86State** @env, align 8
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 15, i64 0
<   %7 = load i32* %6, align 4
<   %8 = and i32 %7, 1
<   %9 = icmp eq i32 %8, 0
<   br i1 %9, label %._crit_edge, label %10
< 
< ; <label>:10                                      ; preds = %4
<   %11 = load %struct._IO_FILE** @logfile, align 8
<   %12 = icmp eq %struct._IO_FILE* %11, null
<   br i1 %12, label %30, label %13
---
> ; <label>:6                                       ; preds = %0
>   %7 = call i64 @tcg_llvm_fork_and_concretize(i64 %5, i64 0, i64 4294967295) nounwind
>   br label %8
1762,1767c1497,1507
< ; <label>:13                                      ; preds = %10
<   %14 = load i32* @s2e_do_interrupt_all.count, align 4
<   %15 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 10, i64 1, i32 0
---
> ; <label>:8                                       ; preds = %6, %0
>   %9 = phi i64 [ %7, %6 ], [ %5, %0 ]
>   %10 = trunc i64 %9 to i32
>   %11 = lshr i64 %9, 7
>   %12 = and i64 %11, 33554431
>   %13 = call i64 @tcg_llvm_fork_and_concretize(i64 %12, i64 0, i64 33554431) nounwind
>   %14 = lshr i64 %13, 5
>   %15 = and i64 %14, 255
>   %16 = sext i32 %mmu_idx to i64
>   %17 = load %struct.CPUX86State** @env, align 8
>   %18 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 73, i64 %16, i64 %15, i32 1
1769,1780c1509,1512
<   %20 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 5
<   %21 = load i32* %20, align 4
<   %22 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 10, i64 1, i32 1
<   %23 = load i32* %22, align 4
<   %24 = add i32 %23, %21
<   %25 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 10, i64 2, i32 0
<   %26 = load i32* %25, align 4
<   %27 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 0, i64 4
<   %28 = load i32* %27, align 4
<   %29 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %11, i8* getelementptr inbounds ([65 x i8]* @.str3, i64 0, i64 0), i32 %14, i32 %intno, i32 %error_code, i32 %is_int, i32 %17, i32 %19, i32 %21, i32 %24, i32 %26, i32 %28) nounwind
<   %.pr = load %struct._IO_FILE** @logfile, align 8
<   br label %30
---
>   %20 = and i32 %10, -4096
>   %21 = and i32 %19, -4088
>   %22 = icmp eq i32 %20, %21
>   br i1 %22, label %._crit_edge, label %.lr.ph
1782,1786c1514,1517
< ; <label>:30                                      ; preds = %13, %10
<   %31 = phi %struct._IO_FILE* [ null, %10 ], [ %.pr, %13 ]
<   %32 = icmp eq i32 %intno, 14
<   %33 = icmp ne %struct._IO_FILE* %31, null
<   br i1 %32, label %34, label %40
---
> .lr.ph:                                           ; preds = %8
>   %23 = trunc i64 %13 to i32
>   %24 = shl i32 %23, 7
>   br label %78
1788,1789c1519,1524
< ; <label>:34                                      ; preds = %30
<   br i1 %33, label %35, label %46
---
> ._crit_edge:                                      ; preds = %78, %8
>   %.lcssa2 = phi i32 [ %19, %8 ], [ %82, %78 ]
>   %.lcssa1 = phi %struct.CPUX86State* [ %17, %8 ], [ %80, %78 ]
>   %25 = and i32 %.lcssa2, 4095
>   %26 = icmp eq i32 %25, 0
>   br i1 %26, label %71, label %27
1791,1796c1526,1548
< ; <label>:35                                      ; preds = %34
<   %36 = load %struct.CPUX86State** @env, align 8
<   %37 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 15, i64 2
<   %38 = load i32* %37, align 4
<   %39 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %31, i8* getelementptr inbounds ([10 x i8]* @.str4, i64 0, i64 0), i32 %38) nounwind
<   br label %46
---
> ; <label>:27                                      ; preds = %._crit_edge
>   %28 = getelementptr inbounds %struct.CPUX86State* %.lcssa1, i64 0, i32 75, i64 %16, i64 %15
>   %29 = load i64* %28, align 8
>   %30 = bitcast i32* %2 to i8*
>   store i8 %val, i8* %1, align 1
>   store i32 %10, i32* %2, align 4
>   %31 = call %struct.MemoryRegion* @iotlb_to_region(i64 %29) nounwind
>   %32 = and i64 %29, -4096
>   %33 = and i64 %9, 4294967295
>   %34 = add i64 %32, %33
>   %35 = icmp ne %struct.MemoryRegion* %31, @io_mem_ram
>   %36 = icmp ne %struct.MemoryRegion* %31, @io_mem_rom
>   %or.cond.i = and i1 %35, %36
>   %37 = icmp ne %struct.MemoryRegion* %31, @io_mem_unassigned
>   %or.cond3.i = and i1 %or.cond.i, %37
>   %38 = icmp ne %struct.MemoryRegion* %31, @io_mem_notdirty
>   %or.cond5.i = and i1 %or.cond3.i, %38
>   %39 = load %struct.CPUX86State** @env, align 8
>   %or.cond5.not.i = xor i1 %or.cond5.i, true
>   %40 = load i32* @use_icount, align 4
>   %41 = icmp eq i32 %40, 0
>   %or.cond17.i = or i1 %41, %or.cond5.not.i
>   br i1 %or.cond17.i, label %can_do_io.exit.thread.i, label %42
1798,1799c1550,1554
< ; <label>:40                                      ; preds = %30
<   br i1 %33, label %41, label %46
---
> ; <label>:42                                      ; preds = %27
>   %43 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 66
>   %44 = load %struct.TranslationBlock** %43, align 8
>   %45 = icmp eq %struct.TranslationBlock* %44, null
>   br i1 %45, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
1801,1806c1556,1560
< ; <label>:41                                      ; preds = %40
<   %42 = load %struct.CPUX86State** @env, align 8
<   %43 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 0, i64 0
<   %44 = load i32* %43, align 4
<   %45 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %31, i8* getelementptr inbounds ([10 x i8]* @.str5, i64 0, i64 0), i32 %44) nounwind
<   br label %46
---
> can_do_io.exit.i:                                 ; preds = %42
>   %46 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 85
>   %47 = load i32* %46, align 4
>   %48 = icmp eq i32 %47, 0
>   br i1 %48, label %49, label %can_do_io.exit.thread.i
1808,1918c1562,1563
< ; <label>:46                                      ; preds = %41, %40, %35, %34
<   %47 = load %struct._IO_FILE** @logfile, align 8
<   %48 = icmp eq %struct._IO_FILE* %47, null
<   br i1 %48, label %50, label %49
< 
< ; <label>:49                                      ; preds = %46
<   %fputc = tail call i32 @fputc(i32 10, %struct._IO_FILE* %47)
<   br label %50
< 
< ; <label>:50                                      ; preds = %49, %46
<   %51 = load i32* @s2e_do_interrupt_all.count, align 4
<   %52 = add nsw i32 %51, 1
<   store i32 %52, i32* @s2e_do_interrupt_all.count, align 4
<   br label %._crit_edge
< 
< ._crit_edge:                                      ; preds = %50, %4, %0
<   %53 = load %struct.CPUX86State** @env, align 8
<   %54 = getelementptr inbounds %struct.CPUX86State* %53, i64 0, i32 15, i64 0
<   %55 = load i32* %54, align 4
<   %56 = and i32 %55, 1
<   %57 = icmp eq i32 %56, 0
<   %58 = getelementptr inbounds %struct.CPUX86State* %53, i64 0, i32 8
<   %59 = load i32* %58, align 4
<   %60 = and i32 %59, 2097152
<   %61 = icmp ne i32 %60, 0
<   br i1 %57, label %765, label %62
< 
< ; <label>:62                                      ; preds = %._crit_edge
<   br i1 %61, label %63, label %handle_even_inj.exit25
< 
< ; <label>:63                                      ; preds = %62
<   %64 = getelementptr inbounds %struct.CPUX86State* %53, i64 0, i32 39
<   %65 = load i64* %64, align 8
<   %66 = add i64 %65, 168
<   %67 = tail call i32 @ldl_phys(i64 %66) nounwind
<   %68 = icmp slt i32 %67, 0
<   br i1 %68, label %handle_even_inj.exit25, label %69
< 
< ; <label>:69                                      ; preds = %63
<   %70 = icmp eq i32 %is_int, 0
<   %..i22 = select i1 %70, i32 768, i32 1024
<   %71 = or i32 %..i22, %intno
<   %72 = or i32 %71, -2147483648
<   %switch.tableidx.i.i23 = add i32 %intno, -8
<   %73 = icmp ult i32 %switch.tableidx.i.i23, 10
<   br i1 %73, label %exeption_has_error_code.exit.i24, label %exeption_has_error_code.exit.thread.i
< 
< exeption_has_error_code.exit.i24:                 ; preds = %69
<   %74 = lshr i32 386, %switch.tableidx.i.i23
<   %75 = and i32 %74, 1
<   %76 = icmp eq i32 %75, 0
<   br i1 %76, label %77, label %exeption_has_error_code.exit.thread.i
< 
< ; <label>:77                                      ; preds = %exeption_has_error_code.exit.i24
<   %78 = or i32 %71, -2147481600
<   %79 = load %struct.CPUX86State** @env, align 8
<   %80 = getelementptr inbounds %struct.CPUX86State* %79, i64 0, i32 39
<   %81 = load i64* %80, align 8
<   %82 = add i64 %81, 172
<   tail call void @stl_phys(i64 %82, i32 %error_code) nounwind
<   br label %exeption_has_error_code.exit.thread.i
< 
< exeption_has_error_code.exit.thread.i:            ; preds = %77, %exeption_has_error_code.exit.i24, %69
<   %event_inj.0.i = phi i32 [ %78, %77 ], [ %72, %exeption_has_error_code.exit.i24 ], [ %72, %69 ]
<   %83 = load %struct.CPUX86State** @env, align 8
<   %84 = getelementptr inbounds %struct.CPUX86State* %83, i64 0, i32 39
<   %85 = load i64* %84, align 8
<   %86 = add i64 %85, 168
<   tail call void @stl_phys(i64 %86, i32 %event_inj.0.i) nounwind
<   br label %handle_even_inj.exit25
< 
< handle_even_inj.exit25:                           ; preds = %exeption_has_error_code.exit.thread.i, %63, %62
<   %87 = icmp ne i32 %is_int, 0
<   %.not.i = xor i1 %87, true
<   %88 = icmp eq i32 %is_hw, 0
<   %or.cond.i = and i1 %88, %.not.i
<   br i1 %or.cond.i, label %89, label %exeption_has_error_code.exit.i
< 
< ; <label>:89                                      ; preds = %handle_even_inj.exit25
<   %switch.tableidx.i.i = add i32 %intno, -8
<   %90 = icmp ult i32 %switch.tableidx.i.i, 10
<   br i1 %90, label %switch.lookup.i.i, label %exeption_has_error_code.exit.i
< 
< switch.lookup.i.i:                                ; preds = %89
<   %91 = sext i32 %switch.tableidx.i.i to i64
<   %switch.gep.i.i = getelementptr inbounds [10 x i32]* @switch.table, i64 0, i64 %91
<   %switch.load.i.i = load i32* %switch.gep.i.i, align 4
<   br label %exeption_has_error_code.exit.i
< 
< exeption_has_error_code.exit.i:                   ; preds = %switch.lookup.i.i, %89, %handle_even_inj.exit25
<   %has_error_code.0.i = phi i32 [ %switch.load.i.i, %switch.lookup.i.i ], [ 0, %handle_even_inj.exit25 ], [ 0, %89 ]
<   %.pre170.i = load %struct.CPUX86State** @env, align 8
<   br i1 %87, label %exeption_has_error_code.exit._crit_edge.i, label %92
< 
< ; <label>:92                                      ; preds = %exeption_has_error_code.exit.i
<   %93 = getelementptr inbounds %struct.CPUX86State* %.pre170.i, i64 0, i32 5
<   %94 = load i32* %93, align 4
<   br label %exeption_has_error_code.exit._crit_edge.i
< 
< exeption_has_error_code.exit._crit_edge.i:        ; preds = %92, %exeption_has_error_code.exit.i
<   %old_eip.0.i = phi i32 [ %94, %92 ], [ %next_eip, %exeption_has_error_code.exit.i ]
<   %95 = shl nsw i32 %intno, 3
<   %96 = or i32 %95, 7
<   %97 = getelementptr inbounds %struct.CPUX86State* %.pre170.i, i64 0, i32 14, i32 2
<   %98 = load i32* %97, align 4
<   %99 = icmp ugt i32 %96, %98
<   br i1 %99, label %100, label %102
< 
< ; <label>:100                                     ; preds = %exeption_has_error_code.exit._crit_edge.i
<   %101 = or i32 %95, 2
<   tail call fastcc void @raise_exception_err(i32 13, i32 %101) noreturn nounwind
---
> ; <label>:49                                      ; preds = %can_do_io.exit.i
>   call void @cpu_io_recompile(%struct.CPUX86State* %39, i8* null) noreturn nounwind
1921,1936c1566,1574
< ; <label>:102                                     ; preds = %exeption_has_error_code.exit._crit_edge.i
<   %103 = getelementptr inbounds %struct.CPUX86State* %.pre170.i, i64 0, i32 14, i32 1
<   %104 = load i32* %103, align 4
<   %105 = add i32 %104, %95
<   %106 = tail call fastcc i32 @ldl_kernel(i32 %105) nounwind
<   %107 = add i32 %105, 4
<   %108 = tail call fastcc i32 @ldl_kernel(i32 %107) nounwind
<   %109 = lshr i32 %108, 8
<   %110 = and i32 %109, 31
<   switch i32 %110, label %148 [
<     i32 5, label %111
<     i32 6, label %150
<     i32 7, label %150
<     i32 14, label %150
<     i32 15, label %150
<   ]
---
> can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %42, %27
>   %50 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 69
>   store i32 %10, i32* %50, align 4
>   %51 = load %struct.CPUX86State** @env, align 8
>   %52 = getelementptr inbounds %struct.CPUX86State* %51, i64 0, i32 68
>   store i64 0, i64* %52, align 8
>   %53 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %31, i32 1) nounwind
>   %54 = icmp eq i32 %53, 0
>   br i1 %54, label %59, label %55
1938,1941c1576,1581
< ; <label>:111                                     ; preds = %102
<   %112 = and i32 %108, 32768
<   %113 = icmp eq i32 %112, 0
<   br i1 %113, label %114, label %116
---
> ; <label>:55                                      ; preds = %can_do_io.exit.thread.i
>   %56 = call i64 @s2e_notdirty_mem_write(i64 %34) nounwind
>   %57 = inttoptr i64 %56 to i8*
>   %58 = load i8* %1, align 1
>   store i8 %58, i8* %57, align 1
>   br label %io_write_chkb_mmu.exit
1943,1946c1583,1586
< ; <label>:114                                     ; preds = %111
<   %115 = or i32 %95, 2
<   tail call fastcc void @raise_exception_err(i32 11, i32 %115) noreturn nounwind
<   unreachable
---
> ; <label>:59                                      ; preds = %can_do_io.exit.thread.i
>   %60 = load i32* @g_s2e_concretize_io_writes, align 4
>   %61 = icmp eq i32 %60, 0
>   br i1 %61, label %63, label %62
1948,1997c1588,1590
< ; <label>:116                                     ; preds = %111
<   tail call fastcc void @switch_tss(i32 %95, i32 %106, i32 %108, i32 2, i32 %old_eip.0.i) nounwind
<   %117 = icmp eq i32 %has_error_code.0.i, 0
<   br i1 %117, label %do_interrupt_protected.exit, label %118
< 
< ; <label>:118                                     ; preds = %116
<   %119 = load %struct.CPUX86State** @env, align 8
<   %120 = getelementptr inbounds %struct.CPUX86State* %119, i64 0, i32 12, i32 3
<   %121 = load i32* %120, align 4
<   %122 = lshr i32 %121, 11
<   %123 = and i32 %122, 1
<   %124 = getelementptr inbounds %struct.CPUX86State* %119, i64 0, i32 10, i64 2, i32 3
<   %125 = load i32* %124, align 4
<   %126 = lshr i32 %125, 6
<   %127 = and i32 %126, 65536
<   %128 = xor i32 %127, 65536
<   %129 = add i32 %128, -1
<   %130 = getelementptr inbounds %struct.CPUX86State* %119, i64 0, i32 0, i64 4
<   %131 = load i32* %130, align 4
<   %132 = shl i32 2, %123
<   %133 = sub i32 %131, %132
<   %134 = and i32 %129, %133
<   %135 = getelementptr inbounds %struct.CPUX86State* %119, i64 0, i32 10, i64 2, i32 1
<   %136 = load i32* %135, align 4
<   %137 = add i32 %134, %136
<   %138 = icmp eq i32 %123, 0
<   br i1 %138, label %140, label %139
< 
< ; <label>:139                                     ; preds = %118
<   tail call fastcc void @stl_kernel(i32 %137, i32 %error_code) nounwind
<   br label %141
< 
< ; <label>:140                                     ; preds = %118
<   tail call fastcc void @stw_kernel(i32 %137, i32 %error_code) nounwind
<   br label %141
< 
< ; <label>:141                                     ; preds = %140, %139
<   %142 = load %struct.CPUX86State** @env, align 8
<   %143 = getelementptr inbounds %struct.CPUX86State* %142, i64 0, i32 0, i64 4
<   %144 = load i32* %143, align 4
<   %145 = sub i32 0, %128
<   %146 = and i32 %144, %145
<   %147 = or i32 %146, %134
<   store i32 %147, i32* %143, align 4
<   br label %do_interrupt_protected.exit
< 
< ; <label>:148                                     ; preds = %102
<   %149 = or i32 %95, 2
<   tail call fastcc void @raise_exception_err(i32 13, i32 %149) noreturn nounwind
<   unreachable
---
> ; <label>:62                                      ; preds = %59
>   call void @tcg_llvm_get_value(i8* %1, i32 1, i1 zeroext true) nounwind
>   br label %63
1999,2004c1592,1595
< ; <label>:150                                     ; preds = %102, %102, %102, %102
<   %151 = load %struct.CPUX86State** @env, align 8
<   %152 = getelementptr inbounds %struct.CPUX86State* %151, i64 0, i32 8
<   %153 = load i32* %152, align 4
<   %154 = and i32 %153, 3
<   br i1 %87, label %155, label %161
---
> ; <label>:63                                      ; preds = %62, %59
>   %64 = load i32* @g_s2e_concretize_io_addresses, align 4
>   %65 = icmp eq i32 %64, 0
>   br i1 %65, label %._crit_edge.i, label %66
2006,2010c1597,1599
< ; <label>:155                                     ; preds = %150
<   %156 = lshr i32 %108, 13
<   %157 = and i32 %156, 3
<   %158 = icmp ult i32 %157, %154
<   br i1 %158, label %159, label %161
---
> ; <label>:66                                      ; preds = %63
>   call void @tcg_llvm_get_value(i8* %30, i32 4, i1 zeroext true) nounwind
>   br label %._crit_edge.i
2012,2015c1601,1605
< ; <label>:159                                     ; preds = %155
<   %160 = or i32 %95, 2
<   tail call fastcc void @raise_exception_err(i32 13, i32 %160) noreturn nounwind
<   unreachable
---
> ._crit_edge.i:                                    ; preds = %66, %63
>   %67 = load i8* %1, align 1
>   %68 = load i32* %2, align 4
>   call void @io_writeb_mmu(i64 %29, i8 zeroext %67, i32 %68, i8* null) nounwind
>   br label %io_write_chkb_mmu.exit
2017,2025c1607,1611
< ; <label>:161                                     ; preds = %155, %150
<   %162 = and i32 %108, 32768
<   %163 = icmp eq i32 %162, 0
<   br i1 %163, label %164, label %166
< 
< ; <label>:164                                     ; preds = %161
<   %165 = or i32 %95, 2
<   tail call fastcc void @raise_exception_err(i32 11, i32 %165) noreturn nounwind
<   unreachable
---
> io_write_chkb_mmu.exit:                           ; preds = %._crit_edge.i, %55
>   %69 = add i64 %29, %33
>   %70 = zext i8 %val to i64
>   call void @tcg_llvm_trace_memory_access(i64 %33, i64 %69, i64 %70, i32 8, i8 zeroext 1, i8 zeroext 1) nounwind
>   br label %85
2027,2034c1613,1622
< ; <label>:166                                     ; preds = %161
<   %167 = lshr i32 %106, 16
<   %168 = and i32 %108, -65536
<   %169 = and i32 %106, 65535
<   %170 = or i32 %168, %169
<   %171 = and i32 %167, 65532
<   %172 = icmp eq i32 %171, 0
<   br i1 %172, label %173, label %174
---
> ; <label>:71                                      ; preds = %._crit_edge
>   %72 = getelementptr inbounds %struct.CPUX86State* %.lcssa1, i64 0, i32 73, i64 %16, i64 %15, i32 3
>   %73 = load i64* %72, align 8
>   %74 = and i64 %9, 4294967295
>   %75 = add i64 %73, %74
>   %76 = inttoptr i64 %75 to i8*
>   store i8 %val, i8* %76, align 1
>   %77 = zext i8 %val to i64
>   call void @tcg_llvm_trace_memory_access(i64 %74, i64 %75, i64 %77, i32 8, i8 zeroext 1, i8 zeroext 0) nounwind
>   br label %85
2036,2038c1624,1632
< ; <label>:173                                     ; preds = %166
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn nounwind
<   unreachable
---
> ; <label>:78                                      ; preds = %78, %.lr.ph
>   %79 = phi %struct.CPUX86State* [ %17, %.lr.ph ], [ %80, %78 ]
>   call void @tlb_fill(%struct.CPUX86State* %79, i32 %10, i32 %24, i32 1, i32 %mmu_idx, i8* null)
>   %80 = load %struct.CPUX86State** @env, align 8
>   %81 = getelementptr inbounds %struct.CPUX86State* %80, i64 0, i32 73, i64 %16, i64 %15, i32 1
>   %82 = load i32* %81, align 4
>   %83 = and i32 %82, -4088
>   %84 = icmp eq i32 %20, %83
>   br i1 %84, label %._crit_edge, label %78
2040,2050c1634,1636
< ; <label>:174                                     ; preds = %166
<   %175 = and i32 %167, 4
<   %176 = icmp eq i32 %175, 0
<   %177 = getelementptr inbounds %struct.CPUX86State* %151, i64 0, i32 11
<   %178 = getelementptr inbounds %struct.CPUX86State* %151, i64 0, i32 13
<   %dt.0.i.i = select i1 %176, %struct.SegmentCache* %178, %struct.SegmentCache* %177
<   %179 = or i32 %167, 7
<   %180 = getelementptr inbounds %struct.SegmentCache* %dt.0.i.i, i64 0, i32 2
<   %181 = load i32* %180, align 4
<   %182 = icmp ugt i32 %179, %181
<   br i1 %182, label %183, label %184
---
> ; <label>:85                                      ; preds = %71, %io_write_chkb_mmu.exit
>   ret void
> }
2052,2054c1638
< ; <label>:183                                     ; preds = %174
<   tail call fastcc void @raise_exception_err(i32 13, i32 %171) noreturn nounwind
<   unreachable
---
> declare i32 @s2e_is_mmio_symbolic_l(i64)
2056,2066c1640
< ; <label>:184                                     ; preds = %174
<   %185 = and i32 %167, 65528
<   %186 = getelementptr inbounds %struct.SegmentCache* %dt.0.i.i, i64 0, i32 1
<   %187 = load i32* %186, align 4
<   %188 = add i32 %187, %185
<   %189 = tail call fastcc i32 @ldl_kernel(i32 %188) nounwind
<   %190 = add i32 %188, 4
<   %191 = tail call fastcc i32 @ldl_kernel(i32 %190) nounwind
<   %192 = and i32 %191, 6144
<   %193 = icmp eq i32 %192, 6144
<   br i1 %193, label %195, label %194
---
> declare i32 @io_readl_mmu(i64, i32, i8*)
2068,2070c1642
< ; <label>:194                                     ; preds = %184
<   tail call fastcc void @raise_exception_err(i32 13, i32 %171) noreturn nounwind
<   unreachable
---
> declare i32 @__ldl_mmu(i32, i32) nounwind uwtable
2072,2076c1644,1650
< ; <label>:195                                     ; preds = %184
<   %196 = lshr i32 %191, 13
<   %197 = and i32 %196, 3
<   %198 = icmp ugt i32 %197, %154
<   br i1 %198, label %199, label %200
---
> define internal fastcc i32 @slow_ldl_mmu(i32 %addr, i32 %mmu_idx) nounwind uwtable {
>   %ret.i.i.i = alloca i8, align 1
>   %label.i = alloca [64 x i8], align 16
>   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
>   %2 = icmp eq i32 %1, 0
>   %3 = zext i32 %addr to i64
>   br i1 %2, label %6, label %4
2078,2080c1652,1654
< ; <label>:199                                     ; preds = %195
<   tail call fastcc void @raise_exception_err(i32 13, i32 %171) noreturn nounwind
<   unreachable
---
> ; <label>:4                                       ; preds = %0
>   %5 = call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
>   br label %6
2082,2085c1656,1671
< ; <label>:200                                     ; preds = %195
<   %201 = and i32 %191, 32768
<   %202 = icmp eq i32 %201, 0
<   br i1 %202, label %203, label %204
---
> ; <label>:6                                       ; preds = %4, %0
>   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
>   %8 = trunc i64 %7 to i32
>   %9 = lshr i64 %7, 7
>   %10 = and i64 %9, 33554431
>   %11 = call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
>   %12 = lshr i64 %11, 5
>   %13 = and i64 %12, 255
>   %14 = sext i32 %mmu_idx to i64
>   %15 = load %struct.CPUX86State** @env, align 8
>   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 73, i64 %14, i64 %13, i32 0
>   %17 = load i32* %16, align 4
>   %18 = and i32 %8, -4096
>   %19 = and i32 %17, -4088
>   %20 = icmp eq i32 %18, %19
>   br i1 %20, label %._crit_edge, label %.lr.ph
2087,2089c1673,1676
< ; <label>:203                                     ; preds = %200
<   tail call fastcc void @raise_exception_err(i32 11, i32 %171) noreturn nounwind
<   unreachable
---
> .lr.ph:                                           ; preds = %6
>   %21 = trunc i64 %11 to i32
>   %22 = shl i32 %21, 7
>   br label %138
2091,2104c1678,1683
< ; <label>:204                                     ; preds = %200
<   %205 = and i32 %191, 1024
<   %206 = icmp eq i32 %205, 0
<   %207 = icmp ult i32 %197, %154
<   %or.cond96.i = and i1 %206, %207
<   br i1 %or.cond96.i, label %208, label %298
< 
< ; <label>:208                                     ; preds = %204
<   %209 = load %struct.CPUX86State** @env, align 8
<   %210 = getelementptr inbounds %struct.CPUX86State* %209, i64 0, i32 12, i32 3
<   %211 = load i32* %210, align 4
<   %212 = and i32 %211, 32768
<   %213 = icmp eq i32 %212, 0
<   br i1 %213, label %214, label %215
---
> ._crit_edge:                                      ; preds = %138, %6
>   %.lcssa3 = phi i32 [ %17, %6 ], [ %142, %138 ]
>   %.lcssa2 = phi %struct.CPUX86State* [ %15, %6 ], [ %140, %138 ]
>   %23 = and i32 %.lcssa3, 4095
>   %24 = icmp eq i32 %23, 0
>   br i1 %24, label %115, label %25
2106,2108c1685,1688
< ; <label>:214                                     ; preds = %208
<   tail call void (%struct.CPUX86State*, i8*, ...)* @cpu_abort(%struct.CPUX86State* %209, i8* getelementptr inbounds ([12 x i8]* @.str20, i64 0, i64 0)) noreturn nounwind
<   unreachable
---
> ; <label>:25                                      ; preds = %._crit_edge
>   %26 = and i32 %8, 3
>   %27 = icmp eq i32 %26, 0
>   br i1 %27, label %28, label %119
2110,2122c1690,1701
< ; <label>:215                                     ; preds = %208
<   %216 = lshr i32 %211, 11
<   %217 = and i32 %216, 1
<   %218 = shl nuw nsw i32 %197, 2
<   %219 = or i32 %218, 2
<   %220 = shl i32 %219, %217
<   %221 = shl i32 4, %217
<   %222 = add i32 %221, -1
<   %223 = add i32 %222, %220
<   %224 = getelementptr inbounds %struct.CPUX86State* %209, i64 0, i32 12, i32 2
<   %225 = load i32* %224, align 4
<   %226 = icmp ugt i32 %223, %225
<   br i1 %226, label %227, label %231
---
> ; <label>:28                                      ; preds = %25
>   %29 = getelementptr inbounds %struct.CPUX86State* %.lcssa2, i64 0, i32 75, i64 %14, i64 %13
>   %30 = load i64* %29, align 8
>   %31 = getelementptr inbounds [64 x i8]* %label.i, i64 0, i64 0
>   %32 = call %struct.MemoryRegion* @iotlb_to_region(i64 %30) nounwind
>   %33 = and i64 %30, 4294963200
>   %34 = and i64 %7, 4294967295
>   %35 = add i64 %33, %34
>   %36 = trunc i64 %35 to i32
>   %37 = load i32* @g_s2e_enable_mmio_checks, align 4
>   %38 = icmp eq i32 %37, 0
>   br i1 %38, label %47, label %39
2124,2129c1703,1708
< ; <label>:227                                     ; preds = %215
<   %228 = getelementptr inbounds %struct.CPUX86State* %209, i64 0, i32 12, i32 0
<   %229 = load i32* %228, align 4
<   %230 = and i32 %229, 65532
<   tail call fastcc void @raise_exception_err(i32 10, i32 %230) noreturn nounwind
<   unreachable
---
> ; <label>:39                                      ; preds = %28
>   %fold = add i64 %33, %7
>   %40 = and i64 %fold, 4294967295
>   %41 = call i32 @s2e_is_mmio_symbolic_l(i64 %40) nounwind
>   %42 = icmp eq i32 %41, 0
>   br i1 %42, label %47, label %43
2131,2136c1710,1715
< ; <label>:231                                     ; preds = %215
<   %232 = icmp eq i32 %217, 0
<   %233 = getelementptr inbounds %struct.CPUX86State* %209, i64 0, i32 12, i32 1
<   %234 = load i32* %233, align 4
<   %235 = add i32 %234, %220
<   br i1 %232, label %236, label %244
---
> ; <label>:43                                      ; preds = %39
>   %44 = load %struct.CPUX86State** @env, align 8
>   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 5
>   %46 = load i32* %45, align 4
>   call void @trace_port(i8* %31, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %36, i32 %46) nounwind
>   br label %47
2138,2163c1717,1734
< ; <label>:236                                     ; preds = %231
<   %237 = tail call fastcc i32 @lduw_kernel(i32 %235) nounwind
<   %238 = load %struct.CPUX86State** @env, align 8
<   %239 = getelementptr inbounds %struct.CPUX86State* %238, i64 0, i32 12, i32 1
<   %240 = load i32* %239, align 4
<   %241 = add i32 %220, 2
<   %242 = add i32 %241, %240
<   %243 = tail call fastcc i32 @lduw_kernel(i32 %242) nounwind
<   br label %get_ss_esp_from_tss.exit.i
< 
< ; <label>:244                                     ; preds = %231
<   %245 = tail call fastcc i32 @ldl_kernel(i32 %235) nounwind
<   %246 = load %struct.CPUX86State** @env, align 8
<   %247 = getelementptr inbounds %struct.CPUX86State* %246, i64 0, i32 12, i32 1
<   %248 = load i32* %247, align 4
<   %249 = add i32 %220, 4
<   %250 = add i32 %249, %248
<   %251 = tail call fastcc i32 @lduw_kernel(i32 %250) nounwind
<   br label %get_ss_esp_from_tss.exit.i
< 
< get_ss_esp_from_tss.exit.i:                       ; preds = %244, %236
<   %252 = phi i32 [ %245, %244 ], [ %237, %236 ]
<   %storemerge.i.i = phi i32 [ %251, %244 ], [ %243, %236 ]
<   %253 = and i32 %storemerge.i.i, 65532
<   %254 = icmp eq i32 %253, 0
<   br i1 %254, label %255, label %256
---
> ; <label>:47                                      ; preds = %43, %39, %28
>   %isSymb.0.i = phi i32 [ %41, %43 ], [ 0, %39 ], [ 0, %28 ]
>   %48 = load %struct.CPUX86State** @env, align 8
>   %49 = getelementptr inbounds %struct.CPUX86State* %48, i64 0, i32 68
>   store i64 0, i64* %49, align 8
>   %50 = icmp ne %struct.MemoryRegion* %32, @io_mem_ram
>   %51 = icmp ne %struct.MemoryRegion* %32, @io_mem_rom
>   %or.cond.i = and i1 %50, %51
>   %52 = icmp ne %struct.MemoryRegion* %32, @io_mem_unassigned
>   %or.cond3.i = and i1 %or.cond.i, %52
>   %53 = icmp ne %struct.MemoryRegion* %32, @io_mem_notdirty
>   %or.cond5.i = and i1 %or.cond3.i, %53
>   %54 = load %struct.CPUX86State** @env, align 8
>   %or.cond5.not.i = xor i1 %or.cond5.i, true
>   %55 = load i32* @use_icount, align 4
>   %56 = icmp eq i32 %55, 0
>   %or.cond26.i = or i1 %56, %or.cond5.not.i
>   br i1 %or.cond26.i, label %can_do_io.exit.thread.i, label %57
2165,2167c1736,1740
< ; <label>:255                                     ; preds = %get_ss_esp_from_tss.exit.i
<   tail call fastcc void @raise_exception_err(i32 10, i32 0) noreturn nounwind
<   unreachable
---
> ; <label>:57                                      ; preds = %47
>   %58 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 66
>   %59 = load %struct.TranslationBlock** %58, align 8
>   %60 = icmp eq %struct.TranslationBlock* %59, null
>   br i1 %60, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
2169,2172c1742,1746
< ; <label>:256                                     ; preds = %get_ss_esp_from_tss.exit.i
<   %257 = and i32 %storemerge.i.i, 3
<   %258 = icmp eq i32 %257, %197
<   br i1 %258, label %260, label %259
---
> can_do_io.exit.i:                                 ; preds = %57
>   %61 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 85
>   %62 = load i32* %61, align 4
>   %63 = icmp eq i32 %62, 0
>   br i1 %63, label %64, label %can_do_io.exit.thread.i
2174,2175c1748,1749
< ; <label>:259                                     ; preds = %256
<   tail call fastcc void @raise_exception_err(i32 10, i32 %253) noreturn nounwind
---
> ; <label>:64                                      ; preds = %can_do_io.exit.i
>   call void @cpu_io_recompile(%struct.CPUX86State* %54, i8* null) noreturn nounwind
2178,2189c1752,1757
< ; <label>:260                                     ; preds = %256
<   %261 = and i32 %storemerge.i.i, 4
<   %262 = icmp eq i32 %261, 0
<   %263 = load %struct.CPUX86State** @env, align 8
<   %264 = getelementptr inbounds %struct.CPUX86State* %263, i64 0, i32 11
<   %265 = getelementptr inbounds %struct.CPUX86State* %263, i64 0, i32 13
<   %dt.0.i102.i = select i1 %262, %struct.SegmentCache* %265, %struct.SegmentCache* %264
<   %266 = or i32 %storemerge.i.i, 7
<   %267 = getelementptr inbounds %struct.SegmentCache* %dt.0.i102.i, i64 0, i32 2
<   %268 = load i32* %267, align 4
<   %269 = icmp ugt i32 %266, %268
<   br i1 %269, label %270, label %271
---
> can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %57, %47
>   %65 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 69
>   store i32 %8, i32* %65, align 4
>   %66 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %32, i32 0) nounwind
>   %67 = icmp eq i32 %66, 0
>   br i1 %67, label %111, label %68
2191,2193c1759,1764
< ; <label>:270                                     ; preds = %260
<   tail call fastcc void @raise_exception_err(i32 10, i32 %253) noreturn nounwind
<   unreachable
---
> ; <label>:68                                      ; preds = %can_do_io.exit.thread.i
>   %69 = call i64 @s2e_notdirty_mem_write(i64 %30) nounwind
>   %70 = icmp eq i32 %isSymb.0.i, 0
>   %71 = inttoptr i64 %69 to i32*
>   %72 = load i32* %71, align 4
>   br i1 %70, label %io_read_chkl_mmu.exit, label %73
2195,2206c1766,1776
< ; <label>:271                                     ; preds = %260
<   %272 = and i32 %storemerge.i.i, -8
<   %273 = getelementptr inbounds %struct.SegmentCache* %dt.0.i102.i, i64 0, i32 1
<   %274 = load i32* %273, align 4
<   %275 = add i32 %274, %272
<   %276 = tail call fastcc i32 @ldl_kernel(i32 %275) nounwind
<   %277 = add i32 %275, 4
<   %278 = tail call fastcc i32 @ldl_kernel(i32 %277) nounwind
<   %279 = lshr i32 %278, 13
<   %280 = and i32 %279, 3
<   %281 = icmp eq i32 %280, %197
<   br i1 %281, label %283, label %282
---
> ; <label>:73                                      ; preds = %68
>   %data.i.sroa.0.0.extract.trunc.i = trunc i32 %72 to i8
>   %data.i.sroa.1.1.extract.shift.i = lshr i32 %72, 8
>   %data.i.sroa.1.1.extract.trunc.i = trunc i32 %data.i.sroa.1.1.extract.shift.i to i8
>   %data.i.sroa.2.2.extract.shift.i = lshr i32 %72, 16
>   %data.i.sroa.2.2.extract.trunc.i = trunc i32 %data.i.sroa.2.2.extract.shift.i to i8
>   %data.i.sroa.3.3.extract.shift.i = lshr i32 %72, 24
>   %data.i.sroa.3.3.extract.trunc.i = trunc i32 %data.i.sroa.3.3.extract.shift.i to i8
>   %74 = load i32* @g_s2e_enable_mmio_checks, align 4
>   %75 = icmp eq i32 %74, 0
>   br i1 %75, label %io_read_chk_symb_l.exit.i, label %76
2208,2210c1778,1783
< ; <label>:282                                     ; preds = %271
<   tail call fastcc void @raise_exception_err(i32 10, i32 %253) noreturn nounwind
<   unreachable
---
> ; <label>:76                                      ; preds = %73
>   %fold1 = add i64 %33, %7
>   %77 = and i64 %fold1, 4294967295
>   %78 = call i32 @s2e_is_mmio_symbolic_b(i64 %77) nounwind
>   %79 = icmp eq i32 %78, 0
>   br i1 %79, label %._crit_edge10.i.i, label %80
2212,2215c1785,1788
< ; <label>:283                                     ; preds = %271
<   %284 = and i32 %278, 6656
<   %285 = icmp eq i32 %284, 4608
<   br i1 %285, label %287, label %286
---
> ; <label>:80                                      ; preds = %76
>   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
>   %81 = load i8* %ret.i.i.i, align 1
>   br label %._crit_edge10.i.i
2217,2219c1790,1794
< ; <label>:286                                     ; preds = %283
<   tail call fastcc void @raise_exception_err(i32 10, i32 %253) noreturn nounwind
<   unreachable
---
> ._crit_edge10.i.i:                                ; preds = %80, %76
>   %data.i.sroa.0.0.extract.trunc23.i = phi i8 [ %81, %80 ], [ %data.i.sroa.0.0.extract.trunc.i, %76 ]
>   %.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
>   %82 = icmp eq i32 %.pr.i.i, 0
>   br i1 %82, label %io_read_chk_symb_l.exit.i, label %83
2221,2224c1796,1801
< ; <label>:287                                     ; preds = %283
<   %288 = and i32 %278, 32768
<   %289 = icmp eq i32 %288, 0
<   br i1 %289, label %290, label %291
---
> ; <label>:83                                      ; preds = %._crit_edge10.i.i
>   %84 = add i64 %35, 1
>   %85 = and i64 %84, 4294967295
>   %86 = call i32 @s2e_is_mmio_symbolic_b(i64 %85) nounwind
>   %87 = icmp eq i32 %86, 0
>   br i1 %87, label %._crit_edge9.i.i, label %88
2226,2228c1803,1806
< ; <label>:290                                     ; preds = %287
<   tail call fastcc void @raise_exception_err(i32 10, i32 %253) noreturn nounwind
<   unreachable
---
> ; <label>:88                                      ; preds = %83
>   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
>   %89 = load i8* %ret.i.i.i, align 1
>   br label %._crit_edge9.i.i
2230,2238c1808,1812
< ; <label>:291                                     ; preds = %287
<   %292 = lshr i32 %276, 16
<   %293 = shl i32 %278, 16
<   %294 = and i32 %293, 16711680
<   %295 = and i32 %278, -16777216
<   %296 = or i32 %295, %292
<   %297 = or i32 %296, %294
<   %phitmp.i = and i32 %276, 65535
<   br label %316
---
> ._crit_edge9.i.i:                                 ; preds = %88, %83
>   %90 = phi i8 [ %89, %88 ], [ %data.i.sroa.1.1.extract.trunc.i, %83 ]
>   %.pr11.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
>   %91 = icmp eq i32 %.pr11.pr.i.i, 0
>   br i1 %91, label %io_read_chk_symb_l.exit.i, label %92
2240,2244c1814,1819
< ; <label>:298                                     ; preds = %204
<   %299 = icmp ne i32 %205, 0
<   %300 = icmp eq i32 %197, %154
<   %or.cond101.i = or i1 %299, %300
<   br i1 %or.cond101.i, label %301, label %315
---
> ; <label>:92                                      ; preds = %._crit_edge9.i.i
>   %93 = add i64 %35, 2
>   %94 = and i64 %93, 4294967295
>   %95 = call i32 @s2e_is_mmio_symbolic_b(i64 %94) nounwind
>   %96 = icmp eq i32 %95, 0
>   br i1 %96, label %._crit_edge8.i.i, label %97
2246,2894c1821,1824
< ; <label>:301                                     ; preds = %298
<   %302 = load %struct.CPUX86State** @env, align 8
<   %303 = getelementptr inbounds %struct.CPUX86State* %302, i64 0, i32 7
<   %304 = load i32* %303, align 4
<   %305 = and i32 %304, 131072
<   %306 = icmp eq i32 %305, 0
<   br i1 %306, label %308, label %307
< 
< ; <label>:307                                     ; preds = %301
<   tail call fastcc void @raise_exception_err(i32 13, i32 %171) noreturn nounwind
<   unreachable
< 
< ; <label>:308                                     ; preds = %301
<   %309 = getelementptr inbounds %struct.CPUX86State* %302, i64 0, i32 10, i64 2, i32 3
<   %310 = load i32* %309, align 4
<   %311 = getelementptr inbounds %struct.CPUX86State* %302, i64 0, i32 10, i64 2, i32 1
<   %312 = load i32* %311, align 4
<   %313 = getelementptr inbounds %struct.CPUX86State* %302, i64 0, i32 0, i64 4
<   %314 = load i32* %313, align 4
<   br label %316
< 
< ; <label>:315                                     ; preds = %298
<   tail call fastcc void @raise_exception_err(i32 13, i32 %171) noreturn nounwind
<   unreachable
< 
< ; <label>:316                                     ; preds = %308, %291
<   %317 = phi i32 [ 0, %308 ], [ %storemerge.i.i, %291 ]
<   %318 = phi i32 [ %314, %308 ], [ %252, %291 ]
<   %319 = phi i32 [ 0, %308 ], [ %phitmp.i, %291 ]
<   %320 = phi i32 [ 0, %308 ], [ %278, %291 ]
<   %new_stack.0.i = phi i1 [ false, %308 ], [ true, %291 ]
<   %dpl.0.i = phi i32 [ %154, %308 ], [ %197, %291 ]
<   %sp_mask.0.in.in.in.in.i = phi i32 [ %310, %308 ], [ %278, %291 ]
<   %321 = phi i32 [ %312, %308 ], [ %297, %291 ]
<   %sp_mask.0.in.in.in.i = lshr i32 %sp_mask.0.in.in.in.in.i, 6
<   %sp_mask.0.in.in.i = and i32 %sp_mask.0.in.in.in.i, 65536
<   %sp_mask.0.in.i = xor i32 %sp_mask.0.in.in.i, 65536
<   %sp_mask.0.i = add i32 %sp_mask.0.in.i, -1
<   %.mask.i = and i32 %109, 24
<   %322 = icmp eq i32 %.mask.i, 8
<   br i1 %322, label %323, label %397
< 
< ; <label>:323                                     ; preds = %316
<   br i1 %new_stack.0.i, label %324, label %._crit_edge169.i
< 
< ; <label>:324                                     ; preds = %323
<   %325 = load %struct.CPUX86State** @env, align 8
<   %326 = getelementptr inbounds %struct.CPUX86State* %325, i64 0, i32 7
<   %327 = load i32* %326, align 4
<   %328 = and i32 %327, 131072
<   %329 = icmp eq i32 %328, 0
<   br i1 %329, label %354, label %330
< 
< ; <label>:330                                     ; preds = %324
<   %331 = add i32 %318, -4
<   %332 = and i32 %sp_mask.0.i, %331
<   %333 = add i32 %332, %321
<   %334 = getelementptr inbounds %struct.CPUX86State* %325, i64 0, i32 10, i64 5, i32 0
<   %335 = load i32* %334, align 4
<   tail call fastcc void @stl_kernel(i32 %333, i32 %335) nounwind
<   %336 = add i32 %318, -8
<   %337 = and i32 %sp_mask.0.i, %336
<   %338 = add i32 %337, %321
<   %339 = load %struct.CPUX86State** @env, align 8
<   %340 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 10, i64 4, i32 0
<   %341 = load i32* %340, align 4
<   tail call fastcc void @stl_kernel(i32 %338, i32 %341) nounwind
<   %342 = add i32 %318, -12
<   %343 = and i32 %sp_mask.0.i, %342
<   %344 = add i32 %343, %321
<   %345 = load %struct.CPUX86State** @env, align 8
<   %346 = getelementptr inbounds %struct.CPUX86State* %345, i64 0, i32 10, i64 3, i32 0
<   %347 = load i32* %346, align 4
<   tail call fastcc void @stl_kernel(i32 %344, i32 %347) nounwind
<   %348 = add i32 %318, -16
<   %349 = and i32 %sp_mask.0.i, %348
<   %350 = add i32 %349, %321
<   %351 = load %struct.CPUX86State** @env, align 8
<   %352 = getelementptr inbounds %struct.CPUX86State* %351, i64 0, i32 10, i64 0, i32 0
<   %353 = load i32* %352, align 4
<   tail call fastcc void @stl_kernel(i32 %350, i32 %353) nounwind
<   %.pre.i = load %struct.CPUX86State** @env, align 8
<   br label %354
< 
< ; <label>:354                                     ; preds = %330, %324
<   %355 = phi %struct.CPUX86State* [ %325, %324 ], [ %.pre.i, %330 ]
<   %356 = phi i32 [ %318, %324 ], [ %348, %330 ]
<   %357 = add i32 %356, -4
<   %358 = and i32 %357, %sp_mask.0.i
<   %359 = add i32 %358, %321
<   %360 = getelementptr inbounds %struct.CPUX86State* %355, i64 0, i32 10, i64 2, i32 0
<   %361 = load i32* %360, align 4
<   tail call fastcc void @stl_kernel(i32 %359, i32 %361) nounwind
<   %362 = add i32 %356, -8
<   %363 = and i32 %362, %sp_mask.0.i
<   %364 = add i32 %363, %321
<   %365 = load %struct.CPUX86State** @env, align 8
<   %366 = getelementptr inbounds %struct.CPUX86State* %365, i64 0, i32 0, i64 4
<   %367 = load i32* %366, align 4
<   tail call fastcc void @stl_kernel(i32 %364, i32 %367) nounwind
<   br label %._crit_edge169.i
< 
< ._crit_edge169.i:                                 ; preds = %354, %323
<   %368 = phi i32 [ %362, %354 ], [ %318, %323 ]
<   %369 = add i32 %368, -4
<   %370 = and i32 %369, %sp_mask.0.i
<   %371 = add i32 %370, %321
<   %372 = load %struct.CPUX86State** @env, align 8
<   %373 = getelementptr inbounds %struct.CPUX86State* %372, i64 0, i32 7
<   %374 = load i32* %373, align 4
<   %375 = getelementptr inbounds %struct.CPUX86State* %372, i64 0, i32 1
<   %376 = load i32* %375, align 4
<   %377 = tail call i32 @helper_cc_compute_all(i32 %376) nounwind
<   %378 = or i32 %377, %374
<   %379 = getelementptr inbounds %struct.CPUX86State* %372, i64 0, i32 6
<   %380 = load i32* %379, align 4
<   %381 = and i32 %380, 1024
<   %382 = or i32 %378, %381
<   tail call fastcc void @stl_kernel(i32 %371, i32 %382) nounwind
<   %383 = add i32 %368, -8
<   %384 = and i32 %383, %sp_mask.0.i
<   %385 = add i32 %384, %321
<   %386 = load %struct.CPUX86State** @env, align 8
<   %387 = getelementptr inbounds %struct.CPUX86State* %386, i64 0, i32 10, i64 1, i32 0
<   %388 = load i32* %387, align 4
<   tail call fastcc void @stl_kernel(i32 %385, i32 %388) nounwind
<   %389 = add i32 %368, -12
<   %390 = and i32 %389, %sp_mask.0.i
<   %391 = add i32 %390, %321
<   tail call fastcc void @stl_kernel(i32 %391, i32 %old_eip.0.i) nounwind
<   %392 = icmp eq i32 %has_error_code.0.i, 0
<   br i1 %392, label %471, label %393
< 
< ; <label>:393                                     ; preds = %._crit_edge169.i
<   %394 = add i32 %368, -16
<   %395 = and i32 %394, %sp_mask.0.i
<   %396 = add i32 %395, %321
<   tail call fastcc void @stl_kernel(i32 %396, i32 %error_code) nounwind
<   br label %471
< 
< ; <label>:397                                     ; preds = %316
<   br i1 %new_stack.0.i, label %398, label %._crit_edge.i
< 
< ; <label>:398                                     ; preds = %397
<   %399 = load %struct.CPUX86State** @env, align 8
<   %400 = getelementptr inbounds %struct.CPUX86State* %399, i64 0, i32 7
<   %401 = load i32* %400, align 4
<   %402 = and i32 %401, 131072
<   %403 = icmp eq i32 %402, 0
<   br i1 %403, label %428, label %404
< 
< ; <label>:404                                     ; preds = %398
<   %405 = add i32 %318, -2
<   %406 = and i32 %sp_mask.0.i, %405
<   %407 = add i32 %406, %321
<   %408 = getelementptr inbounds %struct.CPUX86State* %399, i64 0, i32 10, i64 5, i32 0
<   %409 = load i32* %408, align 4
<   tail call fastcc void @stw_kernel(i32 %407, i32 %409) nounwind
<   %410 = add i32 %318, -4
<   %411 = and i32 %sp_mask.0.i, %410
<   %412 = add i32 %411, %321
<   %413 = load %struct.CPUX86State** @env, align 8
<   %414 = getelementptr inbounds %struct.CPUX86State* %413, i64 0, i32 10, i64 4, i32 0
<   %415 = load i32* %414, align 4
<   tail call fastcc void @stw_kernel(i32 %412, i32 %415) nounwind
<   %416 = add i32 %318, -6
<   %417 = and i32 %sp_mask.0.i, %416
<   %418 = add i32 %417, %321
<   %419 = load %struct.CPUX86State** @env, align 8
<   %420 = getelementptr inbounds %struct.CPUX86State* %419, i64 0, i32 10, i64 3, i32 0
<   %421 = load i32* %420, align 4
<   tail call fastcc void @stw_kernel(i32 %418, i32 %421) nounwind
<   %422 = add i32 %318, -8
<   %423 = and i32 %sp_mask.0.i, %422
<   %424 = add i32 %423, %321
<   %425 = load %struct.CPUX86State** @env, align 8
<   %426 = getelementptr inbounds %struct.CPUX86State* %425, i64 0, i32 10, i64 0, i32 0
<   %427 = load i32* %426, align 4
<   tail call fastcc void @stw_kernel(i32 %424, i32 %427) nounwind
<   %.pre168.i = load %struct.CPUX86State** @env, align 8
<   br label %428
< 
< ; <label>:428                                     ; preds = %404, %398
<   %429 = phi %struct.CPUX86State* [ %399, %398 ], [ %.pre168.i, %404 ]
<   %430 = phi i32 [ %318, %398 ], [ %422, %404 ]
<   %431 = add i32 %430, -2
<   %432 = and i32 %431, %sp_mask.0.i
<   %433 = add i32 %432, %321
<   %434 = getelementptr inbounds %struct.CPUX86State* %429, i64 0, i32 10, i64 2, i32 0
<   %435 = load i32* %434, align 4
<   tail call fastcc void @stw_kernel(i32 %433, i32 %435) nounwind
<   %436 = add i32 %430, -4
<   %437 = and i32 %436, %sp_mask.0.i
<   %438 = add i32 %437, %321
<   %439 = load %struct.CPUX86State** @env, align 8
<   %440 = getelementptr inbounds %struct.CPUX86State* %439, i64 0, i32 0, i64 4
<   %441 = load i32* %440, align 4
<   tail call fastcc void @stw_kernel(i32 %438, i32 %441) nounwind
<   br label %._crit_edge.i
< 
< ._crit_edge.i:                                    ; preds = %428, %397
<   %442 = phi i32 [ %436, %428 ], [ %318, %397 ]
<   %443 = add i32 %442, -2
<   %444 = and i32 %443, %sp_mask.0.i
<   %445 = add i32 %444, %321
<   %446 = load %struct.CPUX86State** @env, align 8
<   %447 = getelementptr inbounds %struct.CPUX86State* %446, i64 0, i32 7
<   %448 = load i32* %447, align 4
<   %449 = getelementptr inbounds %struct.CPUX86State* %446, i64 0, i32 1
<   %450 = load i32* %449, align 4
<   %451 = tail call i32 @helper_cc_compute_all(i32 %450) nounwind
<   %452 = or i32 %451, %448
<   %453 = getelementptr inbounds %struct.CPUX86State* %446, i64 0, i32 6
<   %454 = load i32* %453, align 4
<   %455 = and i32 %454, 1024
<   %456 = or i32 %452, %455
<   tail call fastcc void @stw_kernel(i32 %445, i32 %456) nounwind
<   %457 = add i32 %442, -4
<   %458 = and i32 %457, %sp_mask.0.i
<   %459 = add i32 %458, %321
<   %460 = load %struct.CPUX86State** @env, align 8
<   %461 = getelementptr inbounds %struct.CPUX86State* %460, i64 0, i32 10, i64 1, i32 0
<   %462 = load i32* %461, align 4
<   tail call fastcc void @stw_kernel(i32 %459, i32 %462) nounwind
<   %463 = add i32 %442, -6
<   %464 = and i32 %463, %sp_mask.0.i
<   %465 = add i32 %464, %321
<   tail call fastcc void @stw_kernel(i32 %465, i32 %old_eip.0.i) nounwind
<   %466 = icmp eq i32 %has_error_code.0.i, 0
<   br i1 %466, label %471, label %467
< 
< ; <label>:467                                     ; preds = %._crit_edge.i
<   %468 = add i32 %442, -8
<   %469 = and i32 %468, %sp_mask.0.i
<   %470 = add i32 %469, %321
<   tail call fastcc void @stw_kernel(i32 %470, i32 %error_code) nounwind
<   br label %471
< 
< ; <label>:471                                     ; preds = %467, %._crit_edge.i, %393, %._crit_edge169.i
<   %472 = phi i32 [ %389, %._crit_edge169.i ], [ %463, %._crit_edge.i ], [ %468, %467 ], [ %394, %393 ]
<   br i1 %new_stack.0.i, label %473, label %679
< 
< ; <label>:473                                     ; preds = %471
<   %474 = load %struct.CPUX86State** @env, align 8
<   %475 = getelementptr inbounds %struct.CPUX86State* %474, i64 0, i32 7
<   %476 = load i32* %475, align 4
<   %477 = and i32 %476, 131072
<   %478 = icmp eq i32 %477, 0
<   br i1 %478, label %632, label %cpu_x86_load_seg_cache.exit.i
< 
< cpu_x86_load_seg_cache.exit.i:                    ; preds = %473
<   %479 = getelementptr inbounds %struct.CPUX86State* %474, i64 0, i32 10, i64 0, i32 0
<   %.phi.trans.insert.i.i = getelementptr inbounds %struct.CPUX86State* %474, i64 0, i32 8
<   %480 = bitcast i32* %479 to i8*
<   br label %481
< 
< ; <label>:481                                     ; preds = %484, %cpu_x86_load_seg_cache.exit.i
<   %482 = phi i64 [ 0, %cpu_x86_load_seg_cache.exit.i ], [ %486, %484 ]
<   %483 = icmp ult i64 %482, 16
<   br i1 %483, label %484, label %487
< 
< ; <label>:484                                     ; preds = %481
<   %485 = getelementptr i8* %480, i64 %482
<   store i8 0, i8* %485, align 1
<   %486 = add i64 %482, 1
<   br label %481
< 
< ; <label>:487                                     ; preds = %481
<   %.pre.i.i = load i32* %.phi.trans.insert.i.i, align 4
<   %488 = getelementptr inbounds %struct.CPUX86State* %474, i64 0, i32 10, i64 2, i32 3
<   %489 = load i32* %488, align 4
<   %490 = lshr i32 %489, 17
<   %491 = and i32 %490, 32
<   %492 = and i32 %.pre.i.i, 32768
<   %493 = icmp eq i32 %492, 0
<   %494 = or i32 %491, 64
<   %new_hflags.0.i.i = select i1 %493, i32 %494, i32 %491
<   %495 = and i32 %.pre.i.i, -97
<   %496 = or i32 %new_hflags.0.i.i, %495
<   store i32 %496, i32* %.phi.trans.insert.i.i, align 4
<   %497 = load %struct.CPUX86State** @env, align 8
<   %498 = getelementptr inbounds %struct.CPUX86State* %497, i64 0, i32 10, i64 3, i32 0
<   %.phi.trans.insert.i105.i = getelementptr inbounds %struct.CPUX86State* %497, i64 0, i32 8
<   %499 = bitcast i32* %498 to i8*
<   br label %500
< 
< ; <label>:500                                     ; preds = %503, %487
<   %501 = phi i64 [ 0, %487 ], [ %505, %503 ]
<   %502 = icmp ult i64 %501, 16
<   br i1 %502, label %503, label %506
< 
< ; <label>:503                                     ; preds = %500
<   %504 = getelementptr i8* %499, i64 %501
<   store i8 0, i8* %504, align 1
<   %505 = add i64 %501, 1
<   br label %500
< 
< ; <label>:506                                     ; preds = %500
<   %.pre.i106.i = load i32* %.phi.trans.insert.i105.i, align 4
<   %507 = getelementptr inbounds %struct.CPUX86State* %497, i64 0, i32 10, i64 2, i32 3
<   %508 = load i32* %507, align 4
<   %509 = lshr i32 %508, 17
<   %510 = and i32 %509, 32
<   %511 = and i32 %.pre.i106.i, 32768
<   %512 = icmp eq i32 %511, 0
<   br i1 %512, label %513, label %cpu_x86_load_seg_cache.exit108.i
< 
< ; <label>:513                                     ; preds = %506
<   %514 = getelementptr inbounds %struct.CPUX86State* %497, i64 0, i32 15, i64 0
<   %515 = load i32* %514, align 4
<   %516 = and i32 %515, 1
<   %517 = icmp eq i32 %516, 0
<   br i1 %517, label %526, label %518
< 
< ; <label>:518                                     ; preds = %513
<   %519 = getelementptr inbounds %struct.CPUX86State* %497, i64 0, i32 7
<   %520 = load i32* %519, align 4
<   %521 = and i32 %520, 131072
<   %522 = icmp eq i32 %521, 0
<   br i1 %522, label %523, label %526
< 
< ; <label>:523                                     ; preds = %518
<   %524 = and i32 %.pre.i106.i, 16
<   %525 = icmp eq i32 %524, 0
<   br i1 %525, label %526, label %528
< 
< ; <label>:526                                     ; preds = %523, %518, %513
<   %527 = or i32 %510, 64
<   br label %cpu_x86_load_seg_cache.exit108.i
< 
< ; <label>:528                                     ; preds = %523
<   %529 = getelementptr inbounds %struct.CPUX86State* %497, i64 0, i32 10, i64 0, i32 1
<   %530 = load i32* %529, align 4
<   %531 = getelementptr inbounds %struct.CPUX86State* %497, i64 0, i32 10, i64 2, i32 1
<   %532 = load i32* %531, align 4
<   %533 = or i32 %532, %530
<   %534 = icmp ne i32 %533, 0
<   %535 = zext i1 %534 to i32
<   %536 = shl nuw nsw i32 %535, 6
<   %537 = or i32 %536, %510
<   br label %cpu_x86_load_seg_cache.exit108.i
< 
< cpu_x86_load_seg_cache.exit108.i:                 ; preds = %528, %526, %506
<   %new_hflags.0.i107.i = phi i32 [ %510, %506 ], [ %527, %526 ], [ %537, %528 ]
<   %538 = and i32 %.pre.i106.i, -97
<   %539 = or i32 %new_hflags.0.i107.i, %538
<   store i32 %539, i32* %.phi.trans.insert.i105.i, align 4
<   %540 = load %struct.CPUX86State** @env, align 8
<   %541 = getelementptr inbounds %struct.CPUX86State* %540, i64 0, i32 10, i64 4, i32 0
<   %.phi.trans.insert.i109.i = getelementptr inbounds %struct.CPUX86State* %540, i64 0, i32 8
<   %542 = bitcast i32* %541 to i8*
<   br label %543
< 
< ; <label>:543                                     ; preds = %546, %cpu_x86_load_seg_cache.exit108.i
<   %544 = phi i64 [ 0, %cpu_x86_load_seg_cache.exit108.i ], [ %548, %546 ]
<   %545 = icmp ult i64 %544, 16
<   br i1 %545, label %546, label %549
< 
< ; <label>:546                                     ; preds = %543
<   %547 = getelementptr i8* %542, i64 %544
<   store i8 0, i8* %547, align 1
<   %548 = add i64 %544, 1
<   br label %543
< 
< ; <label>:549                                     ; preds = %543
<   %.pre.i110.i = load i32* %.phi.trans.insert.i109.i, align 4
<   %550 = getelementptr inbounds %struct.CPUX86State* %540, i64 0, i32 10, i64 2, i32 3
<   %551 = load i32* %550, align 4
<   %552 = lshr i32 %551, 17
<   %553 = and i32 %552, 32
<   %554 = and i32 %.pre.i110.i, 32768
<   %555 = icmp eq i32 %554, 0
<   br i1 %555, label %556, label %cpu_x86_load_seg_cache.exit112.i
< 
< ; <label>:556                                     ; preds = %549
<   %557 = getelementptr inbounds %struct.CPUX86State* %540, i64 0, i32 15, i64 0
<   %558 = load i32* %557, align 4
<   %559 = and i32 %558, 1
<   %560 = icmp eq i32 %559, 0
<   br i1 %560, label %569, label %561
< 
< ; <label>:561                                     ; preds = %556
<   %562 = getelementptr inbounds %struct.CPUX86State* %540, i64 0, i32 7
<   %563 = load i32* %562, align 4
<   %564 = and i32 %563, 131072
<   %565 = icmp eq i32 %564, 0
<   br i1 %565, label %566, label %569
< 
< ; <label>:566                                     ; preds = %561
<   %567 = and i32 %.pre.i110.i, 16
<   %568 = icmp eq i32 %567, 0
<   br i1 %568, label %569, label %571
< 
< ; <label>:569                                     ; preds = %566, %561, %556
<   %570 = or i32 %553, 64
<   br label %cpu_x86_load_seg_cache.exit112.i
< 
< ; <label>:571                                     ; preds = %566
<   %572 = getelementptr inbounds %struct.CPUX86State* %540, i64 0, i32 10, i64 3, i32 1
<   %573 = load i32* %572, align 4
<   %574 = getelementptr inbounds %struct.CPUX86State* %540, i64 0, i32 10, i64 0, i32 1
<   %575 = load i32* %574, align 4
<   %576 = or i32 %575, %573
<   %577 = getelementptr inbounds %struct.CPUX86State* %540, i64 0, i32 10, i64 2, i32 1
<   %578 = load i32* %577, align 4
<   %579 = or i32 %576, %578
<   %580 = icmp ne i32 %579, 0
<   %581 = zext i1 %580 to i32
<   %582 = shl nuw nsw i32 %581, 6
<   %583 = or i32 %582, %553
<   br label %cpu_x86_load_seg_cache.exit112.i
< 
< cpu_x86_load_seg_cache.exit112.i:                 ; preds = %571, %569, %549
<   %new_hflags.0.i111.i = phi i32 [ %553, %549 ], [ %570, %569 ], [ %583, %571 ]
<   %584 = and i32 %.pre.i110.i, -97
<   %585 = or i32 %new_hflags.0.i111.i, %584
<   store i32 %585, i32* %.phi.trans.insert.i109.i, align 4
<   %586 = load %struct.CPUX86State** @env, align 8
<   %587 = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 10, i64 5, i32 0
<   %.phi.trans.insert.i113.i = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 8
<   %588 = bitcast i32* %587 to i8*
<   br label %589
< 
< ; <label>:589                                     ; preds = %592, %cpu_x86_load_seg_cache.exit112.i
<   %590 = phi i64 [ 0, %cpu_x86_load_seg_cache.exit112.i ], [ %594, %592 ]
<   %591 = icmp ult i64 %590, 16
<   br i1 %591, label %592, label %595
< 
< ; <label>:592                                     ; preds = %589
<   %593 = getelementptr i8* %588, i64 %590
<   store i8 0, i8* %593, align 1
<   %594 = add i64 %590, 1
<   br label %589
< 
< ; <label>:595                                     ; preds = %589
<   %.pre.i114.i = load i32* %.phi.trans.insert.i113.i, align 4
<   %596 = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 10, i64 2, i32 3
<   %597 = load i32* %596, align 4
<   %598 = lshr i32 %597, 17
<   %599 = and i32 %598, 32
<   %600 = and i32 %.pre.i114.i, 32768
<   %601 = icmp eq i32 %600, 0
<   br i1 %601, label %602, label %cpu_x86_load_seg_cache.exit116.i
< 
< ; <label>:602                                     ; preds = %595
<   %603 = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 15, i64 0
<   %604 = load i32* %603, align 4
<   %605 = and i32 %604, 1
<   %606 = icmp eq i32 %605, 0
<   br i1 %606, label %615, label %607
< 
< ; <label>:607                                     ; preds = %602
<   %608 = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 7
<   %609 = load i32* %608, align 4
<   %610 = and i32 %609, 131072
<   %611 = icmp eq i32 %610, 0
<   br i1 %611, label %612, label %615
< 
< ; <label>:612                                     ; preds = %607
<   %613 = and i32 %.pre.i114.i, 16
<   %614 = icmp eq i32 %613, 0
<   br i1 %614, label %615, label %617
< 
< ; <label>:615                                     ; preds = %612, %607, %602
<   %616 = or i32 %599, 64
<   br label %cpu_x86_load_seg_cache.exit116.i
< 
< ; <label>:617                                     ; preds = %612
<   %618 = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 10, i64 3, i32 1
<   %619 = load i32* %618, align 4
<   %620 = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 10, i64 0, i32 1
<   %621 = load i32* %620, align 4
<   %622 = or i32 %621, %619
<   %623 = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 10, i64 2, i32 1
<   %624 = load i32* %623, align 4
<   %625 = or i32 %622, %624
<   %626 = icmp ne i32 %625, 0
<   %627 = zext i1 %626 to i32
<   %628 = shl nuw nsw i32 %627, 6
<   %629 = or i32 %628, %599
<   br label %cpu_x86_load_seg_cache.exit116.i
< 
< cpu_x86_load_seg_cache.exit116.i:                 ; preds = %617, %615, %595
<   %new_hflags.0.i115.i = phi i32 [ %599, %595 ], [ %616, %615 ], [ %629, %617 ]
<   %630 = and i32 %.pre.i114.i, -97
<   %631 = or i32 %new_hflags.0.i115.i, %630
<   store i32 %631, i32* %.phi.trans.insert.i113.i, align 4
<   %.pre167.i = load %struct.CPUX86State** @env, align 8
<   br label %632
< 
< ; <label>:632                                     ; preds = %cpu_x86_load_seg_cache.exit116.i, %473
<   %633 = phi %struct.CPUX86State* [ %474, %473 ], [ %.pre167.i, %cpu_x86_load_seg_cache.exit116.i ]
<   %634 = and i32 %317, -4
<   %635 = or i32 %dpl.0.i, %634
<   %636 = and i32 %320, 983040
<   %637 = or i32 %636, %319
<   %638 = and i32 %320, 8388608
<   %639 = icmp eq i32 %638, 0
<   br i1 %639, label %get_seg_limit.exit.i, label %640
< 
< ; <label>:640                                     ; preds = %632
<   %641 = shl nuw i32 %637, 12
<   %642 = or i32 %641, 4095
<   br label %get_seg_limit.exit.i
< 
< get_seg_limit.exit.i:                             ; preds = %640, %632
<   %limit.0.i.i = phi i32 [ %642, %640 ], [ %637, %632 ]
<   %643 = getelementptr inbounds %struct.CPUX86State* %633, i64 0, i32 10, i64 2, i32 0
<   store i32 %635, i32* %643, align 4
<   %644 = getelementptr inbounds %struct.CPUX86State* %633, i64 0, i32 10, i64 2, i32 1
<   store i32 %321, i32* %644, align 4
<   %645 = getelementptr inbounds %struct.CPUX86State* %633, i64 0, i32 10, i64 2, i32 2
<   store i32 %limit.0.i.i, i32* %645, align 4
<   %646 = getelementptr inbounds %struct.CPUX86State* %633, i64 0, i32 10, i64 2, i32 3
<   store i32 %320, i32* %646, align 4
<   %.phi.trans.insert.i121.i = getelementptr inbounds %struct.CPUX86State* %633, i64 0, i32 8
<   %.pre.i122.i = load i32* %.phi.trans.insert.i121.i, align 4
<   %647 = lshr i32 %320, 17
<   %648 = and i32 %647, 32
<   %649 = and i32 %.pre.i122.i, 32768
<   %650 = icmp eq i32 %649, 0
<   br i1 %650, label %651, label %cpu_x86_load_seg_cache.exit124.i
< 
< ; <label>:651                                     ; preds = %get_seg_limit.exit.i
<   %652 = getelementptr inbounds %struct.CPUX86State* %633, i64 0, i32 15, i64 0
<   %653 = load i32* %652, align 4
<   %654 = and i32 %653, 1
<   %655 = icmp eq i32 %654, 0
<   br i1 %655, label %664, label %656
< 
< ; <label>:656                                     ; preds = %651
<   %657 = getelementptr inbounds %struct.CPUX86State* %633, i64 0, i32 7
<   %658 = load i32* %657, align 4
<   %659 = and i32 %658, 131072
<   %660 = icmp eq i32 %659, 0
<   br i1 %660, label %661, label %664
< 
< ; <label>:661                                     ; preds = %656
<   %662 = and i32 %.pre.i122.i, 16
<   %663 = icmp eq i32 %662, 0
<   br i1 %663, label %664, label %666
< 
< ; <label>:664                                     ; preds = %661, %656, %651
<   %665 = or i32 %648, 64
<   br label %cpu_x86_load_seg_cache.exit124.i
< 
< ; <label>:666                                     ; preds = %661
<   %667 = getelementptr inbounds %struct.CPUX86State* %633, i64 0, i32 10, i64 3, i32 1
<   %668 = load i32* %667, align 4
<   %669 = getelementptr inbounds %struct.CPUX86State* %633, i64 0, i32 10, i64 0, i32 1
<   %670 = load i32* %669, align 4
<   %671 = or i32 %668, %321
<   %672 = or i32 %671, %670
<   %673 = icmp ne i32 %672, 0
<   %674 = zext i1 %673 to i32
<   %675 = shl nuw nsw i32 %674, 6
<   %676 = or i32 %675, %648
<   br label %cpu_x86_load_seg_cache.exit124.i
< 
< cpu_x86_load_seg_cache.exit124.i:                 ; preds = %666, %664, %get_seg_limit.exit.i
<   %new_hflags.0.i123.i = phi i32 [ %648, %get_seg_limit.exit.i ], [ %665, %664 ], [ %676, %666 ]
<   %677 = and i32 %.pre.i122.i, -97
<   %678 = or i32 %new_hflags.0.i123.i, %677
<   store i32 %678, i32* %.phi.trans.insert.i121.i, align 4
<   br label %679
< 
< ; <label>:679                                     ; preds = %cpu_x86_load_seg_cache.exit124.i, %471
<   %680 = load %struct.CPUX86State** @env, align 8
<   %681 = getelementptr inbounds %struct.CPUX86State* %680, i64 0, i32 0, i64 4
<   %682 = load i32* %681, align 4
<   %683 = sub i32 0, %sp_mask.0.in.i
<   %684 = and i32 %682, %683
<   %685 = and i32 %472, %sp_mask.0.i
<   %686 = or i32 %684, %685
<   store i32 %686, i32* %681, align 4
<   %687 = or i32 %dpl.0.i, %171
<   %688 = load %struct.CPUX86State** @env, align 8
<   %689 = lshr i32 %189, 16
<   %690 = shl i32 %191, 16
<   %691 = and i32 %690, 16711680
<   %692 = and i32 %191, -16777216
<   %693 = or i32 %692, %689
<   %694 = or i32 %693, %691
<   %695 = and i32 %189, 65535
<   %696 = and i32 %191, 983040
<   %697 = or i32 %696, %695
<   %698 = and i32 %191, 8388608
<   %699 = icmp eq i32 %698, 0
<   br i1 %699, label %get_seg_limit.exit120.i, label %700
< 
< ; <label>:700                                     ; preds = %679
<   %701 = shl nuw i32 %697, 12
<   %702 = or i32 %701, 4095
<   br label %get_seg_limit.exit120.i
< 
< get_seg_limit.exit120.i:                          ; preds = %700, %679
<   %limit.0.i119.i = phi i32 [ %702, %700 ], [ %697, %679 ]
<   %703 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 10, i64 1, i32 0
<   store i32 %687, i32* %703, align 4
<   %704 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 10, i64 1, i32 1
<   store i32 %694, i32* %704, align 4
<   %705 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 10, i64 1, i32 2
<   store i32 %limit.0.i119.i, i32* %705, align 4
<   %706 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 10, i64 1, i32 3
<   store i32 %191, i32* %706, align 4
<   %707 = lshr i32 %191, 18
<   %708 = and i32 %707, 16
<   %709 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 8
<   %710 = load i32* %709, align 4
<   %711 = and i32 %710, -32785
<   %712 = or i32 %711, %708
<   store i32 %712, i32* %709, align 4
<   %713 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 10, i64 2, i32 3
<   %714 = load i32* %713, align 4
<   %715 = lshr i32 %714, 17
<   %716 = and i32 %715, 32
<   %717 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 15, i64 0
<   %718 = load i32* %717, align 4
<   %719 = and i32 %718, 1
<   %720 = icmp eq i32 %719, 0
<   br i1 %720, label %727, label %721
< 
< ; <label>:721                                     ; preds = %get_seg_limit.exit120.i
<   %722 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 7
<   %723 = load i32* %722, align 4
<   %724 = and i32 %723, 131072
<   %725 = icmp ne i32 %724, 0
<   %726 = icmp eq i32 %708, 0
<   %or.cond166.i = or i1 %725, %726
<   br i1 %or.cond166.i, label %727, label %729
< 
< ; <label>:727                                     ; preds = %721, %get_seg_limit.exit120.i
<   %728 = or i32 %716, 64
<   br label %cpu_x86_load_seg_cache.exit118.i
< 
< ; <label>:729                                     ; preds = %721
<   %730 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 10, i64 3, i32 1
<   %731 = load i32* %730, align 4
<   %732 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 10, i64 0, i32 1
<   %733 = load i32* %732, align 4
<   %734 = or i32 %733, %731
<   %735 = getelementptr inbounds %struct.CPUX86State* %688, i64 0, i32 10, i64 2, i32 1
<   %736 = load i32* %735, align 4
<   %737 = or i32 %734, %736
<   %738 = icmp ne i32 %737, 0
<   %739 = zext i1 %738 to i32
<   %740 = shl nuw nsw i32 %739, 6
<   %741 = or i32 %740, %716
<   br label %cpu_x86_load_seg_cache.exit118.i
---
> ; <label>:97                                      ; preds = %92
>   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
>   %98 = load i8* %ret.i.i.i, align 1
>   br label %._crit_edge8.i.i
2896,2969c1826,1830
< cpu_x86_load_seg_cache.exit118.i:                 ; preds = %729, %727
<   %new_hflags.0.i117.i = phi i32 [ %728, %727 ], [ %741, %729 ]
<   %742 = and i32 %712, -32865
<   %743 = or i32 %new_hflags.0.i117.i, %742
<   store i32 %743, i32* %709, align 4
<   %744 = load %struct.CPUX86State** @env, align 8
<   %745 = getelementptr inbounds %struct.CPUX86State* %744, i64 0, i32 8
<   %746 = load i32* %745, align 4
<   %747 = and i32 %746, 3
<   tail call void @s2e_on_privilege_change(i32 %747, i32 %dpl.0.i) nounwind
<   %748 = load i32* %745, align 4
<   %749 = and i32 %748, -4
<   %750 = or i32 %749, %dpl.0.i
<   store i32 %750, i32* %745, align 4
<   %751 = load %struct.CPUX86State** @env, align 8
<   %752 = getelementptr inbounds %struct.CPUX86State* %751, i64 0, i32 5
<   store i32 %170, i32* %752, align 4
<   %753 = and i32 %109, 1
<   %754 = icmp eq i32 %753, 0
<   br i1 %754, label %755, label %760
< 
< ; <label>:755                                     ; preds = %cpu_x86_load_seg_cache.exit118.i
<   %756 = load %struct.CPUX86State** @env, align 8
<   %757 = getelementptr inbounds %struct.CPUX86State* %756, i64 0, i32 7
<   %758 = load i32* %757, align 4
<   %759 = and i32 %758, -513
<   store i32 %759, i32* %757, align 4
<   br label %760
< 
< ; <label>:760                                     ; preds = %755, %cpu_x86_load_seg_cache.exit118.i
<   %761 = load %struct.CPUX86State** @env, align 8
<   %762 = getelementptr inbounds %struct.CPUX86State* %761, i64 0, i32 7
<   %763 = load i32* %762, align 4
<   %764 = and i32 %763, -213249
<   store i32 %764, i32* %762, align 4
<   br label %do_interrupt_protected.exit
< 
< ; <label>:765                                     ; preds = %._crit_edge
<   br i1 %61, label %766, label %handle_even_inj.exit
< 
< ; <label>:766                                     ; preds = %765
<   %767 = getelementptr inbounds %struct.CPUX86State* %53, i64 0, i32 39
<   %768 = load i64* %767, align 8
<   %769 = add i64 %768, 168
<   %770 = tail call i32 @ldl_phys(i64 %769) nounwind
<   %771 = icmp slt i32 %770, 0
<   br i1 %771, label %handle_even_inj.exit, label %772
< 
< ; <label>:772                                     ; preds = %766
<   %773 = icmp eq i32 %is_int, 0
<   %..i = select i1 %773, i32 768, i32 1024
<   %774 = or i32 %..i, %intno
<   %775 = or i32 %774, -2147483648
<   %776 = load %struct.CPUX86State** @env, align 8
<   %777 = getelementptr inbounds %struct.CPUX86State* %776, i64 0, i32 39
<   %778 = load i64* %777, align 8
<   %779 = add i64 %778, 168
<   tail call void @stl_phys(i64 %779, i32 %775) nounwind
<   br label %handle_even_inj.exit
< 
< handle_even_inj.exit:                             ; preds = %772, %766, %765
<   %780 = load %struct.CPUX86State** @env, align 8
<   %781 = shl nsw i32 %intno, 2
<   %782 = or i32 %781, 3
<   %783 = getelementptr inbounds %struct.CPUX86State* %780, i64 0, i32 14, i32 2
<   %784 = load i32* %783, align 4
<   %785 = icmp ugt i32 %782, %784
<   br i1 %785, label %786, label %789
< 
< ; <label>:786                                     ; preds = %handle_even_inj.exit
<   %787 = shl nsw i32 %intno, 3
<   %788 = or i32 %787, 2
<   tail call fastcc void @raise_exception_err(i32 13, i32 %788) noreturn nounwind
<   unreachable
---
> ._crit_edge8.i.i:                                 ; preds = %97, %92
>   %99 = phi i8 [ %98, %97 ], [ %data.i.sroa.2.2.extract.trunc.i, %92 ]
>   %.pr12.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
>   %100 = icmp eq i32 %.pr12.pr.i.i, 0
>   br i1 %100, label %io_read_chk_symb_l.exit.i, label %101
2971,2984c1832,1837
< ; <label>:789                                     ; preds = %handle_even_inj.exit
<   %790 = getelementptr inbounds %struct.CPUX86State* %780, i64 0, i32 14, i32 1
<   %791 = load i32* %790, align 4
<   %792 = add i32 %791, %781
<   %793 = tail call fastcc i32 @lduw_kernel(i32 %792) nounwind
<   %794 = add i32 %792, 2
<   %795 = tail call fastcc i32 @lduw_kernel(i32 %794) nounwind
<   %796 = load %struct.CPUX86State** @env, align 8
<   %797 = getelementptr inbounds %struct.CPUX86State* %796, i64 0, i32 0, i64 4
<   %798 = load i32* %797, align 4
<   %799 = getelementptr inbounds %struct.CPUX86State* %796, i64 0, i32 10, i64 2, i32 1
<   %800 = load i32* %799, align 4
<   %801 = icmp eq i32 %is_int, 0
<   br i1 %801, label %802, label %do_interrupt_real.exit
---
> ; <label>:101                                     ; preds = %._crit_edge8.i.i
>   %102 = add i64 %35, 3
>   %103 = and i64 %102, 4294967295
>   %104 = call i32 @s2e_is_mmio_symbolic_b(i64 %103) nounwind
>   %105 = icmp eq i32 %104, 0
>   br i1 %105, label %io_read_chk_symb_l.exit.i, label %106
2986,3059c1839,1842
< ; <label>:802                                     ; preds = %789
<   %803 = getelementptr inbounds %struct.CPUX86State* %796, i64 0, i32 5
<   %804 = load i32* %803, align 4
<   br label %do_interrupt_real.exit
< 
< do_interrupt_real.exit:                           ; preds = %802, %789
<   %old_eip.0.i21 = phi i32 [ %804, %802 ], [ %next_eip, %789 ]
<   %805 = getelementptr inbounds %struct.CPUX86State* %796, i64 0, i32 10, i64 1, i32 0
<   %806 = load i32* %805, align 4
<   %807 = add i32 %798, 65534
<   %808 = and i32 %807, 65535
<   %809 = add i32 %808, %800
<   %810 = getelementptr inbounds %struct.CPUX86State* %796, i64 0, i32 7
<   %811 = load i32* %810, align 4
<   %812 = getelementptr inbounds %struct.CPUX86State* %796, i64 0, i32 1
<   %813 = load i32* %812, align 4
<   %814 = tail call i32 @helper_cc_compute_all(i32 %813) nounwind
<   %815 = or i32 %814, %811
<   %816 = getelementptr inbounds %struct.CPUX86State* %796, i64 0, i32 6
<   %817 = load i32* %816, align 4
<   %818 = and i32 %817, 1024
<   %819 = or i32 %815, %818
<   tail call fastcc void @stw_kernel(i32 %809, i32 %819) nounwind
<   %820 = add i32 %798, 65532
<   %821 = and i32 %820, 65535
<   %822 = add i32 %821, %800
<   tail call fastcc void @stw_kernel(i32 %822, i32 %806) nounwind
<   %823 = add i32 %798, 65530
<   %824 = and i32 %823, 65535
<   %825 = add i32 %824, %800
<   tail call fastcc void @stw_kernel(i32 %825, i32 %old_eip.0.i21) nounwind
<   %826 = load %struct.CPUX86State** @env, align 8
<   %827 = getelementptr inbounds %struct.CPUX86State* %826, i64 0, i32 0, i64 4
<   %828 = load i32* %827, align 4
<   %829 = and i32 %828, -65536
<   %830 = or i32 %829, %824
<   store i32 %830, i32* %827, align 4
<   %831 = load %struct.CPUX86State** @env, align 8
<   %832 = getelementptr inbounds %struct.CPUX86State* %831, i64 0, i32 5
<   store i32 %793, i32* %832, align 4
<   %833 = load %struct.CPUX86State** @env, align 8
<   %834 = getelementptr inbounds %struct.CPUX86State* %833, i64 0, i32 10, i64 1, i32 0
<   store i32 %795, i32* %834, align 4
<   %835 = shl i32 %795, 4
<   %836 = load %struct.CPUX86State** @env, align 8
<   %837 = getelementptr inbounds %struct.CPUX86State* %836, i64 0, i32 10, i64 1, i32 1
<   store i32 %835, i32* %837, align 4
<   %838 = load %struct.CPUX86State** @env, align 8
<   %839 = getelementptr inbounds %struct.CPUX86State* %838, i64 0, i32 7
<   %840 = load i32* %839, align 4
<   %841 = and i32 %840, -328449
<   store i32 %841, i32* %839, align 4
<   br label %do_interrupt_protected.exit
< 
< do_interrupt_protected.exit:                      ; preds = %do_interrupt_real.exit, %760, %141, %116
<   %842 = load %struct.CPUX86State** @env, align 8
<   %843 = getelementptr inbounds %struct.CPUX86State* %842, i64 0, i32 8
<   %844 = load i32* %843, align 4
<   %845 = and i32 %844, 2097152
<   %846 = icmp eq i32 %845, 0
<   br i1 %846, label %857, label %847
< 
< ; <label>:847                                     ; preds = %do_interrupt_protected.exit
<   %848 = getelementptr inbounds %struct.CPUX86State* %842, i64 0, i32 39
<   %849 = load i64* %848, align 8
<   %850 = add i64 %849, 168
<   %851 = tail call i32 @ldl_phys(i64 %850) nounwind
<   %852 = load %struct.CPUX86State** @env, align 8
<   %853 = getelementptr inbounds %struct.CPUX86State* %852, i64 0, i32 39
<   %854 = load i64* %853, align 8
<   %855 = add i64 %854, 168
<   %856 = and i32 %851, 2147483647
<   tail call void @stl_phys(i64 %855, i32 %856) nounwind
<   br label %857
---
> ; <label>:106                                     ; preds = %101
>   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
>   %107 = load i8* %ret.i.i.i, align 1
>   br label %io_read_chk_symb_l.exit.i
3061,3063c1844,1859
< ; <label>:857                                     ; preds = %847, %do_interrupt_protected.exit
<   ret void
< }
---
> io_read_chk_symb_l.exit.i:                        ; preds = %106, %101, %._crit_edge8.i.i, %._crit_edge9.i.i, %._crit_edge10.i.i, %73
>   %108 = phi i8 [ %data.i.sroa.3.3.extract.trunc.i, %73 ], [ %data.i.sroa.3.3.extract.trunc.i, %._crit_edge10.i.i ], [ %data.i.sroa.3.3.extract.trunc.i, %._crit_edge9.i.i ], [ %data.i.sroa.3.3.extract.trunc.i, %._crit_edge8.i.i ], [ %data.i.sroa.3.3.extract.trunc.i, %101 ], [ %107, %106 ]
>   %109 = phi i8 [ %data.i.sroa.2.2.extract.trunc.i, %73 ], [ %data.i.sroa.2.2.extract.trunc.i, %._crit_edge10.i.i ], [ %data.i.sroa.2.2.extract.trunc.i, %._crit_edge9.i.i ], [ %99, %._crit_edge8.i.i ], [ %99, %101 ], [ %99, %106 ]
>   %110 = phi i8 [ %data.i.sroa.1.1.extract.trunc.i, %73 ], [ %data.i.sroa.1.1.extract.trunc.i, %._crit_edge10.i.i ], [ %90, %._crit_edge9.i.i ], [ %90, %._crit_edge8.i.i ], [ %90, %101 ], [ %90, %106 ]
>   %data.i.sroa.0.0.extract.trunc24.i = phi i8 [ %data.i.sroa.0.0.extract.trunc.i, %73 ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge10.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge9.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge8.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %101 ], [ %data.i.sroa.0.0.extract.trunc23.i, %106 ]
>   %data.i.sroa.3.3.insert.ext.i = zext i8 %108 to i32
>   %data.i.sroa.3.3.insert.shift.i = shl nuw i32 %data.i.sroa.3.3.insert.ext.i, 24
>   %data.i.sroa.2.2.insert.ext.i = zext i8 %109 to i32
>   %data.i.sroa.2.2.insert.shift.i = shl nuw nsw i32 %data.i.sroa.2.2.insert.ext.i, 16
>   %data.i.sroa.2.2.insert.insert.i = or i32 %data.i.sroa.2.2.insert.shift.i, %data.i.sroa.3.3.insert.shift.i
>   %data.i.sroa.1.1.insert.ext.i = zext i8 %110 to i32
>   %data.i.sroa.1.1.insert.shift.i = shl nuw nsw i32 %data.i.sroa.1.1.insert.ext.i, 8
>   %data.i.sroa.1.1.insert.insert.i = or i32 %data.i.sroa.2.2.insert.insert.i, %data.i.sroa.1.1.insert.shift.i
>   %data.i.sroa.0.0.insert.ext.i = zext i8 %data.i.sroa.0.0.extract.trunc24.i to i32
>   %data.i.sroa.0.0.insert.insert.i = or i32 %data.i.sroa.1.1.insert.insert.i, %data.i.sroa.0.0.insert.ext.i
>   br label %io_read_chkl_mmu.exit
3065c1861,1863
< declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture, ...) nounwind
---
> ; <label>:111                                     ; preds = %can_do_io.exit.thread.i
>   %112 = call i32 @io_readl_mmu(i64 %30, i32 %8, i8* null) nounwind
>   br label %io_read_chkl_mmu.exit
3067c1865,1870
< declare i32 @ldl_phys(i64)
---
> io_read_chkl_mmu.exit:                            ; preds = %111, %io_read_chk_symb_l.exit.i, %68
>   %.0.i = phi i32 [ %data.i.sroa.0.0.insert.insert.i, %io_read_chk_symb_l.exit.i ], [ %112, %111 ], [ %72, %68 ]
>   %113 = add i64 %30, %34
>   %114 = zext i32 %.0.i to i64
>   call void @tcg_llvm_trace_memory_access(i64 %34, i64 %113, i64 %114, i32 32, i8 zeroext 0, i8 zeroext 1) nounwind
>   br label %145
3069c1872,1876
< declare void @stl_phys(i64, i32)
---
> ; <label>:115                                     ; preds = %._crit_edge
>   %116 = and i32 %8, 127
>   %117 = add i32 %116, 3
>   %118 = icmp ugt i32 %117, 127
>   br i1 %118, label %119, label %130
3071,3088c1878,1889
< define void @do_interrupt(%struct.CPUX86State* %env1) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   store %struct.CPUX86State* %env1, %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %env1, i64 0, i32 92
<   %3 = load i32* %2, align 4
<   %4 = getelementptr inbounds %struct.CPUX86State* %env1, i64 0, i32 56
<   %5 = load i32* %4, align 4
<   %6 = getelementptr inbounds %struct.CPUX86State* %env1, i64 0, i32 55
<   %7 = load i32* %6, align 4
<   %8 = getelementptr inbounds %struct.CPUX86State* %env1, i64 0, i32 57
<   %9 = load i32* %8, align 4
<   tail call void @do_interrupt_all(i32 %3, i32 %5, i32 %7, i32 %9, i32 0) nounwind
<   %10 = load %struct.CPUX86State** @env, align 8
<   %11 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 61
<   store i32 -1, i32* %11, align 4
<   store %struct.CPUX86State* %1, %struct.CPUX86State** @env, align 8
<   ret void
< }
---
> ; <label>:119                                     ; preds = %115, %25
>   %120 = and i32 %8, -4
>   %121 = add i32 %120, 4
>   %122 = call fastcc i32 @slow_ldl_mmu(i32 %120, i32 %mmu_idx)
>   %123 = call fastcc i32 @slow_ldl_mmu(i32 %121, i32 %mmu_idx)
>   %124 = shl i32 %8, 3
>   %125 = and i32 %124, 24
>   %126 = lshr i32 %122, %125
>   %127 = sub i32 32, %125
>   %128 = shl i32 %123, %127
>   %129 = or i32 %128, %126
>   br label %145
3090c1891,1900
< declare void @do_interrupt_all(i32, i32, i32, i32, i32)
---
> ; <label>:130                                     ; preds = %115
>   %131 = getelementptr inbounds %struct.CPUX86State* %.lcssa2, i64 0, i32 73, i64 %14, i64 %13, i32 3
>   %132 = load i64* %131, align 8
>   %133 = and i64 %7, 4294967295
>   %134 = add i64 %132, %133
>   %135 = inttoptr i64 %134 to i32*
>   %136 = load i32* %135, align 4
>   %137 = zext i32 %136 to i64
>   call void @tcg_llvm_trace_memory_access(i64 %133, i64 %134, i64 %137, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
>   br label %145
3092,3098c1902,1910
< define void @do_interrupt_x86_hardirq(%struct.CPUX86State* %env1, i32 %intno, i32 %is_hw) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   store %struct.CPUX86State* %env1, %struct.CPUX86State** @env, align 8
<   tail call void @do_interrupt_all(i32 %intno, i32 0, i32 0, i32 0, i32 %is_hw) nounwind
<   store %struct.CPUX86State* %1, %struct.CPUX86State** @env, align 8
<   ret void
< }
---
> ; <label>:138                                     ; preds = %138, %.lr.ph
>   %139 = phi %struct.CPUX86State* [ %15, %.lr.ph ], [ %140, %138 ]
>   call void @tlb_fill(%struct.CPUX86State* %139, i32 %8, i32 %22, i32 0, i32 %mmu_idx, i8* null)
>   %140 = load %struct.CPUX86State** @env, align 8
>   %141 = getelementptr inbounds %struct.CPUX86State* %140, i64 0, i32 73, i64 %14, i64 %13, i32 0
>   %142 = load i32* %141, align 4
>   %143 = and i32 %142, -4088
>   %144 = icmp eq i32 %18, %143
>   br i1 %144, label %._crit_edge, label %138
3100,3103c1912,1914
< define void @raise_exception_err_env(%struct.CPUX86State* %nenv, i32 %exception_index, i32 %error_code) noreturn nounwind uwtable {
<   store %struct.CPUX86State* %nenv, %struct.CPUX86State** @env, align 8
<   tail call fastcc void @raise_interrupt(i32 %exception_index, i32 0, i32 %error_code, i32 0) noreturn
<   unreachable
---
> ; <label>:145                                     ; preds = %130, %119, %io_read_chkl_mmu.exit
>   %res.0 = phi i32 [ %129, %119 ], [ %.0.i, %io_read_chkl_mmu.exit ], [ %136, %130 ]
>   ret i32 %res.0
3106,3176c1917
< define internal fastcc void @raise_interrupt(i32 %intno, i32 %is_int, i32 %error_code, i32 %next_eip_addend) noreturn nounwind uwtable {
<   %1 = icmp eq i32 %is_int, 0
<   br i1 %1, label %2, label %50
< 
< ; <label>:2                                       ; preds = %0
<   %3 = add nsw i32 %intno, 64
<   %4 = sext i32 %error_code to i64
<   tail call void @helper_svm_check_intercept_param(i32 %3, i64 %4)
<   %5 = load %struct.CPUX86State** @env, align 8
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 61
<   %7 = load i32* %6, align 4
<   %8 = icmp eq i32 %7, 0
<   br i1 %8, label %10, label %9
< 
< ; <label>:9                                       ; preds = %2
<   %.off.i = add i32 %7, -10
<   %phitmp.i = icmp ugt i32 %.off.i, 3
<   br label %10
< 
< ; <label>:10                                      ; preds = %9, %2
<   %11 = phi i1 [ false, %2 ], [ %phitmp.i, %9 ]
<   %12 = icmp eq i32 %intno, 0
<   br i1 %12, label %15, label %13
< 
< ; <label>:13                                      ; preds = %10
<   %intno.off.i = add i32 %intno, -10
<   %14 = icmp ult i32 %intno.off.i, 4
<   br label %15
< 
< ; <label>:15                                      ; preds = %13, %10
<   %16 = phi i1 [ true, %10 ], [ %14, %13 ]
<   %17 = load i32* @loglevel, align 4
<   %18 = and i32 %17, 16
<   %19 = icmp eq i32 %18, 0
<   br i1 %19, label %23, label %20
< 
< ; <label>:20                                      ; preds = %15
<   %21 = load %struct._IO_FILE** @logfile, align 8
<   %22 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %21, i8* getelementptr inbounds ([36 x i8]* @.str21, i64 0, i64 0), i32 %7, i32 %intno) nounwind
<   %.pre.i = load %struct.CPUX86State** @env, align 8
<   %.phi.trans.insert.i = getelementptr inbounds %struct.CPUX86State* %.pre.i, i64 0, i32 61
<   %.pre18.i = load i32* %.phi.trans.insert.i, align 4
<   br label %23
< 
< ; <label>:23                                      ; preds = %20, %15
<   %24 = phi i32 [ %7, %15 ], [ %.pre18.i, %20 ]
<   %25 = phi %struct.CPUX86State* [ %5, %15 ], [ %.pre.i, %20 ]
<   %26 = icmp eq i32 %24, 8
<   br i1 %26, label %27, label %41
< 
< ; <label>:27                                      ; preds = %23
<   %28 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 8
<   %29 = load i32* %28, align 4
<   %30 = and i32 %29, 2097152
<   %31 = icmp eq i32 %30, 0
<   br i1 %31, label %33, label %32
< 
< ; <label>:32                                      ; preds = %27
<   tail call void @helper_vmexit(i32 127, i64 0) nounwind
<   unreachable
< 
< ; <label>:33                                      ; preds = %27
<   %34 = load i32* @loglevel, align 4
<   %35 = and i32 %34, 512
<   %36 = icmp eq i32 %35, 0
<   br i1 %36, label %40, label %37
< 
< ; <label>:37                                      ; preds = %33
<   %38 = load %struct._IO_FILE** @logfile, align 8
<   %39 = tail call i64 @fwrite(i8* getelementptr inbounds ([14 x i8]* @.str22, i64 0, i64 0), i64 13, i64 1, %struct._IO_FILE* %38) nounwind
<   br label %40
---
> declare void @io_writel_mmu(i64, i32, i32, i8*)
3178,3185c1919
< ; <label>:40                                      ; preds = %37, %33
<   tail call void @qemu_system_reset_request() nounwind
<   br label %check_exception.exit
< 
< ; <label>:41                                      ; preds = %23
<   %.not16.i = xor i1 %16, true
<   %brmerge.i = or i1 %11, %.not16.i
<   br i1 %brmerge.i, label %42, label %46
---
> declare void @__stl_mmu(i32, i32, i32) nounwind uwtable
3187,3189c1921
< ; <label>:42                                      ; preds = %41
<   %43 = icmp eq i32 %24, 14
<   br i1 %43, label %44, label %47
---
> declare void @s2e_on_tlb_miss(%struct.S2E*, %struct.S2EExecutionState*, i64, i32)
3191,3194c1923
< ; <label>:44                                      ; preds = %42
<   %45 = icmp eq i32 %intno, 14
<   %or.cond17.i = or i1 %16, %45
<   br i1 %or.cond17.i, label %46, label %47
---
> declare i32 @cpu_x86_handle_mmu_fault(%struct.CPUX86State*, i32, i32, i32)
3196,3197c1925
< ; <label>:46                                      ; preds = %44, %41
<   br label %47
---
> declare void @stq_phys(i64, i64)
3199,3208c1927
< ; <label>:47                                      ; preds = %46, %44, %42
<   %error_code8 = phi i32 [ 0, %46 ], [ %error_code, %42 ], [ %error_code, %44 ]
<   %.014.i = phi i32 [ 8, %46 ], [ %intno, %42 ], [ %intno, %44 ]
<   br i1 %16, label %._crit_edge.i, label %48
< 
< ; <label>:48                                      ; preds = %47
<   switch i32 %.014.i, label %check_exception.exit [
<     i32 14, label %._crit_edge.i
<     i32 8, label %._crit_edge.i
<   ]
---
> declare %struct.TranslationBlock* @tb_find_pc(i64)
3210,3213c1929
< ._crit_edge.i:                                    ; preds = %48, %48, %47
<   %49 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 61
<   store i32 %.014.i, i32* %49, align 4
<   br label %check_exception.exit
---
> declare i32 @cpu_restore_state(%struct.TranslationBlock*, %struct.CPUX86State*, i64)
3215,3228c1931
< ; <label>:50                                      ; preds = %0
<   %51 = load %struct.CPUX86State** @env, align 8
<   %52 = getelementptr inbounds %struct.CPUX86State* %51, i64 0, i32 8
<   %53 = load i32* %52, align 4
<   %.lobit.i = and i32 %53, 2097152
<   %54 = icmp eq i32 %.lobit.i, 0
<   br i1 %54, label %check_exception.exit, label %55, !prof !0
< 
< ; <label>:55                                      ; preds = %50
<   %56 = getelementptr inbounds %struct.CPUX86State* %51, i64 0, i32 41
<   %57 = load i64* %56, align 8
<   %58 = and i64 %57, 2097152
<   %59 = icmp eq i64 %58, 0
<   br i1 %59, label %check_exception.exit, label %60
---
> declare void @s2e_on_page_fault(%struct.S2E*, %struct.S2EExecutionState*, i64, i32)
3230,3232c1933
< ; <label>:60                                      ; preds = %55
<   tail call void @helper_vmexit(i32 117, i64 0) nounwind
<   unreachable
---
> declare i64 @ldq_phys(i64)
3234,3255c1935
< check_exception.exit:                             ; preds = %55, %50, %._crit_edge.i, %48, %40
<   %error_code6 = phi i32 [ %error_code, %40 ], [ %error_code8, %48 ], [ %error_code8, %._crit_edge.i ], [ %error_code, %50 ], [ %error_code, %55 ]
<   %.0 = phi i32 [ 65537, %40 ], [ %.014.i, %48 ], [ %.014.i, %._crit_edge.i ], [ %intno, %50 ], [ %intno, %55 ]
<   %61 = load %struct.CPUX86State** @env, align 8
<   %62 = getelementptr inbounds %struct.CPUX86State* %61, i64 0, i32 92
<   store i32 %.0, i32* %62, align 4
<   %63 = load %struct.CPUX86State** @env, align 8
<   %64 = getelementptr inbounds %struct.CPUX86State* %63, i64 0, i32 55
<   store i32 %error_code6, i32* %64, align 4
<   %65 = load %struct.CPUX86State** @env, align 8
<   %66 = getelementptr inbounds %struct.CPUX86State* %65, i64 0, i32 56
<   store i32 %is_int, i32* %66, align 4
<   %67 = load %struct.CPUX86State** @env, align 8
<   %68 = getelementptr inbounds %struct.CPUX86State* %67, i64 0, i32 5
<   %69 = load i32* %68, align 4
<   %70 = add i32 %69, %next_eip_addend
<   %71 = getelementptr inbounds %struct.CPUX86State* %67, i64 0, i32 57
<   store i32 %70, i32* %71, align 4
<   %72 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_loop_exit(%struct.CPUX86State* %72) noreturn nounwind
<   unreachable
< }
---
> declare i32 @lduw_phys(i64)
3257,3261c1937
< define void @raise_exception_env(i32 %exception_index, %struct.CPUX86State* %nenv) noreturn nounwind uwtable {
<   store %struct.CPUX86State* %nenv, %struct.CPUX86State** @env, align 8
<   tail call fastcc void @raise_exception(i32 %exception_index) noreturn
<   unreachable
< }
---
> declare i32 @ldub_phys(i64)
3263,3266c1939,1943
< define internal fastcc void @raise_exception(i32 %exception_index) noreturn nounwind uwtable {
<   tail call fastcc void @raise_interrupt(i32 %exception_index, i32 0, i32 0, i32 0) noreturn
<   unreachable
< }
---
> define internal void @helper_vmexit(i32 %exit_code, i64 %exit_info_1) noreturn nounwind uwtable {
>   %1 = load i32* @loglevel, align 4
>   %2 = and i32 %1, 2
>   %3 = icmp eq i32 %2, 0
>   br i1 %3, label %15, label %4
3268,3274c1945,1956
< define void @do_smm_enter(%struct.CPUX86State* %env1) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   store %struct.CPUX86State* %env1, %struct.CPUX86State** @env, align 8
<   %2 = load i32* @loglevel, align 4
<   %3 = and i32 %2, 16
<   %4 = icmp eq i32 %3, 0
<   br i1 %4, label %8, label %5
---
> ; <label>:4                                       ; preds = %0
>   %5 = load %struct._IO_FILE** @logfile, align 8
>   %6 = load %struct.CPUX86State** @env, align 8
>   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 39
>   %8 = load i64* %7, align 8
>   %9 = add i64 %8, 128
>   %10 = tail call i64 @ldq_phys(i64 %9) nounwind
>   %11 = load %struct.CPUX86State** @env, align 8
>   %12 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 5
>   %13 = load i32* %12, align 4
>   %14 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %5, i8* getelementptr inbounds ([37 x i8]* @.str19, i64 0, i64 0), i32 %exit_code, i64 %exit_info_1, i64 %10, i32 %13) nounwind
>   br label %15
3276,3280c1958,1967
< ; <label>:5                                       ; preds = %0
<   %6 = load %struct._IO_FILE** @logfile, align 8
<   %7 = tail call i64 @fwrite(i8* getelementptr inbounds ([12 x i8]* @.str7, i64 0, i64 0), i64 11, i64 1, %struct._IO_FILE* %6)
<   %.pre = load i32* @loglevel, align 4
<   br label %8
---
> ; <label>:15                                      ; preds = %4, %0
>   %16 = load %struct.CPUX86State** @env, align 8
>   %17 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 8
>   %18 = load i32* %17, align 4
>   %19 = and i32 %18, 8
>   %20 = icmp eq i32 %19, 0
>   %21 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 39
>   %22 = load i64* %21, align 8
>   %23 = add i64 %22, 104
>   br i1 %20, label %29, label %24
3282,3286c1969,1976
< ; <label>:8                                       ; preds = %5, %0
<   %9 = phi i32 [ %2, %0 ], [ %.pre, %5 ]
<   %10 = and i32 %9, 16
<   %11 = icmp eq i32 %10, 0
<   br i1 %11, label %._crit_edge, label %12
---
> ; <label>:24                                      ; preds = %15
>   tail call void @stl_phys(i64 %23, i32 1) nounwind
>   %25 = load %struct.CPUX86State** @env, align 8
>   %26 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 8
>   %27 = load i32* %26, align 4
>   %28 = and i32 %27, -9
>   store i32 %28, i32* %26, align 4
>   br label %30
3288,3292c1978,1980
< ; <label>:12                                      ; preds = %8
<   %13 = load %struct.CPUX86State** @env, align 8
<   %14 = load %struct._IO_FILE** @logfile, align 8
<   tail call void @cpu_dump_state(%struct.CPUX86State* %13, %struct._IO_FILE* %14, i32 (%struct._IO_FILE*, i8*, ...)* @fprintf, i32 2) nounwind
<   br label %._crit_edge
---
> ; <label>:29                                      ; preds = %15
>   tail call void @stl_phys(i64 %23, i32 0) nounwind
>   br label %30
3294,3319c1982,1987
< ._crit_edge:                                      ; preds = %8, %12
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 8
<   %17 = load i32* %16, align 4
<   %18 = or i32 %17, 524288
<   store i32 %18, i32* %16, align 4
<   %19 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_smm_update(%struct.CPUX86State* %19) nounwind
<   %20 = load %struct.CPUX86State** @env, align 8
<   %21 = getelementptr inbounds %struct.CPUX86State* %20, i64 0, i32 60
<   %22 = load i32* %21, align 4
<   %23 = add i32 %22, 65532
<   %24 = zext i32 %23 to i64
<   %25 = getelementptr inbounds %struct.CPUX86State* %20, i64 0, i32 15, i64 0
<   %26 = load i32* %25, align 4
<   tail call void @stl_phys(i64 %24, i32 %26) nounwind
<   %27 = add i32 %22, 65528
<   %28 = zext i32 %27 to i64
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 15, i64 3
<   %31 = load i32* %30, align 4
<   tail call void @stl_phys(i64 %28, i32 %31) nounwind
<   %32 = add i32 %22, 65524
<   %33 = zext i32 %32 to i64
<   %34 = load %struct.CPUX86State** @env, align 8
<   %35 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 7
---
> ; <label>:30                                      ; preds = %29, %24
>   %31 = load %struct.CPUX86State** @env, align 8
>   %32 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 39
>   %33 = load i64* %32, align 8
>   %34 = add i64 %33, 1024
>   %35 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 10, i64 0, i32 0
3321,3930c1989,1992
<   %37 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 1
<   %38 = load i32* %37, align 4
<   %39 = tail call i32 @helper_cc_compute_all(i32 %38) nounwind
<   %40 = or i32 %39, %36
<   %41 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 6
<   %42 = load i32* %41, align 4
<   %43 = and i32 %42, 1024
<   %44 = or i32 %40, %43
<   tail call void @stl_phys(i64 %33, i32 %44) nounwind
<   %45 = add i32 %22, 65520
<   %46 = zext i32 %45 to i64
<   %47 = load %struct.CPUX86State** @env, align 8
<   %48 = getelementptr inbounds %struct.CPUX86State* %47, i64 0, i32 5
<   %49 = load i32* %48, align 4
<   tail call void @stl_phys(i64 %46, i32 %49) nounwind
<   %50 = add i32 %22, 65516
<   %51 = zext i32 %50 to i64
<   %52 = load %struct.CPUX86State** @env, align 8
<   %53 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 0, i64 7
<   %54 = load i32* %53, align 4
<   tail call void @stl_phys(i64 %51, i32 %54) nounwind
<   %55 = add i32 %22, 65512
<   %56 = zext i32 %55 to i64
<   %57 = load %struct.CPUX86State** @env, align 8
<   %58 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 0, i64 6
<   %59 = load i32* %58, align 4
<   tail call void @stl_phys(i64 %56, i32 %59) nounwind
<   %60 = add i32 %22, 65508
<   %61 = zext i32 %60 to i64
<   %62 = load %struct.CPUX86State** @env, align 8
<   %63 = getelementptr inbounds %struct.CPUX86State* %62, i64 0, i32 0, i64 5
<   %64 = load i32* %63, align 4
<   tail call void @stl_phys(i64 %61, i32 %64) nounwind
<   %65 = add i32 %22, 65504
<   %66 = zext i32 %65 to i64
<   %67 = load %struct.CPUX86State** @env, align 8
<   %68 = getelementptr inbounds %struct.CPUX86State* %67, i64 0, i32 0, i64 4
<   %69 = load i32* %68, align 4
<   tail call void @stl_phys(i64 %66, i32 %69) nounwind
<   %70 = add i32 %22, 65500
<   %71 = zext i32 %70 to i64
<   %72 = load %struct.CPUX86State** @env, align 8
<   %73 = getelementptr inbounds %struct.CPUX86State* %72, i64 0, i32 0, i64 3
<   %74 = load i32* %73, align 4
<   tail call void @stl_phys(i64 %71, i32 %74) nounwind
<   %75 = add i32 %22, 65496
<   %76 = zext i32 %75 to i64
<   %77 = load %struct.CPUX86State** @env, align 8
<   %78 = getelementptr inbounds %struct.CPUX86State* %77, i64 0, i32 0, i64 2
<   %79 = load i32* %78, align 4
<   tail call void @stl_phys(i64 %76, i32 %79) nounwind
<   %80 = add i32 %22, 65492
<   %81 = zext i32 %80 to i64
<   %82 = load %struct.CPUX86State** @env, align 8
<   %83 = getelementptr inbounds %struct.CPUX86State* %82, i64 0, i32 0, i64 1
<   %84 = load i32* %83, align 4
<   tail call void @stl_phys(i64 %81, i32 %84) nounwind
<   %85 = add i32 %22, 65488
<   %86 = zext i32 %85 to i64
<   %87 = load %struct.CPUX86State** @env, align 8
<   %88 = getelementptr inbounds %struct.CPUX86State* %87, i64 0, i32 0, i64 0
<   %89 = load i32* %88, align 4
<   tail call void @stl_phys(i64 %86, i32 %89) nounwind
<   %90 = add i32 %22, 65484
<   %91 = zext i32 %90 to i64
<   %92 = load %struct.CPUX86State** @env, align 8
<   %93 = getelementptr inbounds %struct.CPUX86State* %92, i64 0, i32 58, i64 6
<   %94 = load i32* %93, align 4
<   tail call void @stl_phys(i64 %91, i32 %94) nounwind
<   %95 = add i32 %22, 65480
<   %96 = zext i32 %95 to i64
<   %97 = load %struct.CPUX86State** @env, align 8
<   %98 = getelementptr inbounds %struct.CPUX86State* %97, i64 0, i32 58, i64 7
<   %99 = load i32* %98, align 4
<   tail call void @stl_phys(i64 %96, i32 %99) nounwind
<   %100 = add i32 %22, 65476
<   %101 = zext i32 %100 to i64
<   %102 = load %struct.CPUX86State** @env, align 8
<   %103 = getelementptr inbounds %struct.CPUX86State* %102, i64 0, i32 12, i32 0
<   %104 = load i32* %103, align 4
<   tail call void @stl_phys(i64 %101, i32 %104) nounwind
<   %105 = add i32 %22, 65380
<   %106 = zext i32 %105 to i64
<   %107 = load %struct.CPUX86State** @env, align 8
<   %108 = getelementptr inbounds %struct.CPUX86State* %107, i64 0, i32 12, i32 1
<   %109 = load i32* %108, align 4
<   tail call void @stl_phys(i64 %106, i32 %109) nounwind
<   %110 = add i32 %22, 65376
<   %111 = zext i32 %110 to i64
<   %112 = load %struct.CPUX86State** @env, align 8
<   %113 = getelementptr inbounds %struct.CPUX86State* %112, i64 0, i32 12, i32 2
<   %114 = load i32* %113, align 4
<   tail call void @stl_phys(i64 %111, i32 %114) nounwind
<   %115 = add i32 %22, 65372
<   %116 = zext i32 %115 to i64
<   %117 = load %struct.CPUX86State** @env, align 8
<   %118 = getelementptr inbounds %struct.CPUX86State* %117, i64 0, i32 12, i32 3
<   %119 = load i32* %118, align 4
<   %120 = lshr i32 %119, 8
<   %121 = and i32 %120, 61695
<   tail call void @stl_phys(i64 %116, i32 %121) nounwind
<   %122 = add i32 %22, 65472
<   %123 = zext i32 %122 to i64
<   %124 = load %struct.CPUX86State** @env, align 8
<   %125 = getelementptr inbounds %struct.CPUX86State* %124, i64 0, i32 11, i32 0
<   %126 = load i32* %125, align 4
<   tail call void @stl_phys(i64 %123, i32 %126) nounwind
<   %127 = add i32 %22, 65408
<   %128 = zext i32 %127 to i64
<   %129 = load %struct.CPUX86State** @env, align 8
<   %130 = getelementptr inbounds %struct.CPUX86State* %129, i64 0, i32 11, i32 1
<   %131 = load i32* %130, align 4
<   tail call void @stl_phys(i64 %128, i32 %131) nounwind
<   %132 = add i32 %22, 65404
<   %133 = zext i32 %132 to i64
<   %134 = load %struct.CPUX86State** @env, align 8
<   %135 = getelementptr inbounds %struct.CPUX86State* %134, i64 0, i32 11, i32 2
<   %136 = load i32* %135, align 4
<   tail call void @stl_phys(i64 %133, i32 %136) nounwind
<   %137 = add i32 %22, 65400
<   %138 = zext i32 %137 to i64
<   %139 = load %struct.CPUX86State** @env, align 8
<   %140 = getelementptr inbounds %struct.CPUX86State* %139, i64 0, i32 11, i32 3
<   %141 = load i32* %140, align 4
<   %142 = lshr i32 %141, 8
<   %143 = and i32 %142, 61695
<   tail call void @stl_phys(i64 %138, i32 %143) nounwind
<   %144 = add i32 %22, 65396
<   %145 = zext i32 %144 to i64
<   %146 = load %struct.CPUX86State** @env, align 8
<   %147 = getelementptr inbounds %struct.CPUX86State* %146, i64 0, i32 13, i32 1
<   %148 = load i32* %147, align 4
<   tail call void @stl_phys(i64 %145, i32 %148) nounwind
<   %149 = add i32 %22, 65392
<   %150 = zext i32 %149 to i64
<   %151 = load %struct.CPUX86State** @env, align 8
<   %152 = getelementptr inbounds %struct.CPUX86State* %151, i64 0, i32 13, i32 2
<   %153 = load i32* %152, align 4
<   tail call void @stl_phys(i64 %150, i32 %153) nounwind
<   %154 = add i32 %22, 65368
<   %155 = zext i32 %154 to i64
<   %156 = load %struct.CPUX86State** @env, align 8
<   %157 = getelementptr inbounds %struct.CPUX86State* %156, i64 0, i32 14, i32 1
<   %158 = load i32* %157, align 4
<   tail call void @stl_phys(i64 %155, i32 %158) nounwind
<   %159 = add i32 %22, 65364
<   %160 = zext i32 %159 to i64
<   %161 = load %struct.CPUX86State** @env, align 8
<   %162 = getelementptr inbounds %struct.CPUX86State* %161, i64 0, i32 14, i32 2
<   %163 = load i32* %162, align 4
<   tail call void @stl_phys(i64 %160, i32 %163) nounwind
<   %164 = add i32 %22, 65448
<   %offset.0 = add i32 %22, 32768
<   br label %165
< 
< ; <label>:165                                     ; preds = %165, %._crit_edge
<   %indvars.iv = phi i64 [ 0, %._crit_edge ], [ %indvars.iv.next, %165 ]
<   %166 = load %struct.CPUX86State** @env, align 8
<   %167 = trunc i64 %indvars.iv to i32
<   %168 = icmp slt i32 %167, 3
<   %169 = mul i64 %indvars.iv, 12
<   %offset.0.v = select i1 %168, i32 32644, i32 32520
<   %170 = shl i64 %indvars.iv, 2
<   %171 = trunc i64 %170 to i32
<   %172 = add i32 %164, %171
<   %173 = zext i32 %172 to i64
<   %174 = getelementptr inbounds %struct.CPUX86State* %166, i64 0, i32 10, i64 %indvars.iv, i32 0
<   %175 = load i32* %174, align 4
<   tail call void @stl_phys(i64 %173, i32 %175) nounwind
<   %176 = trunc i64 %169 to i32
<   %177 = add i32 %offset.0, %176
<   %178 = add i32 %177, %offset.0.v
<   %179 = add i32 %178, 8
<   %180 = zext i32 %179 to i64
<   %181 = getelementptr inbounds %struct.CPUX86State* %166, i64 0, i32 10, i64 %indvars.iv, i32 1
<   %182 = load i32* %181, align 4
<   tail call void @stl_phys(i64 %180, i32 %182) nounwind
<   %183 = add i32 %178, 4
<   %184 = zext i32 %183 to i64
<   %185 = getelementptr inbounds %struct.CPUX86State* %166, i64 0, i32 10, i64 %indvars.iv, i32 2
<   %186 = load i32* %185, align 4
<   tail call void @stl_phys(i64 %184, i32 %186) nounwind
<   %187 = zext i32 %178 to i64
<   %188 = getelementptr inbounds %struct.CPUX86State* %166, i64 0, i32 10, i64 %indvars.iv, i32 3
<   %189 = load i32* %188, align 4
<   %190 = lshr i32 %189, 8
<   %191 = and i32 %190, 61695
<   tail call void @stl_phys(i64 %187, i32 %191) nounwind
<   %indvars.iv.next = add i64 %indvars.iv, 1
<   %lftr.wideiv = trunc i64 %indvars.iv.next to i32
<   %exitcond = icmp eq i32 %lftr.wideiv, 6
<   br i1 %exitcond, label %cpu_x86_load_seg_cache.exit60, label %165
< 
< cpu_x86_load_seg_cache.exit60:                    ; preds = %165
<   %192 = add i32 %22, 65300
<   %193 = zext i32 %192 to i64
<   %194 = load %struct.CPUX86State** @env, align 8
<   %195 = getelementptr inbounds %struct.CPUX86State* %194, i64 0, i32 15, i64 4
<   %196 = load i32* %195, align 4
<   tail call void @stl_phys(i64 %193, i32 %196) nounwind
<   %197 = add i32 %22, 65276
<   %198 = zext i32 %197 to i64
<   tail call void @stl_phys(i64 %198, i32 131072) nounwind
<   %199 = add i32 %22, 65272
<   %200 = zext i32 %199 to i64
<   %201 = load %struct.CPUX86State** @env, align 8
<   %202 = getelementptr inbounds %struct.CPUX86State* %201, i64 0, i32 60
<   %203 = load i32* %202, align 4
<   tail call void @stl_phys(i64 %200, i32 %203) nounwind
<   %204 = load %struct.CPUX86State** @env, align 8
<   %205 = getelementptr inbounds %struct.CPUX86State* %204, i64 0, i32 2
<   store i32 0, i32* %205, align 4
<   %206 = load %struct.CPUX86State** @env, align 8
<   %207 = getelementptr inbounds %struct.CPUX86State* %206, i64 0, i32 6
<   store i32 1, i32* %207, align 4
<   %208 = load %struct.CPUX86State** @env, align 8
<   %209 = getelementptr inbounds %struct.CPUX86State* %208, i64 0, i32 7
<   %210 = load i32* %209, align 4
<   %211 = and i32 %210, 3285
<   store i32 %211, i32* %209, align 4
<   %212 = load %struct.CPUX86State** @env, align 8
<   %213 = getelementptr inbounds %struct.CPUX86State* %212, i64 0, i32 5
<   store i32 32768, i32* %213, align 4
<   %214 = load %struct.CPUX86State** @env, align 8
<   %215 = getelementptr inbounds %struct.CPUX86State* %214, i64 0, i32 60
<   %216 = load i32* %215, align 4
<   %217 = lshr i32 %216, 4
<   %218 = and i32 %217, 65535
<   %219 = getelementptr inbounds %struct.CPUX86State* %214, i64 0, i32 10, i64 1, i32 0
<   store i32 %218, i32* %219, align 4
<   %220 = getelementptr inbounds %struct.CPUX86State* %214, i64 0, i32 10, i64 1, i32 1
<   store i32 %216, i32* %220, align 4
<   %221 = getelementptr inbounds %struct.CPUX86State* %214, i64 0, i32 10, i64 1, i32 2
<   store i32 -1, i32* %221, align 4
<   %222 = getelementptr inbounds %struct.CPUX86State* %214, i64 0, i32 10, i64 1, i32 3
<   store i32 0, i32* %222, align 4
<   %223 = getelementptr inbounds %struct.CPUX86State* %214, i64 0, i32 8
<   %224 = load i32* %223, align 4
<   %225 = getelementptr inbounds %struct.CPUX86State* %214, i64 0, i32 10, i64 2, i32 3
<   %226 = load i32* %225, align 4
<   %227 = lshr i32 %226, 17
<   %228 = and i32 %227, 32
<   %229 = and i32 %224, -32881
<   %230 = or i32 %229, %228
<   %231 = or i32 %230, 64
<   store i32 %231, i32* %223, align 4
<   %232 = load %struct.CPUX86State** @env, align 8
<   %233 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 10, i64 3, i32 0
<   store i32 0, i32* %233, align 4
<   %234 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 10, i64 3, i32 1
<   store i32 0, i32* %234, align 4
<   %235 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 10, i64 3, i32 2
<   store i32 -1, i32* %235, align 4
<   %236 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 10, i64 3, i32 3
<   store i32 0, i32* %236, align 4
<   %.phi.trans.insert.i55 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 8
<   %.pre.i56 = load i32* %.phi.trans.insert.i55, align 4
<   %237 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 10, i64 2, i32 3
<   %238 = load i32* %237, align 4
<   %239 = lshr i32 %238, 17
<   %240 = and i32 %239, 32
<   %241 = and i32 %.pre.i56, 32768
<   %242 = icmp eq i32 %241, 0
<   br i1 %242, label %243, label %cpu_x86_load_seg_cache.exit58
< 
< ; <label>:243                                     ; preds = %cpu_x86_load_seg_cache.exit60
<   %244 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 15, i64 0
<   %245 = load i32* %244, align 4
<   %246 = and i32 %245, 1
<   %247 = icmp eq i32 %246, 0
<   br i1 %247, label %256, label %248
< 
< ; <label>:248                                     ; preds = %243
<   %249 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 7
<   %250 = load i32* %249, align 4
<   %251 = and i32 %250, 131072
<   %252 = icmp eq i32 %251, 0
<   br i1 %252, label %253, label %256
< 
< ; <label>:253                                     ; preds = %248
<   %254 = and i32 %.pre.i56, 16
<   %255 = icmp eq i32 %254, 0
<   br i1 %255, label %256, label %258
< 
< ; <label>:256                                     ; preds = %253, %248, %243
<   %257 = or i32 %240, 64
<   br label %cpu_x86_load_seg_cache.exit58
< 
< ; <label>:258                                     ; preds = %253
<   %259 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 10, i64 0, i32 1
<   %260 = load i32* %259, align 4
<   %261 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 10, i64 2, i32 1
<   %262 = load i32* %261, align 4
<   %263 = or i32 %262, %260
<   %264 = icmp ne i32 %263, 0
<   %265 = zext i1 %264 to i32
<   %266 = shl nuw nsw i32 %265, 6
<   %267 = or i32 %266, %240
<   br label %cpu_x86_load_seg_cache.exit58
< 
< cpu_x86_load_seg_cache.exit58:                    ; preds = %258, %256, %cpu_x86_load_seg_cache.exit60
<   %new_hflags.0.i57 = phi i32 [ %240, %cpu_x86_load_seg_cache.exit60 ], [ %257, %256 ], [ %267, %258 ]
<   %268 = and i32 %.pre.i56, -97
<   %269 = or i32 %new_hflags.0.i57, %268
<   store i32 %269, i32* %.phi.trans.insert.i55, align 4
<   %270 = load %struct.CPUX86State** @env, align 8
<   %271 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 10, i64 0, i32 0
<   store i32 0, i32* %271, align 4
<   %272 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 10, i64 0, i32 1
<   store i32 0, i32* %272, align 4
<   %273 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 10, i64 0, i32 2
<   store i32 -1, i32* %273, align 4
<   %274 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 10, i64 0, i32 3
<   store i32 0, i32* %274, align 4
<   %.phi.trans.insert.i51 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 8
<   %.pre.i52 = load i32* %.phi.trans.insert.i51, align 4
<   %275 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 10, i64 2, i32 3
<   %276 = load i32* %275, align 4
<   %277 = lshr i32 %276, 17
<   %278 = and i32 %277, 32
<   %279 = and i32 %.pre.i52, 32768
<   %280 = icmp eq i32 %279, 0
<   br i1 %280, label %281, label %cpu_x86_load_seg_cache.exit54
< 
< ; <label>:281                                     ; preds = %cpu_x86_load_seg_cache.exit58
<   %282 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 15, i64 0
<   %283 = load i32* %282, align 4
<   %284 = and i32 %283, 1
<   %285 = icmp eq i32 %284, 0
<   br i1 %285, label %294, label %286
< 
< ; <label>:286                                     ; preds = %281
<   %287 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 7
<   %288 = load i32* %287, align 4
<   %289 = and i32 %288, 131072
<   %290 = icmp eq i32 %289, 0
<   br i1 %290, label %291, label %294
< 
< ; <label>:291                                     ; preds = %286
<   %292 = and i32 %.pre.i52, 16
<   %293 = icmp eq i32 %292, 0
<   br i1 %293, label %294, label %296
< 
< ; <label>:294                                     ; preds = %291, %286, %281
<   %295 = or i32 %278, 64
<   br label %cpu_x86_load_seg_cache.exit54
< 
< ; <label>:296                                     ; preds = %291
<   %297 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 10, i64 3, i32 1
<   %298 = load i32* %297, align 4
<   %299 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 10, i64 2, i32 1
<   %300 = load i32* %299, align 4
<   %301 = or i32 %300, %298
<   %302 = icmp ne i32 %301, 0
<   %303 = zext i1 %302 to i32
<   %304 = shl nuw nsw i32 %303, 6
<   %305 = or i32 %304, %278
<   br label %cpu_x86_load_seg_cache.exit54
< 
< cpu_x86_load_seg_cache.exit54:                    ; preds = %296, %294, %cpu_x86_load_seg_cache.exit58
<   %new_hflags.0.i53 = phi i32 [ %278, %cpu_x86_load_seg_cache.exit58 ], [ %295, %294 ], [ %305, %296 ]
<   %306 = and i32 %.pre.i52, -97
<   %307 = or i32 %new_hflags.0.i53, %306
<   store i32 %307, i32* %.phi.trans.insert.i51, align 4
<   %308 = load %struct.CPUX86State** @env, align 8
<   %309 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 10, i64 2, i32 0
<   store i32 0, i32* %309, align 4
<   %310 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 10, i64 2, i32 1
<   store i32 0, i32* %310, align 4
<   %311 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 10, i64 2, i32 2
<   store i32 -1, i32* %311, align 4
<   %312 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 10, i64 2, i32 3
<   store i32 0, i32* %312, align 4
<   %.phi.trans.insert.i47 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 8
<   %.pre.i48 = load i32* %.phi.trans.insert.i47, align 4
<   %313 = and i32 %.pre.i48, 32768
<   %314 = icmp eq i32 %313, 0
<   br i1 %314, label %315, label %cpu_x86_load_seg_cache.exit50
< 
< ; <label>:315                                     ; preds = %cpu_x86_load_seg_cache.exit54
<   %316 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 15, i64 0
<   %317 = load i32* %316, align 4
<   %318 = and i32 %317, 1
<   %319 = icmp eq i32 %318, 0
<   br i1 %319, label %cpu_x86_load_seg_cache.exit50, label %320
< 
< ; <label>:320                                     ; preds = %315
<   %321 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 7
<   %322 = load i32* %321, align 4
<   %323 = and i32 %322, 131072
<   %324 = icmp eq i32 %323, 0
<   br i1 %324, label %325, label %cpu_x86_load_seg_cache.exit50
< 
< ; <label>:325                                     ; preds = %320
<   %326 = and i32 %.pre.i48, 16
<   %327 = icmp eq i32 %326, 0
<   br i1 %327, label %cpu_x86_load_seg_cache.exit50, label %328
< 
< ; <label>:328                                     ; preds = %325
<   %329 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 10, i64 3, i32 1
<   %330 = load i32* %329, align 4
<   %331 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 10, i64 0, i32 1
<   %332 = load i32* %331, align 4
<   %333 = or i32 %332, %330
<   %334 = icmp ne i32 %333, 0
<   %335 = zext i1 %334 to i32
<   %336 = shl nuw nsw i32 %335, 6
<   br label %cpu_x86_load_seg_cache.exit50
< 
< cpu_x86_load_seg_cache.exit50:                    ; preds = %328, %325, %320, %315, %cpu_x86_load_seg_cache.exit54
<   %new_hflags.0.i49 = phi i32 [ 0, %cpu_x86_load_seg_cache.exit54 ], [ %336, %328 ], [ 64, %325 ], [ 64, %320 ], [ 64, %315 ]
<   %337 = and i32 %.pre.i48, -97
<   %338 = or i32 %new_hflags.0.i49, %337
<   store i32 %338, i32* %.phi.trans.insert.i47, align 4
<   %339 = load %struct.CPUX86State** @env, align 8
<   %340 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 10, i64 4, i32 0
<   store i32 0, i32* %340, align 4
<   %341 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 10, i64 4, i32 1
<   store i32 0, i32* %341, align 4
<   %342 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 10, i64 4, i32 2
<   store i32 -1, i32* %342, align 4
<   %343 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 10, i64 4, i32 3
<   store i32 0, i32* %343, align 4
<   %.phi.trans.insert.i43 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 8
<   %.pre.i44 = load i32* %.phi.trans.insert.i43, align 4
<   %344 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 10, i64 2, i32 3
<   %345 = load i32* %344, align 4
<   %346 = lshr i32 %345, 17
<   %347 = and i32 %346, 32
<   %348 = and i32 %.pre.i44, 32768
<   %349 = icmp eq i32 %348, 0
<   br i1 %349, label %350, label %cpu_x86_load_seg_cache.exit46
< 
< ; <label>:350                                     ; preds = %cpu_x86_load_seg_cache.exit50
<   %351 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 15, i64 0
<   %352 = load i32* %351, align 4
<   %353 = and i32 %352, 1
<   %354 = icmp eq i32 %353, 0
<   br i1 %354, label %363, label %355
< 
< ; <label>:355                                     ; preds = %350
<   %356 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 7
<   %357 = load i32* %356, align 4
<   %358 = and i32 %357, 131072
<   %359 = icmp eq i32 %358, 0
<   br i1 %359, label %360, label %363
< 
< ; <label>:360                                     ; preds = %355
<   %361 = and i32 %.pre.i44, 16
<   %362 = icmp eq i32 %361, 0
<   br i1 %362, label %363, label %365
< 
< ; <label>:363                                     ; preds = %360, %355, %350
<   %364 = or i32 %347, 64
<   br label %cpu_x86_load_seg_cache.exit46
< 
< ; <label>:365                                     ; preds = %360
<   %366 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 10, i64 3, i32 1
<   %367 = load i32* %366, align 4
<   %368 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 10, i64 0, i32 1
<   %369 = load i32* %368, align 4
<   %370 = or i32 %369, %367
<   %371 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 10, i64 2, i32 1
<   %372 = load i32* %371, align 4
<   %373 = or i32 %370, %372
<   %374 = icmp ne i32 %373, 0
<   %375 = zext i1 %374 to i32
<   %376 = shl nuw nsw i32 %375, 6
<   %377 = or i32 %376, %347
<   br label %cpu_x86_load_seg_cache.exit46
< 
< cpu_x86_load_seg_cache.exit46:                    ; preds = %365, %363, %cpu_x86_load_seg_cache.exit50
<   %new_hflags.0.i45 = phi i32 [ %347, %cpu_x86_load_seg_cache.exit50 ], [ %364, %363 ], [ %377, %365 ]
<   %378 = and i32 %.pre.i44, -97
<   %379 = or i32 %new_hflags.0.i45, %378
<   store i32 %379, i32* %.phi.trans.insert.i43, align 4
<   %380 = load %struct.CPUX86State** @env, align 8
<   %381 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 10, i64 5, i32 0
<   store i32 0, i32* %381, align 4
<   %382 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 10, i64 5, i32 1
<   store i32 0, i32* %382, align 4
<   %383 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 10, i64 5, i32 2
<   store i32 -1, i32* %383, align 4
<   %384 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 10, i64 5, i32 3
<   store i32 0, i32* %384, align 4
<   %.phi.trans.insert.i = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 8
<   %.pre.i = load i32* %.phi.trans.insert.i, align 4
<   %385 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 10, i64 2, i32 3
<   %386 = load i32* %385, align 4
<   %387 = lshr i32 %386, 17
<   %388 = and i32 %387, 32
<   %389 = and i32 %.pre.i, 32768
<   %390 = icmp eq i32 %389, 0
<   br i1 %390, label %391, label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:391                                     ; preds = %cpu_x86_load_seg_cache.exit46
<   %392 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 15, i64 0
<   %393 = load i32* %392, align 4
<   %394 = and i32 %393, 1
<   %395 = icmp eq i32 %394, 0
<   br i1 %395, label %404, label %396
< 
< ; <label>:396                                     ; preds = %391
<   %397 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 7
<   %398 = load i32* %397, align 4
<   %399 = and i32 %398, 131072
<   %400 = icmp eq i32 %399, 0
<   br i1 %400, label %401, label %404
< 
< ; <label>:401                                     ; preds = %396
<   %402 = and i32 %.pre.i, 16
<   %403 = icmp eq i32 %402, 0
<   br i1 %403, label %404, label %406
< 
< ; <label>:404                                     ; preds = %401, %396, %391
<   %405 = or i32 %388, 64
<   br label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:406                                     ; preds = %401
<   %407 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 10, i64 3, i32 1
<   %408 = load i32* %407, align 4
<   %409 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 10, i64 0, i32 1
<   %410 = load i32* %409, align 4
<   %411 = or i32 %410, %408
<   %412 = getelementptr inbounds %struct.CPUX86State* %380, i64 0, i32 10, i64 2, i32 1
<   %413 = load i32* %412, align 4
<   %414 = or i32 %411, %413
<   %415 = icmp ne i32 %414, 0
<   %416 = zext i1 %415 to i32
<   %417 = shl nuw nsw i32 %416, 6
<   %418 = or i32 %417, %388
<   br label %cpu_x86_load_seg_cache.exit
< 
< cpu_x86_load_seg_cache.exit:                      ; preds = %406, %404, %cpu_x86_load_seg_cache.exit46
<   %new_hflags.0.i = phi i32 [ %388, %cpu_x86_load_seg_cache.exit46 ], [ %405, %404 ], [ %418, %406 ]
<   %419 = and i32 %.pre.i, -97
<   %420 = or i32 %new_hflags.0.i, %419
<   store i32 %420, i32* %.phi.trans.insert.i, align 4
<   %421 = load %struct.CPUX86State** @env, align 8
<   %422 = getelementptr inbounds %struct.CPUX86State* %421, i64 0, i32 15, i64 0
<   %423 = load i32* %422, align 4
<   %424 = and i32 %423, 2147483634
<   tail call void @cpu_x86_update_cr0(%struct.CPUX86State* %421, i32 %424) nounwind
<   %425 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_x86_update_cr4(%struct.CPUX86State* %425, i32 0) nounwind
<   %426 = load %struct.CPUX86State** @env, align 8
<   %427 = getelementptr inbounds %struct.CPUX86State* %426, i64 0, i32 58, i64 7
<   store i32 1024, i32* %427, align 4
<   %428 = load %struct.CPUX86State** @env, align 8
<   %429 = getelementptr inbounds %struct.CPUX86State* %428, i64 0, i32 1
<   store i32 1, i32* %429, align 4
<   store %struct.CPUX86State* %1, %struct.CPUX86State** @env, align 8
<   ret void
< }
< 
< declare void @cpu_dump_state(%struct.CPUX86State*, %struct._IO_FILE*, i32 (%struct._IO_FILE*, i8*, ...)*, i32)
< 
< declare void @cpu_smm_update(%struct.CPUX86State*)
< 
< declare void @cpu_x86_update_cr0(%struct.CPUX86State*, i32)
< 
< declare void @cpu_x86_update_cr4(%struct.CPUX86State*, i32)
< 
< define void @helper_rsm() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 60
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 65532
<   %5 = zext i32 %4 to i64
<   %6 = tail call i32 @ldl_phys(i64 %5) nounwind
<   tail call void @cpu_x86_update_cr0(%struct.CPUX86State* %1, i32 %6) nounwind
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = add i32 %3, 65528
<   %9 = zext i32 %8 to i64
<   %10 = tail call i32 @ldl_phys(i64 %9) nounwind
<   tail call void @cpu_x86_update_cr3(%struct.CPUX86State* %7, i32 %10) nounwind
<   %11 = add i32 %3, 65524
<   %12 = zext i32 %11 to i64
<   %13 = tail call i32 @ldl_phys(i64 %12) nounwind
<   %14 = and i32 %13, 2261
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 2
<   store i32 %14, i32* %16, align 4
<   %17 = lshr i32 %13, 9
<   %18 = and i32 %17, 2
<   %19 = xor i32 %18, 2
<   %20 = add i32 %19, -1
<   %21 = load %struct.CPUX86State** @env, align 8
<   %22 = getelementptr inbounds %struct.CPUX86State* %21, i64 0, i32 6
<   store i32 %20, i32* %22, align 4
<   %23 = load %struct.CPUX86State** @env, align 8
<   %24 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 7
<   %25 = load i32* %24, align 4
<   %26 = and i32 %25, 3285
<   %27 = and i32 %13, -3286
<   %28 = or i32 %26, %27
<   store i32 %28, i32* %24, align 4
<   %29 = add i32 %3, 65520
<   %30 = zext i32 %29 to i64
<   %31 = tail call i32 @ldl_phys(i64 %30) nounwind
<   %32 = load %struct.CPUX86State** @env, align 8
<   %33 = getelementptr inbounds %struct.CPUX86State* %32, i64 0, i32 5
<   store i32 %31, i32* %33, align 4
<   %34 = add i32 %3, 65516
<   %35 = zext i32 %34 to i64
<   %36 = tail call i32 @ldl_phys(i64 %35) nounwind
<   %37 = load %struct.CPUX86State** @env, align 8
<   %38 = getelementptr inbounds %struct.CPUX86State* %37, i64 0, i32 0, i64 7
<   store i32 %36, i32* %38, align 4
<   %39 = add i32 %3, 65512
---
>   tail call void @stw_phys(i64 %34, i32 %36) nounwind
>   %37 = add i64 %33, 1032
>   %38 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 10, i64 0, i32 1
>   %39 = load i32* %38, align 4
3932,3944c1994,2007
<   %41 = tail call i32 @ldl_phys(i64 %40) nounwind
<   %42 = load %struct.CPUX86State** @env, align 8
<   %43 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 0, i64 6
<   store i32 %41, i32* %43, align 4
<   %44 = add i32 %3, 65508
<   %45 = zext i32 %44 to i64
<   %46 = tail call i32 @ldl_phys(i64 %45) nounwind
<   %47 = load %struct.CPUX86State** @env, align 8
<   %48 = getelementptr inbounds %struct.CPUX86State* %47, i64 0, i32 0, i64 5
<   store i32 %46, i32* %48, align 4
<   %49 = add i32 %3, 65504
<   %50 = zext i32 %49 to i64
<   %51 = tail call i32 @ldl_phys(i64 %50) nounwind
---
>   tail call void @stq_phys(i64 %37, i64 %40) nounwind
>   %41 = add i64 %33, 1028
>   %42 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 10, i64 0, i32 2
>   %43 = load i32* %42, align 4
>   tail call void @stl_phys(i64 %41, i32 %43) nounwind
>   %44 = add i64 %33, 1026
>   %45 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 10, i64 0, i32 3
>   %46 = load i32* %45, align 4
>   %47 = lshr i32 %46, 8
>   %48 = and i32 %47, 255
>   %49 = lshr i32 %46, 12
>   %50 = and i32 %49, 3840
>   %51 = or i32 %48, %50
>   tail call void @stw_phys(i64 %44, i32 %51) nounwind
3946,4034c2009,2097
<   %53 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 0, i64 4
<   store i32 %51, i32* %53, align 4
<   %54 = add i32 %3, 65500
<   %55 = zext i32 %54 to i64
<   %56 = tail call i32 @ldl_phys(i64 %55) nounwind
<   %57 = load %struct.CPUX86State** @env, align 8
<   %58 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 0, i64 3
<   store i32 %56, i32* %58, align 4
<   %59 = add i32 %3, 65496
<   %60 = zext i32 %59 to i64
<   %61 = tail call i32 @ldl_phys(i64 %60) nounwind
<   %62 = load %struct.CPUX86State** @env, align 8
<   %63 = getelementptr inbounds %struct.CPUX86State* %62, i64 0, i32 0, i64 2
<   store i32 %61, i32* %63, align 4
<   %64 = add i32 %3, 65492
<   %65 = zext i32 %64 to i64
<   %66 = tail call i32 @ldl_phys(i64 %65) nounwind
<   %67 = load %struct.CPUX86State** @env, align 8
<   %68 = getelementptr inbounds %struct.CPUX86State* %67, i64 0, i32 0, i64 1
<   store i32 %66, i32* %68, align 4
<   %69 = add i32 %3, 65488
<   %70 = zext i32 %69 to i64
<   %71 = tail call i32 @ldl_phys(i64 %70) nounwind
<   %72 = load %struct.CPUX86State** @env, align 8
<   %73 = getelementptr inbounds %struct.CPUX86State* %72, i64 0, i32 0, i64 0
<   store i32 %71, i32* %73, align 4
<   %74 = add i32 %3, 65484
<   %75 = zext i32 %74 to i64
<   %76 = tail call i32 @ldl_phys(i64 %75) nounwind
<   %77 = load %struct.CPUX86State** @env, align 8
<   %78 = getelementptr inbounds %struct.CPUX86State* %77, i64 0, i32 58, i64 6
<   store i32 %76, i32* %78, align 4
<   %79 = add i32 %3, 65480
<   %80 = zext i32 %79 to i64
<   %81 = tail call i32 @ldl_phys(i64 %80) nounwind
<   %82 = load %struct.CPUX86State** @env, align 8
<   %83 = getelementptr inbounds %struct.CPUX86State* %82, i64 0, i32 58, i64 7
<   store i32 %81, i32* %83, align 4
<   %84 = add i32 %3, 65476
<   %85 = zext i32 %84 to i64
<   %86 = tail call i32 @ldl_phys(i64 %85) nounwind
<   %87 = and i32 %86, 65535
<   %88 = load %struct.CPUX86State** @env, align 8
<   %89 = getelementptr inbounds %struct.CPUX86State* %88, i64 0, i32 12, i32 0
<   store i32 %87, i32* %89, align 4
<   %90 = add i32 %3, 65380
<   %91 = zext i32 %90 to i64
<   %92 = tail call i32 @ldl_phys(i64 %91) nounwind
<   %93 = load %struct.CPUX86State** @env, align 8
<   %94 = getelementptr inbounds %struct.CPUX86State* %93, i64 0, i32 12, i32 1
<   store i32 %92, i32* %94, align 4
<   %95 = add i32 %3, 65376
<   %96 = zext i32 %95 to i64
<   %97 = tail call i32 @ldl_phys(i64 %96) nounwind
<   %98 = load %struct.CPUX86State** @env, align 8
<   %99 = getelementptr inbounds %struct.CPUX86State* %98, i64 0, i32 12, i32 2
<   store i32 %97, i32* %99, align 4
<   %100 = add i32 %3, 65372
<   %101 = zext i32 %100 to i64
<   %102 = tail call i32 @ldl_phys(i64 %101) nounwind
<   %103 = shl i32 %102, 8
<   %104 = and i32 %103, 15793920
<   %105 = load %struct.CPUX86State** @env, align 8
<   %106 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 12, i32 3
<   store i32 %104, i32* %106, align 4
<   %107 = add i32 %3, 65472
<   %108 = zext i32 %107 to i64
<   %109 = tail call i32 @ldl_phys(i64 %108) nounwind
<   %110 = and i32 %109, 65535
<   %111 = load %struct.CPUX86State** @env, align 8
<   %112 = getelementptr inbounds %struct.CPUX86State* %111, i64 0, i32 11, i32 0
<   store i32 %110, i32* %112, align 4
<   %113 = add i32 %3, 65408
<   %114 = zext i32 %113 to i64
<   %115 = tail call i32 @ldl_phys(i64 %114) nounwind
<   %116 = load %struct.CPUX86State** @env, align 8
<   %117 = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 11, i32 1
<   store i32 %115, i32* %117, align 4
<   %118 = add i32 %3, 65404
<   %119 = zext i32 %118 to i64
<   %120 = tail call i32 @ldl_phys(i64 %119) nounwind
<   %121 = load %struct.CPUX86State** @env, align 8
<   %122 = getelementptr inbounds %struct.CPUX86State* %121, i64 0, i32 11, i32 2
<   store i32 %120, i32* %122, align 4
<   %123 = add i32 %3, 65400
<   %124 = zext i32 %123 to i64
<   %125 = tail call i32 @ldl_phys(i64 %124) nounwind
<   %126 = shl i32 %125, 8
<   %127 = and i32 %126, 15793920
---
>   %53 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 39
>   %54 = load i64* %53, align 8
>   %55 = add i64 %54, 1040
>   %56 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 10, i64 1, i32 0
>   %57 = load i32* %56, align 4
>   tail call void @stw_phys(i64 %55, i32 %57) nounwind
>   %58 = add i64 %54, 1048
>   %59 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 10, i64 1, i32 1
>   %60 = load i32* %59, align 4
>   %61 = zext i32 %60 to i64
>   tail call void @stq_phys(i64 %58, i64 %61) nounwind
>   %62 = add i64 %54, 1044
>   %63 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 10, i64 1, i32 2
>   %64 = load i32* %63, align 4
>   tail call void @stl_phys(i64 %62, i32 %64) nounwind
>   %65 = add i64 %54, 1042
>   %66 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 10, i64 1, i32 3
>   %67 = load i32* %66, align 4
>   %68 = lshr i32 %67, 8
>   %69 = and i32 %68, 255
>   %70 = lshr i32 %67, 12
>   %71 = and i32 %70, 3840
>   %72 = or i32 %69, %71
>   tail call void @stw_phys(i64 %65, i32 %72) nounwind
>   %73 = load %struct.CPUX86State** @env, align 8
>   %74 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 39
>   %75 = load i64* %74, align 8
>   %76 = add i64 %75, 1056
>   %77 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 10, i64 2, i32 0
>   %78 = load i32* %77, align 4
>   tail call void @stw_phys(i64 %76, i32 %78) nounwind
>   %79 = add i64 %75, 1064
>   %80 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 10, i64 2, i32 1
>   %81 = load i32* %80, align 4
>   %82 = zext i32 %81 to i64
>   tail call void @stq_phys(i64 %79, i64 %82) nounwind
>   %83 = add i64 %75, 1060
>   %84 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 10, i64 2, i32 2
>   %85 = load i32* %84, align 4
>   tail call void @stl_phys(i64 %83, i32 %85) nounwind
>   %86 = add i64 %75, 1058
>   %87 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 10, i64 2, i32 3
>   %88 = load i32* %87, align 4
>   %89 = lshr i32 %88, 8
>   %90 = and i32 %89, 255
>   %91 = lshr i32 %88, 12
>   %92 = and i32 %91, 3840
>   %93 = or i32 %90, %92
>   tail call void @stw_phys(i64 %86, i32 %93) nounwind
>   %94 = load %struct.CPUX86State** @env, align 8
>   %95 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 39
>   %96 = load i64* %95, align 8
>   %97 = add i64 %96, 1072
>   %98 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 10, i64 3, i32 0
>   %99 = load i32* %98, align 4
>   tail call void @stw_phys(i64 %97, i32 %99) nounwind
>   %100 = add i64 %96, 1080
>   %101 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 10, i64 3, i32 1
>   %102 = load i32* %101, align 4
>   %103 = zext i32 %102 to i64
>   tail call void @stq_phys(i64 %100, i64 %103) nounwind
>   %104 = add i64 %96, 1076
>   %105 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 10, i64 3, i32 2
>   %106 = load i32* %105, align 4
>   tail call void @stl_phys(i64 %104, i32 %106) nounwind
>   %107 = add i64 %96, 1074
>   %108 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 10, i64 3, i32 3
>   %109 = load i32* %108, align 4
>   %110 = lshr i32 %109, 8
>   %111 = and i32 %110, 255
>   %112 = lshr i32 %109, 12
>   %113 = and i32 %112, 3840
>   %114 = or i32 %111, %113
>   tail call void @stw_phys(i64 %107, i32 %114) nounwind
>   %115 = load %struct.CPUX86State** @env, align 8
>   %116 = getelementptr inbounds %struct.CPUX86State* %115, i64 0, i32 39
>   %117 = load i64* %116, align 8
>   %118 = add i64 %117, 1128
>   %119 = getelementptr inbounds %struct.CPUX86State* %115, i64 0, i32 13, i32 1
>   %120 = load i32* %119, align 4
>   %121 = zext i32 %120 to i64
>   tail call void @stq_phys(i64 %118, i64 %121) nounwind
>   %122 = load %struct.CPUX86State** @env, align 8
>   %123 = getelementptr inbounds %struct.CPUX86State* %122, i64 0, i32 39
>   %124 = load i64* %123, align 8
>   %125 = add i64 %124, 1124
>   %126 = getelementptr inbounds %struct.CPUX86State* %122, i64 0, i32 13, i32 2
>   %127 = load i32* %126, align 4
>   tail call void @stl_phys(i64 %125, i32 %127) nounwind
4036,4132c2099,2178
<   %129 = getelementptr inbounds %struct.CPUX86State* %128, i64 0, i32 11, i32 3
<   store i32 %127, i32* %129, align 4
<   %130 = add i32 %3, 65396
<   %131 = zext i32 %130 to i64
<   %132 = tail call i32 @ldl_phys(i64 %131) nounwind
<   %133 = load %struct.CPUX86State** @env, align 8
<   %134 = getelementptr inbounds %struct.CPUX86State* %133, i64 0, i32 13, i32 1
<   store i32 %132, i32* %134, align 4
<   %135 = add i32 %3, 65392
<   %136 = zext i32 %135 to i64
<   %137 = tail call i32 @ldl_phys(i64 %136) nounwind
<   %138 = load %struct.CPUX86State** @env, align 8
<   %139 = getelementptr inbounds %struct.CPUX86State* %138, i64 0, i32 13, i32 2
<   store i32 %137, i32* %139, align 4
<   %140 = add i32 %3, 65368
<   %141 = zext i32 %140 to i64
<   %142 = tail call i32 @ldl_phys(i64 %141) nounwind
<   %143 = load %struct.CPUX86State** @env, align 8
<   %144 = getelementptr inbounds %struct.CPUX86State* %143, i64 0, i32 14, i32 1
<   store i32 %142, i32* %144, align 4
<   %145 = add i32 %3, 65364
<   %146 = zext i32 %145 to i64
<   %147 = tail call i32 @ldl_phys(i64 %146) nounwind
<   %148 = load %struct.CPUX86State** @env, align 8
<   %149 = getelementptr inbounds %struct.CPUX86State* %148, i64 0, i32 14, i32 2
<   store i32 %147, i32* %149, align 4
<   %150 = add i32 %3, 65448
<   %offset.0 = add i32 %3, 32768
<   br label %151
< 
< ; <label>:151                                     ; preds = %cpu_x86_load_seg_cache.exit, %0
<   %indvars.iv = phi i64 [ 0, %0 ], [ %indvars.iv.next, %cpu_x86_load_seg_cache.exit ]
<   %152 = trunc i64 %indvars.iv to i32
<   %153 = icmp slt i32 %152, 3
<   %154 = mul i64 %indvars.iv, 12
<   %offset.0.v = select i1 %153, i32 32644, i32 32520
<   %155 = load %struct.CPUX86State** @env, align 8
<   %156 = shl i64 %indvars.iv, 2
<   %157 = trunc i64 %156 to i32
<   %158 = add i32 %150, %157
<   %159 = zext i32 %158 to i64
<   %160 = tail call i32 @ldl_phys(i64 %159) nounwind
<   %161 = and i32 %160, 65535
<   %162 = trunc i64 %154 to i32
<   %163 = add i32 %offset.0, %162
<   %164 = add i32 %163, %offset.0.v
<   %165 = add i32 %164, 8
<   %166 = zext i32 %165 to i64
<   %167 = tail call i32 @ldl_phys(i64 %166) nounwind
<   %168 = add i32 %164, 4
<   %169 = zext i32 %168 to i64
<   %170 = tail call i32 @ldl_phys(i64 %169) nounwind
<   %171 = zext i32 %164 to i64
<   %172 = tail call i32 @ldl_phys(i64 %171) nounwind
<   %173 = shl i32 %172, 8
<   %174 = and i32 %173, 15793920
<   %175 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 10, i64 %indvars.iv, i32 0
<   store i32 %161, i32* %175, align 4
<   %176 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 10, i64 %indvars.iv, i32 1
<   store i32 %167, i32* %176, align 4
<   %177 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 10, i64 %indvars.iv, i32 2
<   store i32 %170, i32* %177, align 4
<   %178 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 10, i64 %indvars.iv, i32 3
<   store i32 %174, i32* %178, align 4
<   %179 = icmp eq i32 %152, 1
<   br i1 %179, label %180, label %._crit_edge.i
< 
< ._crit_edge.i:                                    ; preds = %151
<   %.phi.trans.insert.i = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 8
<   %.pre.i = load i32* %.phi.trans.insert.i, align 4
<   br label %189
< 
< ; <label>:180                                     ; preds = %151
<   %181 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 10, i64 1, i32 3
<   %182 = load i32* %181, align 4
<   %183 = lshr i32 %182, 18
<   %184 = and i32 %183, 16
<   %185 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 8
<   %186 = load i32* %185, align 4
<   %187 = and i32 %186, -32785
<   %188 = or i32 %187, %184
<   store i32 %188, i32* %185, align 4
<   br label %189
< 
< ; <label>:189                                     ; preds = %180, %._crit_edge.i
<   %190 = phi i32 [ %.pre.i, %._crit_edge.i ], [ %188, %180 ]
<   %191 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 10, i64 2, i32 3
<   %192 = load i32* %191, align 4
<   %193 = lshr i32 %192, 17
<   %194 = and i32 %193, 32
<   %195 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 8
<   %196 = and i32 %190, 32768
<   %197 = icmp eq i32 %196, 0
<   br i1 %197, label %198, label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:198                                     ; preds = %189
<   %199 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 15, i64 0
---
>   %129 = getelementptr inbounds %struct.CPUX86State* %128, i64 0, i32 39
>   %130 = load i64* %129, align 8
>   %131 = add i64 %130, 1160
>   %132 = getelementptr inbounds %struct.CPUX86State* %128, i64 0, i32 14, i32 1
>   %133 = load i32* %132, align 4
>   %134 = zext i32 %133 to i64
>   tail call void @stq_phys(i64 %131, i64 %134) nounwind
>   %135 = load %struct.CPUX86State** @env, align 8
>   %136 = getelementptr inbounds %struct.CPUX86State* %135, i64 0, i32 39
>   %137 = load i64* %136, align 8
>   %138 = add i64 %137, 1156
>   %139 = getelementptr inbounds %struct.CPUX86State* %135, i64 0, i32 14, i32 2
>   %140 = load i32* %139, align 4
>   tail call void @stl_phys(i64 %138, i32 %140) nounwind
>   %141 = load %struct.CPUX86State** @env, align 8
>   %142 = getelementptr inbounds %struct.CPUX86State* %141, i64 0, i32 39
>   %143 = load i64* %142, align 8
>   %144 = add i64 %143, 1232
>   %145 = getelementptr inbounds %struct.CPUX86State* %141, i64 0, i32 36
>   %146 = load i64* %145, align 8
>   tail call void @stq_phys(i64 %144, i64 %146) nounwind
>   %147 = load %struct.CPUX86State** @env, align 8
>   %148 = getelementptr inbounds %struct.CPUX86State* %147, i64 0, i32 39
>   %149 = load i64* %148, align 8
>   %150 = add i64 %149, 1368
>   %151 = getelementptr inbounds %struct.CPUX86State* %147, i64 0, i32 15, i64 0
>   %152 = load i32* %151, align 4
>   %153 = zext i32 %152 to i64
>   tail call void @stq_phys(i64 %150, i64 %153) nounwind
>   %154 = load %struct.CPUX86State** @env, align 8
>   %155 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 39
>   %156 = load i64* %155, align 8
>   %157 = add i64 %156, 1600
>   %158 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 15, i64 2
>   %159 = load i32* %158, align 4
>   %160 = zext i32 %159 to i64
>   tail call void @stq_phys(i64 %157, i64 %160) nounwind
>   %161 = load %struct.CPUX86State** @env, align 8
>   %162 = getelementptr inbounds %struct.CPUX86State* %161, i64 0, i32 39
>   %163 = load i64* %162, align 8
>   %164 = add i64 %163, 1360
>   %165 = getelementptr inbounds %struct.CPUX86State* %161, i64 0, i32 15, i64 3
>   %166 = load i32* %165, align 4
>   %167 = zext i32 %166 to i64
>   tail call void @stq_phys(i64 %164, i64 %167) nounwind
>   %168 = load %struct.CPUX86State** @env, align 8
>   %169 = getelementptr inbounds %struct.CPUX86State* %168, i64 0, i32 39
>   %170 = load i64* %169, align 8
>   %171 = add i64 %170, 1352
>   %172 = getelementptr inbounds %struct.CPUX86State* %168, i64 0, i32 15, i64 4
>   %173 = load i32* %172, align 4
>   %174 = zext i32 %173 to i64
>   tail call void @stq_phys(i64 %171, i64 %174) nounwind
>   %175 = load %struct.CPUX86State** @env, align 8
>   %176 = getelementptr inbounds %struct.CPUX86State* %175, i64 0, i32 39
>   %177 = load i64* %176, align 8
>   %178 = add i64 %177, 96
>   %179 = tail call i32 @ldl_phys(i64 %178) nounwind
>   %180 = and i32 %179, -272
>   %181 = load %struct.CPUX86State** @env, align 8
>   %182 = getelementptr inbounds %struct.CPUX86State* %181, i64 0, i32 47
>   %183 = load i8* %182, align 1
>   %184 = zext i8 %183 to i32
>   %185 = and i32 %184, 15
>   %186 = or i32 %185, %180
>   %187 = getelementptr inbounds %struct.CPUX86State* %181, i64 0, i32 71
>   %188 = load i32* %187, align 4
>   %189 = and i32 %188, 256
>   %190 = icmp eq i32 %189, 0
>   %191 = or i32 %186, 256
>   %int_ctl.0 = select i1 %190, i32 %186, i32 %191
>   %192 = getelementptr inbounds %struct.CPUX86State* %181, i64 0, i32 39
>   %193 = load i64* %192, align 8
>   %194 = add i64 %193, 96
>   tail call void @stl_phys(i64 %194, i32 %int_ctl.0) nounwind
>   %195 = load %struct.CPUX86State** @env, align 8
>   %196 = getelementptr inbounds %struct.CPUX86State* %195, i64 0, i32 39
>   %197 = load i64* %196, align 8
>   %198 = add i64 %197, 1392
>   %199 = getelementptr inbounds %struct.CPUX86State* %195, i64 0, i32 7
4134,4155c2180,2194
<   %201 = and i32 %200, 1
<   %202 = icmp eq i32 %201, 0
<   br i1 %202, label %211, label %203
< 
< ; <label>:203                                     ; preds = %198
<   %204 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 7
<   %205 = load i32* %204, align 4
<   %206 = and i32 %205, 131072
<   %207 = icmp eq i32 %206, 0
<   br i1 %207, label %208, label %211
< 
< ; <label>:208                                     ; preds = %203
<   %209 = and i32 %190, 16
<   %210 = icmp eq i32 %209, 0
<   br i1 %210, label %211, label %213
< 
< ; <label>:211                                     ; preds = %208, %203, %198
<   %212 = or i32 %194, 64
<   br label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:213                                     ; preds = %208
<   %214 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 10, i64 3, i32 1
---
>   %201 = getelementptr inbounds %struct.CPUX86State* %195, i64 0, i32 1
>   %202 = load i32* %201, align 4
>   %203 = tail call i32 @helper_cc_compute_all(i32 %202) nounwind
>   %204 = or i32 %203, %200
>   %205 = getelementptr inbounds %struct.CPUX86State* %195, i64 0, i32 6
>   %206 = load i32* %205, align 4
>   %207 = and i32 %206, 1024
>   %208 = or i32 %204, %207
>   %209 = zext i32 %208 to i64
>   tail call void @stq_phys(i64 %198, i64 %209) nounwind
>   %210 = load %struct.CPUX86State** @env, align 8
>   %211 = getelementptr inbounds %struct.CPUX86State* %210, i64 0, i32 39
>   %212 = load i64* %211, align 8
>   %213 = add i64 %212, 1400
>   %214 = getelementptr inbounds %struct.CPUX86State* %210, i64 0, i32 5
4157,4207c2196,2234
<   %216 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 10, i64 0, i32 1
<   %217 = load i32* %216, align 4
<   %218 = or i32 %217, %215
<   %219 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 10, i64 2, i32 1
<   %220 = load i32* %219, align 4
<   %221 = or i32 %218, %220
<   %222 = icmp ne i32 %221, 0
<   %223 = zext i1 %222 to i32
<   %224 = shl nuw nsw i32 %223, 6
<   %225 = or i32 %224, %194
<   br label %cpu_x86_load_seg_cache.exit
< 
< cpu_x86_load_seg_cache.exit:                      ; preds = %213, %211, %189
<   %new_hflags.0.i = phi i32 [ %194, %189 ], [ %212, %211 ], [ %225, %213 ]
<   %226 = and i32 %190, -97
<   %227 = or i32 %new_hflags.0.i, %226
<   store i32 %227, i32* %195, align 4
<   %indvars.iv.next = add i64 %indvars.iv, 1
<   %lftr.wideiv = trunc i64 %indvars.iv.next to i32
<   %exitcond = icmp eq i32 %lftr.wideiv, 6
<   br i1 %exitcond, label %228, label %151
< 
< ; <label>:228                                     ; preds = %cpu_x86_load_seg_cache.exit
<   %229 = load %struct.CPUX86State** @env, align 8
<   %230 = add i32 %3, 65300
<   %231 = zext i32 %230 to i64
<   %232 = tail call i32 @ldl_phys(i64 %231) nounwind
<   tail call void @cpu_x86_update_cr4(%struct.CPUX86State* %229, i32 %232) nounwind
<   %233 = add i32 %3, 65276
<   %234 = zext i32 %233 to i64
<   %235 = tail call i32 @ldl_phys(i64 %234) nounwind
<   %236 = and i32 %235, 131072
<   %237 = icmp eq i32 %236, 0
<   br i1 %237, label %245, label %238
< 
< ; <label>:238                                     ; preds = %228
<   %239 = add i32 %3, 65272
<   %240 = zext i32 %239 to i64
<   %241 = tail call i32 @ldl_phys(i64 %240) nounwind
<   %242 = and i32 %241, -32768
<   %243 = load %struct.CPUX86State** @env, align 8
<   %244 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 60
<   store i32 %242, i32* %244, align 4
<   br label %245
< 
< ; <label>:245                                     ; preds = %238, %228
<   %246 = load %struct.CPUX86State** @env, align 8
<   %247 = getelementptr inbounds %struct.CPUX86State* %246, i64 0, i32 1
<   store i32 1, i32* %247, align 4
<   %248 = load %struct.CPUX86State** @env, align 8
<   %249 = getelementptr inbounds %struct.CPUX86State* %248, i64 0, i32 8
---
>   %216 = zext i32 %215 to i64
>   tail call void @stq_phys(i64 %213, i64 %216) nounwind
>   %217 = load %struct.CPUX86State** @env, align 8
>   %218 = getelementptr inbounds %struct.CPUX86State* %217, i64 0, i32 39
>   %219 = load i64* %218, align 8
>   %220 = add i64 %219, 1496
>   %221 = getelementptr inbounds %struct.CPUX86State* %217, i64 0, i32 0, i64 4
>   %222 = load i32* %221, align 4
>   %223 = zext i32 %222 to i64
>   tail call void @stq_phys(i64 %220, i64 %223) nounwind
>   %224 = load %struct.CPUX86State** @env, align 8
>   %225 = getelementptr inbounds %struct.CPUX86State* %224, i64 0, i32 39
>   %226 = load i64* %225, align 8
>   %227 = add i64 %226, 1528
>   %228 = getelementptr inbounds %struct.CPUX86State* %224, i64 0, i32 0, i64 0
>   %229 = load i32* %228, align 4
>   %230 = zext i32 %229 to i64
>   tail call void @stq_phys(i64 %227, i64 %230) nounwind
>   %231 = load %struct.CPUX86State** @env, align 8
>   %232 = getelementptr inbounds %struct.CPUX86State* %231, i64 0, i32 39
>   %233 = load i64* %232, align 8
>   %234 = add i64 %233, 1376
>   %235 = getelementptr inbounds %struct.CPUX86State* %231, i64 0, i32 58, i64 7
>   %236 = load i32* %235, align 4
>   %237 = zext i32 %236 to i64
>   tail call void @stq_phys(i64 %234, i64 %237) nounwind
>   %238 = load %struct.CPUX86State** @env, align 8
>   %239 = getelementptr inbounds %struct.CPUX86State* %238, i64 0, i32 39
>   %240 = load i64* %239, align 8
>   %241 = add i64 %240, 1384
>   %242 = getelementptr inbounds %struct.CPUX86State* %238, i64 0, i32 58, i64 6
>   %243 = load i32* %242, align 4
>   %244 = zext i32 %243 to i64
>   tail call void @stq_phys(i64 %241, i64 %244) nounwind
>   %245 = load %struct.CPUX86State** @env, align 8
>   %246 = getelementptr inbounds %struct.CPUX86State* %245, i64 0, i32 39
>   %247 = load i64* %246, align 8
>   %248 = add i64 %247, 1227
>   %249 = getelementptr inbounds %struct.CPUX86State* %245, i64 0, i32 8
4209,4210c2236,2237
<   %251 = and i32 %250, -524289
<   store i32 %251, i32* %249, align 4
---
>   %251 = and i32 %250, 3
>   tail call void @stb_phys(i64 %248, i32 %251) nounwind
4212,4227c2239,2400
<   tail call void @cpu_smm_update(%struct.CPUX86State* %252) nounwind
<   %253 = load i32* @loglevel, align 4
<   %254 = and i32 %253, 16
<   %255 = icmp eq i32 %254, 0
<   br i1 %255, label %259, label %256
< 
< ; <label>:256                                     ; preds = %245
<   %257 = load %struct._IO_FILE** @logfile, align 8
<   %258 = tail call i64 @fwrite(i8* getelementptr inbounds ([16 x i8]* @.str8, i64 0, i64 0), i64 15, i64 1, %struct._IO_FILE* %257)
<   br label %259
< 
< ; <label>:259                                     ; preds = %256, %245
<   ret void
< }
< 
< declare void @cpu_x86_update_cr3(%struct.CPUX86State*, i32)
---
>   %253 = getelementptr inbounds %struct.CPUX86State* %252, i64 0, i32 9
>   %254 = load i32* %253, align 4
>   %255 = and i32 %254, -11
>   store i32 %255, i32* %253, align 4
>   %256 = load %struct.CPUX86State** @env, align 8
>   %257 = getelementptr inbounds %struct.CPUX86State* %256, i64 0, i32 8
>   %258 = load i32* %257, align 4
>   %259 = and i32 %258, -2097153
>   store i32 %259, i32* %257, align 4
>   %260 = load %struct.CPUX86State** @env, align 8
>   %261 = getelementptr inbounds %struct.CPUX86State* %260, i64 0, i32 41
>   store i64 0, i64* %261, align 8
>   %262 = load %struct.CPUX86State** @env, align 8
>   %263 = getelementptr inbounds %struct.CPUX86State* %262, i64 0, i32 46
>   store i32 0, i32* %263, align 4
>   %264 = load %struct.CPUX86State** @env, align 8
>   %265 = getelementptr inbounds %struct.CPUX86State* %264, i64 0, i32 71
>   %266 = load i32* %265, align 4
>   %267 = and i32 %266, -257
>   store i32 %267, i32* %265, align 4
>   %268 = load %struct.CPUX86State** @env, align 8
>   %269 = getelementptr inbounds %struct.CPUX86State* %268, i64 0, i32 40
>   store i64 0, i64* %269, align 8
>   %270 = load %struct.CPUX86State** @env, align 8
>   %271 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 38
>   %272 = load i64* %271, align 8
>   %273 = add i64 %272, 1128
>   %274 = tail call i64 @ldq_phys(i64 %273) nounwind
>   %275 = trunc i64 %274 to i32
>   %276 = load %struct.CPUX86State** @env, align 8
>   %277 = getelementptr inbounds %struct.CPUX86State* %276, i64 0, i32 13, i32 1
>   store i32 %275, i32* %277, align 4
>   %278 = load %struct.CPUX86State** @env, align 8
>   %279 = getelementptr inbounds %struct.CPUX86State* %278, i64 0, i32 38
>   %280 = load i64* %279, align 8
>   %281 = add i64 %280, 1124
>   %282 = tail call i32 @ldl_phys(i64 %281) nounwind
>   %283 = load %struct.CPUX86State** @env, align 8
>   %284 = getelementptr inbounds %struct.CPUX86State* %283, i64 0, i32 13, i32 2
>   store i32 %282, i32* %284, align 4
>   %285 = load %struct.CPUX86State** @env, align 8
>   %286 = getelementptr inbounds %struct.CPUX86State* %285, i64 0, i32 38
>   %287 = load i64* %286, align 8
>   %288 = add i64 %287, 1160
>   %289 = tail call i64 @ldq_phys(i64 %288) nounwind
>   %290 = trunc i64 %289 to i32
>   %291 = load %struct.CPUX86State** @env, align 8
>   %292 = getelementptr inbounds %struct.CPUX86State* %291, i64 0, i32 14, i32 1
>   store i32 %290, i32* %292, align 4
>   %293 = load %struct.CPUX86State** @env, align 8
>   %294 = getelementptr inbounds %struct.CPUX86State* %293, i64 0, i32 38
>   %295 = load i64* %294, align 8
>   %296 = add i64 %295, 1156
>   %297 = tail call i32 @ldl_phys(i64 %296) nounwind
>   %298 = load %struct.CPUX86State** @env, align 8
>   %299 = getelementptr inbounds %struct.CPUX86State* %298, i64 0, i32 14, i32 2
>   store i32 %297, i32* %299, align 4
>   %300 = load %struct.CPUX86State** @env, align 8
>   %301 = getelementptr inbounds %struct.CPUX86State* %300, i64 0, i32 38
>   %302 = load i64* %301, align 8
>   %303 = add i64 %302, 1368
>   %304 = tail call i64 @ldq_phys(i64 %303) nounwind
>   %305 = or i64 %304, 1
>   %306 = trunc i64 %305 to i32
>   tail call void @cpu_x86_update_cr0(%struct.CPUX86State* %300, i32 %306) nounwind
>   %307 = load %struct.CPUX86State** @env, align 8
>   %308 = getelementptr inbounds %struct.CPUX86State* %307, i64 0, i32 38
>   %309 = load i64* %308, align 8
>   %310 = add i64 %309, 1352
>   %311 = tail call i64 @ldq_phys(i64 %310) nounwind
>   %312 = trunc i64 %311 to i32
>   tail call void @cpu_x86_update_cr4(%struct.CPUX86State* %307, i32 %312) nounwind
>   %313 = load %struct.CPUX86State** @env, align 8
>   %314 = getelementptr inbounds %struct.CPUX86State* %313, i64 0, i32 38
>   %315 = load i64* %314, align 8
>   %316 = add i64 %315, 1360
>   %317 = tail call i64 @ldq_phys(i64 %316) nounwind
>   %318 = trunc i64 %317 to i32
>   tail call void @cpu_x86_update_cr3(%struct.CPUX86State* %313, i32 %318) nounwind
>   %319 = load %struct.CPUX86State** @env, align 8
>   %320 = getelementptr inbounds %struct.CPUX86State* %319, i64 0, i32 38
>   %321 = load i64* %320, align 8
>   %322 = add i64 %321, 1232
>   %323 = tail call i64 @ldq_phys(i64 %322) nounwind
>   %324 = getelementptr inbounds %struct.CPUX86State* %319, i64 0, i32 36
>   store i64 %323, i64* %324, align 8
>   %325 = getelementptr inbounds %struct.CPUX86State* %319, i64 0, i32 8
>   %326 = load i32* %325, align 4
>   %327 = and i32 %326, -1064961
>   %328 = and i64 %323, 1024
>   %329 = icmp eq i64 %328, 0
>   %330 = or i32 %327, 16384
>   %storemerge.i = select i1 %329, i32 %327, i32 %330
>   %331 = and i64 %323, 4096
>   %332 = icmp eq i64 %331, 0
>   %333 = or i32 %storemerge.i, 1048576
>   %storemerge..i = select i1 %332, i32 %storemerge.i, i32 %333
>   store i32 %storemerge..i, i32* %325, align 4
>   %334 = load %struct.CPUX86State** @env, align 8
>   %335 = getelementptr inbounds %struct.CPUX86State* %334, i64 0, i32 7
>   store i32 0, i32* %335, align 4
>   %336 = load %struct.CPUX86State** @env, align 8
>   %337 = getelementptr inbounds %struct.CPUX86State* %336, i64 0, i32 38
>   %338 = load i64* %337, align 8
>   %339 = add i64 %338, 1392
>   %340 = tail call i64 @ldq_phys(i64 %339) nounwind
>   %341 = trunc i64 %340 to i32
>   %342 = and i32 %341, 2261
>   %343 = load %struct.CPUX86State** @env, align 8
>   %344 = getelementptr inbounds %struct.CPUX86State* %343, i64 0, i32 2
>   store i32 %342, i32* %344, align 4
>   %345 = lshr i32 %341, 9
>   %346 = and i32 %345, 2
>   %347 = xor i32 %346, 2
>   %348 = add i32 %347, -1
>   %349 = load %struct.CPUX86State** @env, align 8
>   %350 = getelementptr inbounds %struct.CPUX86State* %349, i64 0, i32 6
>   store i32 %348, i32* %350, align 4
>   %351 = load %struct.CPUX86State** @env, align 8
>   %352 = getelementptr inbounds %struct.CPUX86State* %351, i64 0, i32 7
>   %353 = load i32* %352, align 4
>   %354 = and i32 %353, 3285
>   %355 = and i32 %341, -3286
>   %356 = or i32 %354, %355
>   store i32 %356, i32* %352, align 4
>   %357 = load %struct.CPUX86State** @env, align 8
>   %358 = getelementptr inbounds %struct.CPUX86State* %357, i64 0, i32 1
>   store i32 1, i32* %358, align 4
>   %359 = load %struct.CPUX86State** @env, align 8
>   %360 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 38
>   %361 = load i64* %360, align 8
>   %362 = add i64 %361, 1024
>   %363 = tail call i32 @lduw_phys(i64 %362) nounwind
>   %364 = add i64 %361, 1032
>   %365 = tail call i64 @ldq_phys(i64 %364) nounwind
>   %366 = trunc i64 %365 to i32
>   %367 = add i64 %361, 1028
>   %368 = tail call i32 @ldl_phys(i64 %367) nounwind
>   %369 = add i64 %361, 1026
>   %370 = tail call i32 @lduw_phys(i64 %369) nounwind
>   %371 = shl i32 %370, 8
>   %372 = and i32 %371, 65280
>   %373 = shl i32 %370, 12
>   %374 = and i32 %373, 15728640
>   %375 = or i32 %372, %374
>   %376 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 0, i32 0
>   store i32 %363, i32* %376, align 4
>   %377 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 0, i32 1
>   store i32 %366, i32* %377, align 4
>   %378 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 0, i32 2
>   store i32 %368, i32* %378, align 4
>   %379 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 0, i32 3
>   store i32 %375, i32* %379, align 4
>   %.phi.trans.insert.i.i = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 8
>   %.pre.i.i = load i32* %.phi.trans.insert.i.i, align 4
>   %380 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 2, i32 3
>   %381 = load i32* %380, align 4
>   %382 = lshr i32 %381, 17
>   %383 = and i32 %382, 32
>   %384 = and i32 %.pre.i.i, 32768
>   %385 = icmp eq i32 %384, 0
>   br i1 %385, label %386, label %svm_load_seg_cache.exit
4229,4236c2402,2407
< define void @helper_divb_AL(i32 %t0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, 65535
<   %5 = and i32 %t0, 255
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %7, label %8
---
> ; <label>:386                                     ; preds = %30
>   %387 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 15, i64 0
>   %388 = load i32* %387, align 4
>   %389 = and i32 %388, 1
>   %390 = icmp eq i32 %389, 0
>   br i1 %390, label %399, label %391
4238,4240c2409,2414
< ; <label>:7                                       ; preds = %0
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
---
> ; <label>:391                                     ; preds = %386
>   %392 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 7
>   %393 = load i32* %392, align 4
>   %394 = and i32 %393, 131072
>   %395 = icmp eq i32 %394, 0
>   br i1 %395, label %396, label %399
4242,4245c2416,2419
< ; <label>:8                                       ; preds = %0
<   %9 = udiv i32 %4, %5
<   %10 = icmp ugt i32 %9, 255
<   br i1 %10, label %11, label %12
---
> ; <label>:396                                     ; preds = %391
>   %397 = and i32 %.pre.i.i, 16
>   %398 = icmp eq i32 %397, 0
>   br i1 %398, label %399, label %401
4247,4249c2421,2423
< ; <label>:11                                      ; preds = %8
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
---
> ; <label>:399                                     ; preds = %396, %391, %386
>   %400 = or i32 %383, 64
>   br label %svm_load_seg_cache.exit
4251,4261c2425,2436
< ; <label>:12                                      ; preds = %8
<   %13 = and i32 %9, 255
<   %14 = urem i32 %4, %5
<   %15 = and i32 %3, -65536
<   %16 = shl nuw nsw i32 %14, 8
<   %17 = and i32 %16, 65280
<   %18 = or i32 %13, %15
<   %19 = or i32 %18, %17
<   store i32 %19, i32* %2, align 4
<   ret void
< }
---
> ; <label>:401                                     ; preds = %396
>   %402 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 3, i32 1
>   %403 = load i32* %402, align 4
>   %404 = or i32 %403, %366
>   %405 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 2, i32 1
>   %406 = load i32* %405, align 4
>   %407 = or i32 %404, %406
>   %408 = icmp ne i32 %407, 0
>   %409 = zext i1 %408 to i32
>   %410 = shl nuw nsw i32 %409, 6
>   %411 = or i32 %410, %383
>   br label %svm_load_seg_cache.exit
4263,4287c2438,2483
< define void @helper_idivb_AL(i32 %t0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %3 = load i32* %2, align 4
<   %sext = shl i32 %3, 16
<   %4 = ashr exact i32 %sext, 16
<   %sext7 = shl i32 %t0, 24
<   %5 = ashr exact i32 %sext7, 24
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %7, label %8
< 
< ; <label>:7                                       ; preds = %0
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
< 
< ; <label>:8                                       ; preds = %0
<   %9 = sdiv i32 %4, %5
<   %sext8 = shl i32 %9, 24
<   %10 = ashr exact i32 %sext8, 24
<   %11 = icmp eq i32 %9, %10
<   br i1 %11, label %13, label %12
< 
< ; <label>:12                                      ; preds = %8
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
---
> svm_load_seg_cache.exit:                          ; preds = %401, %399, %30
>   %new_hflags.0.i.i = phi i32 [ %383, %30 ], [ %400, %399 ], [ %411, %401 ]
>   %412 = and i32 %.pre.i.i, -97
>   %413 = or i32 %new_hflags.0.i.i, %412
>   store i32 %413, i32* %.phi.trans.insert.i.i, align 4
>   %414 = load %struct.CPUX86State** @env, align 8
>   %415 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 38
>   %416 = load i64* %415, align 8
>   %417 = add i64 %416, 1040
>   %418 = tail call i32 @lduw_phys(i64 %417) nounwind
>   %419 = add i64 %416, 1048
>   %420 = tail call i64 @ldq_phys(i64 %419) nounwind
>   %421 = trunc i64 %420 to i32
>   %422 = add i64 %416, 1044
>   %423 = tail call i32 @ldl_phys(i64 %422) nounwind
>   %424 = add i64 %416, 1042
>   %425 = tail call i32 @lduw_phys(i64 %424) nounwind
>   %426 = shl i32 %425, 8
>   %427 = and i32 %426, 65280
>   %428 = shl i32 %425, 12
>   %429 = and i32 %428, 15728640
>   %430 = or i32 %427, %429
>   %431 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 1, i32 0
>   store i32 %418, i32* %431, align 4
>   %432 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 1, i32 1
>   store i32 %421, i32* %432, align 4
>   %433 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 1, i32 2
>   store i32 %423, i32* %433, align 4
>   %434 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 1, i32 3
>   store i32 %430, i32* %434, align 4
>   %435 = lshr exact i32 %429, 18
>   %436 = and i32 %435, 16
>   %437 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 8
>   %438 = load i32* %437, align 4
>   %439 = and i32 %438, -32785
>   %440 = or i32 %436, %439
>   store i32 %440, i32* %437, align 4
>   %441 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 2, i32 3
>   %442 = load i32* %441, align 4
>   %443 = lshr i32 %442, 17
>   %444 = and i32 %443, 32
>   %445 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 15, i64 0
>   %446 = load i32* %445, align 4
>   %447 = and i32 %446, 1
>   %448 = icmp eq i32 %447, 0
>   br i1 %448, label %455, label %449
4289,4299c2485,2492
< ; <label>:13                                      ; preds = %8
<   %14 = and i32 %9, 255
<   %15 = srem i32 %4, %5
<   %16 = and i32 %3, -65536
<   %17 = shl i32 %15, 8
<   %18 = and i32 %17, 65280
<   %19 = or i32 %14, %16
<   %20 = or i32 %19, %18
<   store i32 %20, i32* %2, align 4
<   ret void
< }
---
> ; <label>:449                                     ; preds = %svm_load_seg_cache.exit
>   %450 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 7
>   %451 = load i32* %450, align 4
>   %452 = and i32 %451, 131072
>   %453 = icmp ne i32 %452, 0
>   %454 = icmp eq i32 %436, 0
>   %or.cond = or i1 %453, %454
>   br i1 %or.cond, label %455, label %457
4301,4312c2494,2496
< define void @helper_divw_AX(i32 %t0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, 65535
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 2
<   %6 = load i32* %5, align 4
<   %7 = shl i32 %6, 16
<   %8 = or i32 %7, %4
<   %9 = and i32 %t0, 65535
<   %10 = icmp eq i32 %9, 0
<   br i1 %10, label %11, label %12
---
> ; <label>:455                                     ; preds = %449, %svm_load_seg_cache.exit
>   %456 = or i32 %444, 64
>   br label %svm_load_seg_cache.exit8
4314,4316c2498,2511
< ; <label>:11                                      ; preds = %0
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
---
> ; <label>:457                                     ; preds = %449
>   %458 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 3, i32 1
>   %459 = load i32* %458, align 4
>   %460 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 0, i32 1
>   %461 = load i32* %460, align 4
>   %462 = or i32 %461, %459
>   %463 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 2, i32 1
>   %464 = load i32* %463, align 4
>   %465 = or i32 %462, %464
>   %466 = icmp ne i32 %465, 0
>   %467 = zext i1 %466 to i32
>   %468 = shl nuw nsw i32 %467, 6
>   %469 = or i32 %468, %444
>   br label %svm_load_seg_cache.exit8
4318,4321c2513,2549
< ; <label>:12                                      ; preds = %0
<   %13 = udiv i32 %8, %9
<   %14 = icmp ugt i32 %13, 65535
<   br i1 %14, label %15, label %16
---
> svm_load_seg_cache.exit8:                         ; preds = %457, %455
>   %new_hflags.0.i.i7 = phi i32 [ %456, %455 ], [ %469, %457 ]
>   %470 = and i32 %440, -32865
>   %471 = or i32 %new_hflags.0.i.i7, %470
>   store i32 %471, i32* %437, align 4
>   %472 = load %struct.CPUX86State** @env, align 8
>   %473 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 38
>   %474 = load i64* %473, align 8
>   %475 = add i64 %474, 1056
>   %476 = tail call i32 @lduw_phys(i64 %475) nounwind
>   %477 = add i64 %474, 1064
>   %478 = tail call i64 @ldq_phys(i64 %477) nounwind
>   %479 = trunc i64 %478 to i32
>   %480 = add i64 %474, 1060
>   %481 = tail call i32 @ldl_phys(i64 %480) nounwind
>   %482 = add i64 %474, 1058
>   %483 = tail call i32 @lduw_phys(i64 %482) nounwind
>   %484 = shl i32 %483, 8
>   %485 = and i32 %484, 65280
>   %486 = shl i32 %483, 12
>   %487 = and i32 %486, 15728640
>   %488 = or i32 %485, %487
>   %489 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 2, i32 0
>   store i32 %476, i32* %489, align 4
>   %490 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 2, i32 1
>   store i32 %479, i32* %490, align 4
>   %491 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 2, i32 2
>   store i32 %481, i32* %491, align 4
>   %492 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 2, i32 3
>   store i32 %488, i32* %492, align 4
>   %.phi.trans.insert.i.i9 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 8
>   %.pre.i.i10 = load i32* %.phi.trans.insert.i.i9, align 4
>   %493 = lshr exact i32 %487, 17
>   %494 = and i32 %493, 32
>   %495 = and i32 %.pre.i.i10, 32768
>   %496 = icmp eq i32 %495, 0
>   br i1 %496, label %497, label %svm_load_seg_cache.exit12
4323,4325c2551,2556
< ; <label>:15                                      ; preds = %12
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
---
> ; <label>:497                                     ; preds = %svm_load_seg_cache.exit8
>   %498 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 15, i64 0
>   %499 = load i32* %498, align 4
>   %500 = and i32 %499, 1
>   %501 = icmp eq i32 %500, 0
>   br i1 %501, label %510, label %502
4327,4341c2558,2563
< ; <label>:16                                      ; preds = %12
<   %17 = and i32 %13, 65535
<   %18 = urem i32 %8, %9
<   %19 = and i32 %18, 65535
<   %20 = and i32 %3, -65536
<   %21 = or i32 %17, %20
<   store i32 %21, i32* %2, align 4
<   %22 = load %struct.CPUX86State** @env, align 8
<   %23 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 0, i64 2
<   %24 = load i32* %23, align 4
<   %25 = and i32 %24, -65536
<   %26 = or i32 %25, %19
<   store i32 %26, i32* %23, align 4
<   ret void
< }
---
> ; <label>:502                                     ; preds = %497
>   %503 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 7
>   %504 = load i32* %503, align 4
>   %505 = and i32 %504, 131072
>   %506 = icmp eq i32 %505, 0
>   br i1 %506, label %507, label %510
4343,4355c2565,2568
< define void @helper_idivw_AX(i32 %t0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, 65535
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 2
<   %6 = load i32* %5, align 4
<   %7 = shl i32 %6, 16
<   %8 = or i32 %7, %4
<   %sext = shl i32 %t0, 16
<   %9 = ashr exact i32 %sext, 16
<   %10 = icmp eq i32 %9, 0
<   br i1 %10, label %11, label %12
---
> ; <label>:507                                     ; preds = %502
>   %508 = and i32 %.pre.i.i10, 16
>   %509 = icmp eq i32 %508, 0
>   br i1 %509, label %510, label %512
4357,4359c2570,2572
< ; <label>:11                                      ; preds = %0
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
---
> ; <label>:510                                     ; preds = %507, %502, %497
>   %511 = or i32 %494, 64
>   br label %svm_load_seg_cache.exit12
4361,4366c2574,2585
< ; <label>:12                                      ; preds = %0
<   %13 = sdiv i32 %8, %9
<   %sext7 = shl i32 %13, 16
<   %14 = ashr exact i32 %sext7, 16
<   %15 = icmp eq i32 %13, %14
<   br i1 %15, label %17, label %16
---
> ; <label>:512                                     ; preds = %507
>   %513 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 3, i32 1
>   %514 = load i32* %513, align 4
>   %515 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 0, i32 1
>   %516 = load i32* %515, align 4
>   %517 = or i32 %514, %479
>   %518 = or i32 %517, %516
>   %519 = icmp ne i32 %518, 0
>   %520 = zext i1 %519 to i32
>   %521 = shl nuw nsw i32 %520, 6
>   %522 = or i32 %521, %494
>   br label %svm_load_seg_cache.exit12
4368,4370c2587,2625
< ; <label>:16                                      ; preds = %12
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
---
> svm_load_seg_cache.exit12:                        ; preds = %512, %510, %svm_load_seg_cache.exit8
>   %new_hflags.0.i.i11 = phi i32 [ %494, %svm_load_seg_cache.exit8 ], [ %511, %510 ], [ %522, %512 ]
>   %523 = and i32 %.pre.i.i10, -97
>   %524 = or i32 %new_hflags.0.i.i11, %523
>   store i32 %524, i32* %.phi.trans.insert.i.i9, align 4
>   %525 = load %struct.CPUX86State** @env, align 8
>   %526 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 38
>   %527 = load i64* %526, align 8
>   %528 = add i64 %527, 1072
>   %529 = tail call i32 @lduw_phys(i64 %528) nounwind
>   %530 = add i64 %527, 1080
>   %531 = tail call i64 @ldq_phys(i64 %530) nounwind
>   %532 = trunc i64 %531 to i32
>   %533 = add i64 %527, 1076
>   %534 = tail call i32 @ldl_phys(i64 %533) nounwind
>   %535 = add i64 %527, 1074
>   %536 = tail call i32 @lduw_phys(i64 %535) nounwind
>   %537 = shl i32 %536, 8
>   %538 = and i32 %537, 65280
>   %539 = shl i32 %536, 12
>   %540 = and i32 %539, 15728640
>   %541 = or i32 %538, %540
>   %542 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 3, i32 0
>   store i32 %529, i32* %542, align 4
>   %543 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 3, i32 1
>   store i32 %532, i32* %543, align 4
>   %544 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 3, i32 2
>   store i32 %534, i32* %544, align 4
>   %545 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 3, i32 3
>   store i32 %541, i32* %545, align 4
>   %.phi.trans.insert.i.i13 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 8
>   %.pre.i.i14 = load i32* %.phi.trans.insert.i.i13, align 4
>   %546 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 2, i32 3
>   %547 = load i32* %546, align 4
>   %548 = lshr i32 %547, 17
>   %549 = and i32 %548, 32
>   %550 = and i32 %.pre.i.i14, 32768
>   %551 = icmp eq i32 %550, 0
>   br i1 %551, label %552, label %svm_load_seg_cache.exit16
4372,4386c2627,2632
< ; <label>:17                                      ; preds = %12
<   %18 = and i32 %13, 65535
<   %19 = srem i32 %8, %9
<   %20 = and i32 %19, 65535
<   %21 = and i32 %3, -65536
<   %22 = or i32 %18, %21
<   store i32 %22, i32* %2, align 4
<   %23 = load %struct.CPUX86State** @env, align 8
<   %24 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 0, i64 2
<   %25 = load i32* %24, align 4
<   %26 = and i32 %25, -65536
<   %27 = or i32 %26, %20
<   store i32 %27, i32* %24, align 4
<   ret void
< }
---
> ; <label>:552                                     ; preds = %svm_load_seg_cache.exit12
>   %553 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 15, i64 0
>   %554 = load i32* %553, align 4
>   %555 = and i32 %554, 1
>   %556 = icmp eq i32 %555, 0
>   br i1 %556, label %565, label %557
4388,4399c2634,2639
< define void @helper_divl_EAX(i32 %t0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 2
<   %6 = load i32* %5, align 4
<   %7 = zext i32 %6 to i64
<   %8 = shl nuw i64 %7, 32
<   %9 = or i64 %8, %4
<   %10 = icmp eq i32 %t0, 0
<   br i1 %10, label %11, label %12
---
> ; <label>:557                                     ; preds = %552
>   %558 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 7
>   %559 = load i32* %558, align 4
>   %560 = and i32 %559, 131072
>   %561 = icmp eq i32 %560, 0
>   br i1 %561, label %562, label %565
4401,4403c2641,2644
< ; <label>:11                                      ; preds = %0
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
---
> ; <label>:562                                     ; preds = %557
>   %563 = and i32 %.pre.i.i14, 16
>   %564 = icmp eq i32 %563, 0
>   br i1 %564, label %565, label %567
4405,4409c2646,2648
< ; <label>:12                                      ; preds = %0
<   %13 = zext i32 %t0 to i64
<   %14 = udiv i64 %9, %13
<   %15 = icmp ugt i64 %14, 4294967295
<   br i1 %15, label %16, label %17
---
> ; <label>:565                                     ; preds = %562, %557, %552
>   %566 = or i32 %549, 64
>   br label %svm_load_seg_cache.exit16
4411,4413c2650,2661
< ; <label>:16                                      ; preds = %12
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
---
> ; <label>:567                                     ; preds = %562
>   %568 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 0, i32 1
>   %569 = load i32* %568, align 4
>   %570 = or i32 %569, %532
>   %571 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 2, i32 1
>   %572 = load i32* %571, align 4
>   %573 = or i32 %570, %572
>   %574 = icmp ne i32 %573, 0
>   %575 = zext i1 %574 to i32
>   %576 = shl nuw nsw i32 %575, 6
>   %577 = or i32 %576, %549
>   br label %svm_load_seg_cache.exit16
4415,4452c2663,2776
< ; <label>:17                                      ; preds = %12
<   %18 = urem i64 %9, %13
<   %19 = trunc i64 %18 to i32
<   %20 = trunc i64 %14 to i32
<   store i32 %20, i32* %2, align 4
<   %21 = load %struct.CPUX86State** @env, align 8
<   %22 = getelementptr inbounds %struct.CPUX86State* %21, i64 0, i32 0, i64 2
<   store i32 %19, i32* %22, align 4
<   ret void
< }
< 
< define void @helper_idivl_EAX(i32 %t0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 2
<   %6 = load i32* %5, align 4
<   %7 = zext i32 %6 to i64
<   %8 = shl nuw i64 %7, 32
<   %9 = or i64 %8, %4
<   %10 = icmp eq i32 %t0, 0
<   br i1 %10, label %11, label %12
< 
< ; <label>:11                                      ; preds = %0
<   tail call fastcc void @raise_exception(i32 0) noreturn
<   unreachable
< 
< ; <label>:12                                      ; preds = %0
<   %13 = sext i32 %t0 to i64
<   %14 = sdiv i64 %9, %13
<   %sext = shl i64 %14, 32
<   %15 = ashr exact i64 %sext, 32
<   %16 = icmp eq i64 %14, %15
<   br i1 %16, label %18, label %17
< 
< ; <label>:17                                      ; preds = %12
<   tail call fastcc void @raise_exception(i32 0) noreturn
---
> svm_load_seg_cache.exit16:                        ; preds = %567, %565, %svm_load_seg_cache.exit12
>   %new_hflags.0.i.i15 = phi i32 [ %549, %svm_load_seg_cache.exit12 ], [ %566, %565 ], [ %577, %567 ]
>   %578 = and i32 %.pre.i.i14, -97
>   %579 = or i32 %new_hflags.0.i.i15, %578
>   store i32 %579, i32* %.phi.trans.insert.i.i13, align 4
>   %580 = load %struct.CPUX86State** @env, align 8
>   %581 = getelementptr inbounds %struct.CPUX86State* %580, i64 0, i32 38
>   %582 = load i64* %581, align 8
>   %583 = add i64 %582, 1400
>   %584 = tail call i64 @ldq_phys(i64 %583) nounwind
>   %585 = trunc i64 %584 to i32
>   %586 = load %struct.CPUX86State** @env, align 8
>   %587 = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 5
>   store i32 %585, i32* %587, align 4
>   %588 = load %struct.CPUX86State** @env, align 8
>   %589 = getelementptr inbounds %struct.CPUX86State* %588, i64 0, i32 38
>   %590 = load i64* %589, align 8
>   %591 = add i64 %590, 1496
>   %592 = tail call i64 @ldq_phys(i64 %591) nounwind
>   %593 = trunc i64 %592 to i32
>   %594 = load %struct.CPUX86State** @env, align 8
>   %595 = getelementptr inbounds %struct.CPUX86State* %594, i64 0, i32 0, i64 4
>   store i32 %593, i32* %595, align 4
>   %596 = load %struct.CPUX86State** @env, align 8
>   %597 = getelementptr inbounds %struct.CPUX86State* %596, i64 0, i32 38
>   %598 = load i64* %597, align 8
>   %599 = add i64 %598, 1528
>   %600 = tail call i64 @ldq_phys(i64 %599) nounwind
>   %601 = trunc i64 %600 to i32
>   %602 = load %struct.CPUX86State** @env, align 8
>   %603 = getelementptr inbounds %struct.CPUX86State* %602, i64 0, i32 0, i64 0
>   store i32 %601, i32* %603, align 4
>   %604 = load %struct.CPUX86State** @env, align 8
>   %605 = getelementptr inbounds %struct.CPUX86State* %604, i64 0, i32 38
>   %606 = load i64* %605, align 8
>   %607 = add i64 %606, 1384
>   %608 = tail call i64 @ldq_phys(i64 %607) nounwind
>   %609 = trunc i64 %608 to i32
>   %610 = load %struct.CPUX86State** @env, align 8
>   %611 = getelementptr inbounds %struct.CPUX86State* %610, i64 0, i32 58, i64 6
>   store i32 %609, i32* %611, align 4
>   %612 = load %struct.CPUX86State** @env, align 8
>   %613 = getelementptr inbounds %struct.CPUX86State* %612, i64 0, i32 38
>   %614 = load i64* %613, align 8
>   %615 = add i64 %614, 1376
>   %616 = tail call i64 @ldq_phys(i64 %615) nounwind
>   %617 = trunc i64 %616 to i32
>   %618 = load %struct.CPUX86State** @env, align 8
>   %619 = getelementptr inbounds %struct.CPUX86State* %618, i64 0, i32 58, i64 7
>   store i32 %617, i32* %619, align 4
>   %620 = load %struct.CPUX86State** @env, align 8
>   %621 = getelementptr inbounds %struct.CPUX86State* %620, i64 0, i32 8
>   %622 = load i32* %621, align 4
>   %623 = and i32 %622, 3
>   tail call void @s2e_on_privilege_change(i32 %623, i32 0) nounwind
>   %624 = load i32* %621, align 4
>   %625 = and i32 %624, -4
>   store i32 %625, i32* %621, align 4
>   %626 = load %struct.CPUX86State** @env, align 8
>   %627 = getelementptr inbounds %struct.CPUX86State* %626, i64 0, i32 39
>   %628 = load i64* %627, align 8
>   %629 = add i64 %628, 112
>   %630 = zext i32 %exit_code to i64
>   tail call void @stq_phys(i64 %629, i64 %630) nounwind
>   %631 = load %struct.CPUX86State** @env, align 8
>   %632 = getelementptr inbounds %struct.CPUX86State* %631, i64 0, i32 39
>   %633 = load i64* %632, align 8
>   %634 = add i64 %633, 120
>   tail call void @stq_phys(i64 %634, i64 %exit_info_1) nounwind
>   %635 = load %struct.CPUX86State** @env, align 8
>   %636 = getelementptr inbounds %struct.CPUX86State* %635, i64 0, i32 39
>   %637 = load i64* %636, align 8
>   %638 = add i64 %637, 136
>   %639 = add i64 %637, 168
>   %640 = tail call i32 @ldl_phys(i64 %639) nounwind
>   tail call void @stl_phys(i64 %638, i32 %640) nounwind
>   %641 = load %struct.CPUX86State** @env, align 8
>   %642 = getelementptr inbounds %struct.CPUX86State* %641, i64 0, i32 39
>   %643 = load i64* %642, align 8
>   %644 = add i64 %643, 140
>   %645 = add i64 %643, 172
>   %646 = tail call i32 @ldl_phys(i64 %645) nounwind
>   tail call void @stl_phys(i64 %644, i32 %646) nounwind
>   %647 = load %struct.CPUX86State** @env, align 8
>   %648 = getelementptr inbounds %struct.CPUX86State* %647, i64 0, i32 39
>   %649 = load i64* %648, align 8
>   %650 = add i64 %649, 168
>   tail call void @stl_phys(i64 %650, i32 0) nounwind
>   %651 = load %struct.CPUX86State** @env, align 8
>   %652 = getelementptr inbounds %struct.CPUX86State* %651, i64 0, i32 9
>   %653 = load i32* %652, align 4
>   %654 = and i32 %653, -2
>   store i32 %654, i32* %652, align 4
>   %655 = load %struct.CPUX86State** @env, align 8
>   %656 = getelementptr inbounds %struct.CPUX86State* %655, i64 0, i32 15, i64 0
>   %657 = load i32* %656, align 4
>   %658 = or i32 %657, 1
>   store i32 %658, i32* %656, align 4
>   %659 = load %struct.CPUX86State** @env, align 8
>   %660 = getelementptr inbounds %struct.CPUX86State* %659, i64 0, i32 7
>   %661 = load i32* %660, align 4
>   %662 = and i32 %661, -131073
>   store i32 %662, i32* %660, align 4
>   %663 = load %struct.CPUX86State** @env, align 8
>   %664 = getelementptr inbounds %struct.CPUX86State* %663, i64 0, i32 92
>   store i32 -1, i32* %664, align 4
>   %665 = load %struct.CPUX86State** @env, align 8
>   %666 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 55
>   store i32 0, i32* %666, align 4
>   %667 = load %struct.CPUX86State** @env, align 8
>   %668 = getelementptr inbounds %struct.CPUX86State* %667, i64 0, i32 61
>   store i32 -1, i32* %668, align 4
>   %669 = load %struct.CPUX86State** @env, align 8
>   tail call void @cpu_loop_exit(%struct.CPUX86State* %669) noreturn nounwind
4454,4719d2777
< 
< ; <label>:18                                      ; preds = %12
<   %19 = srem i64 %9, %13
<   %20 = trunc i64 %14 to i32
<   %21 = trunc i64 %19 to i32
<   store i32 %20, i32* %2, align 4
<   %22 = load %struct.CPUX86State** @env, align 8
<   %23 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 0, i64 2
<   store i32 %21, i32* %23, align 4
<   ret void
< }
< 
< define void @helper_aam(i32 %base) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, 255
<   %5 = sdiv i32 %4, %base
<   %6 = srem i32 %4, %base
<   %7 = and i32 %3, -65536
<   %8 = or i32 %6, %7
<   %9 = shl i32 %5, 8
<   %10 = or i32 %8, %9
<   store i32 %10, i32* %2, align 4
<   %11 = load %struct.CPUX86State** @env, align 8
<   %12 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 3
<   store i32 %6, i32* %12, align 4
<   ret void
< }
< 
< define void @helper_aad(i32 %base) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %3 = load i32* %2, align 4
<   %4 = lshr i32 %3, 8
<   %5 = and i32 %4, 255
<   %6 = mul nsw i32 %5, %base
<   %7 = add nsw i32 %6, %3
<   %8 = and i32 %7, 255
<   %9 = and i32 %3, -65536
<   %10 = or i32 %8, %9
<   store i32 %10, i32* %2, align 4
<   %11 = load %struct.CPUX86State** @env, align 8
<   %12 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 3
<   store i32 %8, i32* %12, align 4
<   ret void
< }
< 
< define void @helper_aaa() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %6 = load i32* %5, align 4
<   %7 = and i32 %6, 254
<   %8 = lshr i32 %6, 8
<   %9 = icmp ugt i32 %7, 249
<   %10 = zext i1 %9 to i32
<   %11 = and i32 %6, 15
<   %12 = icmp ugt i32 %11, 9
<   br i1 %12, label %16, label %13
< 
< ; <label>:13                                      ; preds = %0
<   %14 = and i32 %4, 16
<   %15 = icmp eq i32 %14, 0
<   br i1 %15, label %22, label %16
< 
< ; <label>:16                                      ; preds = %13, %0
<   %17 = add nsw i32 %6, 6
<   %18 = and i32 %17, 15
<   %19 = add nsw i32 %8, 1
<   %20 = add nsw i32 %19, %10
<   %21 = or i32 %4, 17
<   br label %24
< 
< ; <label>:22                                      ; preds = %13
<   %23 = and i32 %4, -18
<   br label %24
< 
< ; <label>:24                                      ; preds = %22, %16
<   %ah.0.in = phi i32 [ %20, %16 ], [ %8, %22 ]
<   %al.0 = phi i32 [ %18, %16 ], [ %11, %22 ]
<   %eflags.0 = phi i32 [ %21, %16 ], [ %23, %22 ]
<   %25 = and i32 %6, -65536
<   %ah.0 = shl i32 %ah.0.in, 8
<   %26 = and i32 %ah.0, 65280
<   %27 = or i32 %al.0, %25
<   %28 = or i32 %27, %26
<   store i32 %28, i32* %5, align 4
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 2
<   store i32 %eflags.0, i32* %30, align 4
<   ret void
< }
< 
< define void @helper_aas() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %6 = load i32* %5, align 4
<   %7 = and i32 %6, 254
<   %8 = lshr i32 %6, 8
<   %9 = icmp ult i32 %7, 6
<   %10 = zext i1 %9 to i32
<   %11 = and i32 %6, 15
<   %12 = icmp ugt i32 %11, 9
<   br i1 %12, label %16, label %13
< 
< ; <label>:13                                      ; preds = %0
<   %14 = and i32 %4, 16
<   %15 = icmp eq i32 %14, 0
<   br i1 %15, label %22, label %16
< 
< ; <label>:16                                      ; preds = %13, %0
<   %17 = add nsw i32 %6, 10
<   %18 = and i32 %17, 15
<   %19 = add nsw i32 %8, -1
<   %20 = sub i32 %19, %10
<   %21 = or i32 %4, 17
<   br label %24
< 
< ; <label>:22                                      ; preds = %13
<   %23 = and i32 %4, -18
<   br label %24
< 
< ; <label>:24                                      ; preds = %22, %16
<   %ah.0.in = phi i32 [ %20, %16 ], [ %8, %22 ]
<   %al.0 = phi i32 [ %18, %16 ], [ %11, %22 ]
<   %eflags.0 = phi i32 [ %21, %16 ], [ %23, %22 ]
<   %25 = and i32 %6, -65536
<   %ah.0 = shl i32 %ah.0.in, 8
<   %26 = and i32 %ah.0, 65280
<   %27 = or i32 %al.0, %25
<   %28 = or i32 %27, %26
<   store i32 %28, i32* %5, align 4
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 2
<   store i32 %eflags.0, i32* %30, align 4
<   ret void
< }
< 
< define void @helper_daa() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = and i32 %4, 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %7 = load i32* %6, align 4
<   %8 = and i32 %7, 255
<   %9 = and i32 %7, 14
<   %10 = icmp ugt i32 %9, 9
<   br i1 %10, label %14, label %11
< 
< ; <label>:11                                      ; preds = %0
<   %12 = and i32 %4, 16
<   %13 = icmp eq i32 %12, 0
<   br i1 %13, label %17, label %14
< 
< ; <label>:14                                      ; preds = %11, %0
<   %15 = add nsw i32 %7, 6
<   %16 = and i32 %15, 255
<   br label %17
< 
< ; <label>:17                                      ; preds = %14, %11
<   %al.0 = phi i32 [ %16, %14 ], [ %8, %11 ]
<   %eflags.0 = phi i32 [ 16, %14 ], [ 0, %11 ]
<   %18 = icmp ult i32 %8, 154
<   %19 = icmp eq i32 %5, 0
<   %or.cond = and i1 %18, %19
<   br i1 %or.cond, label %24, label %20
< 
< ; <label>:20                                      ; preds = %17
<   %21 = add nsw i32 %al.0, 96
<   %22 = and i32 %21, 255
<   %23 = or i32 %eflags.0, 1
<   br label %24
< 
< ; <label>:24                                      ; preds = %20, %17
<   %al.1 = phi i32 [ %22, %20 ], [ %al.0, %17 ]
<   %eflags.1 = phi i32 [ %23, %20 ], [ %eflags.0, %17 ]
<   %25 = and i32 %7, -256
<   %26 = or i32 %al.1, %25
<   store i32 %26, i32* %6, align 4
<   %27 = icmp eq i32 %al.1, 0
<   %28 = zext i1 %27 to i32
<   %29 = shl nuw nsw i32 %28, 6
<   %30 = sext i32 %al.1 to i64
<   %31 = getelementptr inbounds [256 x i8]* @parity_table, i64 0, i64 %30
<   %32 = load i8* %31, align 1
<   %33 = zext i8 %32 to i32
<   %34 = and i32 %al.1, 128
<   %35 = or i32 %34, %eflags.1
<   %36 = or i32 %35, %29
<   %37 = or i32 %36, %33
<   %38 = load %struct.CPUX86State** @env, align 8
<   %39 = getelementptr inbounds %struct.CPUX86State* %38, i64 0, i32 2
<   store i32 %37, i32* %39, align 4
<   ret void
< }
< 
< define void @helper_das() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = and i32 %4, 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %7 = load i32* %6, align 4
<   %8 = and i32 %7, 255
<   %9 = and i32 %7, 14
<   %10 = icmp ugt i32 %9, 9
<   br i1 %10, label %14, label %11
< 
< ; <label>:11                                      ; preds = %0
<   %12 = and i32 %4, 16
<   %13 = icmp eq i32 %12, 0
<   br i1 %13, label %19, label %14
< 
< ; <label>:14                                      ; preds = %11, %0
<   %15 = icmp ugt i32 %8, 5
<   %16 = icmp eq i32 %5, 0
<   %or.cond = and i1 %15, %16
<   %eflags.0 = select i1 %or.cond, i32 16, i32 17
<   %17 = add nsw i32 %7, 250
<   %18 = and i32 %17, 255
<   br label %19
< 
< ; <label>:19                                      ; preds = %14, %11
<   %al.0 = phi i32 [ %18, %14 ], [ %8, %11 ]
<   %eflags.1 = phi i32 [ %eflags.0, %14 ], [ 0, %11 ]
<   %20 = icmp ult i32 %8, 154
<   %21 = icmp eq i32 %5, 0
<   %or.cond18 = and i1 %20, %21
<   br i1 %or.cond18, label %26, label %22
< 
< ; <label>:22                                      ; preds = %19
<   %23 = add nsw i32 %al.0, 160
<   %24 = and i32 %23, 255
<   %25 = or i32 %eflags.1, 1
<   br label %26
< 
< ; <label>:26                                      ; preds = %22, %19
<   %al.1 = phi i32 [ %24, %22 ], [ %al.0, %19 ]
<   %eflags.2 = phi i32 [ %25, %22 ], [ %eflags.1, %19 ]
<   %27 = and i32 %7, -256
<   %28 = or i32 %al.1, %27
<   store i32 %28, i32* %6, align 4
<   %29 = icmp eq i32 %al.1, 0
<   %30 = zext i1 %29 to i32
<   %31 = shl nuw nsw i32 %30, 6
<   %32 = sext i32 %al.1 to i64
<   %33 = getelementptr inbounds [256 x i8]* @parity_table, i64 0, i64 %32
<   %34 = load i8* %33, align 1
<   %35 = zext i8 %34 to i32
<   %36 = and i32 %al.1, 128
<   %37 = or i32 %36, %eflags.2
<   %38 = or i32 %37, %31
<   %39 = or i32 %38, %35
<   %40 = load %struct.CPUX86State** @env, align 8
<   %41 = getelementptr inbounds %struct.CPUX86State* %40, i64 0, i32 2
<   store i32 %39, i32* %41, align 4
<   ret void
4722,4733c2780
< define void @helper_into(i32 %next_eip_addend) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = and i32 %4, 2048
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %8, label %7
< 
< ; <label>:7                                       ; preds = %0
<   tail call fastcc void @raise_interrupt(i32 4, i32 1, i32 0, i32 %next_eip_addend) noreturn
<   unreachable
---
> declare void @stb_phys(i64, i32)
4735,4737c2782
< ; <label>:8                                       ; preds = %0
<   ret void
< }
---
> declare void @stw_phys(i64, i32)
4739,4755c2784
< define void @helper_cmpxchg8b(i32 %a0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = tail call fastcc i64 @ldq_data(i32 %a0)
<   %6 = load %struct.CPUX86State** @env, align 8
<   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 0, i64 2
<   %8 = load i32* %7, align 4
<   %9 = zext i32 %8 to i64
<   %10 = shl nuw i64 %9, 32
<   %11 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 0, i64 0
<   %12 = load i32* %11, align 4
<   %13 = zext i32 %12 to i64
<   %14 = or i64 %10, %13
<   %15 = icmp eq i64 %5, %14
<   br i1 %15, label %16, label %26
---
> declare void @s2e_on_privilege_change(i32, i32)
4757,4768c2786
< ; <label>:16                                      ; preds = %0
<   %17 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 0, i64 1
<   %18 = load i32* %17, align 4
<   %19 = zext i32 %18 to i64
<   %20 = shl nuw i64 %19, 32
<   %21 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 0, i64 3
<   %22 = load i32* %21, align 4
<   %23 = zext i32 %22 to i64
<   %24 = or i64 %20, %23
<   tail call fastcc void @stq_data(i32 %a0, i64 %24)
<   %25 = or i32 %4, 64
<   br label %35
---
> declare void @qemu_system_reset_request()
4770,4782c2788
< ; <label>:26                                      ; preds = %0
<   tail call fastcc void @stq_data(i32 %a0, i64 %5)
<   %27 = lshr i64 %5, 32
<   %28 = trunc i64 %27 to i32
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 0, i64 2
<   store i32 %28, i32* %30, align 4
<   %31 = trunc i64 %5 to i32
<   %32 = load %struct.CPUX86State** @env, align 8
<   %33 = getelementptr inbounds %struct.CPUX86State* %32, i64 0, i32 0, i64 0
<   store i32 %31, i32* %33, align 4
<   %34 = and i32 %4, -65
<   br label %35
---
> declare i64 @fwrite(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) nounwind
4784,4789c2790,2796
< ; <label>:35                                      ; preds = %26, %16
<   %eflags.0 = phi i32 [ %25, %16 ], [ %34, %26 ]
<   %36 = load %struct.CPUX86State** @env, align 8
<   %37 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 2
<   store i32 %eflags.0, i32* %37, align 4
<   ret void
---
> define internal i1 @uadd(i32*, i32, i32) {
>   %4 = add i32 %2, %1
>   store i32 %4, i32* %0, align 4
>   %5 = icmp ugt i32 %1, %2
>   %6 = select i1 %5, i32 %1, i32 %2
>   %7 = icmp ult i32 %4, %6
>   ret i1 %7
4792,4881c2799,2866
< define internal fastcc i64 @ldq_data(i32 %ptr) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
< 
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
< 
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = icmp eq i32 %17, 3
<   %19 = zext i1 %18 to i64
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 0
<   %21 = load i32* %20, align 4
<   %22 = and i32 %8, -4089
<   %23 = icmp eq i32 %21, %22
<   br i1 %23, label %27, label %24, !prof !0
< 
< ; <label>:24                                      ; preds = %6
<   %25 = zext i1 %18 to i32
<   %26 = tail call i64 @__ldq_mmu(i32 %8, i32 %25)
<   br label %34
< 
< ; <label>:27                                      ; preds = %6
<   %28 = and i64 %7, 4294967295
<   %29 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 3
<   %30 = load i64* %29, align 8
<   %31 = add i64 %30, %28
<   %32 = inttoptr i64 %31 to i64*
<   %33 = load i64* %32, align 8
<   tail call void @tcg_llvm_trace_memory_access(i64 %28, i64 %31, i64 %33, i32 64, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %34
< 
< ; <label>:34                                      ; preds = %27, %24
<   %res.0 = phi i64 [ %26, %24 ], [ %33, %27 ]
<   ret i64 %res.0
< }
< 
< define internal fastcc void @stq_data(i32 %ptr, i64 %v) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
< 
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
< 
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = icmp eq i32 %17, 3
<   %19 = zext i1 %18 to i64
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 1
<   %21 = load i32* %20, align 4
<   %22 = and i32 %8, -4089
<   %23 = icmp eq i32 %21, %22
<   br i1 %23, label %26, label %24, !prof !0
< 
< ; <label>:24                                      ; preds = %6
<   %25 = zext i1 %18 to i32
<   tail call void @__stq_mmu(i32 %8, i64 %v, i32 %25)
<   br label %32
< 
< ; <label>:26                                      ; preds = %6
<   %27 = and i64 %7, 4294967295
<   %28 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 3
<   %29 = load i64* %28, align 8
<   %30 = add i64 %29, %27
---
> define i64 @Func_804841d(i64*) {
> entry:
>   %loc_16ptr = alloca i32
>   %loc_17ptr = alloca i32
>   %loc_18ptr = alloca i32
>   %loc_20ptr = alloca i32
>   %loc_21ptr = alloca i32
>   %1 = getelementptr i64* %0, i32 0
>   %env_v = load i64* %1
>   %2 = add i64 %env_v, 856
>   %3 = inttoptr i64 %2 to i64*
>   store i64 139967006153600, i64* %3
>   call void @helper_s2e_tcg_execution_handler(i64 139966614905392, i64 134513693)
>   %4 = getelementptr i64* %0, i32 0
>   %env_v1 = load i64* %4
>   %5 = add i64 %env_v1, 48
>   %6 = inttoptr i64 %5 to i32*
>   store i32 134513693, i32* %6
>   %7 = add i64 %env_v1, 317312
>   %8 = inttoptr i64 %7 to i64*
>   %tmp5_v = load i64* %8
>   %tmp5_v2 = add i64 %tmp5_v, 1
>   %9 = add i64 %env_v1, 317312
>   %10 = inttoptr i64 %9 to i64*
>   store i64 %tmp5_v2, i64* %10
>   %11 = add i64 %env_v1, 20
>   %ebp_ptr = inttoptr i64 %11 to i32*
>   %ebp_v = load i32* %ebp_ptr
>   %12 = add i64 %env_v1, 16
>   %esp_ptr = inttoptr i64 %12 to i32*
>   %esp_v = load i32* %esp_ptr
>   %tmp2_v = add i32 %esp_v, -4
>   call void @__stl_mmu(i32 %tmp2_v, i32 %ebp_v, i32 1)
>   store i32 %tmp2_v, i32* %esp_ptr
>   %13 = add i64 %env_v1, 48
>   %14 = inttoptr i64 %13 to i32*
>   store i32 134513694, i32* %14
>   %15 = add i64 %env_v1, 317312
>   %16 = inttoptr i64 %15 to i64*
>   %tmp5_v3 = load i64* %16
>   %tmp5_v4 = add i64 %tmp5_v3, 1
>   %17 = add i64 %env_v1, 317312
>   %18 = inttoptr i64 %17 to i64*
>   store i64 %tmp5_v4, i64* %18
>   store i32 %tmp2_v, i32* %ebp_ptr
>   %19 = add i64 %env_v1, 48
>   %20 = inttoptr i64 %19 to i32*
>   store i32 134513696, i32* %20
>   %21 = add i64 %env_v1, 317312
>   %22 = inttoptr i64 %21 to i64*
>   %tmp5_v5 = load i64* %22
>   %tmp5_v6 = add i64 %tmp5_v5, 1
>   %23 = add i64 %env_v1, 317312
>   %24 = inttoptr i64 %23 to i64*
>   store i64 %tmp5_v6, i64* %24
>   %tmp0_v = and i32 %tmp2_v, -16
>   store i32 %tmp0_v, i32* %esp_ptr
>   %25 = add i64 %env_v1, 40
>   %cc_dst_ptr = inttoptr i64 %25 to i32*
>   store i32 %tmp0_v, i32* %cc_dst_ptr
>   %26 = add i64 %env_v1, 48
>   %27 = inttoptr i64 %26 to i32*
>   store i32 134513699, i32* %27
>   %28 = add i64 %env_v1, 317312
>   %29 = inttoptr i64 %28 to i64*
>   %tmp5_v7 = load i64* %29
>   %tmp5_v8 = add i64 %tmp5_v7, 1
>   %30 = add i64 %env_v1, 317312
4883,4900c2868,2909
<   store i64 %v, i64* %31, align 8
<   tail call void @tcg_llvm_trace_memory_access(i64 %27, i64 %30, i64 %v, i32 64, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %32
< 
< ; <label>:32                                      ; preds = %26, %24
<   ret void
< }
< 
< define void @helper_single_step() noreturn nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = tail call i32 @check_hw_breakpoints(%struct.CPUX86State* %1, i32 1) nounwind
<   %3 = load %struct.CPUX86State** @env, align 8
<   %4 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 58, i64 6
<   %5 = load i32* %4, align 4
<   %6 = or i32 %5, 16384
<   store i32 %6, i32* %4, align 4
<   tail call fastcc void @raise_exception(i32 1) noreturn
<   unreachable
---
>   store i64 %tmp5_v8, i64* %31
>   %32 = add i64 %env_v1, 32
>   %cc_op_ptr = inttoptr i64 %32 to i32*
>   store i32 24, i32* %cc_op_ptr
>   %tmp0_v9 = sub i32 %tmp0_v, 16
>   store i32 %tmp0_v9, i32* %esp_ptr
>   %33 = add i64 %env_v1, 36
>   %cc_src_ptr = inttoptr i64 %33 to i32*
>   store i32 16, i32* %cc_src_ptr
>   store i32 %tmp0_v9, i32* %cc_dst_ptr
>   %34 = add i64 %env_v1, 48
>   %35 = inttoptr i64 %34 to i32*
>   store i32 134513702, i32* %35
>   %36 = add i64 %env_v1, 317312
>   %37 = inttoptr i64 %36 to i64*
>   %tmp5_v10 = load i64* %37
>   %tmp5_v11 = add i64 %tmp5_v10, 1
>   %38 = add i64 %env_v1, 317312
>   %39 = inttoptr i64 %38 to i64*
>   store i64 %tmp5_v11, i64* %39
>   store i32 16, i32* %cc_op_ptr
>   call void @__stl_mmu(i32 %tmp0_v9, i32 134513872, i32 1)
>   %40 = add i64 %env_v1, 48
>   %41 = inttoptr i64 %40 to i32*
>   store i32 134513709, i32* %41
>   %42 = add i64 %env_v1, 317312
>   %43 = inttoptr i64 %42 to i64*
>   %tmp5_v12 = load i64* %43
>   %tmp5_v13 = add i64 %tmp5_v12, 1
>   %44 = add i64 %env_v1, 317312
>   %45 = inttoptr i64 %44 to i64*
>   store i64 %tmp5_v13, i64* %45
>   store i32 16, i32* %cc_op_ptr
>   %tmp2_v14 = add i32 %tmp0_v9, -4
>   call void @__stl_mmu(i32 %tmp2_v14, i32 134513714, i32 1)
>   store i32 %tmp2_v14, i32* %esp_ptr
>   store i32 16, i32* %cc_op_ptr
>   %46 = add i64 %env_v1, 48
>   %47 = inttoptr i64 %46 to i32*
>   store i32 134513392, i32* %47
>   store i8 0, i8* inttoptr (i64 139967457636736 to i8*)
>   ret i64 139967006153600
4903,4942c2912
< declare i32 @check_hw_breakpoints(%struct.CPUX86State*, i32)
< 
< define void @helper_cpuid() nounwind uwtable {
<   %eax = alloca i32, align 4
<   %ebx = alloca i32, align 4
<   %ecx = alloca i32, align 4
<   %edx = alloca i32, align 4
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
< 
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 262144
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
< 
< ; <label>:10                                      ; preds = %5
<   call void @helper_vmexit(i32 114, i64 0) nounwind
<   unreachable
< 
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %12 = load i32* %11, align 4
<   %13 = icmp eq i32 %12, 4
<   br i1 %13, label %14, label %17
< 
< ; <label>:14                                      ; preds = %helper_svm_check_intercept_param.exit
<   %15 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 1
<   %16 = load i32* %15, align 4
<   call void @cpu_x86_cpuid(%struct.CPUX86State* %1, i32 4, i32 %16, i32* %eax, i32* %ebx, i32* %ecx, i32* %edx) nounwind
<   br label %18
< 
< ; <label>:17                                      ; preds = %helper_svm_check_intercept_param.exit
<   call void @cpu_x86_cpuid(%struct.CPUX86State* %1, i32 %12, i32 0, i32* %eax, i32* %ebx, i32* %ecx, i32* %edx) nounwind
<   br label %18
---
> declare void @helper_s2e_tcg_execution_handler(i64, i64)
4944,4961c2914,2947
< ; <label>:18                                      ; preds = %17, %14
<   %19 = load i32* %eax, align 4
<   %20 = load %struct.CPUX86State** @env, align 8
<   %21 = getelementptr inbounds %struct.CPUX86State* %20, i64 0, i32 0, i64 0
<   store i32 %19, i32* %21, align 4
<   %22 = load i32* %ebx, align 4
<   %23 = load %struct.CPUX86State** @env, align 8
<   %24 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 0, i64 3
<   store i32 %22, i32* %24, align 4
<   %25 = load i32* %ecx, align 4
<   %26 = load %struct.CPUX86State** @env, align 8
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 0, i64 1
<   store i32 %25, i32* %27, align 4
<   %28 = load i32* %edx, align 4
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 0, i64 2
<   store i32 %28, i32* %30, align 4
<   ret void
---
> define i64 @Func_80482f0(i64*) {
> entry:
>   %loc_16ptr = alloca i32
>   %loc_17ptr = alloca i32
>   %loc_18ptr = alloca i32
>   %loc_20ptr = alloca i32
>   %loc_21ptr = alloca i32
>   %1 = getelementptr i64* %0, i32 0
>   %env_v = load i64* %1
>   %2 = add i64 %env_v, 856
>   %3 = inttoptr i64 %2 to i64*
>   store i64 139967006153848, i64* %3
>   call void @helper_s2e_tcg_execution_handler(i64 139966614734800, i64 134513392)
>   %4 = getelementptr i64* %0, i32 0
>   %env_v1 = load i64* %4
>   %5 = add i64 %env_v1, 48
>   %6 = inttoptr i64 %5 to i32*
>   store i32 134513392, i32* %6
>   %7 = add i64 %env_v1, 317312
>   %8 = inttoptr i64 %7 to i64*
>   %tmp5_v = load i64* %8
>   %tmp5_v2 = add i64 %tmp5_v, 1
>   %9 = add i64 %env_v1, 317312
>   %10 = inttoptr i64 %9 to i64*
>   store i64 %tmp5_v2, i64* %10
>   %tmp0_v = call i32 @__ldl_mmu(i32 134520844, i32 1)
>   %11 = zext i32 %tmp0_v to i64
>   %12 = call i64 @tcg_llvm_fork_and_concretize(i64 %11, i64 0, i64 4294967295)
>   %13 = trunc i64 %12 to i32
>   %14 = add i64 %env_v1, 48
>   %15 = inttoptr i64 %14 to i32*
>   store i32 %13, i32* %15
>   call void @helper_s2e_tcg_execution_handler(i64 139966614020880, i64 134513392)
>   ret i64 0
4964,4970c2950,2996
< define void @helper_svm_check_intercept_param(i32 %type, i64 %param) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit, 0
<   br i1 %4, label %101, label %5, !prof !0
---
> define i64 @Func_80482f6(i64*) {
> entry:
>   %loc_16ptr = alloca i32
>   %loc_17ptr = alloca i32
>   %loc_18ptr = alloca i32
>   %loc_20ptr = alloca i32
>   %loc_21ptr = alloca i32
>   %1 = getelementptr i64* %0, i32 0
>   %env_v = load i64* %1
>   %2 = add i64 %env_v, 856
>   %3 = inttoptr i64 %2 to i64*
>   store i64 139967006154096, i64* %3
>   call void @helper_s2e_tcg_execution_handler(i64 139966615025120, i64 134513398)
>   %4 = getelementptr i64* %0, i32 0
>   %env_v1 = load i64* %4
>   %5 = add i64 %env_v1, 48
>   %6 = inttoptr i64 %5 to i32*
>   store i32 134513398, i32* %6
>   %7 = add i64 %env_v1, 317312
>   %8 = inttoptr i64 %7 to i64*
>   %tmp5_v = load i64* %8
>   %tmp5_v2 = add i64 %tmp5_v, 1
>   %9 = add i64 %env_v1, 317312
>   %10 = inttoptr i64 %9 to i64*
>   store i64 %tmp5_v2, i64* %10
>   %11 = add i64 %env_v1, 16
>   %esp_ptr = inttoptr i64 %11 to i32*
>   %esp_v = load i32* %esp_ptr
>   %tmp2_v = add i32 %esp_v, -4
>   call void @__stl_mmu(i32 %tmp2_v, i32 0, i32 1)
>   store i32 %tmp2_v, i32* %esp_ptr
>   %12 = add i64 %env_v1, 48
>   %13 = inttoptr i64 %12 to i32*
>   store i32 134513403, i32* %13
>   %14 = add i64 %env_v1, 317312
>   %15 = inttoptr i64 %14 to i64*
>   %tmp5_v3 = load i64* %15
>   %tmp5_v4 = add i64 %tmp5_v3, 1
>   %16 = add i64 %env_v1, 317312
>   %17 = inttoptr i64 %16 to i64*
>   store i64 %tmp5_v4, i64* %17
>   %18 = add i64 %env_v1, 48
>   %19 = inttoptr i64 %18 to i32*
>   store i32 134513376, i32* %19
>   store i8 0, i8* inttoptr (i64 139967457636736 to i8*)
>   ret i64 139967006154096
> }
4972,5041c2998,3049
< ; <label>:5                                       ; preds = %0
<   switch i32 %type, label %92 [
<     i32 0, label %6
<     i32 1, label %6
<     i32 2, label %6
<     i32 3, label %6
<     i32 4, label %6
<     i32 5, label %6
<     i32 6, label %6
<     i32 7, label %6
<     i32 8, label %6
<     i32 16, label %14
<     i32 17, label %14
<     i32 18, label %14
<     i32 19, label %14
<     i32 20, label %14
<     i32 21, label %14
<     i32 22, label %14
<     i32 23, label %14
<     i32 24, label %14
<     i32 32, label %23
<     i32 33, label %23
<     i32 34, label %23
<     i32 35, label %23
<     i32 36, label %23
<     i32 37, label %23
<     i32 38, label %23
<     i32 39, label %23
<     i32 48, label %32
<     i32 49, label %32
<     i32 50, label %32
<     i32 51, label %32
<     i32 52, label %32
<     i32 53, label %32
<     i32 54, label %32
<     i32 55, label %32
<     i32 64, label %41
<     i32 65, label %41
<     i32 66, label %41
<     i32 67, label %41
<     i32 68, label %41
<     i32 69, label %41
<     i32 70, label %41
<     i32 71, label %41
<     i32 72, label %41
<     i32 73, label %41
<     i32 74, label %41
<     i32 75, label %41
<     i32 76, label %41
<     i32 77, label %41
<     i32 78, label %41
<     i32 79, label %41
<     i32 80, label %41
<     i32 81, label %41
<     i32 82, label %41
<     i32 83, label %41
<     i32 84, label %41
<     i32 85, label %41
<     i32 86, label %41
<     i32 87, label %41
<     i32 88, label %41
<     i32 89, label %41
<     i32 90, label %41
<     i32 91, label %41
<     i32 92, label %41
<     i32 93, label %41
<     i32 94, label %41
<     i32 95, label %41
<     i32 124, label %49
<   ]
---
> define i64 @Func_80482e0(i64*) {
> entry:
>   %loc_16ptr = alloca i32
>   %loc_17ptr = alloca i32
>   %loc_18ptr = alloca i32
>   %loc_20ptr = alloca i32
>   %loc_21ptr = alloca i32
>   %1 = getelementptr i64* %0, i32 0
>   %env_v = load i64* %1
>   %2 = add i64 %env_v, 856
>   %3 = inttoptr i64 %2 to i64*
>   store i64 139967006154344, i64* %3
>   call void @helper_s2e_tcg_execution_handler(i64 139966614899008, i64 134513376)
>   %4 = getelementptr i64* %0, i32 0
>   %env_v1 = load i64* %4
>   %5 = add i64 %env_v1, 48
>   %6 = inttoptr i64 %5 to i32*
>   store i32 134513376, i32* %6
>   %7 = add i64 %env_v1, 317312
>   %8 = inttoptr i64 %7 to i64*
>   %tmp5_v = load i64* %8
>   %tmp5_v2 = add i64 %tmp5_v, 1
>   %9 = add i64 %env_v1, 317312
>   %10 = inttoptr i64 %9 to i64*
>   store i64 %tmp5_v2, i64* %10
>   %tmp0_v = call i32 @__ldl_mmu(i32 134520836, i32 1)
>   %11 = add i64 %env_v1, 16
>   %esp_ptr = inttoptr i64 %11 to i32*
>   %esp_v = load i32* %esp_ptr
>   %tmp2_v = add i32 %esp_v, -4
>   call void @__stl_mmu(i32 %tmp2_v, i32 %tmp0_v, i32 1)
>   store i32 %tmp2_v, i32* %esp_ptr
>   %12 = add i64 %env_v1, 48
>   %13 = inttoptr i64 %12 to i32*
>   store i32 134513382, i32* %13
>   %14 = add i64 %env_v1, 317312
>   %15 = inttoptr i64 %14 to i64*
>   %tmp5_v3 = load i64* %15
>   %tmp5_v4 = add i64 %tmp5_v3, 1
>   %16 = add i64 %env_v1, 317312
>   %17 = inttoptr i64 %16 to i64*
>   store i64 %tmp5_v4, i64* %17
>   %tmp0_v5 = call i32 @__ldl_mmu(i32 134520840, i32 1)
>   %18 = zext i32 %tmp0_v5 to i64
>   %19 = call i64 @tcg_llvm_fork_and_concretize(i64 %18, i64 0, i64 4294967295)
>   %20 = trunc i64 %19 to i32
>   %21 = add i64 %env_v1, 48
>   %22 = inttoptr i64 %21 to i32*
>   store i32 %20, i32* %22
>   call void @helper_s2e_tcg_execution_handler(i64 139966614898784, i64 134513382)
>   ret i64 0
> }
5043,5050c3051,3120
< ; <label>:6                                       ; preds = %5, %5, %5, %5, %5, %5, %5, %5, %5
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 42
<   %8 = load i16* %7, align 2
<   %9 = zext i16 %8 to i32
<   %10 = shl i32 1, %type
<   %11 = and i32 %9, %10
<   %12 = icmp eq i32 %11, 0
<   br i1 %12, label %101, label %13
---
> define i64 @Func_8048432(i64*) {
> entry:
>   %loc_17ptr = alloca i32
>   %loc_18ptr = alloca i32
>   %loc_19ptr = alloca i32
>   %loc_20ptr = alloca i32
>   %loc_21ptr = alloca i32
>   %1 = getelementptr i64* %0, i32 0
>   %env_v = load i64* %1
>   %2 = add i64 %env_v, 856
>   %3 = inttoptr i64 %2 to i64*
>   store i64 139967006431608, i64* %3
>   call void @helper_s2e_tcg_execution_handler(i64 139966614077312, i64 134513714)
>   %4 = getelementptr i64* %0, i32 0
>   %env_v1 = load i64* %4
>   %5 = add i64 %env_v1, 48
>   %6 = inttoptr i64 %5 to i32*
>   store i32 134513714, i32* %6
>   %7 = add i64 %env_v1, 317312
>   %8 = inttoptr i64 %7 to i64*
>   %tmp5_v = load i64* %8
>   %tmp5_v2 = add i64 %tmp5_v, 1
>   %9 = add i64 %env_v1, 317312
>   %10 = inttoptr i64 %9 to i64*
>   store i64 %tmp5_v2, i64* %10
>   %11 = add i64 %env_v1, 0
>   %eax_ptr = inttoptr i64 %11 to i32*
>   store i32 0, i32* %eax_ptr
>   %12 = add i64 %env_v1, 48
>   %13 = inttoptr i64 %12 to i32*
>   store i32 134513719, i32* %13
>   %14 = add i64 %env_v1, 317312
>   %15 = inttoptr i64 %14 to i64*
>   %tmp5_v3 = load i64* %15
>   %tmp5_v4 = add i64 %tmp5_v3, 1
>   %16 = add i64 %env_v1, 317312
>   %17 = inttoptr i64 %16 to i64*
>   store i64 %tmp5_v4, i64* %17
>   %18 = add i64 %env_v1, 20
>   %ebp_ptr = inttoptr i64 %18 to i32*
>   %ebp_v = load i32* %ebp_ptr
>   %19 = add i64 %env_v1, 16
>   %esp_ptr = inttoptr i64 %19 to i32*
>   store i32 %ebp_v, i32* %esp_ptr
>   %tmp0_v = call i32 @__ldl_mmu(i32 %ebp_v, i32 1)
>   store i32 %tmp0_v, i32* %ebp_ptr
>   %tmp4_v = add i32 %ebp_v, 4
>   store i32 %tmp4_v, i32* %esp_ptr
>   %20 = add i64 %env_v1, 48
>   %21 = inttoptr i64 %20 to i32*
>   store i32 134513720, i32* %21
>   %22 = add i64 %env_v1, 317312
>   %23 = inttoptr i64 %22 to i64*
>   %tmp5_v5 = load i64* %23
>   %tmp5_v6 = add i64 %tmp5_v5, 1
>   %24 = add i64 %env_v1, 317312
>   %25 = inttoptr i64 %24 to i64*
>   store i64 %tmp5_v6, i64* %25
>   %tmp0_v7 = call i32 @__ldl_mmu(i32 %tmp4_v, i32 1)
>   %tmp4_v8 = add i32 %tmp4_v, 4
>   store i32 %tmp4_v8, i32* %esp_ptr
>   %26 = zext i32 %tmp0_v7 to i64
>   %27 = call i64 @tcg_llvm_fork_and_concretize(i64 %26, i64 0, i64 4294967295)
>   %28 = trunc i64 %27 to i32
>   %29 = add i64 %env_v1, 48
>   %30 = inttoptr i64 %29 to i32*
>   store i32 %28, i32* %30
>   call void @helper_s2e_tcg_execution_handler(i64 139966614077200, i64 134513720)
>   ret i64 0
> }
5052,5054c3122,3137
< ; <label>:13                                      ; preds = %6
<   tail call void @helper_vmexit(i32 %type, i64 %param)
<   unreachable
---
> define internal void @float_raise(i8 signext %flags, %struct.float_status* %status) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca %struct.float_status*, align 4
>   store i8 %flags, i8* %1, align 1
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i8* %1, align 1
>   %4 = sext i8 %3 to i32
>   %5 = load %struct.float_status** %2, align 4
>   %6 = getelementptr inbounds %struct.float_status* %5, i32 0, i32 2
>   %7 = load i8* %6, align 1
>   %8 = sext i8 %7 to i32
>   %9 = or i32 %8, %4
>   %10 = trunc i32 %9 to i8
>   store i8 %10, i8* %6, align 1
>   ret void
> }
5056,5064c3139,3151
< ; <label>:14                                      ; preds = %5, %5, %5, %5, %5, %5, %5, %5, %5
<   %15 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 43
<   %16 = load i16* %15, align 2
<   %17 = zext i16 %16 to i32
<   %18 = add i32 %type, -16
<   %19 = shl i32 1, %18
<   %20 = and i32 %17, %19
<   %21 = icmp eq i32 %20, 0
<   br i1 %21, label %101, label %22
---
> define internal i32 @float16_is_quiet_nan(i16 zeroext %a_) nounwind {
>   %1 = alloca i16, align 2
>   %a = alloca i16, align 2
>   store i16 %a_, i16* %1, align 2
>   %2 = load i16* %1, align 2
>   store i16 %2, i16* %a, align 2
>   %3 = load i16* %a, align 2
>   %4 = zext i16 %3 to i32
>   %5 = and i32 %4, -32769
>   %6 = icmp sge i32 %5, 31872
>   %7 = zext i1 %6 to i32
>   ret i32 %7
> }
5066,5068c3153,3164
< ; <label>:22                                      ; preds = %14
<   tail call void @helper_vmexit(i32 %type, i64 %param)
<   unreachable
---
> define internal i32 @float16_is_signaling_nan(i16 zeroext %a_) nounwind {
>   %1 = alloca i16, align 2
>   %a = alloca i16, align 2
>   store i16 %a_, i16* %1, align 2
>   %2 = load i16* %1, align 2
>   store i16 %2, i16* %a, align 2
>   %3 = load i16* %a, align 2
>   %4 = zext i16 %3 to i32
>   %5 = ashr i32 %4, 9
>   %6 = and i32 %5, 63
>   %7 = icmp eq i32 %6, 62
>   br i1 %7, label %8, label %13
5070,5078c3166,3177
< ; <label>:23                                      ; preds = %5, %5, %5, %5, %5, %5, %5, %5
<   %24 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 44
<   %25 = load i16* %24, align 2
<   %26 = zext i16 %25 to i32
<   %27 = add i32 %type, -32
<   %28 = shl i32 1, %27
<   %29 = and i32 %26, %28
<   %30 = icmp eq i32 %29, 0
<   br i1 %30, label %101, label %31
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i16* %a, align 2
>   %10 = zext i16 %9 to i32
>   %11 = and i32 %10, 511
>   %12 = icmp ne i32 %11, 0
>   br label %13
> 
> ; <label>:13                                      ; preds = %8, %0
>   %14 = phi i1 [ false, %0 ], [ %12, %8 ]
>   %15 = zext i1 %14 to i32
>   ret i32 %15
> }
5080,5082c3179,3187
< ; <label>:31                                      ; preds = %23
<   tail call void @helper_vmexit(i32 %type, i64 %param)
<   unreachable
---
> define internal zeroext i16 @float16_maybe_silence_nan(i16 zeroext %a_) nounwind {
>   %1 = alloca i16, align 2
>   %2 = alloca i16, align 2
>   %a = alloca i16, align 2
>   store i16 %a_, i16* %2, align 2
>   %3 = load i16* %2, align 2
>   %4 = call i32 @float16_is_signaling_nan(i16 zeroext %3)
>   %5 = icmp ne i32 %4, 0
>   br i1 %5, label %6, label %13
5084,5092c3189,3199
< ; <label>:32                                      ; preds = %5, %5, %5, %5, %5, %5, %5, %5
<   %33 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 45
<   %34 = load i16* %33, align 2
<   %35 = zext i16 %34 to i32
<   %36 = add i32 %type, -48
<   %37 = shl i32 1, %36
<   %38 = and i32 %35, %37
<   %39 = icmp eq i32 %38, 0
<   br i1 %39, label %101, label %40
---
> ; <label>:6                                       ; preds = %0
>   %7 = load i16* %2, align 2
>   store i16 %7, i16* %a, align 2
>   %8 = load i16* %a, align 2
>   %9 = zext i16 %8 to i32
>   %10 = or i32 %9, 512
>   %11 = trunc i32 %10 to i16
>   store i16 %11, i16* %a, align 2
>   %12 = load i16* %a, align 2
>   store i16 %12, i16* %1
>   br label %15
5094,5096c3201,3204
< ; <label>:40                                      ; preds = %32
<   tail call void @helper_vmexit(i32 %type, i64 %param)
<   unreachable
---
> ; <label>:13                                      ; preds = %0
>   %14 = load i16* %2, align 2
>   store i16 %14, i16* %1
>   br label %15
5098,5105c3206,3209
< ; <label>:41                                      ; preds = %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5, %5
<   %42 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 46
<   %43 = load i32* %42, align 4
<   %44 = add i32 %type, -64
<   %45 = shl i32 1, %44
<   %46 = and i32 %43, %45
<   %47 = icmp eq i32 %46, 0
<   br i1 %47, label %101, label %48
---
> ; <label>:15                                      ; preds = %13, %6
>   %16 = load i16* %1
>   ret i16 %16
> }
5107,5109c3211,3222
< ; <label>:48                                      ; preds = %41
<   tail call void @helper_vmexit(i32 %type, i64 %param)
<   unreachable
---
> define internal i32 @float32_is_quiet_nan(i32 %a_) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca i32, align 4
>   store i32 %a_, i32* %1, align 4
>   %2 = load i32* %1, align 4
>   store i32 %2, i32* %a, align 4
>   %3 = load i32* %a, align 4
>   %4 = shl i32 %3, 1
>   %5 = icmp ule i32 -8388608, %4
>   %6 = zext i1 %5 to i32
>   ret i32 %6
> }
5111,5134c3224,3234
< ; <label>:49                                      ; preds = %5
<   %50 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %51 = load i64* %50, align 8
<   %52 = and i64 %51, 268435456
<   %53 = icmp eq i64 %52, 0
<   br i1 %53, label %101, label %54
< 
< ; <label>:54                                      ; preds = %49
<   %55 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 39
<   %56 = load i64* %55, align 8
<   %57 = add i64 %56, 72
<   %58 = tail call i64 @ldq_phys(i64 %57) nounwind
<   %59 = load %struct.CPUX86State** @env, align 8
<   %60 = getelementptr inbounds %struct.CPUX86State* %59, i64 0, i32 0, i64 1
<   %61 = load i32* %60, align 4
<   %62 = add i32 %61, 1073676288
<   %63 = icmp ult i32 %62, 8192
<   br i1 %63, label %77, label %74
< 
< ; <label>:64                                      ; preds = %68
<   %65 = shl i32 %61, 1
<   %66 = lshr i32 %61, 2
<   %67 = and i32 %66, 536870911
<   br label %82
---
> define internal i32 @float32_is_signaling_nan(i32 %a_) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca i32, align 4
>   store i32 %a_, i32* %1, align 4
>   %2 = load i32* %1, align 4
>   store i32 %2, i32* %a, align 4
>   %3 = load i32* %a, align 4
>   %4 = lshr i32 %3, 22
>   %5 = and i32 %4, 511
>   %6 = icmp eq i32 %5, 510
>   br i1 %6, label %7, label %11
5136,5138c3236,3240
< ; <label>:68                                      ; preds = %74
<   %69 = icmp ult i32 %61, 8192
<   br i1 %69, label %64, label %81
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i32* %a, align 4
>   %9 = and i32 %8, 4194303
>   %10 = icmp ne i32 %9, 0
>   br label %11
5140,5144c3242,3246
< ; <label>:70                                      ; preds = %74
<   %71 = shl i32 %61, 1
<   %72 = add i32 %71, -2147467264
<   %73 = lshr i32 %72, 3
<   br label %82
---
> ; <label>:11                                      ; preds = %7, %0
>   %12 = phi i1 [ false, %0 ], [ %10, %7 ]
>   %13 = zext i1 %12 to i32
>   ret i32 %13
> }
5146,5149c3248,3256
< ; <label>:74                                      ; preds = %54
<   %75 = add i32 %61, 1073741824
<   %76 = icmp ult i32 %75, 8192
<   br i1 %76, label %70, label %68
---
> define internal i32 @float32_maybe_silence_nan(i32 %a_) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %a = alloca i32, align 4
>   store i32 %a_, i32* %2, align 4
>   %3 = load i32* %2, align 4
>   %4 = call i32 @float32_is_signaling_nan(i32 %3)
>   %5 = icmp ne i32 %4, 0
>   br i1 %5, label %6, label %11
5151,5155c3258,3266
< ; <label>:77                                      ; preds = %54
<   %78 = shl i32 %61, 1
<   %79 = add i32 %78, 2147385344
<   %80 = lshr i32 %79, 3
<   br label %82
---
> ; <label>:6                                       ; preds = %0
>   %7 = load i32* %2, align 4
>   store i32 %7, i32* %a, align 4
>   %8 = load i32* %a, align 4
>   %9 = or i32 %8, 4194304
>   store i32 %9, i32* %a, align 4
>   %10 = load i32* %a, align 4
>   store i32 %10, i32* %1
>   br label %13
5157,5159c3268,3271
< ; <label>:81                                      ; preds = %68
<   tail call void @helper_vmexit(i32 124, i64 %param)
<   unreachable
---
> ; <label>:11                                      ; preds = %0
>   %12 = load i32* %2, align 4
>   store i32 %12, i32* %1
>   br label %13
5161,5173c3273,3276
< ; <label>:82                                      ; preds = %77, %70, %64
<   %t0.0.in = phi i32 [ %79, %77 ], [ %72, %70 ], [ %65, %64 ]
<   %t1.0 = phi i32 [ %80, %77 ], [ %73, %70 ], [ %67, %64 ]
<   %t0.0 = and i32 %t0.0.in, 6
<   %83 = zext i32 %t1.0 to i64
<   %84 = add i64 %83, %58
<   %85 = tail call i32 @ldub_phys(i64 %84) nounwind
<   %86 = trunc i64 %param to i32
<   %87 = shl i32 1, %86
<   %88 = shl i32 %87, %t0.0
<   %89 = and i32 %85, %88
<   %90 = icmp eq i32 %89, 0
<   br i1 %90, label %101, label %91
---
> ; <label>:13                                      ; preds = %11, %6
>   %14 = load i32* %1
>   ret i32 %14
> }
5175,5177c3278,3289
< ; <label>:91                                      ; preds = %82
<   tail call void @helper_vmexit(i32 124, i64 %param)
<   unreachable
---
> define internal i32 @float64_is_quiet_nan(i64 %a_) nounwind {
>   %1 = alloca i64, align 8
>   %a = alloca i64, align 8
>   store i64 %a_, i64* %1, align 8
>   %2 = load i64* %1, align 8
>   store i64 %2, i64* %a, align 8
>   %3 = load i64* %a, align 8
>   %4 = shl i64 %3, 1
>   %5 = icmp ule i64 -4503599627370496, %4
>   %6 = zext i1 %5 to i32
>   ret i32 %6
> }
5179,5187c3291,3301
< ; <label>:92                                      ; preds = %5
<   %93 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %94 = load i64* %93, align 8
<   %95 = add i32 %type, -96
<   %96 = zext i32 %95 to i64
<   %97 = shl i64 1, %96
<   %98 = and i64 %94, %97
<   %99 = icmp eq i64 %98, 0
<   br i1 %99, label %101, label %100
---
> define internal i32 @float64_is_signaling_nan(i64 %a_) nounwind {
>   %1 = alloca i64, align 8
>   %a = alloca i64, align 8
>   store i64 %a_, i64* %1, align 8
>   %2 = load i64* %1, align 8
>   store i64 %2, i64* %a, align 8
>   %3 = load i64* %a, align 8
>   %4 = lshr i64 %3, 51
>   %5 = and i64 %4, 4095
>   %6 = icmp eq i64 %5, 4094
>   br i1 %6, label %7, label %11
5189,5191c3303,3307
< ; <label>:100                                     ; preds = %92
<   tail call void @helper_vmexit(i32 %type, i64 %param)
<   unreachable
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i64* %a, align 8
>   %9 = and i64 %8, 2251799813685247
>   %10 = icmp ne i64 %9, 0
>   br label %11
5193,5194c3309,3312
< ; <label>:101                                     ; preds = %92, %82, %49, %41, %32, %23, %14, %6, %0
<   ret void
---
> ; <label>:11                                      ; preds = %7, %0
>   %12 = phi i1 [ false, %0 ], [ %10, %7 ]
>   %13 = zext i1 %12 to i32
>   ret i32 %13
5197,5216c3315,3323
< declare void @cpu_x86_cpuid(%struct.CPUX86State*, i32, i32, i32*, i32*, i32*, i32*)
< 
< define void @helper_enter_level(i32 %level, i32 %data32, i32 %t1) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 2, i32 3
<   %3 = load i32* %2, align 4
<   %4 = lshr i32 %3, 6
<   %5 = and i32 %4, 65536
<   %6 = xor i32 %5, 65536
<   %7 = add i32 %6, -1
<   %8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 2, i32 1
<   %9 = load i32* %8, align 4
<   %10 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 5
<   %11 = load i32* %10, align 4
<   %12 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 4
<   %13 = load i32* %12, align 4
<   %14 = icmp eq i32 %data32, 0
<   %15 = add nsw i32 %level, -1
<   %16 = icmp eq i32 %15, 0
<   br i1 %14, label %37, label %17
---
> define internal i64 @float64_maybe_silence_nan(i64 %a_) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %a = alloca i64, align 8
>   store i64 %a_, i64* %2, align 8
>   %3 = load i64* %2, align 8
>   %4 = call i32 @float64_is_signaling_nan(i64 %3)
>   %5 = icmp ne i32 %4, 0
>   br i1 %5, label %6, label %11
5218,5220c3325,3333
< ; <label>:17                                      ; preds = %0
<   %18 = add i32 %13, -8
<   br i1 %16, label %34, label %.lr.ph28
---
> ; <label>:6                                       ; preds = %0
>   %7 = load i64* %2, align 8
>   store i64 %7, i64* %a, align 8
>   %8 = load i64* %a, align 8
>   %9 = or i64 %8, 2251799813685248
>   store i64 %9, i64* %a, align 8
>   %10 = load i64* %a, align 8
>   store i64 %10, i64* %1
>   br label %13
5222,5224c3335,3351
< .lr.ph28:                                         ; preds = %17
<   %19 = shl i32 %level, 2
<   br label %20
---
> ; <label>:11                                      ; preds = %0
>   %12 = load i64* %2, align 8
>   store i64 %12, i64* %1
>   br label %13
> 
> ; <label>:13                                      ; preds = %11, %6
>   %14 = load i64* %1
>   ret i64 %14
> }
> 
> define internal i32 @floatx80_is_quiet_nan(%struct.floatx80* byval align 4 %a) nounwind {
>   %1 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %2 = load i16* %1, align 1
>   %3 = zext i16 %2 to i32
>   %4 = and i32 %3, 32767
>   %5 = icmp eq i32 %4, 32767
>   br i1 %5, label %6, label %11
5226,5240c3353,3358
< ; <label>:20                                      ; preds = %20, %.lr.ph28
<   %21 = phi i32 [ %18, %.lr.ph28 ], [ %31, %20 ]
<   %22 = phi i32 [ %15, %.lr.ph28 ], [ %29, %20 ]
<   %ebp.026 = phi i32 [ %11, %.lr.ph28 ], [ %23, %20 ]
<   %23 = add i32 %ebp.026, -4
<   %24 = and i32 %21, %7
<   %25 = add i32 %24, %9
<   %26 = and i32 %23, %7
<   %27 = add i32 %26, %9
<   %28 = tail call fastcc i32 @ldl_data(i32 %27)
<   tail call fastcc void @stl_data(i32 %25, i32 %28)
<   %29 = add nsw i32 %22, -1
<   %30 = icmp eq i32 %29, 0
<   %31 = add i32 %21, -4
<   br i1 %30, label %._crit_edge29, label %20
---
> ; <label>:6                                       ; preds = %0
>   %7 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %8 = load i64* %7, align 1
>   %9 = shl i64 %8, 1
>   %10 = icmp ule i64 -9223372036854775808, %9
>   br label %11
5242,5245c3360,3377
< ._crit_edge29:                                    ; preds = %20
<   %32 = sub i32 -4, %19
<   %33 = add i32 %32, %13
<   br label %34
---
> ; <label>:11                                      ; preds = %6, %0
>   %12 = phi i1 [ false, %0 ], [ %10, %6 ]
>   %13 = zext i1 %12 to i32
>   ret i32 %13
> }
> 
> define internal i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %a) nounwind {
>   %aLow = alloca i64, align 8
>   %1 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %2 = load i64* %1, align 1
>   %3 = and i64 %2, -4611686018427387905
>   store i64 %3, i64* %aLow, align 8
>   %4 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %5 = load i16* %4, align 1
>   %6 = zext i16 %5 to i32
>   %7 = and i32 %6, 32767
>   %8 = icmp eq i32 %7, 32767
>   br i1 %8, label %9, label %18
5247,5252c3379,3383
< ; <label>:34                                      ; preds = %._crit_edge29, %17
<   %.lcssa25 = phi i32 [ %33, %._crit_edge29 ], [ %18, %17 ]
<   %35 = and i32 %.lcssa25, %7
<   %36 = add i32 %35, %9
<   tail call fastcc void @stl_data(i32 %36, i32 %t1)
<   br label %57
---
> ; <label>:9                                       ; preds = %0
>   %10 = load i64* %aLow, align 8
>   %11 = shl i64 %10, 1
>   %12 = icmp ne i64 %11, 0
>   br i1 %12, label %13, label %18
5254,5256c3385,3390
< ; <label>:37                                      ; preds = %0
<   %38 = add i32 %13, -4
<   br i1 %16, label %54, label %.lr.ph
---
> ; <label>:13                                      ; preds = %9
>   %14 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %15 = load i64* %14, align 1
>   %16 = load i64* %aLow, align 8
>   %17 = icmp eq i64 %15, %16
>   br label %18
5258,5260c3392,3396
< .lr.ph:                                           ; preds = %37
<   %39 = shl i32 %level, 1
<   br label %40
---
> ; <label>:18                                      ; preds = %13, %9, %0
>   %19 = phi i1 [ false, %9 ], [ false, %0 ], [ %17, %13 ]
>   %20 = zext i1 %19 to i32
>   ret i32 %20
> }
5262,5276c3398,3401
< ; <label>:40                                      ; preds = %40, %.lr.ph
<   %41 = phi i32 [ %38, %.lr.ph ], [ %51, %40 ]
<   %42 = phi i32 [ %15, %.lr.ph ], [ %49, %40 ]
<   %ebp.124 = phi i32 [ %11, %.lr.ph ], [ %43, %40 ]
<   %43 = add i32 %ebp.124, -2
<   %44 = and i32 %41, %7
<   %45 = add i32 %44, %9
<   %46 = and i32 %43, %7
<   %47 = add i32 %46, %9
<   %48 = tail call fastcc i32 @lduw_data(i32 %47)
<   tail call fastcc void @stw_data(i32 %45, i32 %48)
<   %49 = add nsw i32 %42, -1
<   %50 = icmp eq i32 %49, 0
<   %51 = add i32 %41, -2
<   br i1 %50, label %._crit_edge, label %40
---
> define internal void @floatx80_maybe_silence_nan(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a) nounwind {
>   %1 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %a)
>   %2 = icmp ne i32 %1, 0
>   br i1 %2, label %3, label %9
5278,5281c3403,3411
< ._crit_edge:                                      ; preds = %40
<   %52 = sub i32 -2, %39
<   %53 = add i32 %52, %13
<   br label %54
---
> ; <label>:3                                       ; preds = %0
>   %4 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %5 = load i64* %4, align 1
>   %6 = or i64 %5, -4611686018427387904
>   store i64 %6, i64* %4, align 1
>   %7 = bitcast %struct.floatx80* %agg.result to i8*
>   %8 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %7, i8* %8, i32 10, i32 1, i1 false)
>   br label %12
5283,5288c3413,3417
< ; <label>:54                                      ; preds = %._crit_edge, %37
<   %.lcssa = phi i32 [ %53, %._crit_edge ], [ %38, %37 ]
<   %55 = and i32 %.lcssa, %7
<   %56 = add i32 %55, %9
<   tail call fastcc void @stw_data(i32 %56, i32 %t1)
<   br label %57
---
> ; <label>:9                                       ; preds = %0
>   %10 = bitcast %struct.floatx80* %agg.result to i8*
>   %11 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %10, i8* %11, i32 10, i32 1, i1 false)
>   br label %12
5290c3419
< ; <label>:57                                      ; preds = %54, %34
---
> ; <label>:12                                      ; preds = %9, %3
5294,5302c3423
< define internal fastcc void @stl_data(i32 %ptr, i32 %v) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
< 
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind
5304,5327c3425,3435
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = icmp eq i32 %17, 3
<   %19 = zext i1 %18 to i64
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 1
<   %21 = load i32* %20, align 4
<   %22 = and i32 %8, -4093
<   %23 = icmp eq i32 %21, %22
<   br i1 %23, label %26, label %24, !prof !0
< 
< ; <label>:24                                      ; preds = %6
<   %25 = zext i1 %18 to i32
<   tail call void @__stl_mmu(i32 %8, i32 %v, i32 %25)
<   br label %33
---
> define internal i32 @float128_is_quiet_nan(i64 %a.0, i64 %a.1) nounwind {
>   %a = alloca %struct.float128, align 4
>   %1 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %1, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %4 = load i64* %3, align 4
>   %5 = shl i64 %4, 1
>   %6 = icmp ule i64 -562949953421312, %5
>   br i1 %6, label %7, label %18
5329,5338c3437,3448
< ; <label>:26                                      ; preds = %6
<   %27 = and i64 %7, 4294967295
<   %28 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 3
<   %29 = load i64* %28, align 8
<   %30 = add i64 %29, %27
<   %31 = inttoptr i64 %30 to i32*
<   store i32 %v, i32* %31, align 4
<   %32 = zext i32 %v to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %27, i64 %30, i64 %32, i32 32, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %33
---
> ; <label>:7                                       ; preds = %0
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %9 = load i64* %8, align 4
>   %10 = icmp ne i64 %9, 0
>   br i1 %10, label %16, label %11
> 
> ; <label>:11                                      ; preds = %7
>   %12 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %13 = load i64* %12, align 4
>   %14 = and i64 %13, 281474976710655
>   %15 = icmp ne i64 %14, 0
>   br label %16
5340,5342c3450,3452
< ; <label>:33                                      ; preds = %26, %24
<   ret void
< }
---
> ; <label>:16                                      ; preds = %11, %7
>   %17 = phi i1 [ true, %7 ], [ %15, %11 ]
>   br label %18
5344,5348c3454,3471
< define internal fastcc i32 @ldl_data(i32 %ptr) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:18                                      ; preds = %16, %0
>   %19 = phi i1 [ false, %0 ], [ %17, %16 ]
>   %20 = zext i1 %19 to i32
>   ret i32 %20
> }
> 
> define internal i32 @float128_is_signaling_nan(i64 %a.0, i64 %a.1) nounwind {
>   %a = alloca %struct.float128, align 4
>   %1 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %1, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %4 = load i64* %3, align 4
>   %5 = lshr i64 %4, 47
>   %6 = and i64 %5, 65535
>   %7 = icmp eq i64 %6, 65534
>   br i1 %7, label %8, label %19
5350,5352c3473,3477
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:8                                       ; preds = %0
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %10 = load i64* %9, align 4
>   %11 = icmp ne i64 %10, 0
>   br i1 %11, label %17, label %12
5354,5377c3479,3484
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = icmp eq i32 %17, 3
<   %19 = zext i1 %18 to i64
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 0
<   %21 = load i32* %20, align 4
<   %22 = and i32 %8, -4093
<   %23 = icmp eq i32 %21, %22
<   br i1 %23, label %27, label %24, !prof !0
< 
< ; <label>:24                                      ; preds = %6
<   %25 = zext i1 %18 to i32
<   %26 = tail call i32 @__ldl_mmu(i32 %8, i32 %25)
<   br label %35
---
> ; <label>:12                                      ; preds = %8
>   %13 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = and i64 %14, 140737488355327
>   %16 = icmp ne i64 %15, 0
>   br label %17
5379,5388c3486,3488
< ; <label>:27                                      ; preds = %6
<   %28 = and i64 %7, 4294967295
<   %29 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 3
<   %30 = load i64* %29, align 8
<   %31 = add i64 %30, %28
<   %32 = inttoptr i64 %31 to i32*
<   %33 = load i32* %32, align 4
<   %34 = zext i32 %33 to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %28, i64 %31, i64 %34, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %35
---
> ; <label>:17                                      ; preds = %12, %8
>   %18 = phi i1 [ true, %8 ], [ %16, %12 ]
>   br label %19
5390,5393c3490,3508
< ; <label>:35                                      ; preds = %27, %24
<   %res.0 = phi i32 [ %26, %24 ], [ %33, %27 ]
<   ret i32 %res.0
< }
---
> ; <label>:19                                      ; preds = %17, %0
>   %20 = phi i1 [ false, %0 ], [ %18, %17 ]
>   %21 = zext i1 %20 to i32
>   ret i32 %21
> }
> 
> define internal void @float128_maybe_silence_nan(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1) nounwind {
>   %a = alloca %struct.float128, align 4
>   %1 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %1, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %4 = load i64* %3, align 4
>   %5 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %6 = load i64* %5, align 4
>   %7 = call i32 @float128_is_signaling_nan(i64 %4, i64 %6)
>   %8 = icmp ne i32 %7, 0
>   br i1 %8, label %9, label %15
5395,5399c3510,3518
< define internal fastcc void @stw_data(i32 %ptr, i32 %v) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:9                                       ; preds = %0
>   %10 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %11 = load i64* %10, align 4
>   %12 = or i64 %11, 140737488355328
>   store i64 %12, i64* %10, align 4
>   %13 = bitcast %struct.float128* %agg.result to i8*
>   %14 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %13, i8* %14, i32 16, i32 4, i1 false)
>   br label %18
5401,5403c3520,3524
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:15                                      ; preds = %0
>   %16 = bitcast %struct.float128* %agg.result to i8*
>   %17 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %16, i8* %17, i32 16, i32 4, i1 false)
>   br label %18
5405,5429c3526,3528
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = icmp eq i32 %17, 3
<   %19 = zext i1 %18 to i64
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 1
<   %21 = load i32* %20, align 4
<   %22 = and i32 %8, -4095
<   %23 = icmp eq i32 %21, %22
<   br i1 %23, label %27, label %24, !prof !0
< 
< ; <label>:24                                      ; preds = %6
<   %25 = zext i1 %18 to i32
<   %26 = trunc i32 %v to i16
<   tail call void @__stw_mmu(i32 %8, i16 zeroext %26, i32 %25)
<   br label %35
---
> ; <label>:18                                      ; preds = %15, %9
>   ret void
> }
5431,5441c3530,3541
< ; <label>:27                                      ; preds = %6
<   %28 = and i64 %7, 4294967295
<   %29 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 3
<   %30 = load i64* %29, align 8
<   %31 = add i64 %30, %28
<   %32 = trunc i32 %v to i16
<   %33 = inttoptr i64 %31 to i16*
<   store i16 %32, i16* %33, align 2
<   %34 = zext i32 %v to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %28, i64 %31, i64 %34, i32 32, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %35
---
> define internal void @set_float_rounding_mode(i32 %val, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   store i32 %val, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = trunc i32 %3 to i8
>   %5 = load %struct.float_status** %2, align 4
>   %6 = getelementptr inbounds %struct.float_status* %5, i32 0, i32 1
>   store i8 %4, i8* %6, align 1
>   ret void
> }
5443c3543,3552
< ; <label>:35                                      ; preds = %27, %24
---
> define internal void @set_float_exception_flags(i32 %val, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   store i32 %val, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = trunc i32 %3 to i8
>   %5 = load %struct.float_status** %2, align 4
>   %6 = getelementptr inbounds %struct.float_status* %5, i32 0, i32 2
>   store i8 %4, i8* %6, align 1
5447,5451c3556,3567
< define internal fastcc i32 @lduw_data(i32 %ptr) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> define internal void @set_floatx80_rounding_precision(i32 %val, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   store i32 %val, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = trunc i32 %3 to i8
>   %5 = load %struct.float_status** %2, align 4
>   %6 = getelementptr inbounds %struct.float_status* %5, i32 0, i32 3
>   store i8 %4, i8* %6, align 1
>   ret void
> }
5453,5455c3569,3578
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> define internal i32 @int32_to_float32(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %zSign = alloca i8, align 1
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = icmp eq i32 %4, 0
>   br i1 %5, label %6, label %7
5457,5480c3580,3582
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = icmp eq i32 %17, 3
<   %19 = zext i1 %18 to i64
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 0
<   %21 = load i32* %20, align 4
<   %22 = and i32 %8, -4095
<   %23 = icmp eq i32 %21, %22
<   br i1 %23, label %27, label %24, !prof !0
< 
< ; <label>:24                                      ; preds = %6
<   %25 = zext i1 %18 to i32
<   %26 = tail call zeroext i16 @__ldw_mmu(i32 %8, i32 %25)
<   br label %35
---
> ; <label>:6                                       ; preds = %0
>   store i32 0, i32* %1
>   br label %30
5482,5491c3584,3587
< ; <label>:27                                      ; preds = %6
<   %28 = and i64 %7, 4294967295
<   %29 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 3
<   %30 = load i64* %29, align 8
<   %31 = add i64 %30, %28
<   %32 = inttoptr i64 %31 to i16*
<   %33 = load i16* %32, align 2
<   %34 = zext i16 %33 to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %28, i64 %31, i64 %34, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %35
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i32* %2, align 4
>   %9 = icmp eq i32 %8, -2147483648
>   br i1 %9, label %10, label %12
5493,5497c3589,3592
< ; <label>:35                                      ; preds = %27, %24
<   %res.0.in = phi i16 [ %26, %24 ], [ %33, %27 ]
<   %res.0 = zext i16 %res.0.in to i32
<   ret i32 %res.0
< }
---
> ; <label>:10                                      ; preds = %7
>   %11 = call i32 @packFloat32(i8 zeroext 1, i32 158, i32 0)
>   store i32 %11, i32* %1
>   br label %30
5499,5503c3594,3604
< define void @helper_lldt(i32 %selector) nounwind uwtable {
<   %1 = and i32 %selector, 65535
<   %2 = and i32 %selector, 65532
<   %3 = icmp eq i32 %2, 0
<   br i1 %3, label %4, label %9
---
> ; <label>:12                                      ; preds = %7
>   %13 = load i32* %2, align 4
>   %14 = icmp slt i32 %13, 0
>   %15 = zext i1 %14 to i32
>   %16 = trunc i32 %15 to i8
>   store i8 %16, i8* %zSign, align 1
>   %17 = load i8* %zSign, align 1
>   %18 = load i8* %zSign, align 1
>   %19 = zext i8 %18 to i32
>   %20 = icmp ne i32 %19, 0
>   br i1 %20, label %21, label %24
5505,5512c3606,3609
< ; <label>:4                                       ; preds = %0
<   %5 = load %struct.CPUX86State** @env, align 8
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 11, i32 1
<   store i32 0, i32* %6, align 4
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 11, i32 2
<   store i32 0, i32* %8, align 4
<   br label %54
---
> ; <label>:21                                      ; preds = %12
>   %22 = load i32* %2, align 4
>   %23 = sub nsw i32 0, %22
>   br label %26
5514,5517c3611,3613
< ; <label>:9                                       ; preds = %0
<   %10 = and i32 %selector, 4
<   %11 = icmp eq i32 %10, 0
<   br i1 %11, label %13, label %12
---
> ; <label>:24                                      ; preds = %12
>   %25 = load i32* %2, align 4
>   br label %26
5519,5521c3615,3620
< ; <label>:12                                      ; preds = %9
<   tail call fastcc void @raise_exception_err(i32 13, i32 %2) noreturn
<   unreachable
---
> ; <label>:26                                      ; preds = %24, %21
>   %27 = phi i32 [ %23, %21 ], [ %25, %24 ]
>   %28 = load %struct.float_status** %3, align 4
>   %29 = call i32 @normalizeRoundAndPackFloat32(i8 zeroext %17, i32 156, i32 %27, %struct.float_status* %28)
>   store i32 %29, i32* %1
>   br label %30
5523,5530c3622,3625
< ; <label>:13                                      ; preds = %9
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = and i32 %selector, 65528
<   %16 = or i32 %15, 7
<   %17 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 13, i32 2
<   %18 = load i32* %17, align 4
<   %19 = icmp ugt i32 %16, %18
<   br i1 %19, label %20, label %21
---
> ; <label>:30                                      ; preds = %26, %10, %6
>   %31 = load i32* %1
>   ret i32 %31
> }
5532,5534c3627,3643
< ; <label>:20                                      ; preds = %13
<   tail call fastcc void @raise_exception_err(i32 13, i32 %2) noreturn
<   unreachable
---
> define internal i32 @packFloat32(i8 zeroext %zSign, i32 %zExp, i32 %zSig) nounwind inlinehint {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   store i8 %zSign, i8* %1, align 1
>   store i32 %zExp, i32* %2, align 4
>   store i32 %zSig, i32* %3, align 4
>   %4 = load i8* %1, align 1
>   %5 = zext i8 %4 to i32
>   %6 = shl i32 %5, 31
>   %7 = load i32* %2, align 4
>   %8 = shl i32 %7, 23
>   %9 = add i32 %6, %8
>   %10 = load i32* %3, align 4
>   %11 = add i32 %9, %10
>   ret i32 %11
> }
5536,5545c3645,3673
< ; <label>:21                                      ; preds = %13
<   %22 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 13, i32 1
<   %23 = load i32* %22, align 4
<   %24 = add i32 %23, %15
<   %25 = tail call fastcc i32 @ldl_kernel(i32 %24)
<   %26 = add i32 %24, 4
<   %27 = tail call fastcc i32 @ldl_kernel(i32 %26)
<   %28 = and i32 %27, 7936
<   %29 = icmp eq i32 %28, 512
<   br i1 %29, label %31, label %30
---
> define internal i32 @normalizeRoundAndPackFloat32(i8 zeroext %zSign, i32 %zExp, i32 %zSig, %struct.float_status* %status) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %shiftCount = alloca i8, align 1
>   store i8 %zSign, i8* %1, align 1
>   store i32 %zExp, i32* %2, align 4
>   store i32 %zSig, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %3, align 4
>   %6 = call signext i8 @countLeadingZeros32(i32 %5)
>   %7 = sext i8 %6 to i32
>   %8 = sub nsw i32 %7, 1
>   %9 = trunc i32 %8 to i8
>   store i8 %9, i8* %shiftCount, align 1
>   %10 = load i8* %1, align 1
>   %11 = load i32* %2, align 4
>   %12 = load i8* %shiftCount, align 1
>   %13 = sext i8 %12 to i32
>   %14 = sub nsw i32 %11, %13
>   %15 = load i32* %3, align 4
>   %16 = load i8* %shiftCount, align 1
>   %17 = sext i8 %16 to i32
>   %18 = shl i32 %15, %17
>   %19 = load %struct.float_status** %4, align 4
>   %20 = call i32 @roundAndPackFloat32(i8 zeroext %10, i32 %14, i32 %18, %struct.float_status* %19)
>   ret i32 %20
> }
5547,5549c3675,3687
< ; <label>:30                                      ; preds = %21
<   tail call fastcc void @raise_exception_err(i32 13, i32 %2) noreturn
<   unreachable
---
> define internal i64 @int32_to_float64(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %zSign = alloca i8, align 1
>   %absA = alloca i32, align 4
>   %shiftCount = alloca i8, align 1
>   %zSig = alloca i64, align 8
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = icmp eq i32 %4, 0
>   br i1 %5, label %6, label %7
5551,5554c3689,3691
< ; <label>:31                                      ; preds = %21
<   %32 = and i32 %27, 32768
<   %33 = icmp eq i32 %32, 0
<   br i1 %33, label %34, label %35
---
> ; <label>:6                                       ; preds = %0
>   store i64 0, i64* %1
>   br label %39
5556,5558c3693,3707
< ; <label>:34                                      ; preds = %31
<   tail call fastcc void @raise_exception_err(i32 11, i32 %2) noreturn
<   unreachable
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i32* %2, align 4
>   %9 = icmp slt i32 %8, 0
>   %10 = zext i1 %9 to i32
>   %11 = trunc i32 %10 to i8
>   store i8 %11, i8* %zSign, align 1
>   %12 = load i8* %zSign, align 1
>   %13 = zext i8 %12 to i32
>   %14 = icmp ne i32 %13, 0
>   br i1 %14, label %15, label %18
> 
> ; <label>:15                                      ; preds = %7
>   %16 = load i32* %2, align 4
>   %17 = sub nsw i32 0, %16
>   br label %20
5560,5588c3709,3711
< ; <label>:35                                      ; preds = %31
<   %36 = load %struct.CPUX86State** @env, align 8
<   %37 = lshr i32 %25, 16
<   %38 = shl i32 %27, 16
<   %39 = and i32 %38, 16711680
<   %40 = and i32 %27, -16777216
<   %41 = or i32 %40, %37
<   %42 = or i32 %41, %39
<   %43 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 11, i32 1
<   store i32 %42, i32* %43, align 4
<   %44 = and i32 %25, 65535
<   %45 = and i32 %27, 983040
<   %46 = or i32 %45, %44
<   %47 = and i32 %27, 8388608
<   %48 = icmp eq i32 %47, 0
<   br i1 %48, label %load_seg_cache_raw_dt.exit, label %49
< 
< ; <label>:49                                      ; preds = %35
<   %50 = shl nuw i32 %46, 12
<   %51 = or i32 %50, 4095
<   br label %load_seg_cache_raw_dt.exit
< 
< load_seg_cache_raw_dt.exit:                       ; preds = %49, %35
<   %limit.0.i.i = phi i32 [ %51, %49 ], [ %46, %35 ]
<   %52 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 11, i32 2
<   store i32 %limit.0.i.i, i32* %52, align 4
<   %53 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 11, i32 3
<   store i32 %27, i32* %53, align 4
<   br label %54
---
> ; <label>:18                                      ; preds = %7
>   %19 = load i32* %2, align 4
>   br label %20
5590,5595c3713,3736
< ; <label>:54                                      ; preds = %load_seg_cache_raw_dt.exit, %4
<   %55 = load %struct.CPUX86State** @env, align 8
<   %56 = getelementptr inbounds %struct.CPUX86State* %55, i64 0, i32 11, i32 0
<   store i32 %1, i32* %56, align 4
<   ret void
< }
---
> ; <label>:20                                      ; preds = %18, %15
>   %21 = phi i32 [ %17, %15 ], [ %19, %18 ]
>   store i32 %21, i32* %absA, align 4
>   %22 = load i32* %absA, align 4
>   %23 = call signext i8 @countLeadingZeros32(i32 %22)
>   %24 = sext i8 %23 to i32
>   %25 = add nsw i32 %24, 21
>   %26 = trunc i32 %25 to i8
>   store i8 %26, i8* %shiftCount, align 1
>   %27 = load i32* %absA, align 4
>   %28 = zext i32 %27 to i64
>   store i64 %28, i64* %zSig, align 8
>   %29 = load i8* %zSign, align 1
>   %30 = load i8* %shiftCount, align 1
>   %31 = sext i8 %30 to i32
>   %32 = sub nsw i32 1074, %31
>   %33 = load i64* %zSig, align 8
>   %34 = load i8* %shiftCount, align 1
>   %35 = sext i8 %34 to i32
>   %36 = zext i32 %35 to i64
>   %37 = shl i64 %33, %36
>   %38 = call i64 @packFloat64(i8 zeroext %29, i32 %32, i64 %37)
>   store i64 %38, i64* %1
>   br label %39
5597,5599c3738,3740
< define internal fastcc void @raise_exception_err(i32 %exception_index, i32 %error_code) noreturn nounwind uwtable {
<   tail call fastcc void @raise_interrupt(i32 %exception_index, i32 0, i32 %error_code, i32 0) noreturn
<   unreachable
---
> ; <label>:39                                      ; preds = %20, %6
>   %40 = load i64* %1
>   ret i64 %40
5602,5610c3743,3749
< define internal fastcc i32 @ldl_kernel(i32 %ptr) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
< 
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> define internal signext i8 @countLeadingZeros32(i32 %a) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   %3 = load i32* %2, align 4
>   %4 = icmp ne i32 %3, 0
>   br i1 %4, label %5, label %9
5612,5625c3751,3756
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 0
<   %16 = load i32* %15, align 4
<   %17 = and i32 %8, -4093
<   %18 = icmp eq i32 %16, %17
<   br i1 %18, label %21, label %19, !prof !0
---
> ; <label>:5                                       ; preds = %0
>   %6 = load i32* %2, align 4
>   %7 = call i32 @llvm.ctlz.i32(i32 %6, i1 true)
>   %8 = trunc i32 %7 to i8
>   store i8 %8, i8* %1
>   br label %10
5627,5629c3758,3760
< ; <label>:19                                      ; preds = %6
<   %20 = tail call i32 @__ldl_mmu(i32 %8, i32 0)
<   br label %29
---
> ; <label>:9                                       ; preds = %0
>   store i8 32, i8* %1
>   br label %10
5631,5640c3762,3765
< ; <label>:21                                      ; preds = %6
<   %22 = and i64 %7, 4294967295
<   %23 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 3
<   %24 = load i64* %23, align 8
<   %25 = add i64 %24, %22
<   %26 = inttoptr i64 %25 to i32*
<   %27 = load i32* %26, align 4
<   %28 = zext i32 %27 to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %22, i64 %25, i64 %28, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %29
---
> ; <label>:10                                      ; preds = %9, %5
>   %11 = load i8* %1
>   ret i8 %11
> }
5642,5644c3767,3783
< ; <label>:29                                      ; preds = %21, %19
<   %res.0 = phi i32 [ %20, %19 ], [ %27, %21 ]
<   ret i32 %res.0
---
> define internal i64 @packFloat64(i8 zeroext %zSign, i32 %zExp, i64 %zSig) nounwind inlinehint {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = alloca i64, align 8
>   store i8 %zSign, i8* %1, align 1
>   store i32 %zExp, i32* %2, align 4
>   store i64 %zSig, i64* %3, align 8
>   %4 = load i8* %1, align 1
>   %5 = zext i8 %4 to i64
>   %6 = shl i64 %5, 63
>   %7 = load i32* %2, align 4
>   %8 = sext i32 %7 to i64
>   %9 = shl i64 %8, 52
>   %10 = add i64 %6, %9
>   %11 = load i64* %3, align 8
>   %12 = add i64 %10, %11
>   ret i64 %12
5647,5651c3786,3797
< define void @helper_ltr(i32 %selector) nounwind uwtable {
<   %1 = and i32 %selector, 65535
<   %2 = and i32 %selector, 65532
<   %3 = icmp eq i32 %2, 0
<   br i1 %3, label %4, label %11
---
> define internal void @int32_to_floatx80(%struct.floatx80* noalias sret %agg.result, i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %zSign = alloca i8, align 1
>   %absA = alloca i32, align 4
>   %shiftCount = alloca i8, align 1
>   %zSig = alloca i64, align 8
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = icmp eq i32 %3, 0
>   br i1 %4, label %5, label %6
5653,5663c3799,3801
< ; <label>:4                                       ; preds = %0
<   %5 = load %struct.CPUX86State** @env, align 8
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 12, i32 1
<   store i32 0, i32* %6, align 4
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 12, i32 2
<   store i32 0, i32* %8, align 4
<   %9 = load %struct.CPUX86State** @env, align 8
<   %10 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 12, i32 3
<   store i32 0, i32* %10, align 4
<   br label %60
---
> ; <label>:5                                       ; preds = %0
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext 0, i32 0, i64 0)
>   br label %37
5665,5668c3803,3812
< ; <label>:11                                      ; preds = %0
<   %12 = and i32 %selector, 4
<   %13 = icmp eq i32 %12, 0
<   br i1 %13, label %15, label %14
---
> ; <label>:6                                       ; preds = %0
>   %7 = load i32* %1, align 4
>   %8 = icmp slt i32 %7, 0
>   %9 = zext i1 %8 to i32
>   %10 = trunc i32 %9 to i8
>   store i8 %10, i8* %zSign, align 1
>   %11 = load i8* %zSign, align 1
>   %12 = zext i8 %11 to i32
>   %13 = icmp ne i32 %12, 0
>   br i1 %13, label %14, label %17
5670,5672c3814,3817
< ; <label>:14                                      ; preds = %11
<   tail call fastcc void @raise_exception_err(i32 13, i32 %2) noreturn
<   unreachable
---
> ; <label>:14                                      ; preds = %6
>   %15 = load i32* %1, align 4
>   %16 = sub nsw i32 0, %15
>   br label %19
5674,5681c3819,3821
< ; <label>:15                                      ; preds = %11
<   %16 = load %struct.CPUX86State** @env, align 8
<   %17 = and i32 %selector, 65528
<   %18 = or i32 %17, 7
<   %19 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 13, i32 2
<   %20 = load i32* %19, align 4
<   %21 = icmp ugt i32 %18, %20
<   br i1 %21, label %22, label %23
---
> ; <label>:17                                      ; preds = %6
>   %18 = load i32* %1, align 4
>   br label %19
5683,5685c3823,3845
< ; <label>:22                                      ; preds = %15
<   tail call fastcc void @raise_exception_err(i32 13, i32 %2) noreturn
<   unreachable
---
> ; <label>:19                                      ; preds = %17, %14
>   %20 = phi i32 [ %16, %14 ], [ %18, %17 ]
>   store i32 %20, i32* %absA, align 4
>   %21 = load i32* %absA, align 4
>   %22 = call signext i8 @countLeadingZeros32(i32 %21)
>   %23 = sext i8 %22 to i32
>   %24 = add nsw i32 %23, 32
>   %25 = trunc i32 %24 to i8
>   store i8 %25, i8* %shiftCount, align 1
>   %26 = load i32* %absA, align 4
>   %27 = zext i32 %26 to i64
>   store i64 %27, i64* %zSig, align 8
>   %28 = load i8* %zSign, align 1
>   %29 = load i8* %shiftCount, align 1
>   %30 = sext i8 %29 to i32
>   %31 = sub nsw i32 16446, %30
>   %32 = load i64* %zSig, align 8
>   %33 = load i8* %shiftCount, align 1
>   %34 = sext i8 %33 to i32
>   %35 = zext i32 %34 to i64
>   %36 = shl i64 %32, %35
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %28, i32 %31, i64 %36)
>   br label %37
5687,5696c3847,3849
< ; <label>:23                                      ; preds = %15
<   %24 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 13, i32 1
<   %25 = load i32* %24, align 4
<   %26 = add i32 %25, %17
<   %27 = tail call fastcc i32 @ldl_kernel(i32 %26)
<   %28 = add i32 %26, 4
<   %29 = tail call fastcc i32 @ldl_kernel(i32 %28)
<   %30 = and i32 %29, 4096
<   %31 = icmp eq i32 %30, 0
<   br i1 %31, label %32, label %35
---
> ; <label>:37                                      ; preds = %19, %5
>   ret void
> }
5698,5704c3851,3875
< ; <label>:32                                      ; preds = %23
<   %33 = lshr i32 %29, 8
<   %34 = and i32 %33, 15
<   switch i32 %34, label %35 [
<     i32 9, label %36
<     i32 1, label %36
<   ]
---
> define internal void @packFloatx80(%struct.floatx80* noalias sret %agg.result, i8 zeroext %zSign, i32 %zExp, i64 %zSig) nounwind inlinehint {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = alloca i64, align 8
>   %z = alloca %struct.floatx80, align 1
>   store i8 %zSign, i8* %1, align 1
>   store i32 %zExp, i32* %2, align 4
>   store i64 %zSig, i64* %3, align 8
>   %4 = load i64* %3, align 8
>   %5 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 %4, i64* %5, align 1
>   %6 = load i8* %1, align 1
>   %7 = zext i8 %6 to i16
>   %8 = zext i16 %7 to i32
>   %9 = shl i32 %8, 15
>   %10 = load i32* %2, align 4
>   %11 = add nsw i32 %9, %10
>   %12 = trunc i32 %11 to i16
>   %13 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   store i16 %12, i16* %13, align 1
>   %14 = bitcast %struct.floatx80* %agg.result to i8*
>   %15 = bitcast %struct.floatx80* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %14, i8* %15, i32 10, i32 1, i1 false)
>   ret void
> }
5706,5708c3877,3888
< ; <label>:35                                      ; preds = %32, %23
<   tail call fastcc void @raise_exception_err(i32 13, i32 %2) noreturn
<   unreachable
---
> define internal void @int32_to_float128(%struct.float128* noalias sret %agg.result, i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %zSign = alloca i8, align 1
>   %absA = alloca i32, align 4
>   %shiftCount = alloca i8, align 1
>   %zSig0 = alloca i64, align 8
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = icmp eq i32 %3, 0
>   br i1 %4, label %5, label %6
5710,5713c3890,3892
< ; <label>:36                                      ; preds = %32, %32
<   %37 = and i32 %29, 32768
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %39, label %40
---
> ; <label>:5                                       ; preds = %0
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext 0, i32 0, i64 0, i64 0)
>   br label %37
5715,5717c3894,3903
< ; <label>:39                                      ; preds = %36
<   tail call fastcc void @raise_exception_err(i32 11, i32 %2) noreturn
<   unreachable
---
> ; <label>:6                                       ; preds = %0
>   %7 = load i32* %1, align 4
>   %8 = icmp slt i32 %7, 0
>   %9 = zext i1 %8 to i32
>   %10 = trunc i32 %9 to i8
>   store i8 %10, i8* %zSign, align 1
>   %11 = load i8* %zSign, align 1
>   %12 = zext i8 %11 to i32
>   %13 = icmp ne i32 %12, 0
>   br i1 %13, label %14, label %17
5719,5734c3905,3908
< ; <label>:40                                      ; preds = %36
<   %41 = load %struct.CPUX86State** @env, align 8
<   %42 = lshr i32 %27, 16
<   %43 = shl i32 %29, 16
<   %44 = and i32 %43, 16711680
<   %45 = and i32 %29, -16777216
<   %46 = or i32 %45, %42
<   %47 = or i32 %46, %44
<   %48 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 12, i32 1
<   store i32 %47, i32* %48, align 4
<   %49 = and i32 %27, 65535
<   %50 = and i32 %29, 983040
<   %51 = or i32 %50, %49
<   %52 = and i32 %29, 8388608
<   %53 = icmp eq i32 %52, 0
<   br i1 %53, label %load_seg_cache_raw_dt.exit, label %54
---
> ; <label>:14                                      ; preds = %6
>   %15 = load i32* %1, align 4
>   %16 = sub nsw i32 0, %15
>   br label %19
5736,5749c3910,3936
< ; <label>:54                                      ; preds = %40
<   %55 = shl nuw i32 %51, 12
<   %56 = or i32 %55, 4095
<   br label %load_seg_cache_raw_dt.exit
< 
< load_seg_cache_raw_dt.exit:                       ; preds = %54, %40
<   %limit.0.i.i = phi i32 [ %56, %54 ], [ %51, %40 ]
<   %57 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 12, i32 2
<   store i32 %limit.0.i.i, i32* %57, align 4
<   %58 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 12, i32 3
<   store i32 %29, i32* %58, align 4
<   %59 = or i32 %29, 512
<   tail call fastcc void @stl_kernel(i32 %28, i32 %59)
<   br label %60
---
> ; <label>:17                                      ; preds = %6
>   %18 = load i32* %1, align 4
>   br label %19
> 
> ; <label>:19                                      ; preds = %17, %14
>   %20 = phi i32 [ %16, %14 ], [ %18, %17 ]
>   store i32 %20, i32* %absA, align 4
>   %21 = load i32* %absA, align 4
>   %22 = call signext i8 @countLeadingZeros32(i32 %21)
>   %23 = sext i8 %22 to i32
>   %24 = add nsw i32 %23, 17
>   %25 = trunc i32 %24 to i8
>   store i8 %25, i8* %shiftCount, align 1
>   %26 = load i32* %absA, align 4
>   %27 = zext i32 %26 to i64
>   store i64 %27, i64* %zSig0, align 8
>   %28 = load i8* %zSign, align 1
>   %29 = load i8* %shiftCount, align 1
>   %30 = sext i8 %29 to i32
>   %31 = sub nsw i32 16430, %30
>   %32 = load i64* %zSig0, align 8
>   %33 = load i8* %shiftCount, align 1
>   %34 = sext i8 %33 to i32
>   %35 = zext i32 %34 to i64
>   %36 = shl i64 %32, %35
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %28, i32 %31, i64 %36, i64 0)
>   br label %37
5751,5754c3938
< ; <label>:60                                      ; preds = %load_seg_cache_raw_dt.exit, %4
<   %61 = load %struct.CPUX86State** @env, align 8
<   %62 = getelementptr inbounds %struct.CPUX86State* %61, i64 0, i32 12, i32 0
<   store i32 %1, i32* %62, align 4
---
> ; <label>:37                                      ; preds = %19, %5
5758,5762c3942,3970
< define internal fastcc void @stl_kernel(i32 %ptr, i32 %v) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> define internal void @packFloat128(%struct.float128* noalias sret %agg.result, i8 zeroext %zSign, i32 %zExp, i64 %zSig0, i64 %zSig1) nounwind inlinehint {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %z = alloca %struct.float128, align 4
>   store i8 %zSign, i8* %1, align 1
>   store i32 %zExp, i32* %2, align 4
>   store i64 %zSig0, i64* %3, align 8
>   store i64 %zSig1, i64* %4, align 8
>   %5 = load i64* %4, align 8
>   %6 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   store i64 %5, i64* %6, align 4
>   %7 = load i8* %1, align 1
>   %8 = zext i8 %7 to i64
>   %9 = shl i64 %8, 63
>   %10 = load i32* %2, align 4
>   %11 = sext i32 %10 to i64
>   %12 = shl i64 %11, 48
>   %13 = add i64 %9, %12
>   %14 = load i64* %3, align 8
>   %15 = add i64 %13, %14
>   %16 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   store i64 %15, i64* %16, align 4
>   %17 = bitcast %struct.float128* %agg.result to i8*
>   %18 = bitcast %struct.float128* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %17, i8* %18, i32 16, i32 4, i1 false)
>   ret void
> }
5764,5766c3972,3983
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> define internal i32 @int64_to_float32(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %zSign = alloca i8, align 1
>   %absA = alloca i64, align 8
>   %shiftCount = alloca i8, align 1
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = icmp eq i64 %4, 0
>   br i1 %5, label %6, label %7
5768,5781c3985,3987
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 1
<   %16 = load i32* %15, align 4
<   %17 = and i32 %8, -4093
<   %18 = icmp eq i32 %16, %17
<   br i1 %18, label %20, label %19, !prof !0
---
> ; <label>:6                                       ; preds = %0
>   store i32 0, i32* %1
>   br label %70
5783,5785c3989,4003
< ; <label>:19                                      ; preds = %6
<   tail call void @__stl_mmu(i32 %8, i32 %v, i32 0)
<   br label %27
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i64* %2, align 8
>   %9 = icmp slt i64 %8, 0
>   %10 = zext i1 %9 to i32
>   %11 = trunc i32 %10 to i8
>   store i8 %11, i8* %zSign, align 1
>   %12 = load i8* %zSign, align 1
>   %13 = zext i8 %12 to i32
>   %14 = icmp ne i32 %13, 0
>   br i1 %14, label %15, label %18
> 
> ; <label>:15                                      ; preds = %7
>   %16 = load i64* %2, align 8
>   %17 = sub nsw i64 0, %16
>   br label %20
5787,5796c4005,4007
< ; <label>:20                                      ; preds = %6
<   %21 = and i64 %7, 4294967295
<   %22 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 3
<   %23 = load i64* %22, align 8
<   %24 = add i64 %23, %21
<   %25 = inttoptr i64 %24 to i32*
<   store i32 %v, i32* %25, align 4
<   %26 = zext i32 %v to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %21, i64 %24, i64 %26, i32 32, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %27
---
> ; <label>:18                                      ; preds = %7
>   %19 = load i64* %2, align 8
>   br label %20
5798,5799c4009,4080
< ; <label>:27                                      ; preds = %20, %19
<   ret void
---
> ; <label>:20                                      ; preds = %18, %15
>   %21 = phi i64 [ %17, %15 ], [ %19, %18 ]
>   store i64 %21, i64* %absA, align 8
>   %22 = load i64* %absA, align 8
>   %23 = call signext i8 @countLeadingZeros64(i64 %22)
>   %24 = sext i8 %23 to i32
>   %25 = sub nsw i32 %24, 40
>   %26 = trunc i32 %25 to i8
>   store i8 %26, i8* %shiftCount, align 1
>   %27 = load i8* %shiftCount, align 1
>   %28 = sext i8 %27 to i32
>   %29 = icmp sle i32 0, %28
>   br i1 %29, label %30, label %42
> 
> ; <label>:30                                      ; preds = %20
>   %31 = load i8* %zSign, align 1
>   %32 = load i8* %shiftCount, align 1
>   %33 = sext i8 %32 to i32
>   %34 = sub nsw i32 149, %33
>   %35 = load i64* %absA, align 8
>   %36 = load i8* %shiftCount, align 1
>   %37 = sext i8 %36 to i32
>   %38 = zext i32 %37 to i64
>   %39 = shl i64 %35, %38
>   %40 = trunc i64 %39 to i32
>   %41 = call i32 @packFloat32(i8 zeroext %31, i32 %34, i32 %40)
>   store i32 %41, i32* %1
>   br label %70
> 
> ; <label>:42                                      ; preds = %20
>   %43 = load i8* %shiftCount, align 1
>   %44 = sext i8 %43 to i32
>   %45 = add nsw i32 %44, 7
>   %46 = trunc i32 %45 to i8
>   store i8 %46, i8* %shiftCount, align 1
>   %47 = load i8* %shiftCount, align 1
>   %48 = sext i8 %47 to i32
>   %49 = icmp slt i32 %48, 0
>   br i1 %49, label %50, label %55
> 
> ; <label>:50                                      ; preds = %42
>   %51 = load i64* %absA, align 8
>   %52 = load i8* %shiftCount, align 1
>   %53 = sext i8 %52 to i32
>   %54 = sub nsw i32 0, %53
>   call void @shift64RightJamming(i64 %51, i32 %54, i64* %absA)
>   br label %61
> 
> ; <label>:55                                      ; preds = %42
>   %56 = load i8* %shiftCount, align 1
>   %57 = sext i8 %56 to i32
>   %58 = load i64* %absA, align 8
>   %59 = zext i32 %57 to i64
>   %60 = shl i64 %58, %59
>   store i64 %60, i64* %absA, align 8
>   br label %61
> 
> ; <label>:61                                      ; preds = %55, %50
>   %62 = load i8* %zSign, align 1
>   %63 = load i8* %shiftCount, align 1
>   %64 = sext i8 %63 to i32
>   %65 = sub nsw i32 156, %64
>   %66 = load i64* %absA, align 8
>   %67 = trunc i64 %66 to i32
>   %68 = load %struct.float_status** %3, align 4
>   %69 = call i32 @roundAndPackFloat32(i8 zeroext %62, i32 %65, i32 %67, %struct.float_status* %68)
>   store i32 %69, i32* %1
>   br label %70
> 
> ; <label>:70                                      ; preds = %61, %30, %6
>   %71 = load i32* %1
>   ret i32 %71
5802,5814c4083,4089
< define void @helper_load_seg(i32 %seg_reg, i32 %selector) nounwind uwtable {
<   %1 = and i32 %selector, 65535
<   %2 = load %struct.CPUX86State** @env, align 8
<   %3 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 8
<   %4 = load i32* %3, align 4
<   %5 = and i32 %4, 3
<   %6 = and i32 %selector, 65532
<   %7 = icmp eq i32 %6, 0
<   br i1 %7, label %8, label %64
< 
< ; <label>:8                                       ; preds = %0
<   %9 = icmp eq i32 %seg_reg, 2
<   br i1 %9, label %10, label %11
---
> define internal signext i8 @countLeadingZeros64(i64 %a) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   %3 = load i64* %2, align 8
>   %4 = icmp ne i64 %3, 0
>   br i1 %4, label %5, label %10
5816,5818c4091,4097
< ; <label>:10                                      ; preds = %8
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn
<   unreachable
---
> ; <label>:5                                       ; preds = %0
>   %6 = load i64* %2, align 8
>   %7 = call i64 @llvm.ctlz.i64(i64 %6, i1 true)
>   %8 = trunc i64 %7 to i32
>   %9 = trunc i32 %8 to i8
>   store i8 %9, i8* %1
>   br label %11
5820,5831c4099,4101
< ; <label>:11                                      ; preds = %8
<   %12 = sext i32 %seg_reg to i64
<   %13 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 10, i64 %12, i32 0
<   store i32 %1, i32* %13, align 4
<   %14 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 10, i64 %12, i32 1
<   store i32 0, i32* %14, align 4
<   %15 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 10, i64 %12, i32 2
<   store i32 0, i32* %15, align 4
<   %16 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 10, i64 %12, i32 3
<   store i32 0, i32* %16, align 4
<   %17 = icmp eq i32 %seg_reg, 1
<   br i1 %17, label %18, label %._crit_edge.i
---
> ; <label>:10                                      ; preds = %0
>   store i8 64, i8* %1
>   br label %11
5833,5835c4103,4106
< ._crit_edge.i:                                    ; preds = %11
<   %.pre.i = load i32* %3, align 4
<   br label %26
---
> ; <label>:11                                      ; preds = %10, %5
>   %12 = load i8* %1
>   ret i8 %12
> }
5837,5846c4108,4118
< ; <label>:18                                      ; preds = %11
<   %19 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 10, i64 1, i32 3
<   %20 = load i32* %19, align 4
<   %21 = lshr i32 %20, 18
<   %22 = and i32 %21, 16
<   %23 = load i32* %3, align 4
<   %24 = and i32 %23, -32785
<   %25 = or i32 %24, %22
<   store i32 %25, i32* %3, align 4
<   br label %26
---
> define internal void @shift64RightJamming(i64 %a, i32 %count, i64* %zPtr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i32, align 4
>   %3 = alloca i64*, align 4
>   %z = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   store i32 %count, i32* %2, align 4
>   store i64* %zPtr, i64** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = icmp eq i32 %4, 0
>   br i1 %5, label %6, label %8
5848,5856c4120,4123
< ; <label>:26                                      ; preds = %18, %._crit_edge.i
<   %27 = phi i32 [ %.pre.i, %._crit_edge.i ], [ %25, %18 ]
<   %28 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 10, i64 2, i32 3
<   %29 = load i32* %28, align 4
<   %30 = lshr i32 %29, 17
<   %31 = and i32 %30, 32
<   %32 = and i32 %27, 32768
<   %33 = icmp eq i32 %32, 0
<   br i1 %33, label %34, label %cpu_x86_load_seg_cache.exit
---
> ; <label>:6                                       ; preds = %0
>   %7 = load i64* %1, align 8
>   store i64 %7, i64* %z, align 8
>   br label %32
5858,5863c4125,4128
< ; <label>:34                                      ; preds = %26
<   %35 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 15, i64 0
<   %36 = load i32* %35, align 4
<   %37 = and i32 %36, 1
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %47, label %39
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i32* %2, align 4
>   %10 = icmp slt i32 %9, 64
>   br i1 %10, label %11, label %26
5865,5870c4130,4146
< ; <label>:39                                      ; preds = %34
<   %40 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 7
<   %41 = load i32* %40, align 4
<   %42 = and i32 %41, 131072
<   %43 = icmp eq i32 %42, 0
<   br i1 %43, label %44, label %47
---
> ; <label>:11                                      ; preds = %8
>   %12 = load i64* %1, align 8
>   %13 = load i32* %2, align 4
>   %14 = zext i32 %13 to i64
>   %15 = lshr i64 %12, %14
>   %16 = load i64* %1, align 8
>   %17 = load i32* %2, align 4
>   %18 = sub nsw i32 0, %17
>   %19 = and i32 %18, 63
>   %20 = zext i32 %19 to i64
>   %21 = shl i64 %16, %20
>   %22 = icmp ne i64 %21, 0
>   %23 = zext i1 %22 to i32
>   %24 = sext i32 %23 to i64
>   %25 = or i64 %15, %24
>   store i64 %25, i64* %z, align 8
>   br label %31
5872,5875c4148,4154
< ; <label>:44                                      ; preds = %39
<   %45 = and i32 %27, 16
<   %46 = icmp eq i32 %45, 0
<   br i1 %46, label %47, label %49
---
> ; <label>:26                                      ; preds = %8
>   %27 = load i64* %1, align 8
>   %28 = icmp ne i64 %27, 0
>   %29 = zext i1 %28 to i32
>   %30 = sext i32 %29 to i64
>   store i64 %30, i64* %z, align 8
>   br label %31
5877,5879c4156,4157
< ; <label>:47                                      ; preds = %44, %39, %34
<   %48 = or i32 %31, 64
<   br label %cpu_x86_load_seg_cache.exit
---
> ; <label>:31                                      ; preds = %26, %11
>   br label %32
5881,5901c4159,4164
< ; <label>:49                                      ; preds = %44
<   %50 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 10, i64 3, i32 1
<   %51 = load i32* %50, align 4
<   %52 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 10, i64 0, i32 1
<   %53 = load i32* %52, align 4
<   %54 = or i32 %53, %51
<   %55 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 10, i64 2, i32 1
<   %56 = load i32* %55, align 4
<   %57 = or i32 %54, %56
<   %58 = icmp ne i32 %57, 0
<   %59 = zext i1 %58 to i32
<   %60 = shl nuw nsw i32 %59, 6
<   %61 = or i32 %60, %31
<   br label %cpu_x86_load_seg_cache.exit
< 
< cpu_x86_load_seg_cache.exit:                      ; preds = %49, %47, %26
<   %new_hflags.0.i = phi i32 [ %31, %26 ], [ %48, %47 ], [ %61, %49 ]
<   %62 = and i32 %27, -97
<   %63 = or i32 %new_hflags.0.i, %62
<   store i32 %63, i32* %3, align 4
<   br label %189
---
> ; <label>:32                                      ; preds = %31, %6
>   %33 = load i64* %z, align 8
>   %34 = load i64** %3, align 4
>   store i64 %33, i64* %34, align 4
>   ret void
> }
5903,5914c4166,4194
< ; <label>:64                                      ; preds = %0
<   %65 = and i32 %selector, 4
<   %66 = icmp eq i32 %65, 0
<   %67 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 11
<   %68 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 13
<   %dt.0 = select i1 %66, %struct.SegmentCache* %68, %struct.SegmentCache* %67
<   %69 = and i32 %selector, 65528
<   %70 = or i32 %69, 7
<   %71 = getelementptr inbounds %struct.SegmentCache* %dt.0, i64 0, i32 2
<   %72 = load i32* %71, align 4
<   %73 = icmp ugt i32 %70, %72
<   br i1 %73, label %74, label %75
---
> define internal i32 @roundAndPackFloat32(i8 zeroext %zSign, i32 %zExp, i32 %zSig, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i8, align 1
>   %3 = alloca i32, align 4
>   %4 = alloca i32, align 4
>   %5 = alloca %struct.float_status*, align 4
>   %roundingMode = alloca i8, align 1
>   %roundNearestEven = alloca i8, align 1
>   %roundIncrement = alloca i8, align 1
>   %roundBits = alloca i8, align 1
>   %isTiny = alloca i8, align 1
>   store i8 %zSign, i8* %2, align 1
>   store i32 %zExp, i32* %3, align 4
>   store i32 %zSig, i32* %4, align 4
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load %struct.float_status** %5, align 4
>   %7 = getelementptr inbounds %struct.float_status* %6, i32 0, i32 1
>   %8 = load i8* %7, align 1
>   store i8 %8, i8* %roundingMode, align 1
>   %9 = load i8* %roundingMode, align 1
>   %10 = sext i8 %9 to i32
>   %11 = icmp eq i32 %10, 0
>   %12 = zext i1 %11 to i32
>   %13 = trunc i32 %12 to i8
>   store i8 %13, i8* %roundNearestEven, align 1
>   store i8 64, i8* %roundIncrement, align 1
>   %14 = load i8* %roundNearestEven, align 1
>   %15 = icmp ne i8 %14, 0
>   br i1 %15, label %38, label %16
5916,5918c4196,4200
< ; <label>:74                                      ; preds = %64
<   tail call fastcc void @raise_exception_err(i32 13, i32 %6) noreturn
<   unreachable
---
> ; <label>:16                                      ; preds = %0
>   %17 = load i8* %roundingMode, align 1
>   %18 = sext i8 %17 to i32
>   %19 = icmp eq i32 %18, 3
>   br i1 %19, label %20, label %21
5920,5929c4202,4204
< ; <label>:75                                      ; preds = %64
<   %76 = getelementptr inbounds %struct.SegmentCache* %dt.0, i64 0, i32 1
<   %77 = load i32* %76, align 4
<   %78 = add i32 %77, %69
<   %79 = tail call fastcc i32 @ldl_kernel(i32 %78)
<   %80 = add i32 %78, 4
<   %81 = tail call fastcc i32 @ldl_kernel(i32 %80)
<   %82 = and i32 %81, 4096
<   %83 = icmp eq i32 %82, 0
<   br i1 %83, label %84, label %85
---
> ; <label>:20                                      ; preds = %16
>   store i8 0, i8* %roundIncrement, align 1
>   br label %37
5931,5933c4206,4210
< ; <label>:84                                      ; preds = %75
<   tail call fastcc void @raise_exception_err(i32 13, i32 %6) noreturn
<   unreachable
---
> ; <label>:21                                      ; preds = %16
>   store i8 127, i8* %roundIncrement, align 1
>   %22 = load i8* %2, align 1
>   %23 = icmp ne i8 %22, 0
>   br i1 %23, label %24, label %30
5935,5945c4212,4216
< ; <label>:85                                      ; preds = %75
<   %86 = and i32 %selector, 3
<   %87 = lshr i32 %81, 13
<   %88 = and i32 %87, 3
<   %89 = icmp eq i32 %seg_reg, 2
<   %90 = and i32 %81, 2560
<   br i1 %89, label %91, label %98
< 
< ; <label>:91                                      ; preds = %85
<   %92 = icmp eq i32 %90, 512
<   br i1 %92, label %94, label %93
---
> ; <label>:24                                      ; preds = %21
>   %25 = load i8* %roundingMode, align 1
>   %26 = sext i8 %25 to i32
>   %27 = icmp eq i32 %26, 2
>   br i1 %27, label %28, label %29
5947,5949c4218,4220
< ; <label>:93                                      ; preds = %91
<   tail call fastcc void @raise_exception_err(i32 13, i32 %6) noreturn
<   unreachable
---
> ; <label>:28                                      ; preds = %24
>   store i8 0, i8* %roundIncrement, align 1
>   br label %29
5951,5955c4222,4223
< ; <label>:94                                      ; preds = %91
<   %95 = icmp eq i32 %86, %5
<   %96 = icmp eq i32 %88, %5
<   %or.cond41 = and i1 %95, %96
<   br i1 %or.cond41, label %108, label %97
---
> ; <label>:29                                      ; preds = %28, %24
>   br label %36
5957,5959c4225,4229
< ; <label>:97                                      ; preds = %94
<   tail call fastcc void @raise_exception_err(i32 13, i32 %6) noreturn
<   unreachable
---
> ; <label>:30                                      ; preds = %21
>   %31 = load i8* %roundingMode, align 1
>   %32 = sext i8 %31 to i32
>   %33 = icmp eq i32 %32, 1
>   br i1 %33, label %34, label %35
5961,5963c4231,4233
< ; <label>:98                                      ; preds = %85
<   %99 = icmp eq i32 %90, 2048
<   br i1 %99, label %100, label %101
---
> ; <label>:34                                      ; preds = %30
>   store i8 0, i8* %roundIncrement, align 1
>   br label %35
5965,5967c4235,4236
< ; <label>:100                                     ; preds = %98
<   tail call fastcc void @raise_exception_err(i32 13, i32 %6) noreturn
<   unreachable
---
> ; <label>:35                                      ; preds = %34, %30
>   br label %36
5969,5972c4238,4239
< ; <label>:101                                     ; preds = %98
<   %102 = and i32 %81, 3072
<   %103 = icmp eq i32 %102, 3072
<   br i1 %103, label %108, label %104
---
> ; <label>:36                                      ; preds = %35, %29
>   br label %37
5974,5978c4241,4242
< ; <label>:104                                     ; preds = %101
<   %105 = icmp ult i32 %88, %5
<   %106 = icmp ult i32 %88, %86
<   %or.cond44 = or i1 %105, %106
<   br i1 %or.cond44, label %107, label %108
---
> ; <label>:37                                      ; preds = %36, %20
>   br label %38
5980,5982c4244,4258
< ; <label>:107                                     ; preds = %104
<   tail call fastcc void @raise_exception_err(i32 13, i32 %6) noreturn
<   unreachable
---
> ; <label>:38                                      ; preds = %37, %0
>   %39 = load i32* %4, align 4
>   %40 = and i32 %39, 127
>   %41 = trunc i32 %40 to i8
>   store i8 %41, i8* %roundBits, align 1
>   %42 = load i32* %3, align 4
>   %43 = trunc i32 %42 to i16
>   %44 = zext i16 %43 to i32
>   %45 = icmp sle i32 253, %44
>   br i1 %45, label %46, label %115
> 
> ; <label>:46                                      ; preds = %38
>   %47 = load i32* %3, align 4
>   %48 = icmp slt i32 253, %47
>   br i1 %48, label %58, label %49
5984,5987c4260,4284
< ; <label>:108                                     ; preds = %104, %101, %94
<   %109 = and i32 %81, 32768
<   %110 = icmp eq i32 %109, 0
<   br i1 %110, label %111, label %114
---
> ; <label>:49                                      ; preds = %46
>   %50 = load i32* %3, align 4
>   %51 = icmp eq i32 %50, 253
>   br i1 %51, label %52, label %67
> 
> ; <label>:52                                      ; preds = %49
>   %53 = load i32* %4, align 4
>   %54 = load i8* %roundIncrement, align 1
>   %55 = sext i8 %54 to i32
>   %56 = add i32 %53, %55
>   %57 = icmp slt i32 %56, 0
>   br i1 %57, label %58, label %67
> 
> ; <label>:58                                      ; preds = %52, %46
>   %59 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext 40, %struct.float_status* %59)
>   %60 = load i8* %2, align 1
>   %61 = load i8* %roundIncrement, align 1
>   %62 = sext i8 %61 to i32
>   %63 = icmp eq i32 %62, 0
>   %64 = zext i1 %63 to i32
>   %65 = sub nsw i32 0, %64
>   %66 = call i32 @packFloat32(i8 zeroext %60, i32 255, i32 %65)
>   store i32 %66, i32* %1
>   br label %150
5989,5990c4286,4296
< ; <label>:111                                     ; preds = %108
<   br i1 %89, label %112, label %113
---
> ; <label>:67                                      ; preds = %52, %49
>   %68 = load i32* %3, align 4
>   %69 = icmp slt i32 %68, 0
>   br i1 %69, label %70, label %114
> 
> ; <label>:70                                      ; preds = %67
>   %71 = load %struct.float_status** %5, align 4
>   %72 = getelementptr inbounds %struct.float_status* %71, i32 0, i32 4
>   %73 = load i8* %72, align 1
>   %74 = icmp ne i8 %73, 0
>   br i1 %74, label %75, label %79
5992,5994c4298,4304
< ; <label>:112                                     ; preds = %111
<   tail call fastcc void @raise_exception_err(i32 12, i32 %6) noreturn
<   unreachable
---
> ; <label>:75                                      ; preds = %70
>   %76 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext -128, %struct.float_status* %76)
>   %77 = load i8* %2, align 1
>   %78 = call i32 @packFloat32(i8 zeroext %77, i32 0, i32 0)
>   store i32 %78, i32* %1
>   br label %150
5996,5998c4306,4350
< ; <label>:113                                     ; preds = %111
<   tail call fastcc void @raise_exception_err(i32 11, i32 %6) noreturn
<   unreachable
---
> ; <label>:79                                      ; preds = %70
>   %80 = load %struct.float_status** %5, align 4
>   %81 = getelementptr inbounds %struct.float_status* %80, i32 0, i32 0
>   %82 = load i8* %81, align 1
>   %83 = sext i8 %82 to i32
>   %84 = icmp eq i32 %83, 1
>   br i1 %84, label %94, label %85
> 
> ; <label>:85                                      ; preds = %79
>   %86 = load i32* %3, align 4
>   %87 = icmp slt i32 %86, -1
>   br i1 %87, label %94, label %88
> 
> ; <label>:88                                      ; preds = %85
>   %89 = load i32* %4, align 4
>   %90 = load i8* %roundIncrement, align 1
>   %91 = sext i8 %90 to i32
>   %92 = add i32 %89, %91
>   %93 = icmp ult i32 %92, -2147483648
>   br label %94
> 
> ; <label>:94                                      ; preds = %88, %85, %79
>   %95 = phi i1 [ true, %85 ], [ true, %79 ], [ %93, %88 ]
>   %96 = zext i1 %95 to i32
>   %97 = trunc i32 %96 to i8
>   store i8 %97, i8* %isTiny, align 1
>   %98 = load i32* %4, align 4
>   %99 = load i32* %3, align 4
>   %100 = sub nsw i32 0, %99
>   call void @shift32RightJamming(i32 %98, i32 %100, i32* %4)
>   store i32 0, i32* %3, align 4
>   %101 = load i32* %4, align 4
>   %102 = and i32 %101, 127
>   %103 = trunc i32 %102 to i8
>   store i8 %103, i8* %roundBits, align 1
>   %104 = load i8* %isTiny, align 1
>   %105 = zext i8 %104 to i32
>   %106 = icmp ne i32 %105, 0
>   br i1 %106, label %107, label %113
> 
> ; <label>:107                                     ; preds = %94
>   %108 = load i8* %roundBits, align 1
>   %109 = sext i8 %108 to i32
>   %110 = icmp ne i32 %109, 0
>   br i1 %110, label %111, label %113
6000,6003c4352,4355
< ; <label>:114                                     ; preds = %108
<   %115 = and i32 %81, 256
<   %116 = icmp eq i32 %115, 0
<   br i1 %116, label %117, label %119
---
> ; <label>:111                                     ; preds = %107
>   %112 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext 16, %struct.float_status* %112)
>   br label %113
6005,6008c4357,4358
< ; <label>:117                                     ; preds = %114
<   %118 = or i32 %81, 256
<   tail call fastcc void @stl_kernel(i32 %80, i32 %118)
<   br label %119
---
> ; <label>:113                                     ; preds = %111, %107, %94
>   br label %114
6010,6048c4360,4361
< ; <label>:119                                     ; preds = %117, %114
<   %e2.0 = phi i32 [ %81, %114 ], [ %118, %117 ]
<   %120 = load %struct.CPUX86State** @env, align 8
<   %121 = lshr i32 %79, 16
<   %122 = shl i32 %e2.0, 16
<   %123 = and i32 %122, 16711680
<   %124 = and i32 %e2.0, -16777216
<   %125 = or i32 %124, %121
<   %126 = or i32 %125, %123
<   %127 = and i32 %79, 65535
<   %128 = and i32 %e2.0, 983040
<   %129 = or i32 %128, %127
<   %130 = and i32 %e2.0, 8388608
<   %131 = icmp eq i32 %130, 0
<   br i1 %131, label %get_seg_limit.exit, label %132
< 
< ; <label>:132                                     ; preds = %119
<   %133 = shl nuw i32 %129, 12
<   %134 = or i32 %133, 4095
<   br label %get_seg_limit.exit
< 
< get_seg_limit.exit:                               ; preds = %132, %119
<   %limit.0.i = phi i32 [ %134, %132 ], [ %129, %119 ]
<   %135 = sext i32 %seg_reg to i64
<   %136 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 10, i64 %135, i32 0
<   store i32 %1, i32* %136, align 4
<   %137 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 10, i64 %135, i32 1
<   store i32 %126, i32* %137, align 4
<   %138 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 10, i64 %135, i32 2
<   store i32 %limit.0.i, i32* %138, align 4
<   %139 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 10, i64 %135, i32 3
<   store i32 %e2.0, i32* %139, align 4
<   %140 = icmp eq i32 %seg_reg, 1
<   br i1 %140, label %141, label %._crit_edge.i47
< 
< ._crit_edge.i47:                                  ; preds = %get_seg_limit.exit
<   %.phi.trans.insert.i45 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 8
<   %.pre.i46 = load i32* %.phi.trans.insert.i45, align 4
<   br label %150
---
> ; <label>:114                                     ; preds = %113, %67
>   br label %115
6050,6060c4363,4399
< ; <label>:141                                     ; preds = %get_seg_limit.exit
<   %142 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 10, i64 1, i32 3
<   %143 = load i32* %142, align 4
<   %144 = lshr i32 %143, 18
<   %145 = and i32 %144, 16
<   %146 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 8
<   %147 = load i32* %146, align 4
<   %148 = and i32 %147, -32785
<   %149 = or i32 %148, %145
<   store i32 %149, i32* %146, align 4
<   br label %150
---
> ; <label>:115                                     ; preds = %114, %38
>   %116 = load i8* %roundBits, align 1
>   %117 = icmp ne i8 %116, 0
>   br i1 %117, label %118, label %125
> 
> ; <label>:118                                     ; preds = %115
>   %119 = load %struct.float_status** %5, align 4
>   %120 = getelementptr inbounds %struct.float_status* %119, i32 0, i32 2
>   %121 = load i8* %120, align 1
>   %122 = sext i8 %121 to i32
>   %123 = or i32 %122, 32
>   %124 = trunc i32 %123 to i8
>   store i8 %124, i8* %120, align 1
>   br label %125
> 
> ; <label>:125                                     ; preds = %118, %115
>   %126 = load i32* %4, align 4
>   %127 = load i8* %roundIncrement, align 1
>   %128 = sext i8 %127 to i32
>   %129 = add i32 %126, %128
>   %130 = lshr i32 %129, 7
>   store i32 %130, i32* %4, align 4
>   %131 = load i8* %roundBits, align 1
>   %132 = sext i8 %131 to i32
>   %133 = xor i32 %132, 64
>   %134 = icmp eq i32 %133, 0
>   %135 = zext i1 %134 to i32
>   %136 = load i8* %roundNearestEven, align 1
>   %137 = zext i8 %136 to i32
>   %138 = and i32 %135, %137
>   %139 = xor i32 %138, -1
>   %140 = load i32* %4, align 4
>   %141 = and i32 %140, %139
>   store i32 %141, i32* %4, align 4
>   %142 = load i32* %4, align 4
>   %143 = icmp eq i32 %142, 0
>   br i1 %143, label %144, label %145
6062,6078c4401,4403
< ; <label>:150                                     ; preds = %141, %._crit_edge.i47
<   %151 = phi i32 [ %.pre.i46, %._crit_edge.i47 ], [ %149, %141 ]
<   %152 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 10, i64 2, i32 3
<   %153 = load i32* %152, align 4
<   %154 = lshr i32 %153, 17
<   %155 = and i32 %154, 32
<   %156 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 8
<   %157 = and i32 %151, 32768
<   %158 = icmp eq i32 %157, 0
<   br i1 %158, label %159, label %cpu_x86_load_seg_cache.exit49
< 
< ; <label>:159                                     ; preds = %150
<   %160 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 15, i64 0
<   %161 = load i32* %160, align 4
<   %162 = and i32 %161, 1
<   %163 = icmp eq i32 %162, 0
<   br i1 %163, label %172, label %164
---
> ; <label>:144                                     ; preds = %125
>   store i32 0, i32* %3, align 4
>   br label %145
6080,6116c4405,4411
< ; <label>:164                                     ; preds = %159
<   %165 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 7
<   %166 = load i32* %165, align 4
<   %167 = and i32 %166, 131072
<   %168 = icmp eq i32 %167, 0
<   br i1 %168, label %169, label %172
< 
< ; <label>:169                                     ; preds = %164
<   %170 = and i32 %151, 16
<   %171 = icmp eq i32 %170, 0
<   br i1 %171, label %172, label %174
< 
< ; <label>:172                                     ; preds = %169, %164, %159
<   %173 = or i32 %155, 64
<   br label %cpu_x86_load_seg_cache.exit49
< 
< ; <label>:174                                     ; preds = %169
<   %175 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 10, i64 3, i32 1
<   %176 = load i32* %175, align 4
<   %177 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 10, i64 0, i32 1
<   %178 = load i32* %177, align 4
<   %179 = or i32 %178, %176
<   %180 = getelementptr inbounds %struct.CPUX86State* %120, i64 0, i32 10, i64 2, i32 1
<   %181 = load i32* %180, align 4
<   %182 = or i32 %179, %181
<   %183 = icmp ne i32 %182, 0
<   %184 = zext i1 %183 to i32
<   %185 = shl nuw nsw i32 %184, 6
<   %186 = or i32 %185, %155
<   br label %cpu_x86_load_seg_cache.exit49
< 
< cpu_x86_load_seg_cache.exit49:                    ; preds = %174, %172, %150
<   %new_hflags.0.i48 = phi i32 [ %155, %150 ], [ %173, %172 ], [ %186, %174 ]
<   %187 = and i32 %151, -97
<   %188 = or i32 %new_hflags.0.i48, %187
<   store i32 %188, i32* %156, align 4
<   br label %189
---
> ; <label>:145                                     ; preds = %144, %125
>   %146 = load i8* %2, align 1
>   %147 = load i32* %3, align 4
>   %148 = load i32* %4, align 4
>   %149 = call i32 @packFloat32(i8 zeroext %146, i32 %147, i32 %148)
>   store i32 %149, i32* %1
>   br label %150
6118,6119c4413,4415
< ; <label>:189                                     ; preds = %cpu_x86_load_seg_cache.exit49, %cpu_x86_load_seg_cache.exit
<   ret void
---
> ; <label>:150                                     ; preds = %145, %75, %58
>   %151 = load i32* %1
>   ret i32 %151
6122,6125c4418,4427
< define void @helper_ljmp_protected(i32 %new_cs, i32 %new_eip, i32 %next_eip_addend) nounwind uwtable {
<   %1 = and i32 %new_cs, 65532
<   %2 = icmp eq i32 %1, 0
<   br i1 %2, label %3, label %4
---
> define internal i32 @uint64_to_float32(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %shiftCount = alloca i8, align 1
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = icmp eq i64 %4, 0
>   br i1 %5, label %6, label %7
6127,6129c4429,4431
< ; <label>:3                                       ; preds = %0
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn
<   unreachable
---
> ; <label>:6                                       ; preds = %0
>   store i32 0, i32* %1
>   br label %54
6131,6142c4433,4457
< ; <label>:4                                       ; preds = %0
<   %5 = and i32 %new_cs, 4
<   %6 = icmp eq i32 %5, 0
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 11
<   %9 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 13
<   %dt.0.i = select i1 %6, %struct.SegmentCache* %9, %struct.SegmentCache* %8
<   %10 = or i32 %new_cs, 7
<   %11 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 2
<   %12 = load i32* %11, align 4
<   %13 = icmp ugt i32 %10, %12
<   br i1 %13, label %14, label %15
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i64* %2, align 8
>   %9 = call signext i8 @countLeadingZeros64(i64 %8)
>   %10 = sext i8 %9 to i32
>   %11 = sub nsw i32 %10, 40
>   %12 = trunc i32 %11 to i8
>   store i8 %12, i8* %shiftCount, align 1
>   %13 = load i8* %shiftCount, align 1
>   %14 = sext i8 %13 to i32
>   %15 = icmp sle i32 0, %14
>   br i1 %15, label %16, label %27
> 
> ; <label>:16                                      ; preds = %7
>   %17 = load i8* %shiftCount, align 1
>   %18 = sext i8 %17 to i32
>   %19 = sub nsw i32 149, %18
>   %20 = load i64* %2, align 8
>   %21 = load i8* %shiftCount, align 1
>   %22 = sext i8 %21 to i32
>   %23 = zext i32 %22 to i64
>   %24 = shl i64 %20, %23
>   %25 = trunc i64 %24 to i32
>   %26 = call i32 @packFloat32(i8 zeroext 1, i32 %19, i32 %25)
>   store i32 %26, i32* %1
>   br label %54
6144,6146c4459,4476
< ; <label>:14                                      ; preds = %4
<   tail call fastcc void @raise_exception_err(i32 13, i32 %1) noreturn
<   unreachable
---
> ; <label>:27                                      ; preds = %7
>   %28 = load i8* %shiftCount, align 1
>   %29 = sext i8 %28 to i32
>   %30 = add nsw i32 %29, 7
>   %31 = trunc i32 %30 to i8
>   store i8 %31, i8* %shiftCount, align 1
>   %32 = load i8* %shiftCount, align 1
>   %33 = sext i8 %32 to i32
>   %34 = icmp slt i32 %33, 0
>   br i1 %34, label %35, label %40
> 
> ; <label>:35                                      ; preds = %27
>   %36 = load i64* %2, align 8
>   %37 = load i8* %shiftCount, align 1
>   %38 = sext i8 %37 to i32
>   %39 = sub nsw i32 0, %38
>   call void @shift64RightJamming(i64 %36, i32 %39, i64* %2)
>   br label %46
6148,6162c4478,4485
< ; <label>:15                                      ; preds = %4
<   %16 = and i32 %new_cs, -8
<   %17 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 1
<   %18 = load i32* %17, align 4
<   %19 = add i32 %18, %16
<   %20 = tail call fastcc i32 @ldl_kernel(i32 %19) nounwind
<   %21 = add i32 %19, 4
<   %22 = tail call fastcc i32 @ldl_kernel(i32 %21) nounwind
<   %23 = load %struct.CPUX86State** @env, align 8
<   %24 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 8
<   %25 = load i32* %24, align 4
<   %26 = and i32 %25, 3
<   %27 = and i32 %22, 4096
<   %28 = icmp eq i32 %27, 0
<   br i1 %28, label %118, label %29
---
> ; <label>:40                                      ; preds = %27
>   %41 = load i8* %shiftCount, align 1
>   %42 = sext i8 %41 to i32
>   %43 = load i64* %2, align 8
>   %44 = zext i32 %42 to i64
>   %45 = shl i64 %43, %44
>   store i64 %45, i64* %2, align 8
>   br label %46
6164,6167c4487,4496
< ; <label>:29                                      ; preds = %15
<   %30 = and i32 %22, 2048
<   %31 = icmp eq i32 %30, 0
<   br i1 %31, label %32, label %33
---
> ; <label>:46                                      ; preds = %40, %35
>   %47 = load i8* %shiftCount, align 1
>   %48 = sext i8 %47 to i32
>   %49 = sub nsw i32 156, %48
>   %50 = load i64* %2, align 8
>   %51 = trunc i64 %50 to i32
>   %52 = load %struct.float_status** %3, align 4
>   %53 = call i32 @roundAndPackFloat32(i8 zeroext 1, i32 %49, i32 %51, %struct.float_status* %52)
>   store i32 %53, i32* %1
>   br label %54
6169,6171c4498,4501
< ; <label>:32                                      ; preds = %29
<   tail call fastcc void @raise_exception_err(i32 13, i32 %1) noreturn
<   unreachable
---
> ; <label>:54                                      ; preds = %46, %16, %6
>   %55 = load i32* %1
>   ret i32 %55
> }
6173,6178c4503,4512
< ; <label>:33                                      ; preds = %29
<   %34 = lshr i32 %22, 13
<   %35 = and i32 %34, 3
<   %36 = and i32 %22, 1024
<   %37 = icmp eq i32 %36, 0
<   br i1 %37, label %41, label %38
---
> define internal i64 @int64_to_float64(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %zSign = alloca i8, align 1
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = icmp eq i64 %4, 0
>   br i1 %5, label %6, label %7
6180,6182c4514,4516
< ; <label>:38                                      ; preds = %33
<   %39 = icmp ugt i32 %35, %26
<   br i1 %39, label %40, label %48
---
> ; <label>:6                                       ; preds = %0
>   store i64 0, i64* %1
>   br label %30
6184,6186c4518,4521
< ; <label>:40                                      ; preds = %38
<   tail call fastcc void @raise_exception_err(i32 13, i32 %1) noreturn
<   unreachable
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i64* %2, align 8
>   %9 = icmp eq i64 %8, -9223372036854775808
>   br i1 %9, label %10, label %12
6188,6191c4523,4526
< ; <label>:41                                      ; preds = %33
<   %42 = and i32 %new_cs, 3
<   %43 = icmp ugt i32 %42, %26
<   br i1 %43, label %44, label %45
---
> ; <label>:10                                      ; preds = %7
>   %11 = call i64 @packFloat64(i8 zeroext 1, i32 1086, i64 0)
>   store i64 %11, i64* %1
>   br label %30
6193,6195c4528,4538
< ; <label>:44                                      ; preds = %41
<   tail call fastcc void @raise_exception_err(i32 13, i32 %1) noreturn
<   unreachable
---
> ; <label>:12                                      ; preds = %7
>   %13 = load i64* %2, align 8
>   %14 = icmp slt i64 %13, 0
>   %15 = zext i1 %14 to i32
>   %16 = trunc i32 %15 to i8
>   store i8 %16, i8* %zSign, align 1
>   %17 = load i8* %zSign, align 1
>   %18 = load i8* %zSign, align 1
>   %19 = zext i8 %18 to i32
>   %20 = icmp ne i32 %19, 0
>   br i1 %20, label %21, label %24
6197,6199c4540,4543
< ; <label>:45                                      ; preds = %41
<   %46 = icmp eq i32 %35, %26
<   br i1 %46, label %48, label %47
---
> ; <label>:21                                      ; preds = %12
>   %22 = load i64* %2, align 8
>   %23 = sub nsw i64 0, %22
>   br label %26
6201,6203c4545,4547
< ; <label>:47                                      ; preds = %45
<   tail call fastcc void @raise_exception_err(i32 13, i32 %1) noreturn
<   unreachable
---
> ; <label>:24                                      ; preds = %12
>   %25 = load i64* %2, align 8
>   br label %26
6205,6208c4549,4554
< ; <label>:48                                      ; preds = %45, %38
<   %49 = and i32 %22, 32768
<   %50 = icmp eq i32 %49, 0
<   br i1 %50, label %51, label %52
---
> ; <label>:26                                      ; preds = %24, %21
>   %27 = phi i64 [ %23, %21 ], [ %25, %24 ]
>   %28 = load %struct.float_status** %3, align 4
>   %29 = call i64 @normalizeRoundAndPackFloat64(i8 zeroext %17, i32 1084, i64 %27, %struct.float_status* %28)
>   store i64 %29, i64* %1
>   br label %30
6210,6212c4556,4559
< ; <label>:51                                      ; preds = %48
<   tail call fastcc void @raise_exception_err(i32 11, i32 %1) noreturn
<   unreachable
---
> ; <label>:30                                      ; preds = %26, %10, %6
>   %31 = load i64* %1
>   ret i64 %31
> }
6214,6220c4561,4590
< ; <label>:52                                      ; preds = %48
<   %53 = and i32 %20, 65535
<   %54 = and i32 %22, 983040
<   %55 = or i32 %54, %53
<   %56 = and i32 %22, 8388608
<   %57 = icmp eq i32 %56, 0
<   br i1 %57, label %get_seg_limit.exit, label %58
---
> define internal i64 @normalizeRoundAndPackFloat64(i8 zeroext %zSign, i32 %zExp, i64 %zSig, %struct.float_status* %status) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %shiftCount = alloca i8, align 1
>   store i8 %zSign, i8* %1, align 1
>   store i32 %zExp, i32* %2, align 4
>   store i64 %zSig, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %3, align 8
>   %6 = call signext i8 @countLeadingZeros64(i64 %5)
>   %7 = sext i8 %6 to i32
>   %8 = sub nsw i32 %7, 1
>   %9 = trunc i32 %8 to i8
>   store i8 %9, i8* %shiftCount, align 1
>   %10 = load i8* %1, align 1
>   %11 = load i32* %2, align 4
>   %12 = load i8* %shiftCount, align 1
>   %13 = sext i8 %12 to i32
>   %14 = sub nsw i32 %11, %13
>   %15 = load i64* %3, align 8
>   %16 = load i8* %shiftCount, align 1
>   %17 = sext i8 %16 to i32
>   %18 = zext i32 %17 to i64
>   %19 = shl i64 %15, %18
>   %20 = load %struct.float_status** %4, align 4
>   %21 = call i64 @roundAndPackFloat64(i8 zeroext %10, i32 %14, i64 %19, %struct.float_status* %20)
>   ret i64 %21
> }
6222,6230c4592,4600
< ; <label>:58                                      ; preds = %52
<   %59 = shl nuw i32 %55, 12
<   %60 = or i32 %59, 4095
<   br label %get_seg_limit.exit
< 
< get_seg_limit.exit:                               ; preds = %58, %52
<   %limit.0.i = phi i32 [ %60, %58 ], [ %55, %52 ]
<   %61 = icmp ult i32 %limit.0.i, %new_eip
<   br i1 %61, label %62, label %69
---
> define internal i64 @uint64_to_float64(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = icmp eq i64 %4, 0
>   br i1 %5, label %6, label %7
6232,6235c4602,4604
< ; <label>:62                                      ; preds = %get_seg_limit.exit
<   %63 = and i32 %25, 16384
<   %64 = icmp eq i32 %63, 0
<   br i1 %64, label %65, label %69
---
> ; <label>:6                                       ; preds = %0
>   store i64 0, i64* %1
>   br label %11
6237,6240c4606,4611
< ; <label>:65                                      ; preds = %62
<   %66 = and i32 %22, 2097152
<   %67 = icmp eq i32 %66, 0
<   br i1 %67, label %68, label %69
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i64* %2, align 8
>   %9 = load %struct.float_status** %3, align 4
>   %10 = call i64 @normalizeRoundAndPackFloat64(i8 zeroext 0, i32 1084, i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %1
>   br label %11
6242,6244c4613,4616
< ; <label>:68                                      ; preds = %65
<   tail call fastcc void @raise_exception_err(i32 13, i32 %1) noreturn
<   unreachable
---
> ; <label>:11                                      ; preds = %7, %6
>   %12 = load i64* %1
>   ret i64 %12
> }
6246,6275c4618,4628
< ; <label>:69                                      ; preds = %65, %62, %get_seg_limit.exit
<   %70 = or i32 %26, %1
<   %71 = lshr i32 %20, 16
<   %72 = shl i32 %22, 16
<   %73 = and i32 %72, 16711680
<   %74 = and i32 %22, -16777216
<   %75 = or i32 %74, %71
<   %76 = or i32 %75, %73
<   %77 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 10, i64 1, i32 0
<   store i32 %70, i32* %77, align 4
<   %78 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 10, i64 1, i32 1
<   store i32 %76, i32* %78, align 4
<   %79 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 10, i64 1, i32 2
<   store i32 %limit.0.i, i32* %79, align 4
<   %80 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 10, i64 1, i32 3
<   store i32 %22, i32* %80, align 4
<   %81 = lshr i32 %22, 18
<   %82 = and i32 %81, 16
<   %83 = and i32 %25, -32785
<   %84 = or i32 %83, %82
<   store i32 %84, i32* %24, align 4
<   %85 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 10, i64 2, i32 3
<   %86 = load i32* %85, align 4
<   %87 = lshr i32 %86, 17
<   %88 = and i32 %87, 32
<   %89 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 15, i64 0
<   %90 = load i32* %89, align 4
<   %91 = and i32 %90, 1
<   %92 = icmp eq i32 %91, 0
<   br i1 %92, label %99, label %93
---
> define internal void @int64_to_floatx80(%struct.floatx80* noalias sret %agg.result, i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %zSign = alloca i8, align 1
>   %absA = alloca i64, align 8
>   %shiftCount = alloca i8, align 1
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i64* %1, align 8
>   %4 = icmp eq i64 %3, 0
>   br i1 %4, label %5, label %6
6277,6327c4630,4632
< ; <label>:93                                      ; preds = %69
<   %94 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 7
<   %95 = load i32* %94, align 4
<   %96 = and i32 %95, 131072
<   %97 = icmp ne i32 %96, 0
<   %98 = icmp eq i32 %82, 0
<   %or.cond85 = or i1 %97, %98
<   br i1 %or.cond85, label %99, label %101
< 
< ; <label>:99                                      ; preds = %93, %69
<   %100 = or i32 %88, 64
<   br label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:101                                     ; preds = %93
<   %102 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 10, i64 3, i32 1
<   %103 = load i32* %102, align 4
<   %104 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 10, i64 0, i32 1
<   %105 = load i32* %104, align 4
<   %106 = or i32 %105, %103
<   %107 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 10, i64 2, i32 1
<   %108 = load i32* %107, align 4
<   %109 = or i32 %106, %108
<   %110 = icmp ne i32 %109, 0
<   %111 = zext i1 %110 to i32
<   %112 = shl nuw nsw i32 %111, 6
<   %113 = or i32 %112, %88
<   br label %cpu_x86_load_seg_cache.exit
< 
< cpu_x86_load_seg_cache.exit:                      ; preds = %101, %99
<   %new_hflags.0.i = phi i32 [ %100, %99 ], [ %113, %101 ]
<   %114 = and i32 %84, -32865
<   %115 = or i32 %new_hflags.0.i, %114
<   store i32 %115, i32* %24, align 4
<   %116 = load %struct.CPUX86State** @env, align 8
<   %117 = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 5
<   store i32 %new_eip, i32* %117, align 4
<   br label %251
< 
< ; <label>:118                                     ; preds = %15
<   %119 = lshr i32 %22, 13
<   %120 = and i32 %119, 3
<   %121 = and i32 %new_cs, 3
<   %122 = lshr i32 %22, 8
<   %123 = and i32 %122, 15
<   switch i32 %123, label %250 [
<     i32 1, label %124
<     i32 9, label %124
<     i32 5, label %124
<     i32 4, label %134
<     i32 12, label %134
<   ]
---
> ; <label>:5                                       ; preds = %0
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext 0, i32 0, i64 0)
>   br label %32
6329,6333c4634,4643
< ; <label>:124                                     ; preds = %118, %118, %118
<   %125 = icmp ult i32 %120, %26
<   %126 = icmp ult i32 %120, %121
<   %or.cond = or i1 %125, %126
<   br i1 %or.cond, label %127, label %128
---
> ; <label>:6                                       ; preds = %0
>   %7 = load i64* %1, align 8
>   %8 = icmp slt i64 %7, 0
>   %9 = zext i1 %8 to i32
>   %10 = trunc i32 %9 to i8
>   store i8 %10, i8* %zSign, align 1
>   %11 = load i8* %zSign, align 1
>   %12 = zext i8 %11 to i32
>   %13 = icmp ne i32 %12, 0
>   br i1 %13, label %14, label %17
6335,6337c4645,4648
< ; <label>:127                                     ; preds = %124
<   tail call fastcc void @raise_exception_err(i32 13, i32 %1) noreturn
<   unreachable
---
> ; <label>:14                                      ; preds = %6
>   %15 = load i64* %1, align 8
>   %16 = sub nsw i64 0, %15
>   br label %19
6339,6353c4650,4652
< ; <label>:128                                     ; preds = %124
<   %129 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 5
<   %130 = load i32* %129, align 4
<   %131 = add i32 %130, %next_eip_addend
<   tail call fastcc void @switch_tss(i32 %new_cs, i32 %20, i32 %22, i32 0, i32 %131)
<   %132 = load %struct.CPUX86State** @env, align 8
<   %133 = getelementptr inbounds %struct.CPUX86State* %132, i64 0, i32 1
<   store i32 1, i32* %133, align 4
<   br label %251
< 
< ; <label>:134                                     ; preds = %118, %118
<   %135 = icmp ult i32 %120, %26
<   %136 = icmp ult i32 %120, %121
<   %or.cond49 = or i1 %135, %136
<   br i1 %or.cond49, label %137, label %138
---
> ; <label>:17                                      ; preds = %6
>   %18 = load i64* %1, align 8
>   br label %19
6355,6357c4654,4670
< ; <label>:137                                     ; preds = %134
<   tail call fastcc void @raise_exception_err(i32 13, i32 %1) noreturn
<   unreachable
---
> ; <label>:19                                      ; preds = %17, %14
>   %20 = phi i64 [ %16, %14 ], [ %18, %17 ]
>   store i64 %20, i64* %absA, align 8
>   %21 = load i64* %absA, align 8
>   %22 = call signext i8 @countLeadingZeros64(i64 %21)
>   store i8 %22, i8* %shiftCount, align 1
>   %23 = load i8* %zSign, align 1
>   %24 = load i8* %shiftCount, align 1
>   %25 = sext i8 %24 to i32
>   %26 = sub nsw i32 16446, %25
>   %27 = load i64* %absA, align 8
>   %28 = load i8* %shiftCount, align 1
>   %29 = sext i8 %28 to i32
>   %30 = zext i32 %29 to i64
>   %31 = shl i64 %27, %30
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %23, i32 %26, i64 %31)
>   br label %32
6359,6362c4672,4674
< ; <label>:138                                     ; preds = %134
<   %139 = and i32 %22, 32768
<   %140 = icmp eq i32 %139, 0
<   br i1 %140, label %141, label %142
---
> ; <label>:32                                      ; preds = %19, %5
>   ret void
> }
6364,6366c4676,4689
< ; <label>:141                                     ; preds = %138
<   tail call fastcc void @raise_exception_err(i32 11, i32 %1) noreturn
<   unreachable
---
> define internal void @int64_to_float128(%struct.float128* noalias sret %agg.result, i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %zSign = alloca i8, align 1
>   %absA = alloca i64, align 8
>   %shiftCount = alloca i8, align 1
>   %zExp = alloca i32, align 4
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i64* %1, align 8
>   %4 = icmp eq i64 %3, 0
>   br i1 %4, label %5, label %6
6368,6372c4691,4693
< ; <label>:142                                     ; preds = %138
<   %143 = lshr i32 %20, 16
<   %144 = and i32 %20, 65535
<   %145 = icmp eq i32 %123, 12
<   br i1 %145, label %146, label %149
---
> ; <label>:5                                       ; preds = %0
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext 0, i32 0, i64 0, i64 0)
>   br label %49
6374,6377c4695,4704
< ; <label>:146                                     ; preds = %142
<   %147 = and i32 %22, -65536
<   %148 = or i32 %147, %144
<   br label %149
---
> ; <label>:6                                       ; preds = %0
>   %7 = load i64* %1, align 8
>   %8 = icmp slt i64 %7, 0
>   %9 = zext i1 %8 to i32
>   %10 = trunc i32 %9 to i8
>   store i8 %10, i8* %zSign, align 1
>   %11 = load i8* %zSign, align 1
>   %12 = zext i8 %11 to i32
>   %13 = icmp ne i32 %12, 0
>   br i1 %13, label %14, label %17
6379,6395c4706,4709
< ; <label>:149                                     ; preds = %146, %142
<   %.0 = phi i32 [ %148, %146 ], [ %144, %142 ]
<   %150 = and i32 %143, 4
<   %151 = icmp eq i32 %150, 0
<   %152 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 11
<   %153 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 13
<   %dt.0.i54 = select i1 %151, %struct.SegmentCache* %153, %struct.SegmentCache* %152
<   %154 = or i32 %143, 7
<   %155 = getelementptr inbounds %struct.SegmentCache* %dt.0.i54, i64 0, i32 2
<   %156 = load i32* %155, align 4
<   %157 = icmp ugt i32 %154, %156
<   br i1 %157, label %158, label %160
< 
< ; <label>:158                                     ; preds = %149
<   %159 = and i32 %143, 65532
<   tail call fastcc void @raise_exception_err(i32 13, i32 %159) noreturn
<   unreachable
---
> ; <label>:14                                      ; preds = %6
>   %15 = load i64* %1, align 8
>   %16 = sub nsw i64 0, %15
>   br label %19
6397,6414c4711,4713
< ; <label>:160                                     ; preds = %149
<   %161 = and i32 %143, 65528
<   %162 = getelementptr inbounds %struct.SegmentCache* %dt.0.i54, i64 0, i32 1
<   %163 = load i32* %162, align 4
<   %164 = add i32 %163, %161
<   %165 = tail call fastcc i32 @ldl_kernel(i32 %164) nounwind
<   %166 = add i32 %164, 4
<   %167 = tail call fastcc i32 @ldl_kernel(i32 %166) nounwind
<   %168 = lshr i32 %167, 13
<   %169 = and i32 %168, 3
<   %170 = and i32 %167, 6144
<   %171 = icmp eq i32 %170, 6144
<   br i1 %171, label %174, label %172
< 
< ; <label>:172                                     ; preds = %160
<   %173 = and i32 %143, 65532
<   tail call fastcc void @raise_exception_err(i32 13, i32 %173) noreturn
<   unreachable
---
> ; <label>:17                                      ; preds = %6
>   %18 = load i64* %1, align 8
>   br label %19
6416,6429c4715,4742
< ; <label>:174                                     ; preds = %160
<   %175 = and i32 %167, 1024
<   %176 = icmp ne i32 %175, 0
<   %177 = icmp ugt i32 %169, %26
<   %or.cond50 = and i1 %176, %177
<   %178 = icmp eq i32 %169, %26
<   %or.cond51 = or i1 %176, %178
<   %or.cond86 = xor i1 %or.cond50, %or.cond51
<   br i1 %or.cond86, label %181, label %179
< 
< ; <label>:179                                     ; preds = %174
<   %180 = and i32 %143, 65532
<   tail call fastcc void @raise_exception_err(i32 13, i32 %180) noreturn
<   unreachable
---
> ; <label>:19                                      ; preds = %17, %14
>   %20 = phi i64 [ %16, %14 ], [ %18, %17 ]
>   store i64 %20, i64* %absA, align 8
>   %21 = load i64* %absA, align 8
>   %22 = call signext i8 @countLeadingZeros64(i64 %21)
>   %23 = sext i8 %22 to i32
>   %24 = add nsw i32 %23, 49
>   %25 = trunc i32 %24 to i8
>   store i8 %25, i8* %shiftCount, align 1
>   %26 = load i8* %shiftCount, align 1
>   %27 = sext i8 %26 to i32
>   %28 = sub nsw i32 16494, %27
>   store i32 %28, i32* %zExp, align 4
>   %29 = load i8* %shiftCount, align 1
>   %30 = sext i8 %29 to i32
>   %31 = icmp sle i32 64, %30
>   br i1 %31, label %32, label %38
> 
> ; <label>:32                                      ; preds = %19
>   store i64 0, i64* %zSig1, align 8
>   %33 = load i64* %absA, align 8
>   store i64 %33, i64* %zSig0, align 8
>   %34 = load i8* %shiftCount, align 1
>   %35 = sext i8 %34 to i32
>   %36 = sub nsw i32 %35, 64
>   %37 = trunc i32 %36 to i8
>   store i8 %37, i8* %shiftCount, align 1
>   br label %40
6431,6434c4744,4748
< ; <label>:181                                     ; preds = %174
<   %182 = and i32 %167, 32768
<   %183 = icmp eq i32 %182, 0
<   br i1 %183, label %184, label %186
---
> ; <label>:38                                      ; preds = %19
>   %39 = load i64* %absA, align 8
>   store i64 %39, i64* %zSig1, align 8
>   store i64 0, i64* %zSig0, align 8
>   br label %40
6436,6439c4750,4761
< ; <label>:184                                     ; preds = %181
<   %185 = and i32 %143, 65532
<   tail call fastcc void @raise_exception_err(i32 13, i32 %185) noreturn
<   unreachable
---
> ; <label>:40                                      ; preds = %38, %32
>   %41 = load i64* %zSig0, align 8
>   %42 = load i64* %zSig1, align 8
>   %43 = load i8* %shiftCount, align 1
>   %44 = sext i8 %43 to i32
>   call void @shortShift128Left(i64 %41, i64 %42, i32 %44, i64* %zSig0, i64* %zSig1)
>   %45 = load i8* %zSign, align 1
>   %46 = load i32* %zExp, align 4
>   %47 = load i64* %zSig0, align 8
>   %48 = load i64* %zSig1, align 8
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %45, i32 %46, i64 %47, i64 %48)
>   br label %49
6441,6457c4763,4765
< ; <label>:186                                     ; preds = %181
<   %187 = and i32 %165, 65535
<   %188 = and i32 %167, 983040
<   %189 = or i32 %188, %187
<   %190 = and i32 %167, 8388608
<   %191 = icmp eq i32 %190, 0
<   br i1 %191, label %get_seg_limit.exit58, label %192
< 
< ; <label>:192                                     ; preds = %186
<   %193 = shl nuw i32 %189, 12
<   %194 = or i32 %193, 4095
<   br label %get_seg_limit.exit58
< 
< get_seg_limit.exit58:                             ; preds = %192, %186
<   %limit.0.i57 = phi i32 [ %194, %192 ], [ %189, %186 ]
<   %195 = icmp ugt i32 %.0, %limit.0.i57
<   br i1 %195, label %196, label %197
---
> ; <label>:49                                      ; preds = %40, %5
>   ret void
> }
6459,6461c4767,4786
< ; <label>:196                                     ; preds = %get_seg_limit.exit58
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn
<   unreachable
---
> define internal void @shortShift128Left(i64 %a0, i64 %a1, i32 %count, i64* %z0Ptr, i64* %z1Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i32, align 4
>   %4 = alloca i64*, align 4
>   %5 = alloca i64*, align 4
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i32 %count, i32* %3, align 4
>   store i64* %z0Ptr, i64** %4, align 4
>   store i64* %z1Ptr, i64** %5, align 4
>   %6 = load i64* %2, align 8
>   %7 = load i32* %3, align 4
>   %8 = zext i32 %7 to i64
>   %9 = shl i64 %6, %8
>   %10 = load i64** %5, align 4
>   store i64 %9, i64* %10, align 4
>   %11 = load i32* %3, align 4
>   %12 = icmp eq i32 %11, 0
>   br i1 %12, label %13, label %15
6463,6534c4788,4790
< ; <label>:197                                     ; preds = %get_seg_limit.exit58
<   %198 = load %struct.CPUX86State** @env, align 8
<   %199 = and i32 %143, 65532
<   %200 = or i32 %26, %199
<   %201 = lshr i32 %165, 16
<   %202 = shl i32 %167, 16
<   %203 = and i32 %202, 16711680
<   %204 = and i32 %167, -16777216
<   %205 = or i32 %204, %201
<   %206 = or i32 %205, %203
<   %207 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 10, i64 1, i32 0
<   store i32 %200, i32* %207, align 4
<   %208 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 10, i64 1, i32 1
<   store i32 %206, i32* %208, align 4
<   %209 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 10, i64 1, i32 2
<   store i32 %limit.0.i57, i32* %209, align 4
<   %210 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 10, i64 1, i32 3
<   store i32 %167, i32* %210, align 4
<   %211 = lshr i32 %167, 18
<   %212 = and i32 %211, 16
<   %213 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 8
<   %214 = load i32* %213, align 4
<   %215 = and i32 %214, -32785
<   %216 = or i32 %215, %212
<   store i32 %216, i32* %213, align 4
<   %217 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 10, i64 2, i32 3
<   %218 = load i32* %217, align 4
<   %219 = lshr i32 %218, 17
<   %220 = and i32 %219, 32
<   %221 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 15, i64 0
<   %222 = load i32* %221, align 4
<   %223 = and i32 %222, 1
<   %224 = icmp eq i32 %223, 0
<   br i1 %224, label %231, label %225
< 
< ; <label>:225                                     ; preds = %197
<   %226 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 7
<   %227 = load i32* %226, align 4
<   %228 = and i32 %227, 131072
<   %229 = icmp ne i32 %228, 0
<   %230 = icmp eq i32 %212, 0
<   %or.cond87 = or i1 %229, %230
<   br i1 %or.cond87, label %231, label %233
< 
< ; <label>:231                                     ; preds = %225, %197
<   %232 = or i32 %220, 64
<   br label %cpu_x86_load_seg_cache.exit53
< 
< ; <label>:233                                     ; preds = %225
<   %234 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 10, i64 3, i32 1
<   %235 = load i32* %234, align 4
<   %236 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 10, i64 0, i32 1
<   %237 = load i32* %236, align 4
<   %238 = or i32 %237, %235
<   %239 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 10, i64 2, i32 1
<   %240 = load i32* %239, align 4
<   %241 = or i32 %238, %240
<   %242 = icmp ne i32 %241, 0
<   %243 = zext i1 %242 to i32
<   %244 = shl nuw nsw i32 %243, 6
<   %245 = or i32 %244, %220
<   br label %cpu_x86_load_seg_cache.exit53
< 
< cpu_x86_load_seg_cache.exit53:                    ; preds = %233, %231
<   %new_hflags.0.i52 = phi i32 [ %232, %231 ], [ %245, %233 ]
<   %246 = and i32 %216, -32865
<   %247 = or i32 %new_hflags.0.i52, %246
<   store i32 %247, i32* %213, align 4
<   %248 = load %struct.CPUX86State** @env, align 8
<   %249 = getelementptr inbounds %struct.CPUX86State* %248, i64 0, i32 5
<   store i32 %.0, i32* %249, align 4
<   br label %251
---
> ; <label>:13                                      ; preds = %0
>   %14 = load i64* %1, align 8
>   br label %27
6536,6538c4792,4804
< ; <label>:250                                     ; preds = %118
<   tail call fastcc void @raise_exception_err(i32 13, i32 %1) noreturn
<   unreachable
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i64* %1, align 8
>   %17 = load i32* %3, align 4
>   %18 = zext i32 %17 to i64
>   %19 = shl i64 %16, %18
>   %20 = load i64* %2, align 8
>   %21 = load i32* %3, align 4
>   %22 = sub nsw i32 0, %21
>   %23 = and i32 %22, 63
>   %24 = zext i32 %23 to i64
>   %25 = lshr i64 %20, %24
>   %26 = or i64 %19, %25
>   br label %27
6540c4806,4809
< ; <label>:251                                     ; preds = %cpu_x86_load_seg_cache.exit53, %128, %cpu_x86_load_seg_cache.exit
---
> ; <label>:27                                      ; preds = %15, %13
>   %28 = phi i64 [ %14, %13 ], [ %26, %15 ]
>   %29 = load i64** %4, align 4
>   store i64 %28, i64* %29, align 4
6544,6550c4813,4838
< define internal fastcc void @switch_tss(i32 %tss_selector, i32 %e1, i32 %e2, i32 %source, i32 %next_eip) nounwind uwtable {
<   %new_regs = alloca [8 x i32], align 16
<   %new_segs = alloca [6 x i32], align 16
<   %1 = lshr i32 %e2, 8
<   %2 = and i32 %1, 15
<   %3 = icmp eq i32 %2, 5
<   br i1 %3, label %4, label %42
---
> define internal i32 @float32_to_int32(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %aSig64 = alloca i64, align 8
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = load %struct.float_status** %2, align 4
>   %5 = call i32 @float32_squash_input_denormal(i32 %3, %struct.float_status* %4)
>   store i32 %5, i32* %1, align 4
>   %6 = load i32* %1, align 4
>   %7 = call i32 @extractFloat32Frac(i32 %6)
>   store i32 %7, i32* %aSig, align 4
>   %8 = load i32* %1, align 4
>   %9 = call i32 @extractFloat32Exp(i32 %8)
>   store i32 %9, i32* %aExp, align 4
>   %10 = load i32* %1, align 4
>   %11 = call zeroext i8 @extractFloat32Sign(i32 %10)
>   store i8 %11, i8* %aSign, align 1
>   %12 = load i32* %aExp, align 4
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %18
6552,6555c4840,4843
< ; <label>:4                                       ; preds = %0
<   %5 = and i32 %e2, 32768
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %7, label %9
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %aSig, align 4
>   %16 = icmp ne i32 %15, 0
>   br i1 %16, label %17, label %18
6557,6560c4845,4847
< ; <label>:7                                       ; preds = %4
<   %8 = and i32 %tss_selector, 65532
<   call fastcc void @raise_exception_err(i32 11, i32 %8) noreturn
<   unreachable
---
> ; <label>:17                                      ; preds = %14
>   store i8 0, i8* %aSign, align 1
>   br label %18
6562,6566c4849,4852
< ; <label>:9                                       ; preds = %4
<   %10 = lshr i32 %e1, 16
<   %11 = and i32 %10, 4
<   %12 = icmp eq i32 %11, 0
<   br i1 %12, label %15, label %13
---
> ; <label>:18                                      ; preds = %17, %14, %0
>   %19 = load i32* %aExp, align 4
>   %20 = icmp ne i32 %19, 0
>   br i1 %20, label %21, label %24
6568,6571c4854,4858
< ; <label>:13                                      ; preds = %9
<   %14 = and i32 %10, 65532
<   call fastcc void @raise_exception_err(i32 10, i32 %14) noreturn
<   unreachable
---
> ; <label>:21                                      ; preds = %18
>   %22 = load i32* %aSig, align 4
>   %23 = or i32 %22, 8388608
>   store i32 %23, i32* %aSig, align 4
>   br label %24
6573,6579c4860,4878
< ; <label>:15                                      ; preds = %9
<   %16 = load %struct.CPUX86State** @env, align 8
<   %17 = or i32 %10, 7
<   %18 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 13, i32 2
<   %19 = load i32* %18, align 4
<   %20 = icmp ugt i32 %17, %19
<   br i1 %20, label %21, label %23
---
> ; <label>:24                                      ; preds = %21, %18
>   %25 = load i32* %aExp, align 4
>   %26 = sub nsw i32 175, %25
>   store i32 %26, i32* %shiftCount, align 4
>   %27 = load i32* %aSig, align 4
>   %28 = zext i32 %27 to i64
>   store i64 %28, i64* %aSig64, align 8
>   %29 = load i64* %aSig64, align 8
>   %30 = shl i64 %29, 32
>   store i64 %30, i64* %aSig64, align 8
>   %31 = load i32* %shiftCount, align 4
>   %32 = icmp slt i32 0, %31
>   br i1 %32, label %33, label %36
> 
> ; <label>:33                                      ; preds = %24
>   %34 = load i64* %aSig64, align 8
>   %35 = load i32* %shiftCount, align 4
>   call void @shift64RightJamming(i64 %34, i32 %35, i64* %aSig64)
>   br label %36
6581,6584c4880,4886
< ; <label>:21                                      ; preds = %15
<   %22 = and i32 %10, 65532
<   call fastcc void @raise_exception_err(i32 13, i32 %22) noreturn
<   unreachable
---
> ; <label>:36                                      ; preds = %33, %24
>   %37 = load i8* %aSign, align 1
>   %38 = load i64* %aSig64, align 8
>   %39 = load %struct.float_status** %2, align 4
>   %40 = call i32 @roundAndPackInt32(i8 zeroext %37, i64 %38, %struct.float_status* %39)
>   ret i32 %40
> }
6586,6596c4888,4898
< ; <label>:23                                      ; preds = %15
<   %24 = and i32 %10, 65528
<   %25 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 13, i32 1
<   %26 = load i32* %25, align 4
<   %27 = add i32 %26, %24
<   %28 = call fastcc i32 @ldl_kernel(i32 %27) nounwind
<   %29 = add i32 %27, 4
<   %30 = call fastcc i32 @ldl_kernel(i32 %29) nounwind
<   %31 = and i32 %30, 4096
<   %32 = icmp eq i32 %31, 0
<   br i1 %32, label %35, label %33
---
> define internal i32 @float32_squash_input_denormal(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load %struct.float_status** %3, align 4
>   %5 = getelementptr inbounds %struct.float_status* %4, i32 0, i32 5
>   %6 = load i8* %5, align 1
>   %7 = icmp ne i8 %6, 0
>   br i1 %7, label %8, label %21
6598,6601c4900,4904
< ; <label>:33                                      ; preds = %23
<   %34 = and i32 %10, 65532
<   call fastcc void @raise_exception_err(i32 13, i32 %34) noreturn
<   unreachable
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i32* %2, align 4
>   %10 = call i32 @extractFloat32Exp(i32 %9)
>   %11 = icmp eq i32 %10, 0
>   br i1 %11, label %12, label %20
6603,6608c4906,4910
< ; <label>:35                                      ; preds = %23
<   %36 = lshr i32 %30, 8
<   %37 = and i32 %36, 15
<   %38 = and i32 %36, 7
<   %39 = icmp eq i32 %38, 1
<   br i1 %39, label %42, label %40
---
> ; <label>:12                                      ; preds = %8
>   %13 = load i32* %2, align 4
>   %14 = call i32 @extractFloat32Frac(i32 %13)
>   %15 = icmp ne i32 %14, 0
>   br i1 %15, label %16, label %20
6610,6613c4912,4918
< ; <label>:40                                      ; preds = %35
<   %41 = and i32 %10, 65532
<   call fastcc void @raise_exception_err(i32 13, i32 %41) noreturn
<   unreachable
---
> ; <label>:16                                      ; preds = %12
>   %17 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 64, %struct.float_status* %17)
>   %18 = load i32* %2, align 4
>   %19 = and i32 %18, -2147483648
>   store i32 %19, i32* %1
>   br label %23
6615,6622c4920,4921
< ; <label>:42                                      ; preds = %35, %0
<   %e1115 = phi i32 [ %28, %35 ], [ %e1, %0 ]
<   %e2114 = phi i32 [ %30, %35 ], [ %e2, %0 ]
<   %type.0 = phi i32 [ %37, %35 ], [ %2, %0 ]
<   %.0 = phi i32 [ %10, %35 ], [ %tss_selector, %0 ]
<   %43 = and i32 %e2114, 32768
<   %44 = icmp eq i32 %43, 0
<   br i1 %44, label %45, label %47
---
> ; <label>:20                                      ; preds = %12, %8
>   br label %21
6624,6627c4923,4926
< ; <label>:45                                      ; preds = %42
<   %46 = and i32 %.0, 65532
<   call fastcc void @raise_exception_err(i32 11, i32 %46) noreturn
<   unreachable
---
> ; <label>:21                                      ; preds = %20, %0
>   %22 = load i32* %2, align 4
>   store i32 %22, i32* %1
>   br label %23
6629,6638c4928,4931
< ; <label>:47                                      ; preds = %42
<   %48 = and i32 %type.0, 8
<   %49 = icmp ne i32 %48, 0
<   %. = select i1 %49, i32 103, i32 43
<   %50 = and i32 %e1115, 65535
<   %51 = and i32 %e2114, 983040
<   %52 = or i32 %51, %50
<   %53 = and i32 %e2114, 8388608
<   %54 = icmp eq i32 %53, 0
<   br i1 %54, label %get_seg_limit.exit, label %55
---
> ; <label>:23                                      ; preds = %21, %16
>   %24 = load i32* %1
>   ret i32 %24
> }
6640,6662c4933,4939
< ; <label>:55                                      ; preds = %47
<   %56 = shl nuw i32 %52, 12
<   %57 = or i32 %56, 4095
<   br label %get_seg_limit.exit
< 
< get_seg_limit.exit:                               ; preds = %55, %47
<   %limit.0.i = phi i32 [ %57, %55 ], [ %52, %47 ]
<   %58 = lshr i32 %e1115, 16
<   %59 = shl i32 %e2114, 16
<   %60 = and i32 %59, 16711680
<   %61 = and i32 %e2114, -16777216
<   %62 = or i32 %61, %58
<   %63 = or i32 %62, %60
<   %64 = and i32 %.0, 4
<   %65 = icmp ne i32 %64, 0
<   %66 = icmp slt i32 %limit.0.i, %.
<   %or.cond = or i1 %65, %66
<   br i1 %or.cond, label %67, label %69
< 
< ; <label>:67                                      ; preds = %get_seg_limit.exit
<   %68 = and i32 %.0, 65532
<   call fastcc void @raise_exception_err(i32 10, i32 %68) noreturn
<   unreachable
---
> define internal i32 @extractFloat32Frac(i32 %a) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   store i32 %a, i32* %1, align 4
>   %2 = load i32* %1, align 4
>   %3 = and i32 %2, 8388607
>   ret i32 %3
> }
6664,6671c4941,4948
< ; <label>:69                                      ; preds = %get_seg_limit.exit
<   %70 = load %struct.CPUX86State** @env, align 8
<   %71 = getelementptr inbounds %struct.CPUX86State* %70, i64 0, i32 12, i32 3
<   %72 = load i32* %71, align 4
<   %73 = and i32 %72, 2048
<   %74 = icmp eq i32 %73, 0
<   %.100 = select i1 %74, i32 43, i32 103
<   br i1 %49, label %.preheader131, label %.preheader134
---
> define internal i32 @extractFloat32Exp(i32 %a) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   store i32 %a, i32* %1, align 4
>   %2 = load i32* %1, align 4
>   %3 = lshr i32 %2, 23
>   %4 = and i32 %3, 255
>   ret i32 %4
> }
6673,6740c4950,4957
< .preheader131:                                    ; preds = %69
<   %75 = add i32 %63, 28
<   %76 = call fastcc i32 @ldl_kernel(i32 %75)
<   %77 = add i32 %63, 32
<   %78 = call fastcc i32 @ldl_kernel(i32 %77)
<   %79 = add i32 %63, 36
<   %80 = call fastcc i32 @ldl_kernel(i32 %79)
<   %81 = add i32 %63, 40
<   %82 = call fastcc i32 @ldl_kernel(i32 %81)
<   %83 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 0
<   store i32 %82, i32* %83, align 16
<   %84 = add i32 %63, 44
<   %85 = call fastcc i32 @ldl_kernel(i32 %84)
<   %86 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 1
<   store i32 %85, i32* %86, align 4
<   %87 = add i32 %63, 48
<   %88 = call fastcc i32 @ldl_kernel(i32 %87)
<   %89 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 2
<   store i32 %88, i32* %89, align 8
<   %90 = add i32 %63, 52
<   %91 = call fastcc i32 @ldl_kernel(i32 %90)
<   %92 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 3
<   store i32 %91, i32* %92, align 4
<   %93 = add i32 %63, 56
<   %94 = call fastcc i32 @ldl_kernel(i32 %93)
<   %95 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 4
<   store i32 %94, i32* %95, align 16
<   %96 = add i32 %63, 60
<   %97 = call fastcc i32 @ldl_kernel(i32 %96)
<   %98 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 5
<   store i32 %97, i32* %98, align 4
<   %99 = add i32 %63, 64
<   %100 = call fastcc i32 @ldl_kernel(i32 %99)
<   %101 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 6
<   store i32 %100, i32* %101, align 8
<   %102 = add i32 %63, 68
<   %103 = call fastcc i32 @ldl_kernel(i32 %102)
<   %104 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 7
<   store i32 %103, i32* %104, align 4
<   %105 = add i32 %63, 72
<   %106 = call fastcc i32 @lduw_kernel(i32 %105)
<   %107 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 0
<   store i32 %106, i32* %107, align 16
<   %108 = add i32 %63, 76
<   %109 = call fastcc i32 @lduw_kernel(i32 %108)
<   %110 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 1
<   store i32 %109, i32* %110, align 4
<   %111 = add i32 %63, 80
<   %112 = call fastcc i32 @lduw_kernel(i32 %111)
<   %113 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 2
<   store i32 %112, i32* %113, align 8
<   %114 = add i32 %63, 84
<   %115 = call fastcc i32 @lduw_kernel(i32 %114)
<   %116 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 3
<   store i32 %115, i32* %116, align 4
<   %117 = add i32 %63, 88
<   %118 = call fastcc i32 @lduw_kernel(i32 %117)
<   %119 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 4
<   store i32 %118, i32* %119, align 16
<   %120 = add i32 %63, 92
<   %121 = call fastcc i32 @lduw_kernel(i32 %120)
<   %122 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 5
<   store i32 %121, i32* %122, align 4
<   %123 = add i32 %63, 96
<   %124 = call fastcc i32 @lduw_kernel(i32 %123)
<   %125 = add i32 %63, 100
<   %126 = call fastcc i32 @ldl_kernel(i32 %125)
<   br label %178
---
> define internal zeroext i8 @extractFloat32Sign(i32 %a) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   store i32 %a, i32* %1, align 4
>   %2 = load i32* %1, align 4
>   %3 = lshr i32 %2, 31
>   %4 = trunc i32 %3 to i8
>   ret i8 %4
> }
6742,6808c4959,4985
< .preheader134:                                    ; preds = %69
<   %127 = add i32 %63, 14
<   %128 = call fastcc i32 @lduw_kernel(i32 %127)
<   %129 = add i32 %63, 16
<   %130 = call fastcc i32 @lduw_kernel(i32 %129)
<   %131 = add i32 %63, 18
<   %132 = call fastcc i32 @lduw_kernel(i32 %131)
<   %133 = or i32 %132, -65536
<   %134 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 0
<   store i32 %133, i32* %134, align 16
<   %135 = add i32 %63, 20
<   %136 = call fastcc i32 @lduw_kernel(i32 %135)
<   %137 = or i32 %136, -65536
<   %138 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 1
<   store i32 %137, i32* %138, align 4
<   %139 = add i32 %63, 22
<   %140 = call fastcc i32 @lduw_kernel(i32 %139)
<   %141 = or i32 %140, -65536
<   %142 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 2
<   store i32 %141, i32* %142, align 8
<   %143 = add i32 %63, 24
<   %144 = call fastcc i32 @lduw_kernel(i32 %143)
<   %145 = or i32 %144, -65536
<   %146 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 3
<   store i32 %145, i32* %146, align 4
<   %147 = add i32 %63, 26
<   %148 = call fastcc i32 @lduw_kernel(i32 %147)
<   %149 = or i32 %148, -65536
<   %150 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 4
<   store i32 %149, i32* %150, align 16
<   %151 = add i32 %63, 28
<   %152 = call fastcc i32 @lduw_kernel(i32 %151)
<   %153 = or i32 %152, -65536
<   %154 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 5
<   store i32 %153, i32* %154, align 4
<   %155 = add i32 %63, 30
<   %156 = call fastcc i32 @lduw_kernel(i32 %155)
<   %157 = or i32 %156, -65536
<   %158 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 6
<   store i32 %157, i32* %158, align 8
<   %159 = add i32 %63, 32
<   %160 = call fastcc i32 @lduw_kernel(i32 %159)
<   %161 = or i32 %160, -65536
<   %162 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 7
<   store i32 %161, i32* %162, align 4
<   %163 = add i32 %63, 34
<   %164 = call fastcc i32 @lduw_kernel(i32 %163)
<   %165 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 0
<   store i32 %164, i32* %165, align 16
<   %166 = add i32 %63, 38
<   %167 = call fastcc i32 @lduw_kernel(i32 %166)
<   %168 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 1
<   store i32 %167, i32* %168, align 4
<   %169 = add i32 %63, 42
<   %170 = call fastcc i32 @lduw_kernel(i32 %169)
<   %171 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 2
<   store i32 %170, i32* %171, align 8
<   %172 = add i32 %63, 46
<   %173 = call fastcc i32 @lduw_kernel(i32 %172)
<   %174 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 3
<   store i32 %173, i32* %174, align 4
<   %175 = call fastcc i32 @lduw_kernel(i32 %169)
<   %176 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 4
<   store i32 0, i32* %176, align 16
<   %177 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 5
<   store i32 0, i32* %177, align 4
<   br label %178
---
> define internal i32 @roundAndPackInt32(i8 zeroext %zSign, i64 %absZ, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i8, align 1
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %roundingMode = alloca i8, align 1
>   %roundNearestEven = alloca i8, align 1
>   %roundIncrement = alloca i8, align 1
>   %roundBits = alloca i8, align 1
>   %z = alloca i32, align 4
>   store i8 %zSign, i8* %2, align 1
>   store i64 %absZ, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load %struct.float_status** %4, align 4
>   %6 = getelementptr inbounds %struct.float_status* %5, i32 0, i32 1
>   %7 = load i8* %6, align 1
>   store i8 %7, i8* %roundingMode, align 1
>   %8 = load i8* %roundingMode, align 1
>   %9 = sext i8 %8 to i32
>   %10 = icmp eq i32 %9, 0
>   %11 = zext i1 %10 to i32
>   %12 = trunc i32 %11 to i8
>   store i8 %12, i8* %roundNearestEven, align 1
>   store i8 64, i8* %roundIncrement, align 1
>   %13 = load i8* %roundNearestEven, align 1
>   %14 = icmp ne i8 %13, 0
>   br i1 %14, label %37, label %15
6810,6867c4987,4991
< ; <label>:178                                     ; preds = %.preheader134, %.preheader131
<   %new_cr3.0 = phi i32 [ %76, %.preheader131 ], [ 0, %.preheader134 ]
<   %new_ldt.0 = phi i32 [ %124, %.preheader131 ], [ %175, %.preheader134 ]
<   %new_eip.0 = phi i32 [ %78, %.preheader131 ], [ %128, %.preheader134 ]
<   %new_eflags.0 = phi i32 [ %80, %.preheader131 ], [ %130, %.preheader134 ]
<   %179 = load %struct.CPUX86State** @env, align 8
<   %180 = getelementptr inbounds %struct.CPUX86State* %179, i64 0, i32 12, i32 1
<   %181 = load i32* %180, align 4
<   %182 = call fastcc i32 @ldub_kernel(i32 %181)
<   %183 = load %struct.CPUX86State** @env, align 8
<   %184 = getelementptr inbounds %struct.CPUX86State* %183, i64 0, i32 12, i32 1
<   %185 = load i32* %184, align 4
<   %186 = add i32 %185, %.100
<   %187 = call fastcc i32 @ldub_kernel(i32 %186)
<   %188 = load %struct.CPUX86State** @env, align 8
<   %189 = getelementptr inbounds %struct.CPUX86State* %188, i64 0, i32 12, i32 1
<   %190 = load i32* %189, align 4
<   call fastcc void @stb_kernel(i32 %190, i32 %182)
<   %191 = load %struct.CPUX86State** @env, align 8
<   %192 = getelementptr inbounds %struct.CPUX86State* %191, i64 0, i32 12, i32 1
<   %193 = load i32* %192, align 4
<   %194 = add i32 %193, %.100
<   call fastcc void @stb_kernel(i32 %194, i32 %187)
<   %195 = icmp eq i32 %source, 1
<   %196 = icmp ult i32 %source, 2
<   br i1 %196, label %197, label %208
< 
< ; <label>:197                                     ; preds = %178
<   %198 = load %struct.CPUX86State** @env, align 8
<   %199 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 13, i32 1
<   %200 = load i32* %199, align 4
<   %201 = getelementptr inbounds %struct.CPUX86State* %198, i64 0, i32 12, i32 0
<   %202 = load i32* %201, align 4
<   %203 = and i32 %202, -8
<   %204 = add i32 %200, 4
<   %205 = add i32 %204, %203
<   %206 = call fastcc i32 @ldl_kernel(i32 %205)
<   %207 = and i32 %206, -513
<   call fastcc void @stl_kernel(i32 %205, i32 %207)
<   br label %208
< 
< ; <label>:208                                     ; preds = %197, %178
<   %209 = load %struct.CPUX86State** @env, align 8
<   %210 = getelementptr inbounds %struct.CPUX86State* %209, i64 0, i32 7
<   %211 = load i32* %210, align 4
<   %212 = getelementptr inbounds %struct.CPUX86State* %209, i64 0, i32 1
<   %213 = load i32* %212, align 4
<   %214 = call i32 @helper_cc_compute_all(i32 %213) nounwind
<   %215 = or i32 %214, %211
<   %216 = getelementptr inbounds %struct.CPUX86State* %209, i64 0, i32 6
<   %217 = load i32* %216, align 4
<   %218 = and i32 %217, 1024
<   %219 = or i32 %215, %218
<   %220 = and i32 %219, -16385
<   %.101 = select i1 %195, i32 %220, i32 %219
<   %221 = getelementptr inbounds %struct.CPUX86State* %209, i64 0, i32 12, i32 1
<   %222 = load i32* %221, align 4
<   br i1 %49, label %.loopexit127, label %.loopexit129
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i8* %roundingMode, align 1
>   %17 = sext i8 %16 to i32
>   %18 = icmp eq i32 %17, 3
>   br i1 %18, label %19, label %20
6869,7069c4993,4995
< .loopexit127:                                     ; preds = %208
<   %223 = add i32 %222, 32
<   call fastcc void @stl_kernel(i32 %223, i32 %next_eip)
<   %224 = load %struct.CPUX86State** @env, align 8
<   %225 = getelementptr inbounds %struct.CPUX86State* %224, i64 0, i32 12, i32 1
<   %226 = load i32* %225, align 4
<   %227 = add i32 %226, 36
<   call fastcc void @stl_kernel(i32 %227, i32 %.101)
<   %228 = load %struct.CPUX86State** @env, align 8
<   %229 = getelementptr inbounds %struct.CPUX86State* %228, i64 0, i32 12, i32 1
<   %230 = load i32* %229, align 4
<   %231 = add i32 %230, 40
<   %232 = getelementptr inbounds %struct.CPUX86State* %228, i64 0, i32 0, i64 0
<   %233 = load i32* %232, align 4
<   call fastcc void @stl_kernel(i32 %231, i32 %233)
<   %234 = load %struct.CPUX86State** @env, align 8
<   %235 = getelementptr inbounds %struct.CPUX86State* %234, i64 0, i32 12, i32 1
<   %236 = load i32* %235, align 4
<   %237 = add i32 %236, 44
<   %238 = getelementptr inbounds %struct.CPUX86State* %234, i64 0, i32 0, i64 1
<   %239 = load i32* %238, align 4
<   call fastcc void @stl_kernel(i32 %237, i32 %239)
<   %240 = load %struct.CPUX86State** @env, align 8
<   %241 = getelementptr inbounds %struct.CPUX86State* %240, i64 0, i32 12, i32 1
<   %242 = load i32* %241, align 4
<   %243 = add i32 %242, 48
<   %244 = getelementptr inbounds %struct.CPUX86State* %240, i64 0, i32 0, i64 2
<   %245 = load i32* %244, align 4
<   call fastcc void @stl_kernel(i32 %243, i32 %245)
<   %246 = load %struct.CPUX86State** @env, align 8
<   %247 = getelementptr inbounds %struct.CPUX86State* %246, i64 0, i32 12, i32 1
<   %248 = load i32* %247, align 4
<   %249 = add i32 %248, 52
<   %250 = getelementptr inbounds %struct.CPUX86State* %246, i64 0, i32 0, i64 3
<   %251 = load i32* %250, align 4
<   call fastcc void @stl_kernel(i32 %249, i32 %251)
<   %252 = load %struct.CPUX86State** @env, align 8
<   %253 = getelementptr inbounds %struct.CPUX86State* %252, i64 0, i32 12, i32 1
<   %254 = load i32* %253, align 4
<   %255 = add i32 %254, 56
<   %256 = getelementptr inbounds %struct.CPUX86State* %252, i64 0, i32 0, i64 4
<   %257 = load i32* %256, align 4
<   call fastcc void @stl_kernel(i32 %255, i32 %257)
<   %258 = load %struct.CPUX86State** @env, align 8
<   %259 = getelementptr inbounds %struct.CPUX86State* %258, i64 0, i32 12, i32 1
<   %260 = load i32* %259, align 4
<   %261 = add i32 %260, 60
<   %262 = getelementptr inbounds %struct.CPUX86State* %258, i64 0, i32 0, i64 5
<   %263 = load i32* %262, align 4
<   call fastcc void @stl_kernel(i32 %261, i32 %263)
<   %264 = load %struct.CPUX86State** @env, align 8
<   %265 = getelementptr inbounds %struct.CPUX86State* %264, i64 0, i32 12, i32 1
<   %266 = load i32* %265, align 4
<   %267 = add i32 %266, 64
<   %268 = getelementptr inbounds %struct.CPUX86State* %264, i64 0, i32 0, i64 6
<   %269 = load i32* %268, align 4
<   call fastcc void @stl_kernel(i32 %267, i32 %269)
<   %270 = load %struct.CPUX86State** @env, align 8
<   %271 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 12, i32 1
<   %272 = load i32* %271, align 4
<   %273 = add i32 %272, 68
<   %274 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 0, i64 7
<   %275 = load i32* %274, align 4
<   call fastcc void @stl_kernel(i32 %273, i32 %275)
<   %276 = load %struct.CPUX86State** @env, align 8
<   %277 = getelementptr inbounds %struct.CPUX86State* %276, i64 0, i32 12, i32 1
<   %278 = load i32* %277, align 4
<   %279 = add i32 %278, 72
<   %280 = getelementptr inbounds %struct.CPUX86State* %276, i64 0, i32 10, i64 0, i32 0
<   %281 = load i32* %280, align 4
<   call fastcc void @stw_kernel(i32 %279, i32 %281)
<   %282 = load %struct.CPUX86State** @env, align 8
<   %283 = getelementptr inbounds %struct.CPUX86State* %282, i64 0, i32 12, i32 1
<   %284 = load i32* %283, align 4
<   %285 = add i32 %284, 76
<   %286 = getelementptr inbounds %struct.CPUX86State* %282, i64 0, i32 10, i64 1, i32 0
<   %287 = load i32* %286, align 4
<   call fastcc void @stw_kernel(i32 %285, i32 %287)
<   %288 = load %struct.CPUX86State** @env, align 8
<   %289 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 12, i32 1
<   %290 = load i32* %289, align 4
<   %291 = add i32 %290, 80
<   %292 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 10, i64 2, i32 0
<   %293 = load i32* %292, align 4
<   call fastcc void @stw_kernel(i32 %291, i32 %293)
<   %294 = load %struct.CPUX86State** @env, align 8
<   %295 = getelementptr inbounds %struct.CPUX86State* %294, i64 0, i32 12, i32 1
<   %296 = load i32* %295, align 4
<   %297 = add i32 %296, 84
<   %298 = getelementptr inbounds %struct.CPUX86State* %294, i64 0, i32 10, i64 3, i32 0
<   %299 = load i32* %298, align 4
<   call fastcc void @stw_kernel(i32 %297, i32 %299)
<   %300 = load %struct.CPUX86State** @env, align 8
<   %301 = getelementptr inbounds %struct.CPUX86State* %300, i64 0, i32 12, i32 1
<   %302 = load i32* %301, align 4
<   %303 = add i32 %302, 88
<   %304 = getelementptr inbounds %struct.CPUX86State* %300, i64 0, i32 10, i64 4, i32 0
<   %305 = load i32* %304, align 4
<   call fastcc void @stw_kernel(i32 %303, i32 %305)
<   %306 = load %struct.CPUX86State** @env, align 8
<   %307 = getelementptr inbounds %struct.CPUX86State* %306, i64 0, i32 12, i32 1
<   %308 = load i32* %307, align 4
<   %309 = add i32 %308, 92
<   %310 = getelementptr inbounds %struct.CPUX86State* %306, i64 0, i32 10, i64 5, i32 0
<   %311 = load i32* %310, align 4
<   call fastcc void @stw_kernel(i32 %309, i32 %311)
<   br label %389
< 
< .loopexit129:                                     ; preds = %208
<   %312 = add i32 %222, 14
<   call fastcc void @stw_kernel(i32 %312, i32 %next_eip)
<   %313 = load %struct.CPUX86State** @env, align 8
<   %314 = getelementptr inbounds %struct.CPUX86State* %313, i64 0, i32 12, i32 1
<   %315 = load i32* %314, align 4
<   %316 = add i32 %315, 16
<   call fastcc void @stw_kernel(i32 %316, i32 %.101)
<   %317 = load %struct.CPUX86State** @env, align 8
<   %318 = getelementptr inbounds %struct.CPUX86State* %317, i64 0, i32 12, i32 1
<   %319 = load i32* %318, align 4
<   %320 = add i32 %319, 18
<   %321 = getelementptr inbounds %struct.CPUX86State* %317, i64 0, i32 0, i64 0
<   %322 = load i32* %321, align 4
<   call fastcc void @stw_kernel(i32 %320, i32 %322)
<   %323 = load %struct.CPUX86State** @env, align 8
<   %324 = getelementptr inbounds %struct.CPUX86State* %323, i64 0, i32 12, i32 1
<   %325 = load i32* %324, align 4
<   %326 = add i32 %325, 20
<   %327 = getelementptr inbounds %struct.CPUX86State* %323, i64 0, i32 0, i64 1
<   %328 = load i32* %327, align 4
<   call fastcc void @stw_kernel(i32 %326, i32 %328)
<   %329 = load %struct.CPUX86State** @env, align 8
<   %330 = getelementptr inbounds %struct.CPUX86State* %329, i64 0, i32 12, i32 1
<   %331 = load i32* %330, align 4
<   %332 = add i32 %331, 22
<   %333 = getelementptr inbounds %struct.CPUX86State* %329, i64 0, i32 0, i64 2
<   %334 = load i32* %333, align 4
<   call fastcc void @stw_kernel(i32 %332, i32 %334)
<   %335 = load %struct.CPUX86State** @env, align 8
<   %336 = getelementptr inbounds %struct.CPUX86State* %335, i64 0, i32 12, i32 1
<   %337 = load i32* %336, align 4
<   %338 = add i32 %337, 24
<   %339 = getelementptr inbounds %struct.CPUX86State* %335, i64 0, i32 0, i64 3
<   %340 = load i32* %339, align 4
<   call fastcc void @stw_kernel(i32 %338, i32 %340)
<   %341 = load %struct.CPUX86State** @env, align 8
<   %342 = getelementptr inbounds %struct.CPUX86State* %341, i64 0, i32 12, i32 1
<   %343 = load i32* %342, align 4
<   %344 = add i32 %343, 26
<   %345 = getelementptr inbounds %struct.CPUX86State* %341, i64 0, i32 0, i64 4
<   %346 = load i32* %345, align 4
<   call fastcc void @stw_kernel(i32 %344, i32 %346)
<   %347 = load %struct.CPUX86State** @env, align 8
<   %348 = getelementptr inbounds %struct.CPUX86State* %347, i64 0, i32 12, i32 1
<   %349 = load i32* %348, align 4
<   %350 = add i32 %349, 28
<   %351 = getelementptr inbounds %struct.CPUX86State* %347, i64 0, i32 0, i64 5
<   %352 = load i32* %351, align 4
<   call fastcc void @stw_kernel(i32 %350, i32 %352)
<   %353 = load %struct.CPUX86State** @env, align 8
<   %354 = getelementptr inbounds %struct.CPUX86State* %353, i64 0, i32 12, i32 1
<   %355 = load i32* %354, align 4
<   %356 = add i32 %355, 30
<   %357 = getelementptr inbounds %struct.CPUX86State* %353, i64 0, i32 0, i64 6
<   %358 = load i32* %357, align 4
<   call fastcc void @stw_kernel(i32 %356, i32 %358)
<   %359 = load %struct.CPUX86State** @env, align 8
<   %360 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 12, i32 1
<   %361 = load i32* %360, align 4
<   %362 = add i32 %361, 32
<   %363 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 0, i64 7
<   %364 = load i32* %363, align 4
<   call fastcc void @stw_kernel(i32 %362, i32 %364)
<   %365 = load %struct.CPUX86State** @env, align 8
<   %366 = getelementptr inbounds %struct.CPUX86State* %365, i64 0, i32 12, i32 1
<   %367 = load i32* %366, align 4
<   %368 = add i32 %367, 34
<   %369 = getelementptr inbounds %struct.CPUX86State* %365, i64 0, i32 10, i64 0, i32 0
<   %370 = load i32* %369, align 4
<   call fastcc void @stw_kernel(i32 %368, i32 %370)
<   %371 = load %struct.CPUX86State** @env, align 8
<   %372 = getelementptr inbounds %struct.CPUX86State* %371, i64 0, i32 12, i32 1
<   %373 = load i32* %372, align 4
<   %374 = add i32 %373, 38
<   %375 = getelementptr inbounds %struct.CPUX86State* %371, i64 0, i32 10, i64 1, i32 0
<   %376 = load i32* %375, align 4
<   call fastcc void @stw_kernel(i32 %374, i32 %376)
<   %377 = load %struct.CPUX86State** @env, align 8
<   %378 = getelementptr inbounds %struct.CPUX86State* %377, i64 0, i32 12, i32 1
<   %379 = load i32* %378, align 4
<   %380 = add i32 %379, 42
<   %381 = getelementptr inbounds %struct.CPUX86State* %377, i64 0, i32 10, i64 2, i32 0
<   %382 = load i32* %381, align 4
<   call fastcc void @stw_kernel(i32 %380, i32 %382)
<   %383 = load %struct.CPUX86State** @env, align 8
<   %384 = getelementptr inbounds %struct.CPUX86State* %383, i64 0, i32 12, i32 1
<   %385 = load i32* %384, align 4
<   %386 = add i32 %385, 46
<   %387 = getelementptr inbounds %struct.CPUX86State* %383, i64 0, i32 10, i64 3, i32 0
<   %388 = load i32* %387, align 4
<   call fastcc void @stw_kernel(i32 %386, i32 %388)
<   br label %389
---
> ; <label>:19                                      ; preds = %15
>   store i8 0, i8* %roundIncrement, align 1
>   br label %36
7071,7075c4997,5007
< ; <label>:389                                     ; preds = %.loopexit129, %.loopexit127
<   switch i32 %source, label %403 [
<     i32 2, label %.thread
<     i32 0, label %394
<   ]
---
> ; <label>:20                                      ; preds = %15
>   store i8 127, i8* %roundIncrement, align 1
>   %21 = load i8* %2, align 1
>   %22 = icmp ne i8 %21, 0
>   br i1 %22, label %23, label %29
> 
> ; <label>:23                                      ; preds = %20
>   %24 = load i8* %roundingMode, align 1
>   %25 = sext i8 %24 to i32
>   %26 = icmp eq i32 %25, 2
>   br i1 %26, label %27, label %28
7077,7096c5009,5011
< .thread:                                          ; preds = %389
<   %390 = load %struct.CPUX86State** @env, align 8
<   %391 = getelementptr inbounds %struct.CPUX86State* %390, i64 0, i32 12, i32 0
<   %392 = load i32* %391, align 4
<   call fastcc void @stw_kernel(i32 %63, i32 %392)
<   %393 = or i32 %new_eflags.0, 16384
<   br label %394
< 
< ; <label>:394                                     ; preds = %.thread, %389
<   %new_eflags.1120 = phi i32 [ %393, %.thread ], [ %new_eflags.0, %389 ]
<   %395 = load %struct.CPUX86State** @env, align 8
<   %396 = getelementptr inbounds %struct.CPUX86State* %395, i64 0, i32 13, i32 1
<   %397 = load i32* %396, align 4
<   %398 = and i32 %.0, -8
<   %399 = or i32 %398, 4
<   %400 = add i32 %397, %399
<   %401 = call fastcc i32 @ldl_kernel(i32 %400)
<   %402 = or i32 %401, 512
<   call fastcc void @stl_kernel(i32 %400, i32 %402)
<   br label %403
---
> ; <label>:27                                      ; preds = %23
>   store i8 0, i8* %roundIncrement, align 1
>   br label %28
7098,7221c5013,5014
< ; <label>:403                                     ; preds = %394, %389
<   %new_eflags.1121 = phi i32 [ %new_eflags.1120, %394 ], [ %new_eflags.0, %389 ]
<   %404 = load %struct.CPUX86State** @env, align 8
<   %405 = getelementptr inbounds %struct.CPUX86State* %404, i64 0, i32 15, i64 0
<   %406 = load i32* %405, align 4
<   %407 = or i32 %406, 8
<   store i32 %407, i32* %405, align 4
<   %408 = load %struct.CPUX86State** @env, align 8
<   %409 = getelementptr inbounds %struct.CPUX86State* %408, i64 0, i32 8
<   %410 = load i32* %409, align 4
<   %411 = or i32 %410, 2048
<   store i32 %411, i32* %409, align 4
<   %412 = load %struct.CPUX86State** @env, align 8
<   %413 = getelementptr inbounds %struct.CPUX86State* %412, i64 0, i32 12, i32 0
<   store i32 %.0, i32* %413, align 4
<   %414 = load %struct.CPUX86State** @env, align 8
<   %415 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 12, i32 1
<   store i32 %63, i32* %415, align 4
<   %416 = load %struct.CPUX86State** @env, align 8
<   %417 = getelementptr inbounds %struct.CPUX86State* %416, i64 0, i32 12, i32 2
<   store i32 %limit.0.i, i32* %417, align 4
<   %418 = and i32 %e2114, -513
<   %419 = load %struct.CPUX86State** @env, align 8
<   %420 = getelementptr inbounds %struct.CPUX86State* %419, i64 0, i32 12, i32 3
<   store i32 %418, i32* %420, align 4
<   br i1 %49, label %421, label %._crit_edge
< 
< ; <label>:421                                     ; preds = %403
<   %422 = load %struct.CPUX86State** @env, align 8
<   %423 = getelementptr inbounds %struct.CPUX86State* %422, i64 0, i32 15, i64 0
<   %424 = load i32* %423, align 4
<   %425 = icmp slt i32 %424, 0
<   br i1 %425, label %426, label %._crit_edge
< 
< ; <label>:426                                     ; preds = %421
<   call void @cpu_x86_update_cr3(%struct.CPUX86State* %422, i32 %new_cr3.0) nounwind
<   br label %._crit_edge
< 
< ._crit_edge:                                      ; preds = %426, %421, %403
<   %427 = load %struct.CPUX86State** @env, align 8
<   %428 = getelementptr inbounds %struct.CPUX86State* %427, i64 0, i32 5
<   store i32 %new_eip.0, i32* %428, align 4
<   %.102 = select i1 %49, i32 2585344, i32 29440
<   %429 = and i32 %new_eflags.1121, 2261
<   %430 = load %struct.CPUX86State** @env, align 8
<   %431 = getelementptr inbounds %struct.CPUX86State* %430, i64 0, i32 2
<   store i32 %429, i32* %431, align 4
<   %432 = lshr i32 %new_eflags.1121, 9
<   %433 = and i32 %432, 2
<   %434 = xor i32 %433, 2
<   %435 = add i32 %434, -1
<   %436 = load %struct.CPUX86State** @env, align 8
<   %437 = getelementptr inbounds %struct.CPUX86State* %436, i64 0, i32 6
<   store i32 %435, i32* %437, align 4
<   %438 = load %struct.CPUX86State** @env, align 8
<   %439 = getelementptr inbounds %struct.CPUX86State* %438, i64 0, i32 7
<   %440 = load i32* %439, align 4
<   %441 = xor i32 %.102, -1
<   %442 = and i32 %440, %441
<   %443 = and i32 %new_eflags.1121, %.102
<   %444 = or i32 %442, %443
<   store i32 %444, i32* %439, align 4
<   %445 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 0
<   %446 = load i32* %445, align 16
<   %447 = load %struct.CPUX86State** @env, align 8
<   %448 = getelementptr inbounds %struct.CPUX86State* %447, i64 0, i32 0, i64 0
<   store i32 %446, i32* %448, align 4
<   %449 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 1
<   %450 = load i32* %449, align 4
<   %451 = load %struct.CPUX86State** @env, align 8
<   %452 = getelementptr inbounds %struct.CPUX86State* %451, i64 0, i32 0, i64 1
<   store i32 %450, i32* %452, align 4
<   %453 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 2
<   %454 = load i32* %453, align 8
<   %455 = load %struct.CPUX86State** @env, align 8
<   %456 = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 0, i64 2
<   store i32 %454, i32* %456, align 4
<   %457 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 3
<   %458 = load i32* %457, align 4
<   %459 = load %struct.CPUX86State** @env, align 8
<   %460 = getelementptr inbounds %struct.CPUX86State* %459, i64 0, i32 0, i64 3
<   store i32 %458, i32* %460, align 4
<   %461 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 4
<   %462 = load i32* %461, align 16
<   %463 = load %struct.CPUX86State** @env, align 8
<   %464 = getelementptr inbounds %struct.CPUX86State* %463, i64 0, i32 0, i64 4
<   store i32 %462, i32* %464, align 4
<   %465 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 5
<   %466 = load i32* %465, align 4
<   %467 = load %struct.CPUX86State** @env, align 8
<   %468 = getelementptr inbounds %struct.CPUX86State* %467, i64 0, i32 0, i64 5
<   store i32 %466, i32* %468, align 4
<   %469 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 6
<   %470 = load i32* %469, align 8
<   %471 = load %struct.CPUX86State** @env, align 8
<   %472 = getelementptr inbounds %struct.CPUX86State* %471, i64 0, i32 0, i64 6
<   store i32 %470, i32* %472, align 4
<   %473 = getelementptr inbounds [8 x i32]* %new_regs, i64 0, i64 7
<   %474 = load i32* %473, align 4
<   %475 = load %struct.CPUX86State** @env, align 8
<   %476 = getelementptr inbounds %struct.CPUX86State* %475, i64 0, i32 0, i64 7
<   store i32 %474, i32* %476, align 4
<   %477 = and i32 %new_eflags.1121, 131072
<   %478 = icmp ne i32 %477, 0
<   br i1 %478, label %.preheader124, label %545
< 
< .preheader124:                                    ; preds = %load_seg_vm.exit, %._crit_edge
<   %indvars.iv = phi i64 [ %indvars.iv.next, %load_seg_vm.exit ], [ 0, %._crit_edge ]
<   %479 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 %indvars.iv
<   %480 = load i32* %479, align 4
<   %481 = and i32 %480, 65535
<   %482 = load %struct.CPUX86State** @env, align 8
<   %483 = shl nuw nsw i32 %481, 4
<   %484 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 10, i64 %indvars.iv, i32 0
<   store i32 %481, i32* %484, align 4
<   %485 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 10, i64 %indvars.iv, i32 1
<   store i32 %483, i32* %485, align 4
<   %486 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 10, i64 %indvars.iv, i32 2
<   store i32 65535, i32* %486, align 4
<   %487 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 10, i64 %indvars.iv, i32 3
<   store i32 0, i32* %487, align 4
<   %488 = trunc i64 %indvars.iv to i32
<   %489 = icmp eq i32 %488, 1
<   br i1 %489, label %490, label %._crit_edge.i.i
---
> ; <label>:28                                      ; preds = %27, %23
>   br label %35
7223,7226c5016,5020
< ._crit_edge.i.i:                                  ; preds = %.preheader124
<   %.phi.trans.insert.i.i = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 8
<   %.pre.i.i = load i32* %.phi.trans.insert.i.i, align 4
<   br label %499
---
> ; <label>:29                                      ; preds = %20
>   %30 = load i8* %roundingMode, align 1
>   %31 = sext i8 %30 to i32
>   %32 = icmp eq i32 %31, 1
>   br i1 %32, label %33, label %34
7228,7435c5022,5024
< ; <label>:490                                     ; preds = %.preheader124
<   %491 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 10, i64 1, i32 3
<   %492 = load i32* %491, align 4
<   %493 = lshr i32 %492, 18
<   %494 = and i32 %493, 16
<   %495 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 8
<   %496 = load i32* %495, align 4
<   %497 = and i32 %496, -32785
<   %498 = or i32 %497, %494
<   store i32 %498, i32* %495, align 4
<   br label %499
< 
< ; <label>:499                                     ; preds = %490, %._crit_edge.i.i
<   %500 = phi i32 [ %.pre.i.i, %._crit_edge.i.i ], [ %498, %490 ]
<   %501 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 10, i64 2, i32 3
<   %502 = load i32* %501, align 4
<   %503 = lshr i32 %502, 17
<   %504 = and i32 %503, 32
<   %505 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 8
<   %506 = and i32 %500, 32768
<   %507 = icmp eq i32 %506, 0
<   br i1 %507, label %508, label %load_seg_vm.exit
< 
< ; <label>:508                                     ; preds = %499
<   %509 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 15, i64 0
<   %510 = load i32* %509, align 4
<   %511 = and i32 %510, 1
<   %512 = icmp eq i32 %511, 0
<   br i1 %512, label %521, label %513
< 
< ; <label>:513                                     ; preds = %508
<   %514 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 7
<   %515 = load i32* %514, align 4
<   %516 = and i32 %515, 131072
<   %517 = icmp eq i32 %516, 0
<   br i1 %517, label %518, label %521
< 
< ; <label>:518                                     ; preds = %513
<   %519 = and i32 %500, 16
<   %520 = icmp eq i32 %519, 0
<   br i1 %520, label %521, label %523
< 
< ; <label>:521                                     ; preds = %518, %513, %508
<   %522 = or i32 %504, 64
<   br label %load_seg_vm.exit
< 
< ; <label>:523                                     ; preds = %518
<   %524 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 10, i64 3, i32 1
<   %525 = load i32* %524, align 4
<   %526 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 10, i64 0, i32 1
<   %527 = load i32* %526, align 4
<   %528 = or i32 %527, %525
<   %529 = getelementptr inbounds %struct.CPUX86State* %482, i64 0, i32 10, i64 2, i32 1
<   %530 = load i32* %529, align 4
<   %531 = or i32 %528, %530
<   %532 = icmp ne i32 %531, 0
<   %533 = zext i1 %532 to i32
<   %534 = shl nuw nsw i32 %533, 6
<   %535 = or i32 %534, %504
<   br label %load_seg_vm.exit
< 
< load_seg_vm.exit:                                 ; preds = %523, %521, %499
<   %new_hflags.0.i.i = phi i32 [ %504, %499 ], [ %522, %521 ], [ %535, %523 ]
<   %536 = and i32 %500, -97
<   %537 = or i32 %new_hflags.0.i.i, %536
<   store i32 %537, i32* %505, align 4
<   %indvars.iv.next = add i64 %indvars.iv, 1
<   %lftr.wideiv = trunc i64 %indvars.iv.next to i32
<   %exitcond = icmp eq i32 %lftr.wideiv, 6
<   br i1 %exitcond, label %538, label %.preheader124
< 
< ; <label>:538                                     ; preds = %load_seg_vm.exit
<   %539 = load %struct.CPUX86State** @env, align 8
<   %540 = getelementptr inbounds %struct.CPUX86State* %539, i64 0, i32 8
<   %541 = load i32* %540, align 4
<   %542 = and i32 %541, 3
<   call void @s2e_on_privilege_change(i32 %542, i32 3) nounwind
<   %543 = load i32* %540, align 4
<   %544 = or i32 %543, 3
<   store i32 %544, i32* %540, align 4
<   br label %.loopexit
< 
< ; <label>:545                                     ; preds = %._crit_edge
<   %546 = load %struct.CPUX86State** @env, align 8
<   %547 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 1
<   %548 = load i32* %547, align 4
<   %549 = and i32 %548, 3
<   %550 = getelementptr inbounds %struct.CPUX86State* %546, i64 0, i32 8
<   %551 = load i32* %550, align 4
<   %552 = and i32 %551, 3
<   call void @s2e_on_privilege_change(i32 %552, i32 %549) nounwind
<   %553 = load i32* %550, align 4
<   %554 = and i32 %553, -4
<   %555 = or i32 %554, %549
<   store i32 %555, i32* %550, align 4
<   br label %556
< 
< ; <label>:556                                     ; preds = %cpu_x86_load_seg_cache.exit, %545
<   %indvars.iv138 = phi i64 [ 0, %545 ], [ %indvars.iv.next139, %cpu_x86_load_seg_cache.exit ]
<   %557 = load %struct.CPUX86State** @env, align 8
<   %558 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 %indvars.iv138
<   %559 = load i32* %558, align 4
<   %560 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 10, i64 %indvars.iv138, i32 0
<   store i32 %559, i32* %560, align 4
<   %561 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 10, i64 %indvars.iv138, i32 1
<   store i32 0, i32* %561, align 4
<   %562 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 10, i64 %indvars.iv138, i32 2
<   store i32 0, i32* %562, align 4
<   %563 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 10, i64 %indvars.iv138, i32 3
<   store i32 0, i32* %563, align 4
<   %564 = trunc i64 %indvars.iv138 to i32
<   %565 = icmp eq i32 %564, 1
<   br i1 %565, label %566, label %._crit_edge.i
< 
< ._crit_edge.i:                                    ; preds = %556
<   %.phi.trans.insert.i = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 8
<   %.pre.i = load i32* %.phi.trans.insert.i, align 4
<   br label %575
< 
< ; <label>:566                                     ; preds = %556
<   %567 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 10, i64 1, i32 3
<   %568 = load i32* %567, align 4
<   %569 = lshr i32 %568, 18
<   %570 = and i32 %569, 16
<   %571 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 8
<   %572 = load i32* %571, align 4
<   %573 = and i32 %572, -32785
<   %574 = or i32 %573, %570
<   store i32 %574, i32* %571, align 4
<   br label %575
< 
< ; <label>:575                                     ; preds = %566, %._crit_edge.i
<   %576 = phi i32 [ %.pre.i, %._crit_edge.i ], [ %574, %566 ]
<   %577 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 10, i64 2, i32 3
<   %578 = load i32* %577, align 4
<   %579 = lshr i32 %578, 17
<   %580 = and i32 %579, 32
<   %581 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 8
<   %582 = and i32 %576, 32768
<   %583 = icmp eq i32 %582, 0
<   br i1 %583, label %584, label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:584                                     ; preds = %575
<   %585 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 15, i64 0
<   %586 = load i32* %585, align 4
<   %587 = and i32 %586, 1
<   %588 = icmp eq i32 %587, 0
<   br i1 %588, label %597, label %589
< 
< ; <label>:589                                     ; preds = %584
<   %590 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 7
<   %591 = load i32* %590, align 4
<   %592 = and i32 %591, 131072
<   %593 = icmp eq i32 %592, 0
<   br i1 %593, label %594, label %597
< 
< ; <label>:594                                     ; preds = %589
<   %595 = and i32 %576, 16
<   %596 = icmp eq i32 %595, 0
<   br i1 %596, label %597, label %599
< 
< ; <label>:597                                     ; preds = %594, %589, %584
<   %598 = or i32 %580, 64
<   br label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:599                                     ; preds = %594
<   %600 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 10, i64 3, i32 1
<   %601 = load i32* %600, align 4
<   %602 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 10, i64 0, i32 1
<   %603 = load i32* %602, align 4
<   %604 = or i32 %603, %601
<   %605 = getelementptr inbounds %struct.CPUX86State* %557, i64 0, i32 10, i64 2, i32 1
<   %606 = load i32* %605, align 4
<   %607 = or i32 %604, %606
<   %608 = icmp ne i32 %607, 0
<   %609 = zext i1 %608 to i32
<   %610 = shl nuw nsw i32 %609, 6
<   %611 = or i32 %610, %580
<   br label %cpu_x86_load_seg_cache.exit
< 
< cpu_x86_load_seg_cache.exit:                      ; preds = %599, %597, %575
<   %new_hflags.0.i = phi i32 [ %580, %575 ], [ %598, %597 ], [ %611, %599 ]
<   %612 = and i32 %576, -97
<   %613 = or i32 %new_hflags.0.i, %612
<   store i32 %613, i32* %581, align 4
<   %indvars.iv.next139 = add i64 %indvars.iv138, 1
<   %lftr.wideiv140 = trunc i64 %indvars.iv.next139 to i32
<   %exitcond141 = icmp eq i32 %lftr.wideiv140, 6
<   br i1 %exitcond141, label %.loopexit, label %556
< 
< .loopexit:                                        ; preds = %cpu_x86_load_seg_cache.exit, %538
<   %614 = and i32 %new_ldt.0, -5
<   %615 = load %struct.CPUX86State** @env, align 8
<   %616 = getelementptr inbounds %struct.CPUX86State* %615, i64 0, i32 11, i32 0
<   store i32 %614, i32* %616, align 4
<   %617 = load %struct.CPUX86State** @env, align 8
<   %618 = getelementptr inbounds %struct.CPUX86State* %617, i64 0, i32 11, i32 1
<   store i32 0, i32* %618, align 4
<   %619 = load %struct.CPUX86State** @env, align 8
<   %620 = getelementptr inbounds %struct.CPUX86State* %619, i64 0, i32 11, i32 2
<   store i32 0, i32* %620, align 4
<   %621 = load %struct.CPUX86State** @env, align 8
<   %622 = getelementptr inbounds %struct.CPUX86State* %621, i64 0, i32 11, i32 3
<   store i32 0, i32* %622, align 4
<   %623 = and i32 %new_ldt.0, 4
<   %624 = icmp eq i32 %623, 0
<   %625 = and i32 %new_ldt.0, 65532
<   br i1 %624, label %627, label %626
---
> ; <label>:33                                      ; preds = %29
>   store i8 0, i8* %roundIncrement, align 1
>   br label %34
7437,7439c5026,5027
< ; <label>:626                                     ; preds = %.loopexit
<   call fastcc void @raise_exception_err(i32 10, i32 %625) noreturn
<   unreachable
---
> ; <label>:34                                      ; preds = %33, %29
>   br label %35
7441,7451c5029,5030
< ; <label>:627                                     ; preds = %.loopexit
<   %628 = icmp eq i32 %625, 0
<   br i1 %628, label %670, label %629
< 
< ; <label>:629                                     ; preds = %627
<   %630 = load %struct.CPUX86State** @env, align 8
<   %631 = or i32 %new_ldt.0, 7
<   %632 = getelementptr inbounds %struct.CPUX86State* %630, i64 0, i32 13, i32 2
<   %633 = load i32* %632, align 4
<   %634 = icmp ugt i32 %631, %633
<   br i1 %634, label %635, label %636
---
> ; <label>:35                                      ; preds = %34, %28
>   br label %36
7453,7455c5032,5033
< ; <label>:635                                     ; preds = %629
<   call fastcc void @raise_exception_err(i32 10, i32 %625) noreturn
<   unreachable
---
> ; <label>:36                                      ; preds = %35, %19
>   br label %37
7457,7467c5035,5070
< ; <label>:636                                     ; preds = %629
<   %637 = and i32 %new_ldt.0, -8
<   %638 = getelementptr inbounds %struct.CPUX86State* %630, i64 0, i32 13, i32 1
<   %639 = load i32* %638, align 4
<   %640 = add i32 %639, %637
<   %641 = call fastcc i32 @ldl_kernel(i32 %640)
<   %642 = add i32 %640, 4
<   %643 = call fastcc i32 @ldl_kernel(i32 %642)
<   %644 = and i32 %643, 7936
<   %645 = icmp eq i32 %644, 512
<   br i1 %645, label %647, label %646
---
> ; <label>:37                                      ; preds = %36, %0
>   %38 = load i64* %3, align 8
>   %39 = and i64 %38, 127
>   %40 = trunc i64 %39 to i8
>   store i8 %40, i8* %roundBits, align 1
>   %41 = load i64* %3, align 8
>   %42 = load i8* %roundIncrement, align 1
>   %43 = sext i8 %42 to i64
>   %44 = add i64 %41, %43
>   %45 = lshr i64 %44, 7
>   store i64 %45, i64* %3, align 8
>   %46 = load i8* %roundBits, align 1
>   %47 = sext i8 %46 to i32
>   %48 = xor i32 %47, 64
>   %49 = icmp eq i32 %48, 0
>   %50 = zext i1 %49 to i32
>   %51 = load i8* %roundNearestEven, align 1
>   %52 = zext i8 %51 to i32
>   %53 = and i32 %50, %52
>   %54 = xor i32 %53, -1
>   %55 = sext i32 %54 to i64
>   %56 = load i64* %3, align 8
>   %57 = and i64 %56, %55
>   store i64 %57, i64* %3, align 8
>   %58 = load i64* %3, align 8
>   %59 = trunc i64 %58 to i32
>   store i32 %59, i32* %z, align 4
>   %60 = load i8* %2, align 1
>   %61 = icmp ne i8 %60, 0
>   br i1 %61, label %62, label %65
> 
> ; <label>:62                                      ; preds = %37
>   %63 = load i32* %z, align 4
>   %64 = sub nsw i32 0, %63
>   store i32 %64, i32* %z, align 4
>   br label %65
7469,7471c5072,5081
< ; <label>:646                                     ; preds = %636
<   call fastcc void @raise_exception_err(i32 10, i32 %625) noreturn
<   unreachable
---
> ; <label>:65                                      ; preds = %62, %37
>   %66 = load i64* %3, align 8
>   %67 = lshr i64 %66, 32
>   %68 = icmp ne i64 %67, 0
>   br i1 %68, label %80, label %69
> 
> ; <label>:69                                      ; preds = %65
>   %70 = load i32* %z, align 4
>   %71 = icmp ne i32 %70, 0
>   br i1 %71, label %72, label %86
7473,7476c5083,5126
< ; <label>:647                                     ; preds = %636
<   %648 = and i32 %643, 32768
<   %649 = icmp eq i32 %648, 0
<   br i1 %649, label %650, label %651
---
> ; <label>:72                                      ; preds = %69
>   %73 = load i32* %z, align 4
>   %74 = icmp slt i32 %73, 0
>   %75 = zext i1 %74 to i32
>   %76 = load i8* %2, align 1
>   %77 = zext i8 %76 to i32
>   %78 = xor i32 %75, %77
>   %79 = icmp ne i32 %78, 0
>   br i1 %79, label %80, label %86
> 
> ; <label>:80                                      ; preds = %72, %65
>   %81 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %81)
>   %82 = load i8* %2, align 1
>   %83 = zext i8 %82 to i32
>   %84 = icmp ne i32 %83, 0
>   %85 = select i1 %84, i32 -2147483648, i32 2147483647
>   store i32 %85, i32* %1
>   br label %98
> 
> ; <label>:86                                      ; preds = %72, %69
>   %87 = load i8* %roundBits, align 1
>   %88 = icmp ne i8 %87, 0
>   br i1 %88, label %89, label %96
> 
> ; <label>:89                                      ; preds = %86
>   %90 = load %struct.float_status** %4, align 4
>   %91 = getelementptr inbounds %struct.float_status* %90, i32 0, i32 2
>   %92 = load i8* %91, align 1
>   %93 = sext i8 %92 to i32
>   %94 = or i32 %93, 32
>   %95 = trunc i32 %94 to i8
>   store i8 %95, i8* %91, align 1
>   br label %96
> 
> ; <label>:96                                      ; preds = %89, %86
>   %97 = load i32* %z, align 4
>   store i32 %97, i32* %1
>   br label %98
> 
> ; <label>:98                                      ; preds = %96, %80
>   %99 = load i32* %1
>   ret i32 %99
> }
7478,7480c5128,5157
< ; <label>:650                                     ; preds = %647
<   call fastcc void @raise_exception_err(i32 10, i32 %625) noreturn
<   unreachable
---
> define internal i32 @float32_to_int32_round_to_zero(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %z = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i32 @float32_squash_input_denormal(i32 %4, %struct.float_status* %5)
>   store i32 %6, i32* %2, align 4
>   %7 = load i32* %2, align 4
>   %8 = call i32 @extractFloat32Frac(i32 %7)
>   store i32 %8, i32* %aSig, align 4
>   %9 = load i32* %2, align 4
>   %10 = call i32 @extractFloat32Exp(i32 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i32* %2, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = sub nsw i32 %13, 158
>   store i32 %14, i32* %shiftCount, align 4
>   %15 = load i32* %shiftCount, align 4
>   %16 = icmp sle i32 0, %15
>   br i1 %16, label %17, label %33
7482,7541c5159,5162
< ; <label>:651                                     ; preds = %647
<   %652 = load %struct.CPUX86State** @env, align 8
<   %653 = lshr i32 %641, 16
<   %654 = shl i32 %643, 16
<   %655 = and i32 %654, 16711680
<   %656 = and i32 %643, -16777216
<   %657 = or i32 %656, %653
<   %658 = or i32 %657, %655
<   %659 = getelementptr inbounds %struct.CPUX86State* %652, i64 0, i32 11, i32 1
<   store i32 %658, i32* %659, align 4
<   %660 = and i32 %641, 65535
<   %661 = and i32 %643, 983040
<   %662 = or i32 %661, %660
<   %663 = and i32 %643, 8388608
<   %664 = icmp eq i32 %663, 0
<   br i1 %664, label %load_seg_cache_raw_dt.exit, label %665
< 
< ; <label>:665                                     ; preds = %651
<   %666 = shl nuw i32 %662, 12
<   %667 = or i32 %666, 4095
<   br label %load_seg_cache_raw_dt.exit
< 
< load_seg_cache_raw_dt.exit:                       ; preds = %665, %651
<   %limit.0.i.i = phi i32 [ %667, %665 ], [ %662, %651 ]
<   %668 = getelementptr inbounds %struct.CPUX86State* %652, i64 0, i32 11, i32 2
<   store i32 %limit.0.i.i, i32* %668, align 4
<   %669 = getelementptr inbounds %struct.CPUX86State* %652, i64 0, i32 11, i32 3
<   store i32 %643, i32* %669, align 4
<   br label %670
< 
< ; <label>:670                                     ; preds = %load_seg_cache_raw_dt.exit, %627
<   br i1 %478, label %684, label %671
< 
< ; <label>:671                                     ; preds = %670
<   %672 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 1
<   %673 = load i32* %672, align 4
<   call fastcc void @tss_load_seg(i32 1, i32 %673)
<   %674 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 2
<   %675 = load i32* %674, align 8
<   call fastcc void @tss_load_seg(i32 2, i32 %675)
<   %676 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 0
<   %677 = load i32* %676, align 16
<   call fastcc void @tss_load_seg(i32 0, i32 %677)
<   %678 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 3
<   %679 = load i32* %678, align 4
<   call fastcc void @tss_load_seg(i32 3, i32 %679)
<   %680 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 4
<   %681 = load i32* %680, align 16
<   call fastcc void @tss_load_seg(i32 4, i32 %681)
<   %682 = getelementptr inbounds [6 x i32]* %new_segs, i64 0, i64 5
<   %683 = load i32* %682, align 4
<   call fastcc void @tss_load_seg(i32 5, i32 %683)
<   br label %684
< 
< ; <label>:684                                     ; preds = %671, %670
<   %685 = load %struct.CPUX86State** @env, align 8
<   %686 = getelementptr inbounds %struct.CPUX86State* %685, i64 0, i32 10, i64 1, i32 2
<   %687 = load i32* %686, align 4
<   %688 = icmp ugt i32 %new_eip.0, %687
<   br i1 %688, label %689, label %690
---
> ; <label>:17                                      ; preds = %0
>   %18 = load i32* %2, align 4
>   %19 = icmp ne i32 %18, -822083584
>   br i1 %19, label %20, label %32
7543,7545c5164,5179
< ; <label>:689                                     ; preds = %684
<   call fastcc void @raise_exception_err(i32 13, i32 0) noreturn
<   unreachable
---
> ; <label>:20                                      ; preds = %17
>   %21 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %21)
>   %22 = load i8* %aSign, align 1
>   %23 = icmp ne i8 %22, 0
>   br i1 %23, label %24, label %30
> 
> ; <label>:24                                      ; preds = %20
>   %25 = load i32* %aExp, align 4
>   %26 = icmp eq i32 %25, 255
>   br i1 %26, label %27, label %31
> 
> ; <label>:27                                      ; preds = %24
>   %28 = load i32* %aSig, align 4
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %30, label %31
7547,7571c5181,5183
< ; <label>:690                                     ; preds = %684
<   %691 = getelementptr inbounds %struct.CPUX86State* %685, i64 0, i32 58, i64 7
<   %692 = load i32* %691, align 4
<   %693 = and i32 %692, 85
<   %694 = icmp eq i32 %693, 0
<   br i1 %694, label %703, label %.preheader
< 
< .preheader:                                       ; preds = %690
<   %695 = and i32 %692, 3
<   %696 = icmp eq i32 %695, 1
<   br i1 %696, label %697, label %698
< 
< ; <label>:697                                     ; preds = %.preheader
<   call void @hw_breakpoint_remove(%struct.CPUX86State* %685, i32 0) nounwind
<   %.pre = load %struct.CPUX86State** @env, align 8
<   %.phi.trans.insert = getelementptr inbounds %struct.CPUX86State* %.pre, i64 0, i32 58, i64 7
<   %.pre166 = load i32* %.phi.trans.insert, align 4
<   br label %698
< 
< ; <label>:698                                     ; preds = %697, %.preheader
<   %699 = phi i32 [ %692, %.preheader ], [ %.pre166, %697 ]
<   %700 = phi %struct.CPUX86State* [ %685, %.preheader ], [ %.pre, %697 ]
<   %701 = and i32 %699, 12
<   %702 = icmp eq i32 %701, 4
<   br i1 %702, label %704, label %705
---
> ; <label>:30                                      ; preds = %27, %20
>   store i32 2147483647, i32* %1
>   br label %78
7573,7574c5185,5186
< ; <label>:703                                     ; preds = %717, %690
<   ret void
---
> ; <label>:31                                      ; preds = %27, %24
>   br label %32
7576,7618c5188,5190
< ; <label>:704                                     ; preds = %698
<   call void @hw_breakpoint_remove(%struct.CPUX86State* %700, i32 1) nounwind
<   %.pre167 = load %struct.CPUX86State** @env, align 8
<   %.phi.trans.insert168 = getelementptr inbounds %struct.CPUX86State* %.pre167, i64 0, i32 58, i64 7
<   %.pre169 = load i32* %.phi.trans.insert168, align 4
<   br label %705
< 
< ; <label>:705                                     ; preds = %704, %698
<   %706 = phi i32 [ %.pre169, %704 ], [ %699, %698 ]
<   %707 = phi %struct.CPUX86State* [ %.pre167, %704 ], [ %700, %698 ]
<   %708 = and i32 %706, 48
<   %709 = icmp eq i32 %708, 16
<   br i1 %709, label %710, label %711
< 
< ; <label>:710                                     ; preds = %705
<   call void @hw_breakpoint_remove(%struct.CPUX86State* %707, i32 2) nounwind
<   %.pre170 = load %struct.CPUX86State** @env, align 8
<   %.phi.trans.insert171 = getelementptr inbounds %struct.CPUX86State* %.pre170, i64 0, i32 58, i64 7
<   %.pre172 = load i32* %.phi.trans.insert171, align 4
<   br label %711
< 
< ; <label>:711                                     ; preds = %710, %705
<   %712 = phi i32 [ %.pre172, %710 ], [ %706, %705 ]
<   %713 = phi %struct.CPUX86State* [ %.pre170, %710 ], [ %707, %705 ]
<   %714 = and i32 %712, 192
<   %715 = icmp eq i32 %714, 64
<   br i1 %715, label %716, label %717
< 
< ; <label>:716                                     ; preds = %711
<   call void @hw_breakpoint_remove(%struct.CPUX86State* %713, i32 3) nounwind
<   %.pre173 = load %struct.CPUX86State** @env, align 8
<   %.phi.trans.insert174 = getelementptr inbounds %struct.CPUX86State* %.pre173, i64 0, i32 58, i64 7
<   %.pre175 = load i32* %.phi.trans.insert174, align 4
<   br label %717
< 
< ; <label>:717                                     ; preds = %716, %711
<   %718 = phi i32 [ %.pre175, %716 ], [ %712, %711 ]
<   %719 = phi %struct.CPUX86State* [ %.pre173, %716 ], [ %713, %711 ]
<   %720 = getelementptr inbounds %struct.CPUX86State* %719, i64 0, i32 58, i64 7
<   %721 = and i32 %718, -86
<   store i32 %721, i32* %720, align 4
<   br label %703
< }
---
> ; <label>:32                                      ; preds = %31, %17
>   store i32 -2147483648, i32* %1
>   br label %78
7620,7633c5192,5195
< define void @helper_lcall_real(i32 %new_cs, i32 %new_eip1, i32 %shift, i32 %next_eip) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 4
<   %3 = load i32* %2, align 4
<   %4 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 2, i32 3
<   %5 = load i32* %4, align 4
<   %6 = lshr i32 %5, 6
<   %7 = and i32 %6, 65536
<   %8 = xor i32 %7, 65536
<   %9 = add i32 %8, -1
<   %10 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 2, i32 1
<   %11 = load i32* %10, align 4
<   %12 = icmp eq i32 %shift, 0
<   br i1 %12, label %22, label %13
---
> ; <label>:33                                      ; preds = %0
>   %34 = load i32* %aExp, align 4
>   %35 = icmp sle i32 %34, 126
>   br i1 %35, label %36, label %49
7635,7646c5197,5202
< ; <label>:13                                      ; preds = %0
<   %14 = add i32 %3, -4
<   %15 = and i32 %9, %14
<   %16 = add i32 %15, %11
<   %17 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 1, i32 0
<   %18 = load i32* %17, align 4
<   tail call fastcc void @stl_kernel(i32 %16, i32 %18)
<   %19 = add i32 %3, -8
<   %20 = and i32 %9, %19
<   %21 = add i32 %20, %11
<   tail call fastcc void @stl_kernel(i32 %21, i32 %next_eip)
<   br label %31
---
> ; <label>:36                                      ; preds = %33
>   %37 = load i32* %aExp, align 4
>   %38 = load i32* %aSig, align 4
>   %39 = or i32 %37, %38
>   %40 = icmp ne i32 %39, 0
>   br i1 %40, label %41, label %48
7648,7659c5204,5212
< ; <label>:22                                      ; preds = %0
<   %23 = add i32 %3, -2
<   %24 = and i32 %9, %23
<   %25 = add i32 %24, %11
<   %26 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 1, i32 0
<   %27 = load i32* %26, align 4
<   tail call fastcc void @stw_kernel(i32 %25, i32 %27)
<   %28 = add i32 %3, -4
<   %29 = and i32 %9, %28
<   %30 = add i32 %29, %11
<   tail call fastcc void @stw_kernel(i32 %30, i32 %next_eip)
<   br label %31
---
> ; <label>:41                                      ; preds = %36
>   %42 = load %struct.float_status** %3, align 4
>   %43 = getelementptr inbounds %struct.float_status* %42, i32 0, i32 2
>   %44 = load i8* %43, align 1
>   %45 = sext i8 %44 to i32
>   %46 = or i32 %45, 32
>   %47 = trunc i32 %46 to i8
>   store i8 %47, i8* %43, align 1
>   br label %48
7661,7682c5214,5216
< ; <label>:31                                      ; preds = %22, %13
<   %esp.0 = phi i32 [ %19, %13 ], [ %28, %22 ]
<   %32 = load %struct.CPUX86State** @env, align 8
<   %33 = getelementptr inbounds %struct.CPUX86State* %32, i64 0, i32 0, i64 4
<   %34 = load i32* %33, align 4
<   %35 = sub i32 0, %8
<   %36 = and i32 %34, %35
<   %37 = and i32 %esp.0, %9
<   %38 = or i32 %36, %37
<   store i32 %38, i32* %33, align 4
<   %39 = load %struct.CPUX86State** @env, align 8
<   %40 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 5
<   store i32 %new_eip1, i32* %40, align 4
<   %41 = load %struct.CPUX86State** @env, align 8
<   %42 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 10, i64 1, i32 0
<   store i32 %new_cs, i32* %42, align 4
<   %43 = shl i32 %new_cs, 4
<   %44 = load %struct.CPUX86State** @env, align 8
<   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 10, i64 1, i32 1
<   store i32 %43, i32* %45, align 4
<   ret void
< }
---
> ; <label>:48                                      ; preds = %41, %36
>   store i32 0, i32* %1
>   br label %78
7684,7688c5218,5219
< define internal fastcc void @stw_kernel(i32 %ptr, i32 %v) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:49                                      ; preds = %33
>   br label %50
7690,7692c5221,5262
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:50                                      ; preds = %49
>   %51 = load i32* %aSig, align 4
>   %52 = or i32 %51, 8388608
>   %53 = shl i32 %52, 8
>   store i32 %53, i32* %aSig, align 4
>   %54 = load i32* %aSig, align 4
>   %55 = load i32* %shiftCount, align 4
>   %56 = sub nsw i32 0, %55
>   %57 = lshr i32 %54, %56
>   store i32 %57, i32* %z, align 4
>   %58 = load i32* %aSig, align 4
>   %59 = load i32* %shiftCount, align 4
>   %60 = and i32 %59, 31
>   %61 = shl i32 %58, %60
>   %62 = icmp ne i32 %61, 0
>   br i1 %62, label %63, label %70
> 
> ; <label>:63                                      ; preds = %50
>   %64 = load %struct.float_status** %3, align 4
>   %65 = getelementptr inbounds %struct.float_status* %64, i32 0, i32 2
>   %66 = load i8* %65, align 1
>   %67 = sext i8 %66 to i32
>   %68 = or i32 %67, 32
>   %69 = trunc i32 %68 to i8
>   store i8 %69, i8* %65, align 1
>   br label %70
> 
> ; <label>:70                                      ; preds = %63, %50
>   %71 = load i8* %aSign, align 1
>   %72 = icmp ne i8 %71, 0
>   br i1 %72, label %73, label %76
> 
> ; <label>:73                                      ; preds = %70
>   %74 = load i32* %z, align 4
>   %75 = sub nsw i32 0, %74
>   store i32 %75, i32* %z, align 4
>   br label %76
> 
> ; <label>:76                                      ; preds = %73, %70
>   %77 = load i32* %z, align 4
>   store i32 %77, i32* %1
>   br label %78
7694,7727c5264,5266
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 1
<   %16 = load i32* %15, align 4
<   %17 = and i32 %8, -4095
<   %18 = icmp eq i32 %16, %17
<   br i1 %18, label %21, label %19, !prof !0
< 
< ; <label>:19                                      ; preds = %6
<   %20 = trunc i32 %v to i16
<   tail call void @__stw_mmu(i32 %8, i16 zeroext %20, i32 0)
<   br label %29
< 
< ; <label>:21                                      ; preds = %6
<   %22 = and i64 %7, 4294967295
<   %23 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 3
<   %24 = load i64* %23, align 8
<   %25 = add i64 %24, %22
<   %26 = trunc i32 %v to i16
<   %27 = inttoptr i64 %25 to i16*
<   store i16 %26, i16* %27, align 2
<   %28 = zext i32 %v to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %22, i64 %25, i64 %28, i32 32, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %29
< 
< ; <label>:29                                      ; preds = %21, %19
<   ret void
---
> ; <label>:78                                      ; preds = %76, %48, %32, %30
>   %79 = load i32* %1
>   ret i32 %79
7730,7741c5269,5294
< define void @helper_lcall_protected(i32 %new_cs, i32 %new_eip, i32 %shift, i32 %next_eip_addend) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 5
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %next_eip_addend
<   %5 = and i32 %new_cs, 65532
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %7, label %8
< 
< ; <label>:7                                       ; preds = %0
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn
<   unreachable
---
> define internal i32 @float32_to_int16_round_to_zero(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %z = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = call i32 @extractFloat32Frac(i32 %4)
>   store i32 %5, i32* %aSig, align 4
>   %6 = load i32* %2, align 4
>   %7 = call i32 @extractFloat32Exp(i32 %6)
>   store i32 %7, i32* %aExp, align 4
>   %8 = load i32* %2, align 4
>   %9 = call zeroext i8 @extractFloat32Sign(i32 %8)
>   store i8 %9, i8* %aSign, align 1
>   %10 = load i32* %aExp, align 4
>   %11 = sub nsw i32 %10, 142
>   store i32 %11, i32* %shiftCount, align 4
>   %12 = load i32* %shiftCount, align 4
>   %13 = icmp sle i32 0, %12
>   br i1 %13, label %14, label %30
7743,7753c5296,5311
< ; <label>:8                                       ; preds = %0
<   %9 = and i32 %new_cs, 4
<   %10 = icmp eq i32 %9, 0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 11
<   %12 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 13
<   %dt.0.i = select i1 %10, %struct.SegmentCache* %12, %struct.SegmentCache* %11
<   %13 = or i32 %new_cs, 7
<   %14 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 2
<   %15 = load i32* %14, align 4
<   %16 = icmp ugt i32 %13, %15
<   br i1 %16, label %17, label %18
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %2, align 4
>   %16 = icmp ne i32 %15, -956301312
>   br i1 %16, label %17, label %29
> 
> ; <label>:17                                      ; preds = %14
>   %18 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %18)
>   %19 = load i8* %aSign, align 1
>   %20 = icmp ne i8 %19, 0
>   br i1 %20, label %21, label %27
> 
> ; <label>:21                                      ; preds = %17
>   %22 = load i32* %aExp, align 4
>   %23 = icmp eq i32 %22, 255
>   br i1 %23, label %24, label %28
7755,7757c5313,5316
< ; <label>:17                                      ; preds = %8
<   tail call fastcc void @raise_exception_err(i32 13, i32 %5) noreturn
<   unreachable
---
> ; <label>:24                                      ; preds = %21
>   %25 = load i32* %aSig, align 4
>   %26 = icmp ne i32 %25, 0
>   br i1 %26, label %27, label %28
7759,7773c5318,5320
< ; <label>:18                                      ; preds = %8
<   %19 = and i32 %new_cs, -8
<   %20 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 1
<   %21 = load i32* %20, align 4
<   %22 = add i32 %21, %19
<   %23 = tail call fastcc i32 @ldl_kernel(i32 %22) nounwind
<   %24 = add i32 %22, 4
<   %25 = tail call fastcc i32 @ldl_kernel(i32 %24) nounwind
<   %26 = load %struct.CPUX86State** @env, align 8
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 8
<   %28 = load i32* %27, align 4
<   %29 = and i32 %28, 3
<   %30 = and i32 %25, 4096
<   %31 = icmp eq i32 %30, 0
<   br i1 %31, label %156, label %32
---
> ; <label>:27                                      ; preds = %24, %17
>   store i32 32767, i32* %1
>   br label %77
7775,7778c5322,5323
< ; <label>:32                                      ; preds = %18
<   %33 = and i32 %25, 2048
<   %34 = icmp eq i32 %33, 0
<   br i1 %34, label %35, label %36
---
> ; <label>:28                                      ; preds = %24, %21
>   br label %29
7780,7782c5325,5332
< ; <label>:35                                      ; preds = %32
<   tail call fastcc void @raise_exception_err(i32 13, i32 %5) noreturn
<   unreachable
---
> ; <label>:29                                      ; preds = %28, %14
>   store i32 -32768, i32* %1
>   br label %77
> 
> ; <label>:30                                      ; preds = %0
>   %31 = load i32* %aExp, align 4
>   %32 = icmp sle i32 %31, 126
>   br i1 %32, label %33, label %46
7784,7789c5334,5339
< ; <label>:36                                      ; preds = %32
<   %37 = lshr i32 %25, 13
<   %38 = and i32 %37, 3
<   %39 = and i32 %25, 1024
<   %40 = icmp eq i32 %39, 0
<   br i1 %40, label %44, label %41
---
> ; <label>:33                                      ; preds = %30
>   %34 = load i32* %aExp, align 4
>   %35 = load i32* %aSig, align 4
>   %36 = or i32 %34, %35
>   %37 = icmp ne i32 %36, 0
>   br i1 %37, label %38, label %45
7791,7793c5341,5349
< ; <label>:41                                      ; preds = %36
<   %42 = icmp ugt i32 %38, %29
<   br i1 %42, label %43, label %51
---
> ; <label>:38                                      ; preds = %33
>   %39 = load %struct.float_status** %3, align 4
>   %40 = getelementptr inbounds %struct.float_status* %39, i32 0, i32 2
>   %41 = load i8* %40, align 1
>   %42 = sext i8 %41 to i32
>   %43 = or i32 %42, 32
>   %44 = trunc i32 %43 to i8
>   store i8 %44, i8* %40, align 1
>   br label %45
7795,7797c5351,5353
< ; <label>:43                                      ; preds = %41
<   tail call fastcc void @raise_exception_err(i32 13, i32 %5) noreturn
<   unreachable
---
> ; <label>:45                                      ; preds = %38, %33
>   store i32 0, i32* %1
>   br label %77
7799,7802c5355,5356
< ; <label>:44                                      ; preds = %36
<   %45 = and i32 %new_cs, 3
<   %46 = icmp ugt i32 %45, %29
<   br i1 %46, label %47, label %48
---
> ; <label>:46                                      ; preds = %30
>   br label %47
7804,7806c5358,5376
< ; <label>:47                                      ; preds = %44
<   tail call fastcc void @raise_exception_err(i32 13, i32 %5) noreturn
<   unreachable
---
> ; <label>:47                                      ; preds = %46
>   %48 = load i32* %shiftCount, align 4
>   %49 = sub nsw i32 %48, 16
>   store i32 %49, i32* %shiftCount, align 4
>   %50 = load i32* %aSig, align 4
>   %51 = or i32 %50, 8388608
>   %52 = shl i32 %51, 8
>   store i32 %52, i32* %aSig, align 4
>   %53 = load i32* %aSig, align 4
>   %54 = load i32* %shiftCount, align 4
>   %55 = sub nsw i32 0, %54
>   %56 = lshr i32 %53, %55
>   store i32 %56, i32* %z, align 4
>   %57 = load i32* %aSig, align 4
>   %58 = load i32* %shiftCount, align 4
>   %59 = and i32 %58, 31
>   %60 = shl i32 %57, %59
>   %61 = icmp ne i32 %60, 0
>   br i1 %61, label %62, label %69
7808,7810c5378,5386
< ; <label>:48                                      ; preds = %44
<   %49 = icmp eq i32 %38, %29
<   br i1 %49, label %51, label %50
---
> ; <label>:62                                      ; preds = %47
>   %63 = load %struct.float_status** %3, align 4
>   %64 = getelementptr inbounds %struct.float_status* %63, i32 0, i32 2
>   %65 = load i8* %64, align 1
>   %66 = sext i8 %65 to i32
>   %67 = or i32 %66, 32
>   %68 = trunc i32 %67 to i8
>   store i8 %68, i8* %64, align 1
>   br label %69
7812,7814c5388,5391
< ; <label>:50                                      ; preds = %48
<   tail call fastcc void @raise_exception_err(i32 13, i32 %5) noreturn
<   unreachable
---
> ; <label>:69                                      ; preds = %62, %47
>   %70 = load i8* %aSign, align 1
>   %71 = icmp ne i8 %70, 0
>   br i1 %71, label %72, label %75
7816,7819c5393,5397
< ; <label>:51                                      ; preds = %48, %41
<   %52 = and i32 %25, 32768
<   %53 = icmp eq i32 %52, 0
<   br i1 %53, label %54, label %55
---
> ; <label>:72                                      ; preds = %69
>   %73 = load i32* %z, align 4
>   %74 = sub nsw i32 0, %73
>   store i32 %74, i32* %z, align 4
>   br label %75
7821,7823c5399,5402
< ; <label>:54                                      ; preds = %51
<   tail call fastcc void @raise_exception_err(i32 11, i32 %5) noreturn
<   unreachable
---
> ; <label>:75                                      ; preds = %72, %69
>   %76 = load i32* %z, align 4
>   store i32 %76, i32* %1
>   br label %77
7825,7850c5404,5407
< ; <label>:55                                      ; preds = %51
<   %56 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 0, i64 4
<   %57 = load i32* %56, align 4
<   %58 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 2, i32 3
<   %59 = load i32* %58, align 4
<   %60 = lshr i32 %59, 6
<   %61 = and i32 %60, 65536
<   %62 = xor i32 %61, 65536
<   %63 = add i32 %62, -1
<   %64 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 2, i32 1
<   %65 = load i32* %64, align 4
<   %66 = icmp eq i32 %shift, 0
<   br i1 %66, label %76, label %67
< 
< ; <label>:67                                      ; preds = %55
<   %68 = add i32 %57, -4
<   %69 = and i32 %63, %68
<   %70 = add i32 %69, %65
<   %71 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 1, i32 0
<   %72 = load i32* %71, align 4
<   tail call fastcc void @stl_kernel(i32 %70, i32 %72)
<   %73 = add i32 %57, -8
<   %74 = and i32 %63, %73
<   %75 = add i32 %74, %65
<   tail call fastcc void @stl_kernel(i32 %75, i32 %4)
<   br label %85
---
> ; <label>:77                                      ; preds = %75, %45, %29, %27
>   %78 = load i32* %1
>   ret i32 %78
> }
7852,7863c5409,5439
< ; <label>:76                                      ; preds = %55
<   %77 = add i32 %57, -2
<   %78 = and i32 %63, %77
<   %79 = add i32 %78, %65
<   %80 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 1, i32 0
<   %81 = load i32* %80, align 4
<   tail call fastcc void @stw_kernel(i32 %79, i32 %81)
<   %82 = add i32 %57, -4
<   %83 = and i32 %63, %82
<   %84 = add i32 %83, %65
<   tail call fastcc void @stw_kernel(i32 %84, i32 %4)
<   br label %85
---
> define internal i64 @float32_to_int64(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %aSig64 = alloca i64, align 8
>   %aSigExtra = alloca i64, align 8
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i32 @float32_squash_input_denormal(i32 %4, %struct.float_status* %5)
>   store i32 %6, i32* %2, align 4
>   %7 = load i32* %2, align 4
>   %8 = call i32 @extractFloat32Frac(i32 %7)
>   store i32 %8, i32* %aSig, align 4
>   %9 = load i32* %2, align 4
>   %10 = call i32 @extractFloat32Exp(i32 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i32* %2, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = sub nsw i32 190, %13
>   store i32 %14, i32* %shiftCount, align 4
>   %15 = load i32* %shiftCount, align 4
>   %16 = icmp slt i32 %15, 0
>   br i1 %16, label %17, label %29
7865,7872c5441,5451
< ; <label>:85                                      ; preds = %76, %67
<   %86 = phi i32 [ %82, %76 ], [ %73, %67 ]
<   %87 = and i32 %23, 65535
<   %88 = and i32 %25, 983040
<   %89 = or i32 %88, %87
<   %90 = and i32 %25, 8388608
<   %91 = icmp eq i32 %90, 0
<   br i1 %91, label %get_seg_limit.exit, label %92
---
> ; <label>:17                                      ; preds = %0
>   %18 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %18)
>   %19 = load i8* %aSign, align 1
>   %20 = icmp ne i8 %19, 0
>   br i1 %20, label %21, label %27
> 
> ; <label>:21                                      ; preds = %17
>   %22 = load i32* %aExp, align 4
>   %23 = icmp eq i32 %22, 255
>   br i1 %23, label %24, label %28
7874,7882c5453,5456
< ; <label>:92                                      ; preds = %85
<   %93 = shl nuw i32 %89, 12
<   %94 = or i32 %93, 4095
<   br label %get_seg_limit.exit
< 
< get_seg_limit.exit:                               ; preds = %92, %85
<   %limit.0.i = phi i32 [ %94, %92 ], [ %89, %85 ]
<   %95 = icmp ult i32 %limit.0.i, %new_eip
<   br i1 %95, label %96, label %97
---
> ; <label>:24                                      ; preds = %21
>   %25 = load i32* %aSig, align 4
>   %26 = icmp ne i32 %25, 0
>   br i1 %26, label %27, label %28
7884,7886c5458,5460
< ; <label>:96                                      ; preds = %get_seg_limit.exit
<   tail call fastcc void @raise_exception_err(i32 13, i32 %5) noreturn
<   unreachable
---
> ; <label>:27                                      ; preds = %24, %17
>   store i64 9223372036854775807, i64* %1
>   br label %47
7888,7928c5462,5464
< ; <label>:97                                      ; preds = %get_seg_limit.exit
<   %98 = load %struct.CPUX86State** @env, align 8
<   %99 = getelementptr inbounds %struct.CPUX86State* %98, i64 0, i32 0, i64 4
<   %100 = load i32* %99, align 4
<   %101 = sub i32 0, %62
<   %102 = and i32 %100, %101
<   %103 = and i32 %86, %63
<   %104 = or i32 %102, %103
<   store i32 %104, i32* %99, align 4
<   %105 = load %struct.CPUX86State** @env, align 8
<   %106 = or i32 %29, %5
<   %107 = lshr i32 %23, 16
<   %108 = shl i32 %25, 16
<   %109 = and i32 %108, 16711680
<   %110 = and i32 %25, -16777216
<   %111 = or i32 %110, %107
<   %112 = or i32 %111, %109
<   %113 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 10, i64 1, i32 0
<   store i32 %106, i32* %113, align 4
<   %114 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 10, i64 1, i32 1
<   store i32 %112, i32* %114, align 4
<   %115 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 10, i64 1, i32 2
<   store i32 %limit.0.i, i32* %115, align 4
<   %116 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 10, i64 1, i32 3
<   store i32 %25, i32* %116, align 4
<   %117 = lshr i32 %25, 18
<   %118 = and i32 %117, 16
<   %119 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 8
<   %120 = load i32* %119, align 4
<   %121 = and i32 %120, -32785
<   %122 = or i32 %121, %118
<   store i32 %122, i32* %119, align 4
<   %123 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 10, i64 2, i32 3
<   %124 = load i32* %123, align 4
<   %125 = lshr i32 %124, 17
<   %126 = and i32 %125, 32
<   %127 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 15, i64 0
<   %128 = load i32* %127, align 4
<   %129 = and i32 %128, 1
<   %130 = icmp eq i32 %129, 0
<   br i1 %130, label %137, label %131
---
> ; <label>:28                                      ; preds = %24, %21
>   store i64 -9223372036854775808, i64* %1
>   br label %47
7930,7980c5466,5469
< ; <label>:131                                     ; preds = %97
<   %132 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 7
<   %133 = load i32* %132, align 4
<   %134 = and i32 %133, 131072
<   %135 = icmp ne i32 %134, 0
<   %136 = icmp eq i32 %118, 0
<   %or.cond168 = or i1 %135, %136
<   br i1 %or.cond168, label %137, label %139
< 
< ; <label>:137                                     ; preds = %131, %97
<   %138 = or i32 %126, 64
<   br label %cpu_x86_load_seg_cache.exit113
< 
< ; <label>:139                                     ; preds = %131
<   %140 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 10, i64 3, i32 1
<   %141 = load i32* %140, align 4
<   %142 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 10, i64 0, i32 1
<   %143 = load i32* %142, align 4
<   %144 = or i32 %143, %141
<   %145 = getelementptr inbounds %struct.CPUX86State* %105, i64 0, i32 10, i64 2, i32 1
<   %146 = load i32* %145, align 4
<   %147 = or i32 %144, %146
<   %148 = icmp ne i32 %147, 0
<   %149 = zext i1 %148 to i32
<   %150 = shl nuw nsw i32 %149, 6
<   %151 = or i32 %150, %126
<   br label %cpu_x86_load_seg_cache.exit113
< 
< cpu_x86_load_seg_cache.exit113:                   ; preds = %139, %137
<   %new_hflags.0.i112 = phi i32 [ %138, %137 ], [ %151, %139 ]
<   %152 = and i32 %122, -32865
<   %153 = or i32 %new_hflags.0.i112, %152
<   store i32 %153, i32* %119, align 4
<   %154 = load %struct.CPUX86State** @env, align 8
<   %155 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 5
<   store i32 %new_eip, i32* %155, align 4
<   br label %556
< 
< ; <label>:156                                     ; preds = %18
<   %157 = lshr i32 %25, 8
<   %158 = and i32 %157, 31
<   %159 = lshr i32 %25, 13
<   %160 = and i32 %159, 3
<   %161 = and i32 %new_cs, 3
<   switch i32 %158, label %169 [
<     i32 1, label %162
<     i32 9, label %162
<     i32 5, label %162
<     i32 4, label %170
<     i32 12, label %170
<   ]
---
> ; <label>:29                                      ; preds = %0
>   %30 = load i32* %aExp, align 4
>   %31 = icmp ne i32 %30, 0
>   br i1 %31, label %32, label %35
7982,7986c5471,5475
< ; <label>:162                                     ; preds = %156, %156, %156
<   %163 = icmp ult i32 %160, %29
<   %164 = icmp ult i32 %160, %161
<   %or.cond = or i1 %163, %164
<   br i1 %or.cond, label %165, label %166
---
> ; <label>:32                                      ; preds = %29
>   %33 = load i32* %aSig, align 4
>   %34 = or i32 %33, 8388608
>   store i32 %34, i32* %aSig, align 4
>   br label %35
7988,7990c5477,5493
< ; <label>:165                                     ; preds = %162
<   tail call fastcc void @raise_exception_err(i32 13, i32 %5) noreturn
<   unreachable
---
> ; <label>:35                                      ; preds = %32, %29
>   %36 = load i32* %aSig, align 4
>   %37 = zext i32 %36 to i64
>   store i64 %37, i64* %aSig64, align 8
>   %38 = load i64* %aSig64, align 8
>   %39 = shl i64 %38, 40
>   store i64 %39, i64* %aSig64, align 8
>   %40 = load i64* %aSig64, align 8
>   %41 = load i32* %shiftCount, align 4
>   call void @shift64ExtraRightJamming(i64 %40, i64 0, i32 %41, i64* %aSig64, i64* %aSigExtra)
>   %42 = load i8* %aSign, align 1
>   %43 = load i64* %aSig64, align 8
>   %44 = load i64* %aSigExtra, align 8
>   %45 = load %struct.float_status** %3, align 4
>   %46 = call i64 @roundAndPackInt64(i8 zeroext %42, i64 %43, i64 %44, %struct.float_status* %45)
>   store i64 %46, i64* %1
>   br label %47
7992,7997c5495,5498
< ; <label>:166                                     ; preds = %162
<   tail call fastcc void @switch_tss(i32 %new_cs, i32 %23, i32 %25, i32 2, i32 %4)
<   %167 = load %struct.CPUX86State** @env, align 8
<   %168 = getelementptr inbounds %struct.CPUX86State* %167, i64 0, i32 1
<   store i32 1, i32* %168, align 4
<   br label %556
---
> ; <label>:47                                      ; preds = %35, %28, %27
>   %48 = load i64* %1
>   ret i64 %48
> }
7999,8001c5500,5521
< ; <label>:169                                     ; preds = %156
<   tail call fastcc void @raise_exception_err(i32 13, i32 %5) noreturn
<   unreachable
---
> define internal void @shift64ExtraRightJamming(i64 %a0, i64 %a1, i32 %count, i64* %z0Ptr, i64* %z1Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i32, align 4
>   %4 = alloca i64*, align 4
>   %5 = alloca i64*, align 4
>   %z0 = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   %negCount = alloca i8, align 1
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i32 %count, i32* %3, align 4
>   store i64* %z0Ptr, i64** %4, align 4
>   store i64* %z1Ptr, i64** %5, align 4
>   %6 = load i32* %3, align 4
>   %7 = sub nsw i32 0, %6
>   %8 = and i32 %7, 63
>   %9 = trunc i32 %8 to i8
>   store i8 %9, i8* %negCount, align 1
>   %10 = load i32* %3, align 4
>   %11 = icmp eq i32 %10, 0
>   br i1 %11, label %12, label %15
8003,8008c5523,5528
< ; <label>:170                                     ; preds = %156, %156
<   %171 = lshr i32 %158, 3
<   %172 = icmp ult i32 %160, %29
<   %173 = icmp ult i32 %160, %161
<   %or.cond98 = or i1 %172, %173
<   br i1 %or.cond98, label %174, label %175
---
> ; <label>:12                                      ; preds = %0
>   %13 = load i64* %2, align 8
>   store i64 %13, i64* %z1, align 8
>   %14 = load i64* %1, align 8
>   store i64 %14, i64* %z0, align 8
>   br label %52
8010,8012c5530,5552
< ; <label>:174                                     ; preds = %170
<   tail call fastcc void @raise_exception_err(i32 13, i32 %5) noreturn
<   unreachable
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %3, align 4
>   %17 = icmp slt i32 %16, 64
>   br i1 %17, label %18, label %33
> 
> ; <label>:18                                      ; preds = %15
>   %19 = load i64* %1, align 8
>   %20 = load i8* %negCount, align 1
>   %21 = sext i8 %20 to i32
>   %22 = zext i32 %21 to i64
>   %23 = shl i64 %19, %22
>   %24 = load i64* %2, align 8
>   %25 = icmp ne i64 %24, 0
>   %26 = zext i1 %25 to i32
>   %27 = sext i32 %26 to i64
>   %28 = or i64 %23, %27
>   store i64 %28, i64* %z1, align 8
>   %29 = load i64* %1, align 8
>   %30 = load i32* %3, align 4
>   %31 = zext i32 %30 to i64
>   %32 = lshr i64 %29, %31
>   store i64 %32, i64* %z0, align 8
>   br label %51
8014,8017c5554,5557
< ; <label>:175                                     ; preds = %170
<   %176 = and i32 %25, 32768
<   %177 = icmp eq i32 %176, 0
<   br i1 %177, label %178, label %179
---
> ; <label>:33                                      ; preds = %15
>   %34 = load i32* %3, align 4
>   %35 = icmp eq i32 %34, 64
>   br i1 %35, label %36, label %43
8019,8021c5559,5567
< ; <label>:178                                     ; preds = %175
<   tail call fastcc void @raise_exception_err(i32 11, i32 %5) noreturn
<   unreachable
---
> ; <label>:36                                      ; preds = %33
>   %37 = load i64* %1, align 8
>   %38 = load i64* %2, align 8
>   %39 = icmp ne i64 %38, 0
>   %40 = zext i1 %39 to i32
>   %41 = sext i32 %40 to i64
>   %42 = or i64 %37, %41
>   store i64 %42, i64* %z1, align 8
>   br label %50
8023,8031c5569,5577
< ; <label>:179                                     ; preds = %175
<   %180 = lshr i32 %23, 16
<   %181 = and i32 %25, -65536
<   %182 = and i32 %23, 65535
<   %183 = or i32 %181, %182
<   %184 = and i32 %25, 31
<   %185 = and i32 %180, 65532
<   %186 = icmp eq i32 %185, 0
<   br i1 %186, label %187, label %188
---
> ; <label>:43                                      ; preds = %33
>   %44 = load i64* %1, align 8
>   %45 = load i64* %2, align 8
>   %46 = or i64 %44, %45
>   %47 = icmp ne i64 %46, 0
>   %48 = zext i1 %47 to i32
>   %49 = sext i32 %48 to i64
>   store i64 %49, i64* %z1, align 8
>   br label %50
8033,8035c5579,5581
< ; <label>:187                                     ; preds = %179
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn
<   unreachable
---
> ; <label>:50                                      ; preds = %43, %36
>   store i64 0, i64* %z0, align 8
>   br label %51
8037,8047c5583,5584
< ; <label>:188                                     ; preds = %179
<   %189 = and i32 %180, 4
<   %190 = icmp eq i32 %189, 0
<   %191 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 11
<   %192 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 13
<   %dt.0.i114 = select i1 %190, %struct.SegmentCache* %192, %struct.SegmentCache* %191
<   %193 = or i32 %180, 7
<   %194 = getelementptr inbounds %struct.SegmentCache* %dt.0.i114, i64 0, i32 2
<   %195 = load i32* %194, align 4
<   %196 = icmp ugt i32 %193, %195
<   br i1 %196, label %197, label %198
---
> ; <label>:51                                      ; preds = %50, %18
>   br label %52
8049,8051c5586,5594
< ; <label>:197                                     ; preds = %188
<   tail call fastcc void @raise_exception_err(i32 13, i32 %185) noreturn
<   unreachable
---
> ; <label>:52                                      ; preds = %51, %12
>   %53 = load i64* %z1, align 8
>   %54 = load i64** %5, align 4
>   store i64 %53, i64* %54, align 4
>   %55 = load i64* %z0, align 8
>   %56 = load i64** %4, align 4
>   store i64 %55, i64* %56, align 4
>   ret void
> }
8053,8063c5596,5627
< ; <label>:198                                     ; preds = %188
<   %199 = and i32 %180, 65528
<   %200 = getelementptr inbounds %struct.SegmentCache* %dt.0.i114, i64 0, i32 1
<   %201 = load i32* %200, align 4
<   %202 = add i32 %201, %199
<   %203 = tail call fastcc i32 @ldl_kernel(i32 %202) nounwind
<   %204 = add i32 %202, 4
<   %205 = tail call fastcc i32 @ldl_kernel(i32 %204) nounwind
<   %206 = and i32 %205, 6144
<   %207 = icmp eq i32 %206, 6144
<   br i1 %207, label %209, label %208
---
> define internal i64 @roundAndPackInt64(i8 zeroext %zSign, i64 %absZ0, i64 %absZ1, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i8, align 1
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca %struct.float_status*, align 4
>   %roundingMode = alloca i8, align 1
>   %roundNearestEven = alloca i8, align 1
>   %increment = alloca i8, align 1
>   %z = alloca i64, align 8
>   store i8 %zSign, i8* %2, align 1
>   store i64 %absZ0, i64* %3, align 8
>   store i64 %absZ1, i64* %4, align 8
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load %struct.float_status** %5, align 4
>   %7 = getelementptr inbounds %struct.float_status* %6, i32 0, i32 1
>   %8 = load i8* %7, align 1
>   store i8 %8, i8* %roundingMode, align 1
>   %9 = load i8* %roundingMode, align 1
>   %10 = sext i8 %9 to i32
>   %11 = icmp eq i32 %10, 0
>   %12 = zext i1 %11 to i32
>   %13 = trunc i32 %12 to i8
>   store i8 %13, i8* %roundNearestEven, align 1
>   %14 = load i64* %4, align 8
>   %15 = icmp slt i64 %14, 0
>   %16 = zext i1 %15 to i32
>   %17 = trunc i32 %16 to i8
>   store i8 %17, i8* %increment, align 1
>   %18 = load i8* %roundNearestEven, align 1
>   %19 = icmp ne i8 %18, 0
>   br i1 %19, label %52, label %20
8065,8067c5629,5633
< ; <label>:208                                     ; preds = %198
<   tail call fastcc void @raise_exception_err(i32 13, i32 %185) noreturn
<   unreachable
---
> ; <label>:20                                      ; preds = %0
>   %21 = load i8* %roundingMode, align 1
>   %22 = sext i8 %21 to i32
>   %23 = icmp eq i32 %22, 3
>   br i1 %23, label %24, label %25
8069,8073c5635,5637
< ; <label>:209                                     ; preds = %198
<   %210 = lshr i32 %205, 13
<   %211 = and i32 %210, 3
<   %212 = icmp ugt i32 %211, %29
<   br i1 %212, label %213, label %214
---
> ; <label>:24                                      ; preds = %20
>   store i8 0, i8* %increment, align 1
>   br label %51
8075,8077c5639,5642
< ; <label>:213                                     ; preds = %209
<   tail call fastcc void @raise_exception_err(i32 13, i32 %185) noreturn
<   unreachable
---
> ; <label>:25                                      ; preds = %20
>   %26 = load i8* %2, align 1
>   %27 = icmp ne i8 %26, 0
>   br i1 %27, label %28, label %39
8079,8082c5644,5648
< ; <label>:214                                     ; preds = %209
<   %215 = and i32 %205, 32768
<   %216 = icmp eq i32 %215, 0
<   br i1 %216, label %217, label %218
---
> ; <label>:28                                      ; preds = %25
>   %29 = load i8* %roundingMode, align 1
>   %30 = sext i8 %29 to i32
>   %31 = icmp eq i32 %30, 1
>   br i1 %31, label %32, label %35
8084,8086c5650,5653
< ; <label>:217                                     ; preds = %214
<   tail call fastcc void @raise_exception_err(i32 11, i32 %185) noreturn
<   unreachable
---
> ; <label>:32                                      ; preds = %28
>   %33 = load i64* %4, align 8
>   %34 = icmp ne i64 %33, 0
>   br label %35
8088,8101c5655,5660
< ; <label>:218                                     ; preds = %214
<   %219 = and i32 %205, 1024
<   %220 = icmp eq i32 %219, 0
<   %221 = icmp ult i32 %211, %29
<   %or.cond101 = and i1 %220, %221
<   %222 = load %struct.CPUX86State** @env, align 8
<   br i1 %or.cond101, label %223, label %384
< 
< ; <label>:223                                     ; preds = %218
<   %224 = getelementptr inbounds %struct.CPUX86State* %222, i64 0, i32 12, i32 3
<   %225 = load i32* %224, align 4
<   %226 = and i32 %225, 32768
<   %227 = icmp eq i32 %226, 0
<   br i1 %227, label %228, label %229
---
> ; <label>:35                                      ; preds = %32, %28
>   %36 = phi i1 [ false, %28 ], [ %34, %32 ]
>   %37 = zext i1 %36 to i32
>   %38 = trunc i32 %37 to i8
>   store i8 %38, i8* %increment, align 1
>   br label %50
8103,8105c5662,5666
< ; <label>:228                                     ; preds = %223
<   tail call void (%struct.CPUX86State*, i8*, ...)* @cpu_abort(%struct.CPUX86State* %222, i8* getelementptr inbounds ([12 x i8]* @.str20, i64 0, i64 0)) noreturn nounwind
<   unreachable
---
> ; <label>:39                                      ; preds = %25
>   %40 = load i8* %roundingMode, align 1
>   %41 = sext i8 %40 to i32
>   %42 = icmp eq i32 %41, 2
>   br i1 %42, label %43, label %46
8107,8119c5668,5671
< ; <label>:229                                     ; preds = %223
<   %230 = lshr i32 %225, 11
<   %231 = and i32 %230, 1
<   %232 = shl nuw nsw i32 %211, 2
<   %233 = or i32 %232, 2
<   %234 = shl i32 %233, %231
<   %235 = shl i32 4, %231
<   %236 = add i32 %235, -1
<   %237 = add i32 %236, %234
<   %238 = getelementptr inbounds %struct.CPUX86State* %222, i64 0, i32 12, i32 2
<   %239 = load i32* %238, align 4
<   %240 = icmp ugt i32 %237, %239
<   br i1 %240, label %241, label %245
---
> ; <label>:43                                      ; preds = %39
>   %44 = load i64* %4, align 8
>   %45 = icmp ne i64 %44, 0
>   br label %46
8121,8126c5673,5678
< ; <label>:241                                     ; preds = %229
<   %242 = getelementptr inbounds %struct.CPUX86State* %222, i64 0, i32 12, i32 0
<   %243 = load i32* %242, align 4
<   %244 = and i32 %243, 65532
<   tail call fastcc void @raise_exception_err(i32 10, i32 %244) noreturn nounwind
<   unreachable
---
> ; <label>:46                                      ; preds = %43, %39
>   %47 = phi i1 [ false, %39 ], [ %45, %43 ]
>   %48 = zext i1 %47 to i32
>   %49 = trunc i32 %48 to i8
>   store i8 %49, i8* %increment, align 1
>   br label %50
8128,8133c5680,5681
< ; <label>:245                                     ; preds = %229
<   %246 = icmp eq i32 %231, 0
<   %247 = getelementptr inbounds %struct.CPUX86State* %222, i64 0, i32 12, i32 1
<   %248 = load i32* %247, align 4
<   %249 = add i32 %248, %234
<   br i1 %246, label %250, label %258
---
> ; <label>:50                                      ; preds = %46, %35
>   br label %51
8135,8143c5683,5684
< ; <label>:250                                     ; preds = %245
<   %251 = tail call fastcc i32 @lduw_kernel(i32 %249) nounwind
<   %252 = load %struct.CPUX86State** @env, align 8
<   %253 = getelementptr inbounds %struct.CPUX86State* %252, i64 0, i32 12, i32 1
<   %254 = load i32* %253, align 4
<   %255 = add i32 %234, 2
<   %256 = add i32 %255, %254
<   %257 = tail call fastcc i32 @lduw_kernel(i32 %256) nounwind
<   br label %get_ss_esp_from_tss.exit
---
> ; <label>:51                                      ; preds = %50, %24
>   br label %52
8145,8160c5686,5697
< ; <label>:258                                     ; preds = %245
<   %259 = tail call fastcc i32 @ldl_kernel(i32 %249) nounwind
<   %260 = load %struct.CPUX86State** @env, align 8
<   %261 = getelementptr inbounds %struct.CPUX86State* %260, i64 0, i32 12, i32 1
<   %262 = load i32* %261, align 4
<   %263 = add i32 %234, 4
<   %264 = add i32 %263, %262
<   %265 = tail call fastcc i32 @lduw_kernel(i32 %264) nounwind
<   br label %get_ss_esp_from_tss.exit
< 
< get_ss_esp_from_tss.exit:                         ; preds = %258, %250
<   %266 = phi i32 [ %259, %258 ], [ %251, %250 ]
<   %storemerge.i = phi i32 [ %265, %258 ], [ %257, %250 ]
<   %267 = and i32 %storemerge.i, 65532
<   %268 = icmp eq i32 %267, 0
<   br i1 %268, label %269, label %270
---
> ; <label>:52                                      ; preds = %51, %0
>   %53 = load i8* %increment, align 1
>   %54 = icmp ne i8 %53, 0
>   br i1 %54, label %55, label %73
> 
> ; <label>:55                                      ; preds = %52
>   %56 = load i64* %3, align 8
>   %57 = add i64 %56, 1
>   store i64 %57, i64* %3, align 8
>   %58 = load i64* %3, align 8
>   %59 = icmp eq i64 %58, 0
>   br i1 %59, label %60, label %61
8162,8164c5699,5700
< ; <label>:269                                     ; preds = %get_ss_esp_from_tss.exit
<   tail call fastcc void @raise_exception_err(i32 10, i32 0) noreturn
<   unreachable
---
> ; <label>:60                                      ; preds = %55
>   br label %92
8166,8169c5702,5715
< ; <label>:270                                     ; preds = %get_ss_esp_from_tss.exit
<   %271 = and i32 %storemerge.i, 3
<   %272 = icmp eq i32 %271, %211
<   br i1 %272, label %274, label %273
---
> ; <label>:61                                      ; preds = %55
>   %62 = load i64* %4, align 8
>   %63 = shl i64 %62, 1
>   %64 = icmp eq i64 %63, 0
>   %65 = zext i1 %64 to i32
>   %66 = load i8* %roundNearestEven, align 1
>   %67 = zext i8 %66 to i32
>   %68 = and i32 %65, %67
>   %69 = xor i32 %68, -1
>   %70 = sext i32 %69 to i64
>   %71 = load i64* %3, align 8
>   %72 = and i64 %71, %70
>   store i64 %72, i64* %3, align 8
>   br label %73
8171,8173c5717,5733
< ; <label>:273                                     ; preds = %270
<   tail call fastcc void @raise_exception_err(i32 10, i32 %267) noreturn
<   unreachable
---
> ; <label>:73                                      ; preds = %61, %52
>   %74 = load i64* %3, align 8
>   store i64 %74, i64* %z, align 8
>   %75 = load i8* %2, align 1
>   %76 = icmp ne i8 %75, 0
>   br i1 %76, label %77, label %80
> 
> ; <label>:77                                      ; preds = %73
>   %78 = load i64* %z, align 8
>   %79 = sub nsw i64 0, %78
>   store i64 %79, i64* %z, align 8
>   br label %80
> 
> ; <label>:80                                      ; preds = %77, %73
>   %81 = load i64* %z, align 8
>   %82 = icmp ne i64 %81, 0
>   br i1 %82, label %83, label %98
8175,8186c5735,5761
< ; <label>:274                                     ; preds = %270
<   %275 = and i32 %storemerge.i, 4
<   %276 = icmp eq i32 %275, 0
<   %277 = load %struct.CPUX86State** @env, align 8
<   %278 = getelementptr inbounds %struct.CPUX86State* %277, i64 0, i32 11
<   %279 = getelementptr inbounds %struct.CPUX86State* %277, i64 0, i32 13
<   %dt.0.i117 = select i1 %276, %struct.SegmentCache* %279, %struct.SegmentCache* %278
<   %280 = or i32 %storemerge.i, 7
<   %281 = getelementptr inbounds %struct.SegmentCache* %dt.0.i117, i64 0, i32 2
<   %282 = load i32* %281, align 4
<   %283 = icmp ugt i32 %280, %282
<   br i1 %283, label %284, label %285
---
> ; <label>:83                                      ; preds = %80
>   %84 = load i64* %z, align 8
>   %85 = icmp slt i64 %84, 0
>   %86 = zext i1 %85 to i32
>   %87 = load i8* %2, align 1
>   %88 = zext i8 %87 to i32
>   %89 = xor i32 %86, %88
>   %90 = icmp ne i32 %89, 0
>   br i1 %90, label %91, label %98
> 
> ; <label>:91                                      ; preds = %83
>   br label %92
> 
> ; <label>:92                                      ; preds = %91, %60
>   %93 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %93)
>   %94 = load i8* %2, align 1
>   %95 = zext i8 %94 to i32
>   %96 = icmp ne i32 %95, 0
>   %97 = select i1 %96, i64 -9223372036854775808, i64 9223372036854775807
>   store i64 %97, i64* %1
>   br label %110
> 
> ; <label>:98                                      ; preds = %83, %80
>   %99 = load i64* %4, align 8
>   %100 = icmp ne i64 %99, 0
>   br i1 %100, label %101, label %108
8188,8190c5763,5781
< ; <label>:284                                     ; preds = %274
<   tail call fastcc void @raise_exception_err(i32 10, i32 %267) noreturn
<   unreachable
---
> ; <label>:101                                     ; preds = %98
>   %102 = load %struct.float_status** %5, align 4
>   %103 = getelementptr inbounds %struct.float_status* %102, i32 0, i32 2
>   %104 = load i8* %103, align 1
>   %105 = sext i8 %104 to i32
>   %106 = or i32 %105, 32
>   %107 = trunc i32 %106 to i8
>   store i8 %107, i8* %103, align 1
>   br label %108
> 
> ; <label>:108                                     ; preds = %101, %98
>   %109 = load i64* %z, align 8
>   store i64 %109, i64* %1
>   br label %110
> 
> ; <label>:110                                     ; preds = %108, %92
>   %111 = load i64* %1
>   ret i64 %111
> }
8192,8203c5783,5813
< ; <label>:285                                     ; preds = %274
<   %286 = and i32 %storemerge.i, -8
<   %287 = getelementptr inbounds %struct.SegmentCache* %dt.0.i117, i64 0, i32 1
<   %288 = load i32* %287, align 4
<   %289 = add i32 %288, %286
<   %290 = tail call fastcc i32 @ldl_kernel(i32 %289) nounwind
<   %291 = add i32 %289, 4
<   %292 = tail call fastcc i32 @ldl_kernel(i32 %291) nounwind
<   %293 = lshr i32 %292, 13
<   %294 = and i32 %293, 3
<   %295 = icmp eq i32 %294, %211
<   br i1 %295, label %297, label %296
---
> define internal i64 @float32_to_int64_round_to_zero(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %aSig64 = alloca i64, align 8
>   %z = alloca i64, align 8
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i32 @float32_squash_input_denormal(i32 %4, %struct.float_status* %5)
>   store i32 %6, i32* %2, align 4
>   %7 = load i32* %2, align 4
>   %8 = call i32 @extractFloat32Frac(i32 %7)
>   store i32 %8, i32* %aSig, align 4
>   %9 = load i32* %2, align 4
>   %10 = call i32 @extractFloat32Exp(i32 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i32* %2, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = sub nsw i32 %13, 190
>   store i32 %14, i32* %shiftCount, align 4
>   %15 = load i32* %shiftCount, align 4
>   %16 = icmp sle i32 0, %15
>   br i1 %16, label %17, label %33
8205,8207c5815,5818
< ; <label>:296                                     ; preds = %285
<   tail call fastcc void @raise_exception_err(i32 10, i32 %267) noreturn
<   unreachable
---
> ; <label>:17                                      ; preds = %0
>   %18 = load i32* %2, align 4
>   %19 = icmp ne i32 %18, -553648128
>   br i1 %19, label %20, label %32
8209,8212c5820,5835
< ; <label>:297                                     ; preds = %285
<   %298 = and i32 %292, 6656
<   %299 = icmp eq i32 %298, 4608
<   br i1 %299, label %301, label %300
---
> ; <label>:20                                      ; preds = %17
>   %21 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %21)
>   %22 = load i8* %aSign, align 1
>   %23 = icmp ne i8 %22, 0
>   br i1 %23, label %24, label %30
> 
> ; <label>:24                                      ; preds = %20
>   %25 = load i32* %aExp, align 4
>   %26 = icmp eq i32 %25, 255
>   br i1 %26, label %27, label %31
> 
> ; <label>:27                                      ; preds = %24
>   %28 = load i32* %aSig, align 4
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %30, label %31
8214,8216c5837,5839
< ; <label>:300                                     ; preds = %297
<   tail call fastcc void @raise_exception_err(i32 10, i32 %267) noreturn
<   unreachable
---
> ; <label>:30                                      ; preds = %27, %20
>   store i64 9223372036854775807, i64* %1
>   br label %82
8218,8221c5841,5842
< ; <label>:301                                     ; preds = %297
<   %302 = and i32 %292, 32768
<   %303 = icmp eq i32 %302, 0
<   br i1 %303, label %304, label %305
---
> ; <label>:31                                      ; preds = %27, %24
>   br label %32
8223,8225c5844,5846
< ; <label>:304                                     ; preds = %301
<   tail call fastcc void @raise_exception_err(i32 10, i32 %267) noreturn
<   unreachable
---
> ; <label>:32                                      ; preds = %31, %17
>   store i64 -9223372036854775808, i64* %1
>   br label %82
8227,8451c5848,5851
< ; <label>:305                                     ; preds = %301
<   %306 = load %struct.CPUX86State** @env, align 8
<   %307 = getelementptr inbounds %struct.CPUX86State* %306, i64 0, i32 10, i64 2, i32 3
<   %308 = load i32* %307, align 4
<   %309 = lshr i32 %308, 6
<   %310 = and i32 %309, 65536
<   %311 = xor i32 %310, 65536
<   %312 = add i32 %311, -1
<   %313 = getelementptr inbounds %struct.CPUX86State* %306, i64 0, i32 10, i64 2, i32 1
<   %314 = load i32* %313, align 4
<   %315 = lshr i32 %292, 6
<   %316 = and i32 %315, 65536
<   %317 = xor i32 %316, 65536
<   %318 = add i32 %317, -1
<   %319 = lshr i32 %290, 16
<   %320 = shl i32 %292, 16
<   %321 = and i32 %320, 16711680
<   %322 = and i32 %292, -16777216
<   %323 = or i32 %322, %319
<   %324 = or i32 %323, %321
<   %325 = icmp eq i32 %171, 0
<   br i1 %325, label %355, label %326
< 
< ; <label>:326                                     ; preds = %305
<   %327 = add i32 %266, -4
<   %328 = and i32 %318, %327
<   %329 = add i32 %328, %324
<   %330 = getelementptr inbounds %struct.CPUX86State* %306, i64 0, i32 10, i64 2, i32 0
<   %331 = load i32* %330, align 4
<   tail call fastcc void @stl_kernel(i32 %329, i32 %331)
<   %332 = add i32 %266, -8
<   %333 = and i32 %318, %332
<   %334 = add i32 %333, %324
<   %335 = load %struct.CPUX86State** @env, align 8
<   %336 = getelementptr inbounds %struct.CPUX86State* %335, i64 0, i32 0, i64 4
<   %337 = load i32* %336, align 4
<   tail call fastcc void @stl_kernel(i32 %334, i32 %337)
<   %i.0174 = add i32 %184, -1
<   %338 = icmp sgt i32 %i.0174, -1
<   br i1 %338, label %.lr.ph176, label %.loopexit
< 
< .lr.ph176:                                        ; preds = %326
<   %339 = shl i32 %25, 2
<   %340 = and i32 %339, 124
<   br label %341
< 
< ; <label>:341                                     ; preds = %341, %.lr.ph176
<   %i.0175 = phi i32 [ %i.0174, %.lr.ph176 ], [ %i.0, %341 ]
<   %342 = phi i32 [ %332, %.lr.ph176 ], [ %351, %341 ]
<   %343 = load %struct.CPUX86State** @env, align 8
<   %344 = getelementptr inbounds %struct.CPUX86State* %343, i64 0, i32 0, i64 4
<   %345 = load i32* %344, align 4
<   %346 = shl i32 %i.0175, 2
<   %347 = add i32 %345, %346
<   %348 = and i32 %347, %312
<   %349 = add i32 %348, %314
<   %350 = tail call fastcc i32 @ldl_kernel(i32 %349)
<   %351 = add i32 %342, -4
<   %352 = and i32 %351, %318
<   %353 = add i32 %352, %324
<   tail call fastcc void @stl_kernel(i32 %353, i32 %350)
<   %i.0 = add i32 %i.0175, -1
<   %354 = icmp sgt i32 %i.0, -1
<   br i1 %354, label %341, label %..loopexit172_crit_edge
< 
< ; <label>:355                                     ; preds = %305
<   %356 = add i32 %266, -2
<   %357 = and i32 %318, %356
<   %358 = add i32 %357, %324
<   %359 = getelementptr inbounds %struct.CPUX86State* %306, i64 0, i32 10, i64 2, i32 0
<   %360 = load i32* %359, align 4
<   tail call fastcc void @stw_kernel(i32 %358, i32 %360)
<   %361 = add i32 %266, -4
<   %362 = and i32 %318, %361
<   %363 = add i32 %362, %324
<   %364 = load %struct.CPUX86State** @env, align 8
<   %365 = getelementptr inbounds %struct.CPUX86State* %364, i64 0, i32 0, i64 4
<   %366 = load i32* %365, align 4
<   tail call fastcc void @stw_kernel(i32 %363, i32 %366)
<   %i.1170 = add i32 %184, -1
<   %367 = icmp sgt i32 %i.1170, -1
<   br i1 %367, label %.lr.ph, label %.loopexit.thread
< 
< .lr.ph:                                           ; preds = %355
<   %368 = shl i32 %25, 1
<   %369 = and i32 %368, 62
<   br label %370
< 
< ; <label>:370                                     ; preds = %370, %.lr.ph
<   %i.1171 = phi i32 [ %i.1170, %.lr.ph ], [ %i.1, %370 ]
<   %371 = phi i32 [ %361, %.lr.ph ], [ %380, %370 ]
<   %372 = load %struct.CPUX86State** @env, align 8
<   %373 = getelementptr inbounds %struct.CPUX86State* %372, i64 0, i32 0, i64 4
<   %374 = load i32* %373, align 4
<   %375 = shl i32 %i.1171, 1
<   %376 = add i32 %374, %375
<   %377 = and i32 %376, %312
<   %378 = add i32 %377, %314
<   %379 = tail call fastcc i32 @lduw_kernel(i32 %378)
<   %380 = add i32 %371, -2
<   %381 = and i32 %380, %318
<   %382 = add i32 %381, %324
<   tail call fastcc void @stw_kernel(i32 %382, i32 %379)
<   %i.1 = add i32 %i.1171, -1
<   %383 = icmp sgt i32 %i.1, -1
<   br i1 %383, label %370, label %..loopexit_crit_edge
< 
< ; <label>:384                                     ; preds = %218
<   %385 = getelementptr inbounds %struct.CPUX86State* %222, i64 0, i32 0, i64 4
<   %386 = load i32* %385, align 4
<   %387 = getelementptr inbounds %struct.CPUX86State* %222, i64 0, i32 10, i64 2, i32 3
<   %388 = load i32* %387, align 4
<   %389 = lshr i32 %388, 6
<   %390 = and i32 %389, 65536
<   %391 = xor i32 %390, 65536
<   %392 = add i32 %391, -1
<   %393 = getelementptr inbounds %struct.CPUX86State* %222, i64 0, i32 10, i64 2, i32 1
<   %394 = load i32* %393, align 4
<   br label %.loopexit
< 
< ..loopexit_crit_edge:                             ; preds = %370
<   %395 = sub i32 %361, %369
<   br label %.loopexit
< 
< ..loopexit172_crit_edge:                          ; preds = %341
<   %396 = sub i32 %332, %340
<   br label %.loopexit
< 
< .loopexit:                                        ; preds = %..loopexit172_crit_edge, %..loopexit_crit_edge, %384, %326
<   %397 = phi i32 [ 0, %384 ], [ %storemerge.i, %..loopexit_crit_edge ], [ %storemerge.i, %..loopexit172_crit_edge ], [ %storemerge.i, %326 ]
<   %398 = phi i32 [ 0, %384 ], [ %290, %..loopexit_crit_edge ], [ %290, %..loopexit172_crit_edge ], [ %290, %326 ]
<   %399 = phi i32 [ 0, %384 ], [ %292, %..loopexit_crit_edge ], [ %292, %..loopexit172_crit_edge ], [ %292, %326 ]
<   %400 = phi i32 [ %386, %384 ], [ %395, %..loopexit_crit_edge ], [ %396, %..loopexit172_crit_edge ], [ %332, %326 ]
<   %sp_mask.0 = phi i32 [ %392, %384 ], [ %318, %..loopexit_crit_edge ], [ %318, %..loopexit172_crit_edge ], [ %318, %326 ]
<   %401 = phi i32 [ %394, %384 ], [ %324, %..loopexit_crit_edge ], [ %324, %..loopexit172_crit_edge ], [ %324, %326 ]
<   %new_stack.0 = phi i32 [ 0, %384 ], [ 1, %..loopexit_crit_edge ], [ 1, %..loopexit172_crit_edge ], [ 1, %326 ]
<   %402 = icmp eq i32 %171, 0
<   br i1 %402, label %.loopexit.thread, label %403
< 
< ; <label>:403                                     ; preds = %.loopexit
<   %404 = add i32 %400, -4
<   %405 = and i32 %404, %sp_mask.0
<   %406 = add i32 %401, %405
<   %407 = load %struct.CPUX86State** @env, align 8
<   %408 = getelementptr inbounds %struct.CPUX86State* %407, i64 0, i32 10, i64 1, i32 0
<   %409 = load i32* %408, align 4
<   tail call fastcc void @stl_kernel(i32 %406, i32 %409)
<   %410 = add i32 %400, -8
<   %411 = and i32 %410, %sp_mask.0
<   %412 = add i32 %401, %411
<   tail call fastcc void @stl_kernel(i32 %412, i32 %4)
<   br label %427
< 
< .loopexit.thread:                                 ; preds = %.loopexit, %355
<   %new_stack.0183 = phi i32 [ %new_stack.0, %.loopexit ], [ 1, %355 ]
<   %413 = phi i32 [ %401, %.loopexit ], [ %324, %355 ]
<   %sp_mask.0181 = phi i32 [ %sp_mask.0, %.loopexit ], [ %318, %355 ]
<   %414 = phi i32 [ %400, %.loopexit ], [ %361, %355 ]
<   %415 = phi i32 [ %399, %.loopexit ], [ %292, %355 ]
<   %416 = phi i32 [ %398, %.loopexit ], [ %290, %355 ]
<   %417 = phi i32 [ %397, %.loopexit ], [ %storemerge.i, %355 ]
<   %418 = add i32 %414, -2
<   %419 = and i32 %418, %sp_mask.0181
<   %420 = add i32 %419, %413
<   %421 = load %struct.CPUX86State** @env, align 8
<   %422 = getelementptr inbounds %struct.CPUX86State* %421, i64 0, i32 10, i64 1, i32 0
<   %423 = load i32* %422, align 4
<   tail call fastcc void @stw_kernel(i32 %420, i32 %423)
<   %424 = add i32 %414, -4
<   %425 = and i32 %424, %sp_mask.0181
<   %426 = add i32 %425, %413
<   tail call fastcc void @stw_kernel(i32 %426, i32 %4)
<   br label %427
< 
< ; <label>:427                                     ; preds = %.loopexit.thread, %403
<   %new_stack.0182 = phi i32 [ %new_stack.0183, %.loopexit.thread ], [ %new_stack.0, %403 ]
<   %428 = phi i32 [ %413, %.loopexit.thread ], [ %401, %403 ]
<   %sp_mask.0180 = phi i32 [ %sp_mask.0181, %.loopexit.thread ], [ %sp_mask.0, %403 ]
<   %429 = phi i32 [ %415, %.loopexit.thread ], [ %399, %403 ]
<   %430 = phi i32 [ %416, %.loopexit.thread ], [ %398, %403 ]
<   %431 = phi i32 [ %417, %.loopexit.thread ], [ %397, %403 ]
<   %432 = phi i32 [ %424, %.loopexit.thread ], [ %410, %403 ]
<   %433 = icmp eq i32 %new_stack.0182, 0
<   br i1 %433, label %482, label %434
< 
< ; <label>:434                                     ; preds = %427
<   %435 = and i32 %431, -4
<   %436 = or i32 %435, %211
<   %437 = load %struct.CPUX86State** @env, align 8
<   %438 = and i32 %430, 65535
<   %439 = and i32 %429, 983040
<   %440 = or i32 %438, %439
<   %441 = and i32 %429, 8388608
<   %442 = icmp eq i32 %441, 0
<   br i1 %442, label %get_seg_limit.exit111, label %443
< 
< ; <label>:443                                     ; preds = %434
<   %444 = shl nuw i32 %440, 12
<   %445 = or i32 %444, 4095
<   br label %get_seg_limit.exit111
< 
< get_seg_limit.exit111:                            ; preds = %443, %434
<   %limit.0.i110 = phi i32 [ %445, %443 ], [ %440, %434 ]
<   %446 = getelementptr inbounds %struct.CPUX86State* %437, i64 0, i32 10, i64 2, i32 0
<   store i32 %436, i32* %446, align 4
<   %447 = getelementptr inbounds %struct.CPUX86State* %437, i64 0, i32 10, i64 2, i32 1
<   store i32 %428, i32* %447, align 4
<   %448 = getelementptr inbounds %struct.CPUX86State* %437, i64 0, i32 10, i64 2, i32 2
<   store i32 %limit.0.i110, i32* %448, align 4
<   %449 = getelementptr inbounds %struct.CPUX86State* %437, i64 0, i32 10, i64 2, i32 3
<   store i32 %429, i32* %449, align 4
<   %.phi.trans.insert.i = getelementptr inbounds %struct.CPUX86State* %437, i64 0, i32 8
<   %.pre.i = load i32* %.phi.trans.insert.i, align 4
<   %450 = lshr i32 %429, 17
<   %451 = and i32 %450, 32
<   %452 = and i32 %.pre.i, 32768
<   %453 = icmp eq i32 %452, 0
<   br i1 %453, label %454, label %cpu_x86_load_seg_cache.exit109
< 
< ; <label>:454                                     ; preds = %get_seg_limit.exit111
<   %455 = getelementptr inbounds %struct.CPUX86State* %437, i64 0, i32 15, i64 0
<   %456 = load i32* %455, align 4
<   %457 = and i32 %456, 1
<   %458 = icmp eq i32 %457, 0
<   br i1 %458, label %467, label %459
---
> ; <label>:33                                      ; preds = %0
>   %34 = load i32* %aExp, align 4
>   %35 = icmp sle i32 %34, 126
>   br i1 %35, label %36, label %49
8453,8590c5853,5858
< ; <label>:459                                     ; preds = %454
<   %460 = getelementptr inbounds %struct.CPUX86State* %437, i64 0, i32 7
<   %461 = load i32* %460, align 4
<   %462 = and i32 %461, 131072
<   %463 = icmp eq i32 %462, 0
<   br i1 %463, label %464, label %467
< 
< ; <label>:464                                     ; preds = %459
<   %465 = and i32 %.pre.i, 16
<   %466 = icmp eq i32 %465, 0
<   br i1 %466, label %467, label %469
< 
< ; <label>:467                                     ; preds = %464, %459, %454
<   %468 = or i32 %451, 64
<   br label %cpu_x86_load_seg_cache.exit109
< 
< ; <label>:469                                     ; preds = %464
<   %470 = getelementptr inbounds %struct.CPUX86State* %437, i64 0, i32 10, i64 3, i32 1
<   %471 = load i32* %470, align 4
<   %472 = getelementptr inbounds %struct.CPUX86State* %437, i64 0, i32 10, i64 0, i32 1
<   %473 = load i32* %472, align 4
<   %474 = or i32 %471, %428
<   %475 = or i32 %474, %473
<   %476 = icmp ne i32 %475, 0
<   %477 = zext i1 %476 to i32
<   %478 = shl nuw nsw i32 %477, 6
<   %479 = or i32 %478, %451
<   br label %cpu_x86_load_seg_cache.exit109
< 
< cpu_x86_load_seg_cache.exit109:                   ; preds = %469, %467, %get_seg_limit.exit111
<   %new_hflags.0.i108 = phi i32 [ %451, %get_seg_limit.exit111 ], [ %468, %467 ], [ %479, %469 ]
<   %480 = and i32 %.pre.i, -97
<   %481 = or i32 %new_hflags.0.i108, %480
<   store i32 %481, i32* %.phi.trans.insert.i, align 4
<   br label %482
< 
< ; <label>:482                                     ; preds = %cpu_x86_load_seg_cache.exit109, %427
<   %483 = or i32 %211, %185
<   %484 = load %struct.CPUX86State** @env, align 8
<   %485 = lshr i32 %203, 16
<   %486 = shl i32 %205, 16
<   %487 = and i32 %486, 16711680
<   %488 = and i32 %205, -16777216
<   %489 = or i32 %488, %485
<   %490 = or i32 %489, %487
<   %491 = and i32 %203, 65535
<   %492 = and i32 %205, 983040
<   %493 = or i32 %492, %491
<   %494 = and i32 %205, 8388608
<   %495 = icmp eq i32 %494, 0
<   br i1 %495, label %get_seg_limit.exit107, label %496
< 
< ; <label>:496                                     ; preds = %482
<   %497 = shl nuw i32 %493, 12
<   %498 = or i32 %497, 4095
<   br label %get_seg_limit.exit107
< 
< get_seg_limit.exit107:                            ; preds = %496, %482
<   %limit.0.i106 = phi i32 [ %498, %496 ], [ %493, %482 ]
<   %499 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 10, i64 1, i32 0
<   store i32 %483, i32* %499, align 4
<   %500 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 10, i64 1, i32 1
<   store i32 %490, i32* %500, align 4
<   %501 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 10, i64 1, i32 2
<   store i32 %limit.0.i106, i32* %501, align 4
<   %502 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 10, i64 1, i32 3
<   store i32 %205, i32* %502, align 4
<   %503 = lshr i32 %205, 18
<   %504 = and i32 %503, 16
<   %505 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 8
<   %506 = load i32* %505, align 4
<   %507 = and i32 %506, -32785
<   %508 = or i32 %507, %504
<   store i32 %508, i32* %505, align 4
<   %509 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 10, i64 2, i32 3
<   %510 = load i32* %509, align 4
<   %511 = lshr i32 %510, 17
<   %512 = and i32 %511, 32
<   %513 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 15, i64 0
<   %514 = load i32* %513, align 4
<   %515 = and i32 %514, 1
<   %516 = icmp eq i32 %515, 0
<   br i1 %516, label %523, label %517
< 
< ; <label>:517                                     ; preds = %get_seg_limit.exit107
<   %518 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 7
<   %519 = load i32* %518, align 4
<   %520 = and i32 %519, 131072
<   %521 = icmp ne i32 %520, 0
<   %522 = icmp eq i32 %504, 0
<   %or.cond169 = or i1 %521, %522
<   br i1 %or.cond169, label %523, label %525
< 
< ; <label>:523                                     ; preds = %517, %get_seg_limit.exit107
<   %524 = or i32 %512, 64
<   br label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:525                                     ; preds = %517
<   %526 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 10, i64 3, i32 1
<   %527 = load i32* %526, align 4
<   %528 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 10, i64 0, i32 1
<   %529 = load i32* %528, align 4
<   %530 = or i32 %529, %527
<   %531 = getelementptr inbounds %struct.CPUX86State* %484, i64 0, i32 10, i64 2, i32 1
<   %532 = load i32* %531, align 4
<   %533 = or i32 %530, %532
<   %534 = icmp ne i32 %533, 0
<   %535 = zext i1 %534 to i32
<   %536 = shl nuw nsw i32 %535, 6
<   %537 = or i32 %536, %512
<   br label %cpu_x86_load_seg_cache.exit
< 
< cpu_x86_load_seg_cache.exit:                      ; preds = %525, %523
<   %new_hflags.0.i = phi i32 [ %524, %523 ], [ %537, %525 ]
<   %538 = and i32 %508, -32865
<   %539 = or i32 %new_hflags.0.i, %538
<   store i32 %539, i32* %505, align 4
<   %540 = load %struct.CPUX86State** @env, align 8
<   %541 = getelementptr inbounds %struct.CPUX86State* %540, i64 0, i32 8
<   %542 = load i32* %541, align 4
<   %543 = and i32 %542, 3
<   tail call void @s2e_on_privilege_change(i32 %543, i32 %211) nounwind
<   %544 = load i32* %541, align 4
<   %545 = and i32 %544, -4
<   %546 = or i32 %545, %211
<   store i32 %546, i32* %541, align 4
<   %547 = load %struct.CPUX86State** @env, align 8
<   %548 = getelementptr inbounds %struct.CPUX86State* %547, i64 0, i32 0, i64 4
<   %549 = load i32* %548, align 4
<   %550 = xor i32 %sp_mask.0180, -1
<   %551 = and i32 %549, %550
<   %552 = and i32 %432, %sp_mask.0180
<   %553 = or i32 %551, %552
<   store i32 %553, i32* %548, align 4
<   %554 = load %struct.CPUX86State** @env, align 8
<   %555 = getelementptr inbounds %struct.CPUX86State* %554, i64 0, i32 5
<   store i32 %183, i32* %555, align 4
<   br label %556
---
> ; <label>:36                                      ; preds = %33
>   %37 = load i32* %aExp, align 4
>   %38 = load i32* %aSig, align 4
>   %39 = or i32 %37, %38
>   %40 = icmp ne i32 %39, 0
>   br i1 %40, label %41, label %48
8592,8594c5860,5868
< ; <label>:556                                     ; preds = %cpu_x86_load_seg_cache.exit, %166, %cpu_x86_load_seg_cache.exit113
<   ret void
< }
---
> ; <label>:41                                      ; preds = %36
>   %42 = load %struct.float_status** %3, align 4
>   %43 = getelementptr inbounds %struct.float_status* %42, i32 0, i32 2
>   %44 = load i8* %43, align 1
>   %45 = sext i8 %44 to i32
>   %46 = or i32 %45, 32
>   %47 = trunc i32 %46 to i8
>   store i8 %47, i8* %43, align 1
>   br label %48
8596,8600c5870,5872
< define internal fastcc i32 @lduw_kernel(i32 %ptr) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:48                                      ; preds = %41, %36
>   store i64 0, i64* %1
>   br label %82
8602,8604c5874,5875
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:49                                      ; preds = %33
>   br label %50
8606,8619c5877,5907
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 0
<   %16 = load i32* %15, align 4
<   %17 = and i32 %8, -4095
<   %18 = icmp eq i32 %16, %17
<   br i1 %18, label %21, label %19, !prof !0
---
> ; <label>:50                                      ; preds = %49
>   %51 = load i32* %aSig, align 4
>   %52 = or i32 %51, 8388608
>   %53 = zext i32 %52 to i64
>   store i64 %53, i64* %aSig64, align 8
>   %54 = load i64* %aSig64, align 8
>   %55 = shl i64 %54, 40
>   store i64 %55, i64* %aSig64, align 8
>   %56 = load i64* %aSig64, align 8
>   %57 = load i32* %shiftCount, align 4
>   %58 = sub nsw i32 0, %57
>   %59 = zext i32 %58 to i64
>   %60 = lshr i64 %56, %59
>   store i64 %60, i64* %z, align 8
>   %61 = load i64* %aSig64, align 8
>   %62 = load i32* %shiftCount, align 4
>   %63 = and i32 %62, 63
>   %64 = zext i32 %63 to i64
>   %65 = shl i64 %61, %64
>   %66 = icmp ne i64 %65, 0
>   br i1 %66, label %67, label %74
> 
> ; <label>:67                                      ; preds = %50
>   %68 = load %struct.float_status** %3, align 4
>   %69 = getelementptr inbounds %struct.float_status* %68, i32 0, i32 2
>   %70 = load i8* %69, align 1
>   %71 = sext i8 %70 to i32
>   %72 = or i32 %71, 32
>   %73 = trunc i32 %72 to i8
>   store i8 %73, i8* %69, align 1
>   br label %74
8621,8623c5909,5912
< ; <label>:19                                      ; preds = %6
<   %20 = tail call zeroext i16 @__ldw_mmu(i32 %8, i32 0)
<   br label %29
---
> ; <label>:74                                      ; preds = %67, %50
>   %75 = load i8* %aSign, align 1
>   %76 = icmp ne i8 %75, 0
>   br i1 %76, label %77, label %80
8625,8634c5914,5923
< ; <label>:21                                      ; preds = %6
<   %22 = and i64 %7, 4294967295
<   %23 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 3
<   %24 = load i64* %23, align 8
<   %25 = add i64 %24, %22
<   %26 = inttoptr i64 %25 to i16*
<   %27 = load i16* %26, align 2
<   %28 = zext i16 %27 to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %22, i64 %25, i64 %28, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %29
---
> ; <label>:77                                      ; preds = %74
>   %78 = load i64* %z, align 8
>   %79 = sub nsw i64 0, %78
>   store i64 %79, i64* %z, align 8
>   br label %80
> 
> ; <label>:80                                      ; preds = %77, %74
>   %81 = load i64* %z, align 8
>   store i64 %81, i64* %1
>   br label %82
8636,8639c5925,5927
< ; <label>:29                                      ; preds = %21, %19
<   %res.0.in = phi i16 [ %20, %19 ], [ %27, %21 ]
<   %res.0 = zext i16 %res.0.in to i32
<   ret i32 %res.0
---
> ; <label>:82                                      ; preds = %80, %48, %32, %30
>   %83 = load i64* %1
>   ret i64 %83
8642,8651c5930,5955
< define void @helper_iret_real(i32 %shift) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 4
<   %3 = load i32* %2, align 4
<   %4 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 2, i32 1
<   %5 = load i32* %4, align 4
<   %6 = icmp eq i32 %shift, 1
<   %7 = and i32 %3, 65535
<   %8 = add i32 %5, %7
<   br i1 %6, label %9, label %21
---
> define internal i64 @float32_to_float64(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %4 = alloca %struct.commonNaNT, align 4
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %2, align 4
>   %9 = call i32 @extractFloat32Frac(i32 %8)
>   store i32 %9, i32* %aSig, align 4
>   %10 = load i32* %2, align 4
>   %11 = call i32 @extractFloat32Exp(i32 %10)
>   store i32 %11, i32* %aExp, align 4
>   %12 = load i32* %2, align 4
>   %13 = call zeroext i8 @extractFloat32Sign(i32 %12)
>   store i8 %13, i8* %aSign, align 1
>   %14 = load i32* %aExp, align 4
>   %15 = icmp eq i32 %14, 255
>   br i1 %15, label %16, label %27
8653,8665c5957,5969
< ; <label>:9                                       ; preds = %0
<   %10 = tail call fastcc i32 @ldl_kernel(i32 %8)
<   %11 = add i32 %3, 4
<   %12 = and i32 %11, 65535
<   %13 = add i32 %12, %5
<   %14 = tail call fastcc i32 @ldl_kernel(i32 %13)
<   %15 = add i32 %3, 8
<   %16 = and i32 %14, 65535
<   %17 = and i32 %15, 65535
<   %18 = add i32 %17, %5
<   %19 = tail call fastcc i32 @ldl_kernel(i32 %18)
<   %20 = add i32 %3, 12
<   br label %32
---
> ; <label>:16                                      ; preds = %0
>   %17 = load i32* %aSig, align 4
>   %18 = icmp ne i32 %17, 0
>   br i1 %18, label %19, label %24
> 
> ; <label>:19                                      ; preds = %16
>   %20 = load i32* %2, align 4
>   %21 = load %struct.float_status** %3, align 4
>   call void @float32ToCommonNaN(%struct.commonNaNT* sret %4, i32 %20, %struct.float_status* %21)
>   %22 = load %struct.float_status** %3, align 4
>   %23 = call i64 @commonNaNToFloat64(%struct.commonNaNT* byval align 4 %4, %struct.float_status* %22)
>   store i64 %23, i64* %1
>   br label %48
8667,8678c5971,5975
< ; <label>:21                                      ; preds = %0
<   %22 = tail call fastcc i32 @lduw_kernel(i32 %8)
<   %23 = add i32 %3, 2
<   %24 = and i32 %23, 65535
<   %25 = add i32 %24, %5
<   %26 = tail call fastcc i32 @lduw_kernel(i32 %25)
<   %27 = add i32 %3, 4
<   %28 = and i32 %27, 65535
<   %29 = add i32 %28, %5
<   %30 = tail call fastcc i32 @lduw_kernel(i32 %29)
<   %31 = add i32 %3, 6
<   br label %32
---
> ; <label>:24                                      ; preds = %16
>   %25 = load i8* %aSign, align 1
>   %26 = call i64 @packFloat64(i8 zeroext %25, i32 2047, i64 0)
>   store i64 %26, i64* %1
>   br label %48
8680,8735c5977,5980
< ; <label>:32                                      ; preds = %21, %9
<   %new_eip.0 = phi i32 [ %10, %9 ], [ %22, %21 ]
<   %new_eflags.0 = phi i32 [ %19, %9 ], [ %30, %21 ]
<   %new_cs.0 = phi i32 [ %16, %9 ], [ %26, %21 ]
<   %sp.0 = phi i32 [ %20, %9 ], [ %31, %21 ]
<   %33 = load %struct.CPUX86State** @env, align 8
<   %34 = getelementptr inbounds %struct.CPUX86State* %33, i64 0, i32 0, i64 4
<   %35 = load i32* %34, align 4
<   %36 = and i32 %35, -65536
<   %37 = and i32 %sp.0, 65535
<   %38 = or i32 %36, %37
<   store i32 %38, i32* %34, align 4
<   %39 = load %struct.CPUX86State** @env, align 8
<   %40 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 10, i64 1, i32 0
<   store i32 %new_cs.0, i32* %40, align 4
<   %41 = shl i32 %new_cs.0, 4
<   %42 = load %struct.CPUX86State** @env, align 8
<   %43 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 10, i64 1, i32 1
<   store i32 %41, i32* %43, align 4
<   %44 = load %struct.CPUX86State** @env, align 8
<   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 5
<   store i32 %new_eip.0, i32* %45, align 4
<   %46 = load %struct.CPUX86State** @env, align 8
<   %47 = getelementptr inbounds %struct.CPUX86State* %46, i64 0, i32 7
<   %48 = load i32* %47, align 4
<   %49 = and i32 %48, 131072
<   %50 = icmp eq i32 %49, 0
<   %. = select i1 %50, i32 2454272, i32 2441984
<   %51 = icmp eq i32 %shift, 0
<   %52 = and i32 %., 29440
<   %eflags_mask.1 = select i1 %51, i32 %52, i32 %.
<   %53 = and i32 %new_eflags.0, 2261
<   %54 = getelementptr inbounds %struct.CPUX86State* %46, i64 0, i32 2
<   store i32 %53, i32* %54, align 4
<   %55 = lshr i32 %new_eflags.0, 9
<   %56 = and i32 %55, 2
<   %57 = xor i32 %56, 2
<   %58 = add i32 %57, -1
<   %59 = load %struct.CPUX86State** @env, align 8
<   %60 = getelementptr inbounds %struct.CPUX86State* %59, i64 0, i32 6
<   store i32 %58, i32* %60, align 4
<   %61 = load %struct.CPUX86State** @env, align 8
<   %62 = getelementptr inbounds %struct.CPUX86State* %61, i64 0, i32 7
<   %63 = load i32* %62, align 4
<   %64 = xor i32 %eflags_mask.1, -1
<   %65 = and i32 %63, %64
<   %66 = and i32 %eflags_mask.1, %new_eflags.0
<   %67 = or i32 %65, %66
<   store i32 %67, i32* %62, align 4
<   %68 = load %struct.CPUX86State** @env, align 8
<   %69 = getelementptr inbounds %struct.CPUX86State* %68, i64 0, i32 9
<   %70 = load i32* %69, align 4
<   %71 = and i32 %70, -5
<   store i32 %71, i32* %69, align 4
<   ret void
< }
---
> ; <label>:27                                      ; preds = %0
>   %28 = load i32* %aExp, align 4
>   %29 = icmp eq i32 %28, 0
>   br i1 %29, label %30, label %40
8737,8743c5982,5985
< define void @helper_iret_protected(i32 %shift, i32 %next_eip) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 7
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, 16384
<   %5 = icmp eq i32 %4, 0
<   br i1 %5, label %35, label %6
---
> ; <label>:30                                      ; preds = %27
>   %31 = load i32* %aSig, align 4
>   %32 = icmp eq i32 %31, 0
>   br i1 %32, label %33, label %36
8745,8751c5987,5991
< ; <label>:6                                       ; preds = %0
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 12, i32 1
<   %8 = load i32* %7, align 4
<   %9 = tail call fastcc i32 @lduw_kernel(i32 %8)
<   %10 = and i32 %9, 4
<   %11 = icmp eq i32 %10, 0
<   br i1 %11, label %14, label %12
---
> ; <label>:33                                      ; preds = %30
>   %34 = load i8* %aSign, align 1
>   %35 = call i64 @packFloat64(i8 zeroext %34, i32 0, i64 0)
>   store i64 %35, i64* %1
>   br label %48
8753,8756c5993,5999
< ; <label>:12                                      ; preds = %6
<   %13 = and i32 %9, 65532
<   tail call fastcc void @raise_exception_err(i32 10, i32 %13) noreturn
<   unreachable
---
> ; <label>:36                                      ; preds = %30
>   %37 = load i32* %aSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %37, i32* %aExp, i32* %aSig)
>   %38 = load i32* %aExp, align 4
>   %39 = add nsw i32 %38, -1
>   store i32 %39, i32* %aExp, align 4
>   br label %40
8758,8764c6001,6010
< ; <label>:14                                      ; preds = %6
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = or i32 %9, 7
<   %17 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 13, i32 2
<   %18 = load i32* %17, align 4
<   %19 = icmp ugt i32 %16, %18
<   br i1 %19, label %20, label %22
---
> ; <label>:40                                      ; preds = %36, %27
>   %41 = load i8* %aSign, align 1
>   %42 = load i32* %aExp, align 4
>   %43 = add nsw i32 %42, 896
>   %44 = load i32* %aSig, align 4
>   %45 = zext i32 %44 to i64
>   %46 = shl i64 %45, 29
>   %47 = call i64 @packFloat64(i8 zeroext %41, i32 %43, i64 %46)
>   store i64 %47, i64* %1
>   br label %48
8766,8769c6012,6030
< ; <label>:20                                      ; preds = %14
<   %21 = and i32 %9, 65532
<   tail call fastcc void @raise_exception_err(i32 10, i32 %21) noreturn
<   unreachable
---
> ; <label>:48                                      ; preds = %40, %33, %24, %19
>   %49 = load i64* %1
>   ret i64 %49
> }
> 
> define internal i64 @commonNaNToFloat64(%struct.commonNaNT* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %mantissa = alloca i64, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 1
>   %4 = load i64* %3, align 4
>   %5 = lshr i64 %4, 12
>   store i64 %5, i64* %mantissa, align 8
>   %6 = load %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float_status* %6, i32 0, i32 6
>   %8 = load i8* %7, align 1
>   %9 = icmp ne i8 %8, 0
>   br i1 %9, label %10, label %11
8771,8781c6032,6034
< ; <label>:22                                      ; preds = %14
<   %23 = and i32 %9, -8
<   %24 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 13, i32 1
<   %25 = load i32* %24, align 4
<   %26 = add i32 %25, %23
<   %27 = tail call fastcc i32 @ldl_kernel(i32 %26) nounwind
<   %28 = add i32 %26, 4
<   %29 = tail call fastcc i32 @ldl_kernel(i32 %28) nounwind
<   %30 = and i32 %29, 5888
<   %31 = icmp eq i32 %30, 768
<   br i1 %31, label %34, label %32
---
> ; <label>:10                                      ; preds = %0
>   store i64 -2251799813685248, i64* %1
>   br label %25
8783,8786c6036,6039
< ; <label>:32                                      ; preds = %22
<   %33 = and i32 %9, 65532
<   tail call fastcc void @raise_exception_err(i32 10, i32 %33) noreturn
<   unreachable
---
> ; <label>:11                                      ; preds = %0
>   %12 = load i64* %mantissa, align 8
>   %13 = icmp ne i64 %12, 0
>   br i1 %13, label %14, label %24
8788,8822c6041,6052
< ; <label>:34                                      ; preds = %22
<   tail call fastcc void @switch_tss(i32 %9, i32 %27, i32 %29, i32 1, i32 %next_eip)
<   br label %helper_ret_protected.exit
< 
< ; <label>:35                                      ; preds = %0
<   %36 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 2, i32 3
<   %37 = load i32* %36, align 4
<   %38 = lshr i32 %37, 6
<   %39 = and i32 %38, 65536
<   %40 = xor i32 %39, 65536
<   %41 = add i32 %40, -1
<   %42 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 4
<   %43 = load i32* %42, align 4
<   %44 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 2, i32 1
<   %45 = load i32* %44, align 4
<   %46 = icmp eq i32 %shift, 1
<   %47 = and i32 %41, %43
<   %48 = add i32 %47, %45
<   br i1 %46, label %49, label %63
< 
< ; <label>:49                                      ; preds = %35
<   %50 = tail call fastcc i32 @ldl_kernel(i32 %48) nounwind
<   %51 = add i32 %43, 4
<   %52 = and i32 %41, %51
<   %53 = add i32 %52, %45
<   %54 = tail call fastcc i32 @ldl_kernel(i32 %53) nounwind
<   %55 = add i32 %43, 8
<   %56 = and i32 %54, 65535
<   %57 = and i32 %41, %55
<   %58 = add i32 %57, %45
<   %59 = tail call fastcc i32 @ldl_kernel(i32 %58) nounwind
<   %60 = add i32 %43, 12
<   %61 = and i32 %59, 131072
<   %62 = icmp eq i32 %61, 0
<   br i1 %62, label %74, label %load_seg_vm.exit133.i
---
> ; <label>:14                                      ; preds = %11
>   %15 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 0
>   %16 = load i8* %15, align 1
>   %17 = zext i8 %16 to i64
>   %18 = shl i64 %17, 63
>   %19 = or i64 %18, 9218868437227405312
>   %20 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 1
>   %21 = load i64* %20, align 4
>   %22 = lshr i64 %21, 12
>   %23 = or i64 %19, %22
>   store i64 %23, i64* %1
>   br label %25
8824,8835c6054,6056
< ; <label>:63                                      ; preds = %35
<   %64 = tail call fastcc i32 @lduw_kernel(i32 %48) nounwind
<   %65 = add i32 %43, 2
<   %66 = and i32 %41, %65
<   %67 = add i32 %66, %45
<   %68 = tail call fastcc i32 @lduw_kernel(i32 %67) nounwind
<   %69 = add i32 %43, 4
<   %70 = and i32 %41, %69
<   %71 = add i32 %70, %45
<   %72 = tail call fastcc i32 @lduw_kernel(i32 %71) nounwind
<   %73 = add i32 %43, 6
<   br label %74
---
> ; <label>:24                                      ; preds = %11
>   store i64 -2251799813685248, i64* %1
>   br label %25
8837,8844c6058,6061
< ; <label>:74                                      ; preds = %63, %49
<   %new_eflags.0.i = phi i32 [ %59, %49 ], [ %72, %63 ]
<   %new_cs.0.i = phi i32 [ %56, %49 ], [ %68, %63 ]
<   %sp.0.i = phi i32 [ %60, %49 ], [ %73, %63 ]
<   %new_eip.0.i = phi i32 [ %50, %49 ], [ %64, %63 ]
<   %75 = and i32 %new_cs.0.i, 65532
<   %76 = icmp eq i32 %75, 0
<   br i1 %76, label %77, label %78
---
> ; <label>:25                                      ; preds = %24, %14, %10
>   %26 = load i64* %1
>   ret i64 %26
> }
8846,8848c6063,6072
< ; <label>:77                                      ; preds = %74
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn nounwind
<   unreachable
---
> define internal void @float32ToCommonNaN(%struct.commonNaNT* noalias sret %agg.result, i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %z = alloca %struct.commonNaNT, align 4
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = call i32 @float32_is_signaling_nan(i32 %3)
>   %5 = icmp ne i32 %4, 0
>   br i1 %5, label %6, label %8
8850,8861c6074,6077
< ; <label>:78                                      ; preds = %74
<   %79 = and i32 %new_cs.0.i, 4
<   %80 = icmp eq i32 %79, 0
<   %81 = load %struct.CPUX86State** @env, align 8
<   %82 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 11
<   %83 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 13
<   %dt.0.i.i = select i1 %80, %struct.SegmentCache* %83, %struct.SegmentCache* %82
<   %84 = or i32 %new_cs.0.i, 7
<   %85 = getelementptr inbounds %struct.SegmentCache* %dt.0.i.i, i64 0, i32 2
<   %86 = load i32* %85, align 4
<   %87 = icmp ugt i32 %84, %86
<   br i1 %87, label %88, label %89
---
> ; <label>:6                                       ; preds = %0
>   %7 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %7)
>   br label %8
8863,8865c6079,6096
< ; <label>:88                                      ; preds = %78
<   tail call fastcc void @raise_exception_err(i32 13, i32 %75) noreturn nounwind
<   unreachable
---
> ; <label>:8                                       ; preds = %6, %0
>   %9 = load i32* %1, align 4
>   %10 = lshr i32 %9, 31
>   %11 = trunc i32 %10 to i8
>   %12 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 0
>   store i8 %11, i8* %12, align 1
>   %13 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 2
>   store i64 0, i64* %13, align 4
>   %14 = load i32* %1, align 4
>   %15 = zext i32 %14 to i64
>   %16 = shl i64 %15, 41
>   %17 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 1
>   store i64 %16, i64* %17, align 4
>   %18 = bitcast %struct.commonNaNT* %agg.result to i8*
>   %19 = bitcast %struct.commonNaNT* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %18, i8* %19, i32 20, i32 4, i1 false)
>   ret void
> }
8867,8877c6098,6124
< ; <label>:89                                      ; preds = %78
<   %90 = and i32 %new_cs.0.i, -8
<   %91 = getelementptr inbounds %struct.SegmentCache* %dt.0.i.i, i64 0, i32 1
<   %92 = load i32* %91, align 4
<   %93 = add i32 %92, %90
<   %94 = tail call fastcc i32 @ldl_kernel(i32 %93) nounwind
<   %95 = add i32 %93, 4
<   %96 = tail call fastcc i32 @ldl_kernel(i32 %95) nounwind
<   %97 = and i32 %96, 6144
<   %98 = icmp eq i32 %97, 6144
<   br i1 %98, label %100, label %99
---
> define internal void @normalizeFloat32Subnormal(i32 %aSig, i32* %zExpPtr, i32* %zSigPtr) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32*, align 4
>   %3 = alloca i32*, align 4
>   %shiftCount = alloca i8, align 1
>   store i32 %aSig, i32* %1, align 4
>   store i32* %zExpPtr, i32** %2, align 4
>   store i32* %zSigPtr, i32** %3, align 4
>   %4 = load i32* %1, align 4
>   %5 = call signext i8 @countLeadingZeros32(i32 %4)
>   %6 = sext i8 %5 to i32
>   %7 = sub nsw i32 %6, 8
>   %8 = trunc i32 %7 to i8
>   store i8 %8, i8* %shiftCount, align 1
>   %9 = load i32* %1, align 4
>   %10 = load i8* %shiftCount, align 1
>   %11 = sext i8 %10 to i32
>   %12 = shl i32 %9, %11
>   %13 = load i32** %3, align 4
>   store i32 %12, i32* %13, align 4
>   %14 = load i8* %shiftCount, align 1
>   %15 = sext i8 %14 to i32
>   %16 = sub nsw i32 1, %15
>   %17 = load i32** %2, align 4
>   store i32 %16, i32* %17, align 4
>   ret void
> }
8879,8881c6126,6150
< ; <label>:99                                      ; preds = %89
<   tail call fastcc void @raise_exception_err(i32 13, i32 %75) noreturn nounwind
<   unreachable
---
> define internal void @float32_to_floatx80(%struct.floatx80* noalias sret %agg.result, i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %3 = alloca %struct.commonNaNT, align 4
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %4 = load i32* %1, align 4
>   %5 = load %struct.float_status** %2, align 4
>   %6 = call i32 @float32_squash_input_denormal(i32 %4, %struct.float_status* %5)
>   store i32 %6, i32* %1, align 4
>   %7 = load i32* %1, align 4
>   %8 = call i32 @extractFloat32Frac(i32 %7)
>   store i32 %8, i32* %aSig, align 4
>   %9 = load i32* %1, align 4
>   %10 = call i32 @extractFloat32Exp(i32 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i32* %1, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 255
>   br i1 %14, label %15, label %24
8883,8890c6152,6155
< ; <label>:100                                     ; preds = %89
<   %101 = load %struct.CPUX86State** @env, align 8
<   %102 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 8
<   %103 = load i32* %102, align 4
<   %104 = and i32 %103, 3
<   %105 = and i32 %new_cs.0.i, 3
<   %106 = icmp ult i32 %105, %104
<   br i1 %106, label %107, label %108
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %aSig, align 4
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %18, label %22
8892,8894c6157,6163
< ; <label>:107                                     ; preds = %100
<   tail call fastcc void @raise_exception_err(i32 13, i32 %75) noreturn nounwind
<   unreachable
---
> ; <label>:18                                      ; preds = %15
>   %19 = load i32* %1, align 4
>   %20 = load %struct.float_status** %2, align 4
>   call void @float32ToCommonNaN(%struct.commonNaNT* sret %3, i32 %19, %struct.float_status* %20)
>   %21 = load %struct.float_status** %2, align 4
>   call void @commonNaNToFloatx80(%struct.floatx80* sret %agg.result, %struct.commonNaNT* byval align 4 %3, %struct.float_status* %21)
>   br label %43
8896,8901c6165,6168
< ; <label>:108                                     ; preds = %100
<   %109 = lshr i32 %96, 13
<   %110 = and i32 %109, 3
<   %111 = and i32 %96, 1024
<   %112 = icmp eq i32 %111, 0
<   br i1 %112, label %116, label %113
---
> ; <label>:22                                      ; preds = %15
>   %23 = load i8* %aSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %23, i32 32767, i64 -9223372036854775808)
>   br label %43
8903,8905c6170,6173
< ; <label>:113                                     ; preds = %108
<   %114 = icmp ugt i32 %110, %105
<   br i1 %114, label %115, label %119
---
> ; <label>:24                                      ; preds = %0
>   %25 = load i32* %aExp, align 4
>   %26 = icmp eq i32 %25, 0
>   br i1 %26, label %27, label %34
8907,8909c6175,6183
< ; <label>:115                                     ; preds = %113
<   tail call fastcc void @raise_exception_err(i32 13, i32 %75) noreturn nounwind
<   unreachable
---
> ; <label>:27                                      ; preds = %24
>   %28 = load i32* %aSig, align 4
>   %29 = icmp eq i32 %28, 0
>   br i1 %29, label %30, label %32
> 
> ; <label>:30                                      ; preds = %27
>   %31 = load i8* %aSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %31, i32 0, i64 0)
>   br label %43
8911,8913c6185,6188
< ; <label>:116                                     ; preds = %108
<   %117 = icmp eq i32 %110, %105
<   br i1 %117, label %119, label %118
---
> ; <label>:32                                      ; preds = %27
>   %33 = load i32* %aSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %33, i32* %aExp, i32* %aSig)
>   br label %34
8915,8917c6190,6201
< ; <label>:118                                     ; preds = %116
<   tail call fastcc void @raise_exception_err(i32 13, i32 %75) noreturn nounwind
<   unreachable
---
> ; <label>:34                                      ; preds = %32, %24
>   %35 = load i32* %aSig, align 4
>   %36 = or i32 %35, 8388608
>   store i32 %36, i32* %aSig, align 4
>   %37 = load i8* %aSign, align 1
>   %38 = load i32* %aExp, align 4
>   %39 = add nsw i32 %38, 16256
>   %40 = load i32* %aSig, align 4
>   %41 = zext i32 %40 to i64
>   %42 = shl i64 %41, 40
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %37, i32 %39, i64 %42)
>   br label %43
8919,8922c6203,6205
< ; <label>:119                                     ; preds = %116, %113
<   %120 = and i32 %96, 32768
<   %121 = icmp eq i32 %120, 0
<   br i1 %121, label %122, label %123
---
> ; <label>:43                                      ; preds = %34, %30, %22, %18
>   ret void
> }
8924,8926c6207,6215
< ; <label>:122                                     ; preds = %119
<   tail call fastcc void @raise_exception_err(i32 11, i32 %75) noreturn nounwind
<   unreachable
---
> define internal void @commonNaNToFloatx80(%struct.floatx80* noalias sret %agg.result, %struct.commonNaNT* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %z = alloca %struct.floatx80, align 1
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = load %struct.float_status** %1, align 4
>   %3 = getelementptr inbounds %struct.float_status* %2, i32 0, i32 6
>   %4 = load i8* %3, align 1
>   %5 = icmp ne i8 %4, 0
>   br i1 %5, label %6, label %11
8928,8947c6217,6225
< ; <label>:123                                     ; preds = %119
<   %124 = icmp eq i32 %105, %104
<   %125 = and i32 %103, 32768
<   %126 = icmp eq i32 %125, 0
<   %or.cond = and i1 %124, %126
<   br i1 %or.cond, label %127, label %181
< 
< ; <label>:127                                     ; preds = %123
<   %128 = lshr i32 %94, 16
<   %129 = shl i32 %96, 16
<   %130 = and i32 %129, 16711680
<   %131 = and i32 %96, -16777216
<   %132 = or i32 %131, %128
<   %133 = or i32 %132, %130
<   %134 = and i32 %94, 65535
<   %135 = and i32 %96, 983040
<   %136 = or i32 %135, %134
<   %137 = and i32 %96, 8388608
<   %138 = icmp eq i32 %137, 0
<   br i1 %138, label %get_seg_limit.exit.i, label %139
---
> ; <label>:6                                       ; preds = %0
>   %7 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 -4611686018427387904, i64* %7, align 1
>   %8 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   store i16 -1, i16* %8, align 1
>   %9 = bitcast %struct.floatx80* %agg.result to i8*
>   %10 = bitcast %struct.floatx80* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %9, i8* %10, i32 10, i32 1, i1 false)
>   br label %36
8949,9017c6227,6232
< ; <label>:139                                     ; preds = %127
<   %140 = shl nuw i32 %136, 12
<   %141 = or i32 %140, 4095
<   br label %get_seg_limit.exit.i
< 
< get_seg_limit.exit.i:                             ; preds = %139, %127
<   %limit.0.i.i = phi i32 [ %141, %139 ], [ %136, %127 ]
<   %142 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 10, i64 1, i32 0
<   store i32 %new_cs.0.i, i32* %142, align 4
<   %143 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 10, i64 1, i32 1
<   store i32 %133, i32* %143, align 4
<   %144 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 10, i64 1, i32 2
<   store i32 %limit.0.i.i, i32* %144, align 4
<   %145 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 10, i64 1, i32 3
<   store i32 %96, i32* %145, align 4
<   %146 = lshr i32 %96, 18
<   %147 = and i32 %146, 16
<   %148 = and i32 %103, -32785
<   %149 = or i32 %148, %147
<   store i32 %149, i32* %102, align 4
<   %150 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 10, i64 2, i32 3
<   %151 = load i32* %150, align 4
<   %152 = lshr i32 %151, 17
<   %153 = and i32 %152, 32
<   %154 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 15, i64 0
<   %155 = load i32* %154, align 4
<   %156 = and i32 %155, 1
<   %157 = icmp eq i32 %156, 0
<   br i1 %157, label %164, label %158
< 
< ; <label>:158                                     ; preds = %get_seg_limit.exit.i
<   %159 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 7
<   %160 = load i32* %159, align 4
<   %161 = and i32 %160, 131072
<   %162 = icmp ne i32 %161, 0
<   %163 = icmp eq i32 %147, 0
<   %or.cond192.i = or i1 %162, %163
<   br i1 %or.cond192.i, label %164, label %166
< 
< ; <label>:164                                     ; preds = %158, %get_seg_limit.exit.i
<   %165 = or i32 %153, 64
<   br label %cpu_x86_load_seg_cache.exit.i
< 
< ; <label>:166                                     ; preds = %158
<   %167 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 10, i64 3, i32 1
<   %168 = load i32* %167, align 4
<   %169 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 10, i64 0, i32 1
<   %170 = load i32* %169, align 4
<   %171 = or i32 %170, %168
<   %172 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 10, i64 2, i32 1
<   %173 = load i32* %172, align 4
<   %174 = or i32 %171, %173
<   %175 = icmp ne i32 %174, 0
<   %176 = zext i1 %175 to i32
<   %177 = shl nuw nsw i32 %176, 6
<   %178 = or i32 %177, %153
<   br label %cpu_x86_load_seg_cache.exit.i
< 
< cpu_x86_load_seg_cache.exit.i:                    ; preds = %166, %164
<   %new_hflags.0.i.i = phi i32 [ %165, %164 ], [ %178, %166 ]
<   %179 = and i32 %149, -32865
<   %180 = or i32 %new_hflags.0.i.i, %179
<   store i32 %180, i32* %102, align 4
<   br label %validate_seg.exit.i
< 
< ; <label>:181                                     ; preds = %123
<   %182 = and i32 %sp.0.i, %41
<   %183 = add i32 %182, %45
<   br i1 %46, label %184, label %191
---
> ; <label>:11                                      ; preds = %0
>   %12 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 1
>   %13 = load i64* %12, align 4
>   %14 = lshr i64 %13, 1
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %30
9019,9041c6234,6250
< ; <label>:184                                     ; preds = %181
<   %185 = tail call fastcc i32 @ldl_kernel(i32 %183) nounwind
<   %186 = add i32 %sp.0.i, 4
<   %187 = and i32 %186, %41
<   %188 = add i32 %187, %45
<   %189 = tail call fastcc i32 @ldl_kernel(i32 %188) nounwind
<   %190 = and i32 %189, 65535
<   br label %197
< 
< ; <label>:191                                     ; preds = %181
<   %192 = tail call fastcc i32 @lduw_kernel(i32 %183) nounwind
<   %193 = add i32 %sp.0.i, 2
<   %194 = and i32 %193, %41
<   %195 = add i32 %194, %45
<   %196 = tail call fastcc i32 @lduw_kernel(i32 %195) nounwind
<   br label %197
< 
< ; <label>:197                                     ; preds = %191, %184
<   %new_ss.0.i = phi i32 [ %190, %184 ], [ %196, %191 ]
<   %new_esp.0.i = phi i32 [ %185, %184 ], [ %192, %191 ]
<   %198 = and i32 %new_ss.0.i, 65532
<   %199 = icmp eq i32 %198, 0
<   br i1 %199, label %200, label %201
---
> ; <label>:16                                      ; preds = %11
>   %17 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 1
>   %18 = load i64* %17, align 4
>   %19 = lshr i64 %18, 1
>   %20 = or i64 -9223372036854775808, %19
>   %21 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 %20, i64* %21, align 1
>   %22 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 0
>   %23 = load i8* %22, align 1
>   %24 = zext i8 %23 to i16
>   %25 = zext i16 %24 to i32
>   %26 = shl i32 %25, 15
>   %27 = or i32 %26, 32767
>   %28 = trunc i32 %27 to i16
>   %29 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   store i16 %28, i16* %29, align 1
>   br label %33
9043,9045c6252,6257
< ; <label>:200                                     ; preds = %197
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn nounwind
<   unreachable
---
> ; <label>:30                                      ; preds = %11
>   %31 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 -4611686018427387904, i64* %31, align 1
>   %32 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   store i16 -1, i16* %32, align 1
>   br label %33
9047,9050c6259,6263
< ; <label>:201                                     ; preds = %197
<   %202 = and i32 %new_ss.0.i, 3
<   %203 = icmp eq i32 %202, %105
<   br i1 %203, label %205, label %204
---
> ; <label>:33                                      ; preds = %30, %16
>   %34 = bitcast %struct.floatx80* %agg.result to i8*
>   %35 = bitcast %struct.floatx80* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %34, i8* %35, i32 10, i32 1, i1 false)
>   br label %36
9052,9054c6265,6267
< ; <label>:204                                     ; preds = %201
<   tail call fastcc void @raise_exception_err(i32 13, i32 %198) noreturn nounwind
<   unreachable
---
> ; <label>:36                                      ; preds = %33, %6
>   ret void
> }
9056,9067c6269,6293
< ; <label>:205                                     ; preds = %201
<   %206 = and i32 %new_ss.0.i, 4
<   %207 = icmp eq i32 %206, 0
<   %208 = load %struct.CPUX86State** @env, align 8
<   %209 = getelementptr inbounds %struct.CPUX86State* %208, i64 0, i32 11
<   %210 = getelementptr inbounds %struct.CPUX86State* %208, i64 0, i32 13
<   %dt.0.i134.i = select i1 %207, %struct.SegmentCache* %210, %struct.SegmentCache* %209
<   %211 = or i32 %new_ss.0.i, 7
<   %212 = getelementptr inbounds %struct.SegmentCache* %dt.0.i134.i, i64 0, i32 2
<   %213 = load i32* %212, align 4
<   %214 = icmp ugt i32 %211, %213
<   br i1 %214, label %215, label %216
---
> define internal void @float32_to_float128(%struct.float128* noalias sret %agg.result, i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %3 = alloca %struct.commonNaNT, align 4
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %4 = load i32* %1, align 4
>   %5 = load %struct.float_status** %2, align 4
>   %6 = call i32 @float32_squash_input_denormal(i32 %4, %struct.float_status* %5)
>   store i32 %6, i32* %1, align 4
>   %7 = load i32* %1, align 4
>   %8 = call i32 @extractFloat32Frac(i32 %7)
>   store i32 %8, i32* %aSig, align 4
>   %9 = load i32* %1, align 4
>   %10 = call i32 @extractFloat32Exp(i32 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i32* %1, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 255
>   br i1 %14, label %15, label %24
9069,9071c6295,6298
< ; <label>:215                                     ; preds = %205
<   tail call fastcc void @raise_exception_err(i32 13, i32 %198) noreturn nounwind
<   unreachable
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %aSig, align 4
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %18, label %22
9073,9083c6300,6306
< ; <label>:216                                     ; preds = %205
<   %217 = and i32 %new_ss.0.i, -8
<   %218 = getelementptr inbounds %struct.SegmentCache* %dt.0.i134.i, i64 0, i32 1
<   %219 = load i32* %218, align 4
<   %220 = add i32 %219, %217
<   %221 = tail call fastcc i32 @ldl_kernel(i32 %220) nounwind
<   %222 = add i32 %220, 4
<   %223 = tail call fastcc i32 @ldl_kernel(i32 %222) nounwind
<   %224 = and i32 %223, 6656
<   %225 = icmp eq i32 %224, 4608
<   br i1 %225, label %227, label %226
---
> ; <label>:18                                      ; preds = %15
>   %19 = load i32* %1, align 4
>   %20 = load %struct.float_status** %2, align 4
>   call void @float32ToCommonNaN(%struct.commonNaNT* sret %3, i32 %19, %struct.float_status* %20)
>   %21 = load %struct.float_status** %2, align 4
>   call void @commonNaNToFloat128(%struct.float128* sret %agg.result, %struct.commonNaNT* byval align 4 %3, %struct.float_status* %21)
>   br label %43
9085,9087c6308,6311
< ; <label>:226                                     ; preds = %216
<   tail call fastcc void @raise_exception_err(i32 13, i32 %198) noreturn nounwind
<   unreachable
---
> ; <label>:22                                      ; preds = %15
>   %23 = load i8* %aSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %23, i32 32767, i64 0, i64 0)
>   br label %43
9089,9093c6313,6316
< ; <label>:227                                     ; preds = %216
<   %228 = lshr i32 %223, 13
<   %229 = and i32 %228, 3
<   %230 = icmp eq i32 %229, %105
<   br i1 %230, label %232, label %231
---
> ; <label>:24                                      ; preds = %0
>   %25 = load i32* %aExp, align 4
>   %26 = icmp eq i32 %25, 0
>   br i1 %26, label %27, label %36
9095,9097c6318,6326
< ; <label>:231                                     ; preds = %227
<   tail call fastcc void @raise_exception_err(i32 13, i32 %198) noreturn nounwind
<   unreachable
---
> ; <label>:27                                      ; preds = %24
>   %28 = load i32* %aSig, align 4
>   %29 = icmp eq i32 %28, 0
>   br i1 %29, label %30, label %32
> 
> ; <label>:30                                      ; preds = %27
>   %31 = load i8* %aSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %31, i32 0, i64 0, i64 0)
>   br label %43
9099,9102c6328,6334
< ; <label>:232                                     ; preds = %227
<   %233 = and i32 %223, 32768
<   %234 = icmp eq i32 %233, 0
<   br i1 %234, label %235, label %236
---
> ; <label>:32                                      ; preds = %27
>   %33 = load i32* %aSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %33, i32* %aExp, i32* %aSig)
>   %34 = load i32* %aExp, align 4
>   %35 = add nsw i32 %34, -1
>   store i32 %35, i32* %aExp, align 4
>   br label %36
9104,9106c6336,6344
< ; <label>:235                                     ; preds = %232
<   tail call fastcc void @raise_exception_err(i32 11, i32 %198) noreturn nounwind
<   unreachable
---
> ; <label>:36                                      ; preds = %32, %24
>   %37 = load i8* %aSign, align 1
>   %38 = load i32* %aExp, align 4
>   %39 = add nsw i32 %38, 16256
>   %40 = load i32* %aSig, align 4
>   %41 = zext i32 %40 to i64
>   %42 = shl i64 %41, 25
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %37, i32 %39, i64 %42, i64 0)
>   br label %43
9108,9167c6346,6348
< ; <label>:236                                     ; preds = %232
<   %237 = load %struct.CPUX86State** @env, align 8
<   %238 = lshr i32 %221, 16
<   %239 = shl i32 %223, 16
<   %240 = and i32 %239, 16711680
<   %241 = and i32 %223, -16777216
<   %242 = or i32 %241, %238
<   %243 = or i32 %242, %240
<   %244 = and i32 %221, 65535
<   %245 = and i32 %223, 983040
<   %246 = or i32 %245, %244
<   %247 = and i32 %223, 8388608
<   %248 = icmp eq i32 %247, 0
<   br i1 %248, label %get_seg_limit.exit138.i, label %249
< 
< ; <label>:249                                     ; preds = %236
<   %250 = shl nuw i32 %246, 12
<   %251 = or i32 %250, 4095
<   br label %get_seg_limit.exit138.i
< 
< get_seg_limit.exit138.i:                          ; preds = %249, %236
<   %limit.0.i137.i = phi i32 [ %251, %249 ], [ %246, %236 ]
<   %252 = getelementptr inbounds %struct.CPUX86State* %237, i64 0, i32 10, i64 2, i32 0
<   store i32 %new_ss.0.i, i32* %252, align 4
<   %253 = getelementptr inbounds %struct.CPUX86State* %237, i64 0, i32 10, i64 2, i32 1
<   store i32 %243, i32* %253, align 4
<   %254 = getelementptr inbounds %struct.CPUX86State* %237, i64 0, i32 10, i64 2, i32 2
<   store i32 %limit.0.i137.i, i32* %254, align 4
<   %255 = getelementptr inbounds %struct.CPUX86State* %237, i64 0, i32 10, i64 2, i32 3
<   store i32 %223, i32* %255, align 4
<   %.phi.trans.insert.i.i = getelementptr inbounds %struct.CPUX86State* %237, i64 0, i32 8
<   %.pre.i.i = load i32* %.phi.trans.insert.i.i, align 4
<   %256 = lshr i32 %223, 17
<   %257 = and i32 %256, 32
<   %258 = and i32 %.pre.i.i, 32768
<   %259 = icmp eq i32 %258, 0
<   br i1 %259, label %260, label %cpu_x86_load_seg_cache.exit140.i
< 
< ; <label>:260                                     ; preds = %get_seg_limit.exit138.i
<   %261 = getelementptr inbounds %struct.CPUX86State* %237, i64 0, i32 15, i64 0
<   %262 = load i32* %261, align 4
<   %263 = and i32 %262, 1
<   %264 = icmp eq i32 %263, 0
<   br i1 %264, label %273, label %265
< 
< ; <label>:265                                     ; preds = %260
<   %266 = getelementptr inbounds %struct.CPUX86State* %237, i64 0, i32 7
<   %267 = load i32* %266, align 4
<   %268 = and i32 %267, 131072
<   %269 = icmp eq i32 %268, 0
<   br i1 %269, label %270, label %273
< 
< ; <label>:270                                     ; preds = %265
<   %271 = and i32 %.pre.i.i, 16
<   %272 = icmp eq i32 %271, 0
<   br i1 %272, label %273, label %275
< 
< ; <label>:273                                     ; preds = %270, %265, %260
<   %274 = or i32 %257, 64
<   br label %cpu_x86_load_seg_cache.exit140.i
---
> ; <label>:43                                      ; preds = %36, %30, %22, %18
>   ret void
> }
9169,9298c6350,6358
< ; <label>:275                                     ; preds = %270
<   %276 = getelementptr inbounds %struct.CPUX86State* %237, i64 0, i32 10, i64 3, i32 1
<   %277 = load i32* %276, align 4
<   %278 = getelementptr inbounds %struct.CPUX86State* %237, i64 0, i32 10, i64 0, i32 1
<   %279 = load i32* %278, align 4
<   %280 = or i32 %277, %243
<   %281 = or i32 %280, %279
<   %282 = icmp ne i32 %281, 0
<   %283 = zext i1 %282 to i32
<   %284 = shl nuw nsw i32 %283, 6
<   %285 = or i32 %284, %257
<   br label %cpu_x86_load_seg_cache.exit140.i
< 
< cpu_x86_load_seg_cache.exit140.i:                 ; preds = %275, %273, %get_seg_limit.exit138.i
<   %new_hflags.0.i139.i = phi i32 [ %257, %get_seg_limit.exit138.i ], [ %274, %273 ], [ %285, %275 ]
<   %286 = and i32 %.pre.i.i, -97
<   %287 = or i32 %new_hflags.0.i139.i, %286
<   store i32 %287, i32* %.phi.trans.insert.i.i, align 4
<   %288 = load %struct.CPUX86State** @env, align 8
<   %289 = lshr i32 %94, 16
<   %290 = shl i32 %96, 16
<   %291 = and i32 %290, 16711680
<   %292 = and i32 %96, -16777216
<   %293 = or i32 %292, %289
<   %294 = or i32 %293, %291
<   %295 = and i32 %94, 65535
<   %296 = and i32 %96, 983040
<   %297 = or i32 %296, %295
<   %298 = and i32 %96, 8388608
<   %299 = icmp eq i32 %298, 0
<   br i1 %299, label %get_seg_limit.exit142.i, label %300
< 
< ; <label>:300                                     ; preds = %cpu_x86_load_seg_cache.exit140.i
<   %301 = shl nuw i32 %297, 12
<   %302 = or i32 %301, 4095
<   br label %get_seg_limit.exit142.i
< 
< get_seg_limit.exit142.i:                          ; preds = %300, %cpu_x86_load_seg_cache.exit140.i
<   %limit.0.i141.i = phi i32 [ %302, %300 ], [ %297, %cpu_x86_load_seg_cache.exit140.i ]
<   %303 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 10, i64 1, i32 0
<   store i32 %new_cs.0.i, i32* %303, align 4
<   %304 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 10, i64 1, i32 1
<   store i32 %294, i32* %304, align 4
<   %305 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 10, i64 1, i32 2
<   store i32 %limit.0.i141.i, i32* %305, align 4
<   %306 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 10, i64 1, i32 3
<   store i32 %96, i32* %306, align 4
<   %307 = lshr i32 %96, 18
<   %308 = and i32 %307, 16
<   %309 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 8
<   %310 = load i32* %309, align 4
<   %311 = and i32 %310, -32785
<   %312 = or i32 %311, %308
<   store i32 %312, i32* %309, align 4
<   %313 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 10, i64 2, i32 3
<   %314 = load i32* %313, align 4
<   %315 = lshr i32 %314, 17
<   %316 = and i32 %315, 32
<   %317 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 15, i64 0
<   %318 = load i32* %317, align 4
<   %319 = and i32 %318, 1
<   %320 = icmp eq i32 %319, 0
<   br i1 %320, label %327, label %321
< 
< ; <label>:321                                     ; preds = %get_seg_limit.exit142.i
<   %322 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 7
<   %323 = load i32* %322, align 4
<   %324 = and i32 %323, 131072
<   %325 = icmp ne i32 %324, 0
<   %326 = icmp eq i32 %308, 0
<   %or.cond193.i = or i1 %325, %326
<   br i1 %or.cond193.i, label %327, label %329
< 
< ; <label>:327                                     ; preds = %321, %get_seg_limit.exit142.i
<   %328 = or i32 %316, 64
<   br label %cpu_x86_load_seg_cache.exit144.i
< 
< ; <label>:329                                     ; preds = %321
<   %330 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 10, i64 3, i32 1
<   %331 = load i32* %330, align 4
<   %332 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 10, i64 0, i32 1
<   %333 = load i32* %332, align 4
<   %334 = or i32 %333, %331
<   %335 = getelementptr inbounds %struct.CPUX86State* %288, i64 0, i32 10, i64 2, i32 1
<   %336 = load i32* %335, align 4
<   %337 = or i32 %334, %336
<   %338 = icmp ne i32 %337, 0
<   %339 = zext i1 %338 to i32
<   %340 = shl nuw nsw i32 %339, 6
<   %341 = or i32 %340, %316
<   br label %cpu_x86_load_seg_cache.exit144.i
< 
< cpu_x86_load_seg_cache.exit144.i:                 ; preds = %329, %327
<   %new_hflags.0.i143.i = phi i32 [ %328, %327 ], [ %341, %329 ]
<   %342 = and i32 %312, -32865
<   %343 = or i32 %new_hflags.0.i143.i, %342
<   store i32 %343, i32* %309, align 4
<   %344 = load %struct.CPUX86State** @env, align 8
<   %345 = getelementptr inbounds %struct.CPUX86State* %344, i64 0, i32 8
<   %346 = load i32* %345, align 4
<   %347 = and i32 %346, 3
<   tail call void @s2e_on_privilege_change(i32 %347, i32 %105) nounwind
<   %348 = load i32* %345, align 4
<   %349 = and i32 %348, -4
<   %350 = or i32 %349, %105
<   store i32 %350, i32* %345, align 4
<   %351 = lshr i32 %223, 6
<   %352 = and i32 %351, 65536
<   %353 = xor i32 %352, 65536
<   %354 = add i32 %353, -1
<   %.pre.i161.i = load %struct.CPUX86State** @env, align 8
<   %355 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 0, i32 3
<   %356 = load i32* %355, align 4
<   %357 = lshr i32 %356, 13
<   %358 = and i32 %357, 3
<   %359 = and i32 %356, 3072
<   %360 = icmp ne i32 %359, 3072
<   %361 = icmp ult i32 %358, %105
<   %or.cond10.i162.i = and i1 %360, %361
<   br i1 %or.cond10.i162.i, label %362, label %validate_seg.exit167.i
< 
< ; <label>:362                                     ; preds = %cpu_x86_load_seg_cache.exit144.i
<   %363 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 0, i32 0
<   %364 = bitcast i32* %363 to i8*
<   br label %365
< 
< ; <label>:365                                     ; preds = %368, %362
<   %366 = phi i64 [ 0, %362 ], [ %370, %368 ]
<   %367 = icmp ult i64 %366, 16
<   br i1 %367, label %368, label %371
---
> define internal void @commonNaNToFloat128(%struct.float128* noalias sret %agg.result, %struct.commonNaNT* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %z = alloca %struct.float128, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = load %struct.float_status** %1, align 4
>   %3 = getelementptr inbounds %struct.float_status* %2, i32 0, i32 6
>   %4 = load i8* %3, align 1
>   %5 = icmp ne i8 %4, 0
>   br i1 %5, label %6, label %11
9300,9329c6360,6368
< ; <label>:368                                     ; preds = %365
<   %369 = getelementptr i8* %364, i64 %366
<   store i8 0, i8* %369, align 1
<   %370 = add i64 %366, 1
<   br label %365
< 
< ; <label>:371                                     ; preds = %365
<   %.phi.trans.insert.i.i163.i = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 8
<   %.pre.i.i164.i = load i32* %.phi.trans.insert.i.i163.i, align 4
<   %372 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 2, i32 3
<   %373 = load i32* %372, align 4
<   %374 = lshr i32 %373, 17
<   %375 = and i32 %374, 32
<   %376 = and i32 %.pre.i.i164.i, 32768
<   %377 = icmp eq i32 %376, 0
<   br i1 %377, label %378, label %cpu_x86_load_seg_cache.exit.i166.i
< 
< ; <label>:378                                     ; preds = %371
<   %379 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 15, i64 0
<   %380 = load i32* %379, align 4
<   %381 = and i32 %380, 1
<   %382 = icmp eq i32 %381, 0
<   br i1 %382, label %391, label %383
< 
< ; <label>:383                                     ; preds = %378
<   %384 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 7
<   %385 = load i32* %384, align 4
<   %386 = and i32 %385, 131072
<   %387 = icmp eq i32 %386, 0
<   br i1 %387, label %388, label %391
---
> ; <label>:6                                       ; preds = %0
>   %7 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   store i64 0, i64* %7, align 4
>   %8 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   store i64 -140737488355328, i64* %8, align 4
>   %9 = bitcast %struct.float128* %agg.result to i8*
>   %10 = bitcast %struct.float128* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %9, i8* %10, i32 16, i32 4, i1 false)
>   br label %28
9331,9334c6370,6390
< ; <label>:388                                     ; preds = %383
<   %389 = and i32 %.pre.i.i164.i, 16
<   %390 = icmp eq i32 %389, 0
<   br i1 %390, label %391, label %393
---
> ; <label>:11                                      ; preds = %0
>   %12 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 1
>   %13 = load i64* %12, align 4
>   %14 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 2
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %17 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   call void @shift128Right(i64 %13, i64 %15, i32 16, i64* %16, i64* %17)
>   %18 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 0
>   %19 = load i8* %18, align 1
>   %20 = zext i8 %19 to i64
>   %21 = shl i64 %20, 63
>   %22 = or i64 %21, 9223090561878065152
>   %23 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %24 = load i64* %23, align 4
>   %25 = or i64 %24, %22
>   store i64 %25, i64* %23, align 4
>   %26 = bitcast %struct.float128* %agg.result to i8*
>   %27 = bitcast %struct.float128* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %26, i8* %27, i32 16, i32 4, i1 false)
>   br label %28
9336,9539c6392,6394
< ; <label>:391                                     ; preds = %388, %383, %378
<   %392 = or i32 %375, 64
<   br label %cpu_x86_load_seg_cache.exit.i166.i
< 
< ; <label>:393                                     ; preds = %388
<   %394 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 3, i32 1
<   %395 = load i32* %394, align 4
<   %396 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 2, i32 1
<   %397 = load i32* %396, align 4
<   %398 = or i32 %397, %395
<   %399 = icmp ne i32 %398, 0
<   %400 = zext i1 %399 to i32
<   %401 = shl nuw nsw i32 %400, 6
<   %402 = or i32 %401, %375
<   br label %cpu_x86_load_seg_cache.exit.i166.i
< 
< cpu_x86_load_seg_cache.exit.i166.i:               ; preds = %393, %391, %371
<   %new_hflags.0.i.i165.i = phi i32 [ %375, %371 ], [ %392, %391 ], [ %402, %393 ]
<   %403 = and i32 %.pre.i.i164.i, -97
<   %404 = or i32 %new_hflags.0.i.i165.i, %403
<   store i32 %404, i32* %.phi.trans.insert.i.i163.i, align 4
<   %.pre.i154.pre.i = load %struct.CPUX86State** @env, align 8
<   br label %validate_seg.exit167.i
< 
< validate_seg.exit167.i:                           ; preds = %cpu_x86_load_seg_cache.exit.i166.i, %cpu_x86_load_seg_cache.exit144.i
<   %.pre.i154.i = phi %struct.CPUX86State* [ %.pre.i161.i, %cpu_x86_load_seg_cache.exit144.i ], [ %.pre.i154.pre.i, %cpu_x86_load_seg_cache.exit.i166.i ]
<   %405 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 3, i32 3
<   %406 = load i32* %405, align 4
<   %407 = lshr i32 %406, 13
<   %408 = and i32 %407, 3
<   %409 = and i32 %406, 3072
<   %410 = icmp ne i32 %409, 3072
<   %411 = icmp ult i32 %408, %105
<   %or.cond10.i155.i = and i1 %410, %411
<   br i1 %or.cond10.i155.i, label %412, label %validate_seg.exit160.i
< 
< ; <label>:412                                     ; preds = %validate_seg.exit167.i
<   %413 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 3, i32 0
<   %414 = bitcast i32* %413 to i8*
<   br label %415
< 
< ; <label>:415                                     ; preds = %418, %412
<   %416 = phi i64 [ 0, %412 ], [ %420, %418 ]
<   %417 = icmp ult i64 %416, 16
<   br i1 %417, label %418, label %421
< 
< ; <label>:418                                     ; preds = %415
<   %419 = getelementptr i8* %414, i64 %416
<   store i8 0, i8* %419, align 1
<   %420 = add i64 %416, 1
<   br label %415
< 
< ; <label>:421                                     ; preds = %415
<   %.phi.trans.insert.i.i156.i = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 8
<   %.pre.i.i157.i = load i32* %.phi.trans.insert.i.i156.i, align 4
<   %422 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 2, i32 3
<   %423 = load i32* %422, align 4
<   %424 = lshr i32 %423, 17
<   %425 = and i32 %424, 32
<   %426 = and i32 %.pre.i.i157.i, 32768
<   %427 = icmp eq i32 %426, 0
<   br i1 %427, label %428, label %cpu_x86_load_seg_cache.exit.i159.i
< 
< ; <label>:428                                     ; preds = %421
<   %429 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 15, i64 0
<   %430 = load i32* %429, align 4
<   %431 = and i32 %430, 1
<   %432 = icmp eq i32 %431, 0
<   br i1 %432, label %441, label %433
< 
< ; <label>:433                                     ; preds = %428
<   %434 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 7
<   %435 = load i32* %434, align 4
<   %436 = and i32 %435, 131072
<   %437 = icmp eq i32 %436, 0
<   br i1 %437, label %438, label %441
< 
< ; <label>:438                                     ; preds = %433
<   %439 = and i32 %.pre.i.i157.i, 16
<   %440 = icmp eq i32 %439, 0
<   br i1 %440, label %441, label %443
< 
< ; <label>:441                                     ; preds = %438, %433, %428
<   %442 = or i32 %425, 64
<   br label %cpu_x86_load_seg_cache.exit.i159.i
< 
< ; <label>:443                                     ; preds = %438
<   %444 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 0, i32 1
<   %445 = load i32* %444, align 4
<   %446 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 2, i32 1
<   %447 = load i32* %446, align 4
<   %448 = or i32 %447, %445
<   %449 = icmp ne i32 %448, 0
<   %450 = zext i1 %449 to i32
<   %451 = shl nuw nsw i32 %450, 6
<   %452 = or i32 %451, %425
<   br label %cpu_x86_load_seg_cache.exit.i159.i
< 
< cpu_x86_load_seg_cache.exit.i159.i:               ; preds = %443, %441, %421
<   %new_hflags.0.i.i158.i = phi i32 [ %425, %421 ], [ %442, %441 ], [ %452, %443 ]
<   %453 = and i32 %.pre.i.i157.i, -97
<   %454 = or i32 %new_hflags.0.i.i158.i, %453
<   store i32 %454, i32* %.phi.trans.insert.i.i156.i, align 4
<   %.pre.i = load %struct.CPUX86State** @env, align 8
<   br label %validate_seg.exit160.i
< 
< validate_seg.exit160.i:                           ; preds = %cpu_x86_load_seg_cache.exit.i159.i, %validate_seg.exit167.i
<   %455 = phi %struct.CPUX86State* [ %.pre.i154.i, %validate_seg.exit167.i ], [ %.pre.i, %cpu_x86_load_seg_cache.exit.i159.i ]
<   %456 = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 10, i64 4, i32 0
<   %457 = load i32* %456, align 4
<   %458 = and i32 %457, 65532
<   %459 = icmp eq i32 %458, 0
<   br i1 %459, label %validate_seg.exit153.i, label %460
< 
< ; <label>:460                                     ; preds = %validate_seg.exit160.i
<   %461 = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 10, i64 4, i32 3
<   %462 = load i32* %461, align 4
<   %463 = lshr i32 %462, 13
<   %464 = and i32 %463, 3
<   %465 = and i32 %462, 3072
<   %466 = icmp ne i32 %465, 3072
<   %467 = icmp ult i32 %464, %105
<   %or.cond10.i148.i = and i1 %466, %467
<   br i1 %or.cond10.i148.i, label %468, label %validate_seg.exit153.i
< 
< ; <label>:468                                     ; preds = %460
<   %469 = bitcast i32* %456 to i8*
<   br label %470
< 
< ; <label>:470                                     ; preds = %473, %468
<   %471 = phi i64 [ 0, %468 ], [ %475, %473 ]
<   %472 = icmp ult i64 %471, 16
<   br i1 %472, label %473, label %476
< 
< ; <label>:473                                     ; preds = %470
<   %474 = getelementptr i8* %469, i64 %471
<   store i8 0, i8* %474, align 1
<   %475 = add i64 %471, 1
<   br label %470
< 
< ; <label>:476                                     ; preds = %470
<   %.phi.trans.insert.i.i149.i = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 8
<   %.pre.i.i150.i = load i32* %.phi.trans.insert.i.i149.i, align 4
<   %477 = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 10, i64 2, i32 3
<   %478 = load i32* %477, align 4
<   %479 = lshr i32 %478, 17
<   %480 = and i32 %479, 32
<   %481 = and i32 %.pre.i.i150.i, 32768
<   %482 = icmp eq i32 %481, 0
<   br i1 %482, label %483, label %cpu_x86_load_seg_cache.exit.i152.i
< 
< ; <label>:483                                     ; preds = %476
<   %484 = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 15, i64 0
<   %485 = load i32* %484, align 4
<   %486 = and i32 %485, 1
<   %487 = icmp eq i32 %486, 0
<   br i1 %487, label %496, label %488
< 
< ; <label>:488                                     ; preds = %483
<   %489 = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 7
<   %490 = load i32* %489, align 4
<   %491 = and i32 %490, 131072
<   %492 = icmp eq i32 %491, 0
<   br i1 %492, label %493, label %496
< 
< ; <label>:493                                     ; preds = %488
<   %494 = and i32 %.pre.i.i150.i, 16
<   %495 = icmp eq i32 %494, 0
<   br i1 %495, label %496, label %498
< 
< ; <label>:496                                     ; preds = %493, %488, %483
<   %497 = or i32 %480, 64
<   br label %cpu_x86_load_seg_cache.exit.i152.i
< 
< ; <label>:498                                     ; preds = %493
<   %499 = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 10, i64 3, i32 1
<   %500 = load i32* %499, align 4
<   %501 = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 10, i64 0, i32 1
<   %502 = load i32* %501, align 4
<   %503 = or i32 %502, %500
<   %504 = getelementptr inbounds %struct.CPUX86State* %455, i64 0, i32 10, i64 2, i32 1
<   %505 = load i32* %504, align 4
<   %506 = or i32 %503, %505
<   %507 = icmp ne i32 %506, 0
<   %508 = zext i1 %507 to i32
<   %509 = shl nuw nsw i32 %508, 6
<   %510 = or i32 %509, %480
<   br label %cpu_x86_load_seg_cache.exit.i152.i
< 
< cpu_x86_load_seg_cache.exit.i152.i:               ; preds = %498, %496, %476
<   %new_hflags.0.i.i151.i = phi i32 [ %480, %476 ], [ %497, %496 ], [ %510, %498 ]
<   %511 = and i32 %.pre.i.i150.i, -97
<   %512 = or i32 %new_hflags.0.i.i151.i, %511
<   store i32 %512, i32* %.phi.trans.insert.i.i149.i, align 4
<   %.pre195.i = load %struct.CPUX86State** @env, align 8
<   br label %validate_seg.exit153.i
< 
< validate_seg.exit153.i:                           ; preds = %cpu_x86_load_seg_cache.exit.i152.i, %460, %validate_seg.exit160.i
<   %513 = phi %struct.CPUX86State* [ %455, %validate_seg.exit160.i ], [ %455, %460 ], [ %.pre195.i, %cpu_x86_load_seg_cache.exit.i152.i ]
<   %514 = getelementptr inbounds %struct.CPUX86State* %513, i64 0, i32 10, i64 5, i32 0
<   %515 = load i32* %514, align 4
<   %516 = and i32 %515, 65532
<   %517 = icmp eq i32 %516, 0
<   br i1 %517, label %validate_seg.exit.i, label %518
---
> ; <label>:28                                      ; preds = %11, %6
>   ret void
> }
9541,9583c6396,6417
< ; <label>:518                                     ; preds = %validate_seg.exit153.i
<   %519 = getelementptr inbounds %struct.CPUX86State* %513, i64 0, i32 10, i64 5, i32 3
<   %520 = load i32* %519, align 4
<   %521 = lshr i32 %520, 13
<   %522 = and i32 %521, 3
<   %523 = and i32 %520, 3072
<   %524 = icmp ne i32 %523, 3072
<   %525 = icmp ult i32 %522, %105
<   %or.cond10.i.i = and i1 %524, %525
<   br i1 %or.cond10.i.i, label %526, label %validate_seg.exit.i
< 
< ; <label>:526                                     ; preds = %518
<   %527 = bitcast i32* %514 to i8*
<   br label %528
< 
< ; <label>:528                                     ; preds = %531, %526
<   %529 = phi i64 [ 0, %526 ], [ %533, %531 ]
<   %530 = icmp ult i64 %529, 16
<   br i1 %530, label %531, label %534
< 
< ; <label>:531                                     ; preds = %528
<   %532 = getelementptr i8* %527, i64 %529
<   store i8 0, i8* %532, align 1
<   %533 = add i64 %529, 1
<   br label %528
< 
< ; <label>:534                                     ; preds = %528
<   %.phi.trans.insert.i.i145.i = getelementptr inbounds %struct.CPUX86State* %513, i64 0, i32 8
<   %.pre.i.i146.i = load i32* %.phi.trans.insert.i.i145.i, align 4
<   %535 = getelementptr inbounds %struct.CPUX86State* %513, i64 0, i32 10, i64 2, i32 3
<   %536 = load i32* %535, align 4
<   %537 = lshr i32 %536, 17
<   %538 = and i32 %537, 32
<   %539 = and i32 %.pre.i.i146.i, 32768
<   %540 = icmp eq i32 %539, 0
<   br i1 %540, label %541, label %cpu_x86_load_seg_cache.exit.i.i
< 
< ; <label>:541                                     ; preds = %534
<   %542 = getelementptr inbounds %struct.CPUX86State* %513, i64 0, i32 15, i64 0
<   %543 = load i32* %542, align 4
<   %544 = and i32 %543, 1
<   %545 = icmp eq i32 %544, 0
<   br i1 %545, label %554, label %546
---
> define internal i32 @float32_round_to_int(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %lastBitMask = alloca i32, align 4
>   %roundBitsMask = alloca i32, align 4
>   %roundingMode = alloca i8, align 1
>   %z = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i32 @float32_squash_input_denormal(i32 %4, %struct.float_status* %5)
>   store i32 %6, i32* %2, align 4
>   %7 = load i32* %2, align 4
>   %8 = call i32 @extractFloat32Exp(i32 %7)
>   store i32 %8, i32* %aExp, align 4
>   %9 = load i32* %aExp, align 4
>   %10 = icmp sle i32 150, %9
>   br i1 %10, label %11, label %25
9585,9762c6419,6422
< ; <label>:546                                     ; preds = %541
<   %547 = getelementptr inbounds %struct.CPUX86State* %513, i64 0, i32 7
<   %548 = load i32* %547, align 4
<   %549 = and i32 %548, 131072
<   %550 = icmp eq i32 %549, 0
<   br i1 %550, label %551, label %554
< 
< ; <label>:551                                     ; preds = %546
<   %552 = and i32 %.pre.i.i146.i, 16
<   %553 = icmp eq i32 %552, 0
<   br i1 %553, label %554, label %556
< 
< ; <label>:554                                     ; preds = %551, %546, %541
<   %555 = or i32 %538, 64
<   br label %cpu_x86_load_seg_cache.exit.i.i
< 
< ; <label>:556                                     ; preds = %551
<   %557 = getelementptr inbounds %struct.CPUX86State* %513, i64 0, i32 10, i64 3, i32 1
<   %558 = load i32* %557, align 4
<   %559 = getelementptr inbounds %struct.CPUX86State* %513, i64 0, i32 10, i64 0, i32 1
<   %560 = load i32* %559, align 4
<   %561 = or i32 %560, %558
<   %562 = getelementptr inbounds %struct.CPUX86State* %513, i64 0, i32 10, i64 2, i32 1
<   %563 = load i32* %562, align 4
<   %564 = or i32 %561, %563
<   %565 = icmp ne i32 %564, 0
<   %566 = zext i1 %565 to i32
<   %567 = shl nuw nsw i32 %566, 6
<   %568 = or i32 %567, %538
<   br label %cpu_x86_load_seg_cache.exit.i.i
< 
< cpu_x86_load_seg_cache.exit.i.i:                  ; preds = %556, %554, %534
<   %new_hflags.0.i.i147.i = phi i32 [ %538, %534 ], [ %555, %554 ], [ %568, %556 ]
<   %569 = and i32 %.pre.i.i146.i, -97
<   %570 = or i32 %new_hflags.0.i.i147.i, %569
<   store i32 %570, i32* %.phi.trans.insert.i.i145.i, align 4
<   br label %validate_seg.exit.i
< 
< validate_seg.exit.i:                              ; preds = %cpu_x86_load_seg_cache.exit.i.i, %518, %validate_seg.exit153.i, %cpu_x86_load_seg_cache.exit.i
<   %sp.1.i = phi i32 [ %sp.0.i, %cpu_x86_load_seg_cache.exit.i ], [ %new_esp.0.i, %cpu_x86_load_seg_cache.exit.i.i ], [ %new_esp.0.i, %518 ], [ %new_esp.0.i, %validate_seg.exit153.i ]
<   %sp_mask.0.i = phi i32 [ %41, %cpu_x86_load_seg_cache.exit.i ], [ %354, %cpu_x86_load_seg_cache.exit.i.i ], [ %354, %518 ], [ %354, %validate_seg.exit153.i ]
<   %571 = load %struct.CPUX86State** @env, align 8
<   %572 = getelementptr inbounds %struct.CPUX86State* %571, i64 0, i32 0, i64 4
<   %573 = load i32* %572, align 4
<   %574 = xor i32 %sp_mask.0.i, -1
<   %575 = and i32 %573, %574
<   %576 = and i32 %sp_mask.0.i, %sp.1.i
<   %577 = or i32 %575, %576
<   store i32 %577, i32* %572, align 4
<   %578 = load %struct.CPUX86State** @env, align 8
<   %579 = getelementptr inbounds %struct.CPUX86State* %578, i64 0, i32 5
<   store i32 %new_eip.0.i, i32* %579, align 4
<   %580 = icmp eq i32 %104, 0
<   %..i = select i1 %580, i32 2453760, i32 2441472
<   %581 = load %struct.CPUX86State** @env, align 8
<   %582 = getelementptr inbounds %struct.CPUX86State* %581, i64 0, i32 7
<   %583 = load i32* %582, align 4
<   %584 = lshr i32 %583, 12
<   %585 = and i32 %584, 3
<   %586 = icmp ugt i32 %104, %585
<   %587 = or i32 %..i, 512
<   %eflags_mask.1.i = select i1 %586, i32 %..i, i32 %587
<   %588 = icmp eq i32 %shift, 0
<   %589 = and i32 %eflags_mask.1.i, 29440
<   %.eflags_mask.1.i = select i1 %588, i32 %589, i32 %eflags_mask.1.i
<   %590 = and i32 %new_eflags.0.i, 2261
<   %591 = getelementptr inbounds %struct.CPUX86State* %581, i64 0, i32 2
<   store i32 %590, i32* %591, align 4
<   %592 = lshr i32 %new_eflags.0.i, 9
<   %593 = and i32 %592, 2
<   %594 = xor i32 %593, 2
<   %595 = add i32 %594, -1
<   %596 = load %struct.CPUX86State** @env, align 8
<   %597 = getelementptr inbounds %struct.CPUX86State* %596, i64 0, i32 6
<   store i32 %595, i32* %597, align 4
<   %598 = load %struct.CPUX86State** @env, align 8
<   %599 = getelementptr inbounds %struct.CPUX86State* %598, i64 0, i32 7
<   %600 = load i32* %599, align 4
<   %601 = xor i32 %.eflags_mask.1.i, -1
<   %602 = and i32 %600, %601
<   %603 = and i32 %.eflags_mask.1.i, %new_eflags.0.i
<   %604 = or i32 %602, %603
<   store i32 %604, i32* %599, align 4
<   br label %helper_ret_protected.exit
< 
< load_seg_vm.exit133.i:                            ; preds = %49
<   %605 = and i32 %41, %60
<   %606 = add i32 %605, %45
<   %607 = tail call fastcc i32 @ldl_kernel(i32 %606) nounwind
<   %608 = add i32 %43, 16
<   %609 = and i32 %41, %608
<   %610 = add i32 %609, %45
<   %611 = tail call fastcc i32 @ldl_kernel(i32 %610) nounwind
<   %612 = add i32 %43, 20
<   %613 = and i32 %41, %612
<   %614 = add i32 %613, %45
<   %615 = tail call fastcc i32 @ldl_kernel(i32 %614) nounwind
<   %616 = add i32 %43, 24
<   %617 = and i32 %41, %616
<   %618 = add i32 %617, %45
<   %619 = tail call fastcc i32 @ldl_kernel(i32 %618) nounwind
<   %620 = add i32 %43, 28
<   %621 = and i32 %41, %620
<   %622 = add i32 %621, %45
<   %623 = tail call fastcc i32 @ldl_kernel(i32 %622) nounwind
<   %624 = add i32 %43, 32
<   %625 = and i32 %41, %624
<   %626 = add i32 %625, %45
<   %627 = tail call fastcc i32 @ldl_kernel(i32 %626) nounwind
<   %628 = and i32 %59, 2261
<   %629 = load %struct.CPUX86State** @env, align 8
<   %630 = getelementptr inbounds %struct.CPUX86State* %629, i64 0, i32 2
<   store i32 %628, i32* %630, align 4
<   %631 = lshr i32 %59, 9
<   %632 = and i32 %631, 2
<   %633 = xor i32 %632, 2
<   %634 = add i32 %633, -1
<   %635 = load %struct.CPUX86State** @env, align 8
<   %636 = getelementptr inbounds %struct.CPUX86State* %635, i64 0, i32 6
<   store i32 %634, i32* %636, align 4
<   %637 = load %struct.CPUX86State** @env, align 8
<   %638 = getelementptr inbounds %struct.CPUX86State* %637, i64 0, i32 7
<   %639 = load i32* %638, align 4
<   %640 = and i32 %639, -4092673
<   %641 = and i32 %59, 4092672
<   %642 = or i32 %640, %641
<   store i32 %642, i32* %638, align 4
<   %643 = load %struct.CPUX86State** @env, align 8
<   %644 = shl nuw nsw i32 %56, 4
<   %645 = getelementptr inbounds %struct.CPUX86State* %643, i64 0, i32 10, i64 1, i32 0
<   store i32 %56, i32* %645, align 4
<   %646 = getelementptr inbounds %struct.CPUX86State* %643, i64 0, i32 10, i64 1, i32 1
<   store i32 %644, i32* %646, align 4
<   %647 = getelementptr inbounds %struct.CPUX86State* %643, i64 0, i32 10, i64 1, i32 2
<   store i32 65535, i32* %647, align 4
<   %648 = getelementptr inbounds %struct.CPUX86State* %643, i64 0, i32 10, i64 1, i32 3
<   store i32 0, i32* %648, align 4
<   %649 = getelementptr inbounds %struct.CPUX86State* %643, i64 0, i32 8
<   %650 = load i32* %649, align 4
<   %651 = getelementptr inbounds %struct.CPUX86State* %643, i64 0, i32 10, i64 2, i32 3
<   %652 = load i32* %651, align 4
<   %653 = lshr i32 %652, 17
<   %654 = and i32 %653, 32
<   %655 = and i32 %650, -32881
<   %656 = or i32 %655, %654
<   %657 = or i32 %656, 64
<   store i32 %657, i32* %649, align 4
<   %658 = load %struct.CPUX86State** @env, align 8
<   %659 = getelementptr inbounds %struct.CPUX86State* %658, i64 0, i32 8
<   %660 = load i32* %659, align 4
<   %661 = and i32 %660, 3
<   tail call void @s2e_on_privilege_change(i32 %661, i32 3) nounwind
<   %662 = load i32* %659, align 4
<   %663 = or i32 %662, 3
<   store i32 %663, i32* %659, align 4
<   %664 = and i32 %611, 65535
<   %665 = load %struct.CPUX86State** @env, align 8
<   %666 = shl nuw nsw i32 %664, 4
<   %667 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 10, i64 2, i32 0
<   store i32 %664, i32* %667, align 4
<   %668 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 10, i64 2, i32 1
<   store i32 %666, i32* %668, align 4
<   %669 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 10, i64 2, i32 2
<   store i32 65535, i32* %669, align 4
<   %670 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 10, i64 2, i32 3
<   store i32 0, i32* %670, align 4
<   %.phi.trans.insert.i.i128.i = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 8
<   %.pre.i.i129.i = load i32* %.phi.trans.insert.i.i128.i, align 4
<   %671 = and i32 %.pre.i.i129.i, 32768
<   %672 = icmp eq i32 %671, 0
<   br i1 %672, label %673, label %load_seg_vm.exit131.i
< 
< ; <label>:673                                     ; preds = %load_seg_vm.exit133.i
<   %674 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 15, i64 0
<   %675 = load i32* %674, align 4
<   %676 = and i32 %675, 1
<   %677 = icmp eq i32 %676, 0
<   br i1 %677, label %load_seg_vm.exit131.i, label %678
---
> ; <label>:11                                      ; preds = %0
>   %12 = load i32* %aExp, align 4
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %23
9764,9943c6424,6446
< ; <label>:678                                     ; preds = %673
<   %679 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 7
<   %680 = load i32* %679, align 4
<   %681 = and i32 %680, 131072
<   %682 = icmp eq i32 %681, 0
<   br i1 %682, label %683, label %load_seg_vm.exit131.i
< 
< ; <label>:683                                     ; preds = %678
<   %684 = and i32 %.pre.i.i129.i, 16
<   %685 = icmp eq i32 %684, 0
<   br i1 %685, label %load_seg_vm.exit131.i, label %686
< 
< ; <label>:686                                     ; preds = %683
<   %687 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 10, i64 3, i32 1
<   %688 = load i32* %687, align 4
<   %689 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 10, i64 0, i32 1
<   %690 = load i32* %689, align 4
<   %691 = or i32 %688, %666
<   %692 = or i32 %691, %690
<   %693 = icmp ne i32 %692, 0
<   %694 = zext i1 %693 to i32
<   %695 = shl nuw nsw i32 %694, 6
<   br label %load_seg_vm.exit131.i
< 
< load_seg_vm.exit131.i:                            ; preds = %686, %683, %678, %673, %load_seg_vm.exit133.i
<   %new_hflags.0.i.i130.i = phi i32 [ 0, %load_seg_vm.exit133.i ], [ %695, %686 ], [ 64, %683 ], [ 64, %678 ], [ 64, %673 ]
<   %696 = and i32 %.pre.i.i129.i, -97
<   %697 = or i32 %new_hflags.0.i.i130.i, %696
<   store i32 %697, i32* %.phi.trans.insert.i.i128.i, align 4
<   %698 = and i32 %615, 65535
<   %699 = load %struct.CPUX86State** @env, align 8
<   %700 = shl nuw nsw i32 %698, 4
<   %701 = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 10, i64 0, i32 0
<   store i32 %698, i32* %701, align 4
<   %702 = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 10, i64 0, i32 1
<   store i32 %700, i32* %702, align 4
<   %703 = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 10, i64 0, i32 2
<   store i32 65535, i32* %703, align 4
<   %704 = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 10, i64 0, i32 3
<   store i32 0, i32* %704, align 4
<   %.phi.trans.insert.i.i124.i = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 8
<   %.pre.i.i125.i = load i32* %.phi.trans.insert.i.i124.i, align 4
<   %705 = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 10, i64 2, i32 3
<   %706 = load i32* %705, align 4
<   %707 = lshr i32 %706, 17
<   %708 = and i32 %707, 32
<   %709 = and i32 %.pre.i.i125.i, 32768
<   %710 = icmp eq i32 %709, 0
<   br i1 %710, label %711, label %load_seg_vm.exit127.i
< 
< ; <label>:711                                     ; preds = %load_seg_vm.exit131.i
<   %712 = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 15, i64 0
<   %713 = load i32* %712, align 4
<   %714 = and i32 %713, 1
<   %715 = icmp eq i32 %714, 0
<   br i1 %715, label %724, label %716
< 
< ; <label>:716                                     ; preds = %711
<   %717 = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 7
<   %718 = load i32* %717, align 4
<   %719 = and i32 %718, 131072
<   %720 = icmp eq i32 %719, 0
<   br i1 %720, label %721, label %724
< 
< ; <label>:721                                     ; preds = %716
<   %722 = and i32 %.pre.i.i125.i, 16
<   %723 = icmp eq i32 %722, 0
<   br i1 %723, label %724, label %726
< 
< ; <label>:724                                     ; preds = %721, %716, %711
<   %725 = or i32 %708, 64
<   br label %load_seg_vm.exit127.i
< 
< ; <label>:726                                     ; preds = %721
<   %727 = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 10, i64 3, i32 1
<   %728 = load i32* %727, align 4
<   %729 = or i32 %728, %700
<   %730 = getelementptr inbounds %struct.CPUX86State* %699, i64 0, i32 10, i64 2, i32 1
<   %731 = load i32* %730, align 4
<   %732 = or i32 %729, %731
<   %733 = icmp ne i32 %732, 0
<   %734 = zext i1 %733 to i32
<   %735 = shl nuw nsw i32 %734, 6
<   %736 = or i32 %735, %708
<   br label %load_seg_vm.exit127.i
< 
< load_seg_vm.exit127.i:                            ; preds = %726, %724, %load_seg_vm.exit131.i
<   %new_hflags.0.i.i126.i = phi i32 [ %708, %load_seg_vm.exit131.i ], [ %725, %724 ], [ %736, %726 ]
<   %737 = and i32 %.pre.i.i125.i, -97
<   %738 = or i32 %new_hflags.0.i.i126.i, %737
<   store i32 %738, i32* %.phi.trans.insert.i.i124.i, align 4
<   %739 = and i32 %619, 65535
<   %740 = load %struct.CPUX86State** @env, align 8
<   %741 = shl nuw nsw i32 %739, 4
<   %742 = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 10, i64 3, i32 0
<   store i32 %739, i32* %742, align 4
<   %743 = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 10, i64 3, i32 1
<   store i32 %741, i32* %743, align 4
<   %744 = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 10, i64 3, i32 2
<   store i32 65535, i32* %744, align 4
<   %745 = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 10, i64 3, i32 3
<   store i32 0, i32* %745, align 4
<   %.phi.trans.insert.i.i120.i = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 8
<   %.pre.i.i121.i = load i32* %.phi.trans.insert.i.i120.i, align 4
<   %746 = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 10, i64 2, i32 3
<   %747 = load i32* %746, align 4
<   %748 = lshr i32 %747, 17
<   %749 = and i32 %748, 32
<   %750 = and i32 %.pre.i.i121.i, 32768
<   %751 = icmp eq i32 %750, 0
<   br i1 %751, label %752, label %load_seg_vm.exit123.i
< 
< ; <label>:752                                     ; preds = %load_seg_vm.exit127.i
<   %753 = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 15, i64 0
<   %754 = load i32* %753, align 4
<   %755 = and i32 %754, 1
<   %756 = icmp eq i32 %755, 0
<   br i1 %756, label %765, label %757
< 
< ; <label>:757                                     ; preds = %752
<   %758 = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 7
<   %759 = load i32* %758, align 4
<   %760 = and i32 %759, 131072
<   %761 = icmp eq i32 %760, 0
<   br i1 %761, label %762, label %765
< 
< ; <label>:762                                     ; preds = %757
<   %763 = and i32 %.pre.i.i121.i, 16
<   %764 = icmp eq i32 %763, 0
<   br i1 %764, label %765, label %767
< 
< ; <label>:765                                     ; preds = %762, %757, %752
<   %766 = or i32 %749, 64
<   br label %load_seg_vm.exit123.i
< 
< ; <label>:767                                     ; preds = %762
<   %768 = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 10, i64 0, i32 1
<   %769 = load i32* %768, align 4
<   %770 = or i32 %769, %741
<   %771 = getelementptr inbounds %struct.CPUX86State* %740, i64 0, i32 10, i64 2, i32 1
<   %772 = load i32* %771, align 4
<   %773 = or i32 %770, %772
<   %774 = icmp ne i32 %773, 0
<   %775 = zext i1 %774 to i32
<   %776 = shl nuw nsw i32 %775, 6
<   %777 = or i32 %776, %749
<   br label %load_seg_vm.exit123.i
< 
< load_seg_vm.exit123.i:                            ; preds = %767, %765, %load_seg_vm.exit127.i
<   %new_hflags.0.i.i122.i = phi i32 [ %749, %load_seg_vm.exit127.i ], [ %766, %765 ], [ %777, %767 ]
<   %778 = and i32 %.pre.i.i121.i, -97
<   %779 = or i32 %new_hflags.0.i.i122.i, %778
<   store i32 %779, i32* %.phi.trans.insert.i.i120.i, align 4
<   %780 = and i32 %623, 65535
<   %781 = load %struct.CPUX86State** @env, align 8
<   %782 = shl nuw nsw i32 %780, 4
<   %783 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 10, i64 4, i32 0
<   store i32 %780, i32* %783, align 4
<   %784 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 10, i64 4, i32 1
<   store i32 %782, i32* %784, align 4
<   %785 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 10, i64 4, i32 2
<   store i32 65535, i32* %785, align 4
<   %786 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 10, i64 4, i32 3
<   store i32 0, i32* %786, align 4
<   %.phi.trans.insert.i.i116.i = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 8
<   %.pre.i.i117.i = load i32* %.phi.trans.insert.i.i116.i, align 4
<   %787 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 10, i64 2, i32 3
<   %788 = load i32* %787, align 4
<   %789 = lshr i32 %788, 17
<   %790 = and i32 %789, 32
<   %791 = and i32 %.pre.i.i117.i, 32768
<   %792 = icmp eq i32 %791, 0
<   br i1 %792, label %793, label %load_seg_vm.exit119.i
< 
< ; <label>:793                                     ; preds = %load_seg_vm.exit123.i
<   %794 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 15, i64 0
<   %795 = load i32* %794, align 4
<   %796 = and i32 %795, 1
<   %797 = icmp eq i32 %796, 0
<   br i1 %797, label %806, label %798
---
> ; <label>:14                                      ; preds = %11
>   %15 = load i32* %2, align 4
>   %16 = call i32 @extractFloat32Frac(i32 %15)
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %18, label %23
> 
> ; <label>:18                                      ; preds = %14
>   %19 = load i32* %2, align 4
>   %20 = load i32* %2, align 4
>   %21 = load %struct.float_status** %3, align 4
>   %22 = call i32 @propagateFloat32NaN(i32 %19, i32 %20, %struct.float_status* %21)
>   store i32 %22, i32* %1
>   br label %137
> 
> ; <label>:23                                      ; preds = %14, %11
>   %24 = load i32* %2, align 4
>   store i32 %24, i32* %1
>   br label %137
> 
> ; <label>:25                                      ; preds = %0
>   %26 = load i32* %aExp, align 4
>   %27 = icmp sle i32 %26, 126
>   br i1 %27, label %28, label %71
9945,10061c6448,6452
< ; <label>:798                                     ; preds = %793
<   %799 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 7
<   %800 = load i32* %799, align 4
<   %801 = and i32 %800, 131072
<   %802 = icmp eq i32 %801, 0
<   br i1 %802, label %803, label %806
< 
< ; <label>:803                                     ; preds = %798
<   %804 = and i32 %.pre.i.i117.i, 16
<   %805 = icmp eq i32 %804, 0
<   br i1 %805, label %806, label %808
< 
< ; <label>:806                                     ; preds = %803, %798, %793
<   %807 = or i32 %790, 64
<   br label %load_seg_vm.exit119.i
< 
< ; <label>:808                                     ; preds = %803
<   %809 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 10, i64 3, i32 1
<   %810 = load i32* %809, align 4
<   %811 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 10, i64 0, i32 1
<   %812 = load i32* %811, align 4
<   %813 = or i32 %812, %810
<   %814 = getelementptr inbounds %struct.CPUX86State* %781, i64 0, i32 10, i64 2, i32 1
<   %815 = load i32* %814, align 4
<   %816 = or i32 %813, %815
<   %817 = icmp ne i32 %816, 0
<   %818 = zext i1 %817 to i32
<   %819 = shl nuw nsw i32 %818, 6
<   %820 = or i32 %819, %790
<   br label %load_seg_vm.exit119.i
< 
< load_seg_vm.exit119.i:                            ; preds = %808, %806, %load_seg_vm.exit123.i
<   %new_hflags.0.i.i118.i = phi i32 [ %790, %load_seg_vm.exit123.i ], [ %807, %806 ], [ %820, %808 ]
<   %821 = and i32 %.pre.i.i117.i, -97
<   %822 = or i32 %new_hflags.0.i.i118.i, %821
<   store i32 %822, i32* %.phi.trans.insert.i.i116.i, align 4
<   %823 = and i32 %627, 65535
<   %824 = load %struct.CPUX86State** @env, align 8
<   %825 = shl nuw nsw i32 %823, 4
<   %826 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 10, i64 5, i32 0
<   store i32 %823, i32* %826, align 4
<   %827 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 10, i64 5, i32 1
<   store i32 %825, i32* %827, align 4
<   %828 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 10, i64 5, i32 2
<   store i32 65535, i32* %828, align 4
<   %829 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 10, i64 5, i32 3
<   store i32 0, i32* %829, align 4
<   %.phi.trans.insert.i.i.i = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 8
<   %.pre.i.i.i = load i32* %.phi.trans.insert.i.i.i, align 4
<   %830 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 10, i64 2, i32 3
<   %831 = load i32* %830, align 4
<   %832 = lshr i32 %831, 17
<   %833 = and i32 %832, 32
<   %834 = and i32 %.pre.i.i.i, 32768
<   %835 = icmp eq i32 %834, 0
<   br i1 %835, label %836, label %load_seg_vm.exit.i
< 
< ; <label>:836                                     ; preds = %load_seg_vm.exit119.i
<   %837 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 15, i64 0
<   %838 = load i32* %837, align 4
<   %839 = and i32 %838, 1
<   %840 = icmp eq i32 %839, 0
<   br i1 %840, label %849, label %841
< 
< ; <label>:841                                     ; preds = %836
<   %842 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 7
<   %843 = load i32* %842, align 4
<   %844 = and i32 %843, 131072
<   %845 = icmp eq i32 %844, 0
<   br i1 %845, label %846, label %849
< 
< ; <label>:846                                     ; preds = %841
<   %847 = and i32 %.pre.i.i.i, 16
<   %848 = icmp eq i32 %847, 0
<   br i1 %848, label %849, label %851
< 
< ; <label>:849                                     ; preds = %846, %841, %836
<   %850 = or i32 %833, 64
<   br label %load_seg_vm.exit.i
< 
< ; <label>:851                                     ; preds = %846
<   %852 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 10, i64 3, i32 1
<   %853 = load i32* %852, align 4
<   %854 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 10, i64 0, i32 1
<   %855 = load i32* %854, align 4
<   %856 = or i32 %855, %853
<   %857 = getelementptr inbounds %struct.CPUX86State* %824, i64 0, i32 10, i64 2, i32 1
<   %858 = load i32* %857, align 4
<   %859 = or i32 %856, %858
<   %860 = icmp ne i32 %859, 0
<   %861 = zext i1 %860 to i32
<   %862 = shl nuw nsw i32 %861, 6
<   %863 = or i32 %862, %833
<   br label %load_seg_vm.exit.i
< 
< load_seg_vm.exit.i:                               ; preds = %851, %849, %load_seg_vm.exit119.i
<   %new_hflags.0.i.i.i = phi i32 [ %833, %load_seg_vm.exit119.i ], [ %850, %849 ], [ %863, %851 ]
<   %864 = and i32 %.pre.i.i.i, -97
<   %865 = or i32 %new_hflags.0.i.i.i, %864
<   store i32 %865, i32* %.phi.trans.insert.i.i.i, align 4
<   %866 = and i32 %50, 65535
<   %867 = load %struct.CPUX86State** @env, align 8
<   %868 = getelementptr inbounds %struct.CPUX86State* %867, i64 0, i32 5
<   store i32 %866, i32* %868, align 4
<   %869 = load %struct.CPUX86State** @env, align 8
<   %870 = getelementptr inbounds %struct.CPUX86State* %869, i64 0, i32 0, i64 4
<   store i32 %607, i32* %870, align 4
<   br label %helper_ret_protected.exit
< 
< helper_ret_protected.exit:                        ; preds = %load_seg_vm.exit.i, %validate_seg.exit.i, %34
<   %871 = load %struct.CPUX86State** @env, align 8
<   %872 = getelementptr inbounds %struct.CPUX86State* %871, i64 0, i32 9
<   %873 = load i32* %872, align 4
<   %874 = and i32 %873, -5
<   store i32 %874, i32* %872, align 4
<   ret void
< }
---
> ; <label>:28                                      ; preds = %25
>   %29 = load i32* %2, align 4
>   %30 = shl i32 %29, 1
>   %31 = icmp eq i32 %30, 0
>   br i1 %31, label %32, label %34
10063,10078c6454,6478
< define void @helper_lret_protected(i32 %shift, i32 %addend) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 2, i32 3
<   %3 = load i32* %2, align 4
<   %4 = lshr i32 %3, 6
<   %5 = and i32 %4, 65536
<   %6 = xor i32 %5, 65536
<   %7 = add i32 %6, -1
<   %8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 4
<   %9 = load i32* %8, align 4
<   %10 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 10, i64 2, i32 1
<   %11 = load i32* %10, align 4
<   %12 = icmp eq i32 %shift, 1
<   %13 = and i32 %7, %9
<   %14 = add i32 %13, %11
<   br i1 %12, label %15, label %23
---
> ; <label>:32                                      ; preds = %28
>   %33 = load i32* %2, align 4
>   store i32 %33, i32* %1
>   br label %137
> 
> ; <label>:34                                      ; preds = %28
>   %35 = load %struct.float_status** %3, align 4
>   %36 = getelementptr inbounds %struct.float_status* %35, i32 0, i32 2
>   %37 = load i8* %36, align 1
>   %38 = sext i8 %37 to i32
>   %39 = or i32 %38, 32
>   %40 = trunc i32 %39 to i8
>   store i8 %40, i8* %36, align 1
>   %41 = load i32* %2, align 4
>   %42 = call zeroext i8 @extractFloat32Sign(i32 %41)
>   store i8 %42, i8* %aSign, align 1
>   %43 = load %struct.float_status** %3, align 4
>   %44 = getelementptr inbounds %struct.float_status* %43, i32 0, i32 1
>   %45 = load i8* %44, align 1
>   %46 = sext i8 %45 to i32
>   switch i32 %46, label %68 [
>     i32 0, label %47
>     i32 1, label %58
>     i32 2, label %63
>   ]
10080,10088c6480,6483
< ; <label>:15                                      ; preds = %0
<   %16 = tail call fastcc i32 @ldl_kernel(i32 %14) nounwind
<   %17 = add i32 %9, 4
<   %18 = and i32 %7, %17
<   %19 = add i32 %18, %11
<   %20 = tail call fastcc i32 @ldl_kernel(i32 %19) nounwind
<   %21 = add i32 %9, 8
<   %22 = and i32 %20, 65535
<   br label %30
---
> ; <label>:47                                      ; preds = %34
>   %48 = load i32* %aExp, align 4
>   %49 = icmp eq i32 %48, 126
>   br i1 %49, label %50, label %57
10090,10097c6485,6495
< ; <label>:23                                      ; preds = %0
<   %24 = tail call fastcc i32 @lduw_kernel(i32 %14) nounwind
<   %25 = add i32 %9, 2
<   %26 = and i32 %7, %25
<   %27 = add i32 %26, %11
<   %28 = tail call fastcc i32 @lduw_kernel(i32 %27) nounwind
<   %29 = add i32 %9, 4
<   br label %30
---
> ; <label>:50                                      ; preds = %47
>   %51 = load i32* %2, align 4
>   %52 = call i32 @extractFloat32Frac(i32 %51)
>   %53 = icmp ne i32 %52, 0
>   br i1 %53, label %54, label %57
> 
> ; <label>:54                                      ; preds = %50
>   %55 = load i8* %aSign, align 1
>   %56 = call i32 @packFloat32(i8 zeroext %55, i32 127, i32 0)
>   store i32 %56, i32* %1
>   br label %137
10099,10105c6497,6498
< ; <label>:30                                      ; preds = %23, %15
<   %new_cs.0.i = phi i32 [ %22, %15 ], [ %28, %23 ]
<   %sp.0.i = phi i32 [ %21, %15 ], [ %29, %23 ]
<   %new_eip.0.i = phi i32 [ %16, %15 ], [ %24, %23 ]
<   %31 = and i32 %new_cs.0.i, 65532
<   %32 = icmp eq i32 %31, 0
<   br i1 %32, label %33, label %34
---
> ; <label>:57                                      ; preds = %50, %47
>   br label %68
10107,10109c6500,6541
< ; <label>:33                                      ; preds = %30
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn nounwind
<   unreachable
---
> ; <label>:58                                      ; preds = %34
>   %59 = load i8* %aSign, align 1
>   %60 = zext i8 %59 to i32
>   %61 = icmp ne i32 %60, 0
>   %62 = select i1 %61, i32 -1082130432, i32 0
>   store i32 %62, i32* %1
>   br label %137
> 
> ; <label>:63                                      ; preds = %34
>   %64 = load i8* %aSign, align 1
>   %65 = zext i8 %64 to i32
>   %66 = icmp ne i32 %65, 0
>   %67 = select i1 %66, i32 -2147483648, i32 1065353216
>   store i32 %67, i32* %1
>   br label %137
> 
> ; <label>:68                                      ; preds = %57, %34
>   %69 = load i8* %aSign, align 1
>   %70 = call i32 @packFloat32(i8 zeroext %69, i32 0, i32 0)
>   store i32 %70, i32* %1
>   br label %137
> 
> ; <label>:71                                      ; preds = %25
>   store i32 1, i32* %lastBitMask, align 4
>   %72 = load i32* %aExp, align 4
>   %73 = sub nsw i32 150, %72
>   %74 = load i32* %lastBitMask, align 4
>   %75 = shl i32 %74, %73
>   store i32 %75, i32* %lastBitMask, align 4
>   %76 = load i32* %lastBitMask, align 4
>   %77 = sub i32 %76, 1
>   store i32 %77, i32* %roundBitsMask, align 4
>   %78 = load i32* %2, align 4
>   store i32 %78, i32* %z, align 4
>   %79 = load %struct.float_status** %3, align 4
>   %80 = getelementptr inbounds %struct.float_status* %79, i32 0, i32 1
>   %81 = load i8* %80, align 1
>   store i8 %81, i8* %roundingMode, align 1
>   %82 = load i8* %roundingMode, align 1
>   %83 = sext i8 %82 to i32
>   %84 = icmp eq i32 %83, 0
>   br i1 %84, label %85, label %100
10111,10122c6543,6553
< ; <label>:34                                      ; preds = %30
<   %35 = and i32 %new_cs.0.i, 4
<   %36 = icmp eq i32 %35, 0
<   %37 = load %struct.CPUX86State** @env, align 8
<   %38 = getelementptr inbounds %struct.CPUX86State* %37, i64 0, i32 11
<   %39 = getelementptr inbounds %struct.CPUX86State* %37, i64 0, i32 13
<   %dt.0.i.i = select i1 %36, %struct.SegmentCache* %39, %struct.SegmentCache* %38
<   %40 = or i32 %new_cs.0.i, 7
<   %41 = getelementptr inbounds %struct.SegmentCache* %dt.0.i.i, i64 0, i32 2
<   %42 = load i32* %41, align 4
<   %43 = icmp ugt i32 %40, %42
<   br i1 %43, label %44, label %45
---
> ; <label>:85                                      ; preds = %71
>   %86 = load i32* %lastBitMask, align 4
>   %87 = lshr i32 %86, 1
>   %88 = load i32* %z, align 4
>   %89 = add i32 %88, %87
>   store i32 %89, i32* %z, align 4
>   %90 = load i32* %z, align 4
>   %91 = load i32* %roundBitsMask, align 4
>   %92 = and i32 %90, %91
>   %93 = icmp eq i32 %92, 0
>   br i1 %93, label %94, label %99
10124,10126c6555,6589
< ; <label>:44                                      ; preds = %34
<   tail call fastcc void @raise_exception_err(i32 13, i32 %31) noreturn nounwind
<   unreachable
---
> ; <label>:94                                      ; preds = %85
>   %95 = load i32* %lastBitMask, align 4
>   %96 = xor i32 %95, -1
>   %97 = load i32* %z, align 4
>   %98 = and i32 %97, %96
>   store i32 %98, i32* %z, align 4
>   br label %99
> 
> ; <label>:99                                      ; preds = %94, %85
>   br label %120
> 
> ; <label>:100                                     ; preds = %71
>   %101 = load i8* %roundingMode, align 1
>   %102 = sext i8 %101 to i32
>   %103 = icmp ne i32 %102, 3
>   br i1 %103, label %104, label %119
> 
> ; <label>:104                                     ; preds = %100
>   %105 = load i32* %z, align 4
>   %106 = call zeroext i8 @extractFloat32Sign(i32 %105)
>   %107 = zext i8 %106 to i32
>   %108 = load i8* %roundingMode, align 1
>   %109 = sext i8 %108 to i32
>   %110 = icmp eq i32 %109, 2
>   %111 = zext i1 %110 to i32
>   %112 = xor i32 %107, %111
>   %113 = icmp ne i32 %112, 0
>   br i1 %113, label %114, label %118
> 
> ; <label>:114                                     ; preds = %104
>   %115 = load i32* %roundBitsMask, align 4
>   %116 = load i32* %z, align 4
>   %117 = add i32 %116, %115
>   store i32 %117, i32* %z, align 4
>   br label %118
10128,10138c6591,6592
< ; <label>:45                                      ; preds = %34
<   %46 = and i32 %new_cs.0.i, -8
<   %47 = getelementptr inbounds %struct.SegmentCache* %dt.0.i.i, i64 0, i32 1
<   %48 = load i32* %47, align 4
<   %49 = add i32 %48, %46
<   %50 = tail call fastcc i32 @ldl_kernel(i32 %49) nounwind
<   %51 = add i32 %49, 4
<   %52 = tail call fastcc i32 @ldl_kernel(i32 %51) nounwind
<   %53 = and i32 %52, 6144
<   %54 = icmp eq i32 %53, 6144
<   br i1 %54, label %56, label %55
---
> ; <label>:118                                     ; preds = %114, %104
>   br label %119
10140,10142c6594,6595
< ; <label>:55                                      ; preds = %45
<   tail call fastcc void @raise_exception_err(i32 13, i32 %31) noreturn nounwind
<   unreachable
---
> ; <label>:119                                     ; preds = %118, %100
>   br label %120
10144,10151c6597,6626
< ; <label>:56                                      ; preds = %45
<   %57 = load %struct.CPUX86State** @env, align 8
<   %58 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 8
<   %59 = load i32* %58, align 4
<   %60 = and i32 %59, 3
<   %61 = and i32 %new_cs.0.i, 3
<   %62 = icmp ult i32 %61, %60
<   br i1 %62, label %63, label %64
---
> ; <label>:120                                     ; preds = %119, %99
>   %121 = load i32* %roundBitsMask, align 4
>   %122 = xor i32 %121, -1
>   %123 = load i32* %z, align 4
>   %124 = and i32 %123, %122
>   store i32 %124, i32* %z, align 4
>   %125 = load i32* %z, align 4
>   %126 = load i32* %2, align 4
>   %127 = icmp ne i32 %125, %126
>   br i1 %127, label %128, label %135
> 
> ; <label>:128                                     ; preds = %120
>   %129 = load %struct.float_status** %3, align 4
>   %130 = getelementptr inbounds %struct.float_status* %129, i32 0, i32 2
>   %131 = load i8* %130, align 1
>   %132 = sext i8 %131 to i32
>   %133 = or i32 %132, 32
>   %134 = trunc i32 %133 to i8
>   store i8 %134, i8* %130, align 1
>   br label %135
> 
> ; <label>:135                                     ; preds = %128, %120
>   %136 = load i32* %z, align 4
>   store i32 %136, i32* %1
>   br label %137
> 
> ; <label>:137                                     ; preds = %135, %68, %63, %58, %54, %32, %23, %18
>   %138 = load i32* %1
>   ret i32 %138
> }
10153,10155c6628,6674
< ; <label>:63                                      ; preds = %56
<   tail call fastcc void @raise_exception_err(i32 13, i32 %31) noreturn nounwind
<   unreachable
---
> define internal i32 @propagateFloat32NaN(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aIsQuietNaN = alloca i8, align 1
>   %aIsSignalingNaN = alloca i8, align 1
>   %bIsQuietNaN = alloca i8, align 1
>   %bIsSignalingNaN = alloca i8, align 1
>   %aIsLargerSignificand = alloca i8, align 1
>   %av = alloca i32, align 4
>   %bv = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = call i32 @float32_is_quiet_nan(i32 %5)
>   %7 = trunc i32 %6 to i8
>   store i8 %7, i8* %aIsQuietNaN, align 1
>   %8 = load i32* %2, align 4
>   %9 = call i32 @float32_is_signaling_nan(i32 %8)
>   %10 = trunc i32 %9 to i8
>   store i8 %10, i8* %aIsSignalingNaN, align 1
>   %11 = load i32* %3, align 4
>   %12 = call i32 @float32_is_quiet_nan(i32 %11)
>   %13 = trunc i32 %12 to i8
>   store i8 %13, i8* %bIsQuietNaN, align 1
>   %14 = load i32* %3, align 4
>   %15 = call i32 @float32_is_signaling_nan(i32 %14)
>   %16 = trunc i32 %15 to i8
>   store i8 %16, i8* %bIsSignalingNaN, align 1
>   %17 = load i32* %2, align 4
>   store i32 %17, i32* %av, align 4
>   %18 = load i32* %3, align 4
>   store i32 %18, i32* %bv, align 4
>   %19 = load i8* %aIsSignalingNaN, align 1
>   %20 = zext i8 %19 to i32
>   %21 = load i8* %bIsSignalingNaN, align 1
>   %22 = zext i8 %21 to i32
>   %23 = or i32 %20, %22
>   %24 = icmp ne i32 %23, 0
>   br i1 %24, label %25, label %27
> 
> ; <label>:25                                      ; preds = %0
>   %26 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %26)
>   br label %27
10157,10162c6676,6681
< ; <label>:64                                      ; preds = %56
<   %65 = lshr i32 %52, 13
<   %66 = and i32 %65, 3
<   %67 = and i32 %52, 1024
<   %68 = icmp eq i32 %67, 0
<   br i1 %68, label %72, label %69
---
> ; <label>:27                                      ; preds = %25, %0
>   %28 = load %struct.float_status** %4, align 4
>   %29 = getelementptr inbounds %struct.float_status* %28, i32 0, i32 6
>   %30 = load i8* %29, align 1
>   %31 = icmp ne i8 %30, 0
>   br i1 %31, label %32, label %33
10164,10166c6683,6685
< ; <label>:69                                      ; preds = %64
<   %70 = icmp ugt i32 %66, %61
<   br i1 %70, label %71, label %75
---
> ; <label>:32                                      ; preds = %27
>   store i32 -4194304, i32* %1
>   br label %68
10168,10170c6687,6693
< ; <label>:71                                      ; preds = %69
<   tail call fastcc void @raise_exception_err(i32 13, i32 %31) noreturn nounwind
<   unreachable
---
> ; <label>:33                                      ; preds = %27
>   %34 = load i32* %av, align 4
>   %35 = shl i32 %34, 1
>   %36 = load i32* %bv, align 4
>   %37 = shl i32 %36, 1
>   %38 = icmp ult i32 %35, %37
>   br i1 %38, label %39, label %40
10172,10174c6695,6697
< ; <label>:72                                      ; preds = %64
<   %73 = icmp eq i32 %66, %61
<   br i1 %73, label %75, label %74
---
> ; <label>:39                                      ; preds = %33
>   store i8 0, i8* %aIsLargerSignificand, align 1
>   br label %54
10176,10178c6699,6705
< ; <label>:74                                      ; preds = %72
<   tail call fastcc void @raise_exception_err(i32 13, i32 %31) noreturn nounwind
<   unreachable
---
> ; <label>:40                                      ; preds = %33
>   %41 = load i32* %bv, align 4
>   %42 = shl i32 %41, 1
>   %43 = load i32* %av, align 4
>   %44 = shl i32 %43, 1
>   %45 = icmp ult i32 %42, %44
>   br i1 %45, label %46, label %47
10180,10183c6707,6709
< ; <label>:75                                      ; preds = %72, %69
<   %76 = and i32 %52, 32768
<   %77 = icmp eq i32 %76, 0
<   br i1 %77, label %78, label %79
---
> ; <label>:46                                      ; preds = %40
>   store i8 1, i8* %aIsLargerSignificand, align 1
>   br label %53
10185,10187c6711,6718
< ; <label>:78                                      ; preds = %75
<   tail call fastcc void @raise_exception_err(i32 11, i32 %31) noreturn nounwind
<   unreachable
---
> ; <label>:47                                      ; preds = %40
>   %48 = load i32* %av, align 4
>   %49 = load i32* %bv, align 4
>   %50 = icmp ult i32 %48, %49
>   %51 = select i1 %50, i32 1, i32 0
>   %52 = trunc i32 %51 to i8
>   store i8 %52, i8* %aIsLargerSignificand, align 1
>   br label %53
10189,10192c6720,6721
< ; <label>:79                                      ; preds = %75
<   %80 = add i32 %sp.0.i, %addend
<   %81 = icmp eq i32 %61, %60
<   br i1 %81, label %82, label %136
---
> ; <label>:53                                      ; preds = %47, %46
>   br label %54
10194,10206c6723,6731
< ; <label>:82                                      ; preds = %79
<   %83 = lshr i32 %50, 16
<   %84 = shl i32 %52, 16
<   %85 = and i32 %84, 16711680
<   %86 = and i32 %52, -16777216
<   %87 = or i32 %86, %83
<   %88 = or i32 %87, %85
<   %89 = and i32 %50, 65535
<   %90 = and i32 %52, 983040
<   %91 = or i32 %90, %89
<   %92 = and i32 %52, 8388608
<   %93 = icmp eq i32 %92, 0
<   br i1 %93, label %get_seg_limit.exit.i, label %94
---
> ; <label>:54                                      ; preds = %53, %39
>   %55 = load i8* %aIsQuietNaN, align 1
>   %56 = load i8* %aIsSignalingNaN, align 1
>   %57 = load i8* %bIsQuietNaN, align 1
>   %58 = load i8* %bIsSignalingNaN, align 1
>   %59 = load i8* %aIsLargerSignificand, align 1
>   %60 = call i32 @pickNaN(i8 zeroext %55, i8 zeroext %56, i8 zeroext %57, i8 zeroext %58, i8 zeroext %59)
>   %61 = icmp ne i32 %60, 0
>   br i1 %61, label %62, label %65
10208,10236c6733,6737
< ; <label>:94                                      ; preds = %82
<   %95 = shl nuw i32 %91, 12
<   %96 = or i32 %95, 4095
<   br label %get_seg_limit.exit.i
< 
< get_seg_limit.exit.i:                             ; preds = %94, %82
<   %limit.0.i.i = phi i32 [ %96, %94 ], [ %91, %82 ]
<   %97 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 10, i64 1, i32 0
<   store i32 %new_cs.0.i, i32* %97, align 4
<   %98 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 10, i64 1, i32 1
<   store i32 %88, i32* %98, align 4
<   %99 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 10, i64 1, i32 2
<   store i32 %limit.0.i.i, i32* %99, align 4
<   %100 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 10, i64 1, i32 3
<   store i32 %52, i32* %100, align 4
<   %101 = lshr i32 %52, 18
<   %102 = and i32 %101, 16
<   %103 = and i32 %59, -32785
<   %104 = or i32 %103, %102
<   store i32 %104, i32* %58, align 4
<   %105 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 10, i64 2, i32 3
<   %106 = load i32* %105, align 4
<   %107 = lshr i32 %106, 17
<   %108 = and i32 %107, 32
<   %109 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 15, i64 0
<   %110 = load i32* %109, align 4
<   %111 = and i32 %110, 1
<   %112 = icmp eq i32 %111, 0
<   br i1 %112, label %119, label %113
---
> ; <label>:62                                      ; preds = %54
>   %63 = load i32* %3, align 4
>   %64 = call i32 @float32_maybe_silence_nan(i32 %63)
>   store i32 %64, i32* %1
>   br label %68
10238,10276c6739,6743
< ; <label>:113                                     ; preds = %get_seg_limit.exit.i
<   %114 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 7
<   %115 = load i32* %114, align 4
<   %116 = and i32 %115, 131072
<   %117 = icmp ne i32 %116, 0
<   %118 = icmp eq i32 %102, 0
<   %or.cond192.i = or i1 %117, %118
<   br i1 %or.cond192.i, label %119, label %121
< 
< ; <label>:119                                     ; preds = %113, %get_seg_limit.exit.i
<   %120 = or i32 %108, 64
<   br label %cpu_x86_load_seg_cache.exit.i
< 
< ; <label>:121                                     ; preds = %113
<   %122 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 10, i64 3, i32 1
<   %123 = load i32* %122, align 4
<   %124 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 10, i64 0, i32 1
<   %125 = load i32* %124, align 4
<   %126 = or i32 %125, %123
<   %127 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 10, i64 2, i32 1
<   %128 = load i32* %127, align 4
<   %129 = or i32 %126, %128
<   %130 = icmp ne i32 %129, 0
<   %131 = zext i1 %130 to i32
<   %132 = shl nuw nsw i32 %131, 6
<   %133 = or i32 %132, %108
<   br label %cpu_x86_load_seg_cache.exit.i
< 
< cpu_x86_load_seg_cache.exit.i:                    ; preds = %121, %119
<   %new_hflags.0.i.i = phi i32 [ %120, %119 ], [ %133, %121 ]
<   %134 = and i32 %104, -32865
<   %135 = or i32 %new_hflags.0.i.i, %134
<   store i32 %135, i32* %58, align 4
<   br label %helper_ret_protected.exit
< 
< ; <label>:136                                     ; preds = %79
<   %137 = and i32 %80, %7
<   %138 = add i32 %137, %11
<   br i1 %12, label %139, label %146
---
> ; <label>:65                                      ; preds = %54
>   %66 = load i32* %2, align 4
>   %67 = call i32 @float32_maybe_silence_nan(i32 %66)
>   store i32 %67, i32* %1
>   br label %68
10278,10285c6745,6748
< ; <label>:139                                     ; preds = %136
<   %140 = tail call fastcc i32 @ldl_kernel(i32 %138) nounwind
<   %141 = add i32 %80, 4
<   %142 = and i32 %141, %7
<   %143 = add i32 %142, %11
<   %144 = tail call fastcc i32 @ldl_kernel(i32 %143) nounwind
<   %145 = and i32 %144, 65535
<   br label %152
---
> ; <label>:68                                      ; preds = %65, %62, %32
>   %69 = load i32* %1
>   ret i32 %69
> }
10287,10293c6750,6779
< ; <label>:146                                     ; preds = %136
<   %147 = tail call fastcc i32 @lduw_kernel(i32 %138) nounwind
<   %148 = add i32 %80, 2
<   %149 = and i32 %148, %7
<   %150 = add i32 %149, %11
<   %151 = tail call fastcc i32 @lduw_kernel(i32 %150) nounwind
<   br label %152
---
> define internal i32 @float32_add(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %3, align 4
>   %14 = call zeroext i8 @extractFloat32Sign(i32 %13)
>   store i8 %14, i8* %bSign, align 1
>   %15 = load i8* %aSign, align 1
>   %16 = zext i8 %15 to i32
>   %17 = load i8* %bSign, align 1
>   %18 = zext i8 %17 to i32
>   %19 = icmp eq i32 %16, %18
>   br i1 %19, label %20, label %26
10295,10300c6781,6788
< ; <label>:152                                     ; preds = %146, %139
<   %new_ss.0.i = phi i32 [ %145, %139 ], [ %151, %146 ]
<   %new_esp.0.i = phi i32 [ %140, %139 ], [ %147, %146 ]
<   %153 = and i32 %new_ss.0.i, 65532
<   %154 = icmp eq i32 %153, 0
<   br i1 %154, label %155, label %156
---
> ; <label>:20                                      ; preds = %0
>   %21 = load i32* %2, align 4
>   %22 = load i32* %3, align 4
>   %23 = load i8* %aSign, align 1
>   %24 = load %struct.float_status** %4, align 4
>   %25 = call i32 @addFloat32Sigs(i32 %21, i32 %22, i8 zeroext %23, %struct.float_status* %24)
>   store i32 %25, i32* %1
>   br label %32
10302,10304c6790,6797
< ; <label>:155                                     ; preds = %152
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn nounwind
<   unreachable
---
> ; <label>:26                                      ; preds = %0
>   %27 = load i32* %2, align 4
>   %28 = load i32* %3, align 4
>   %29 = load i8* %aSign, align 1
>   %30 = load %struct.float_status** %4, align 4
>   %31 = call i32 @subFloat32Sigs(i32 %27, i32 %28, i8 zeroext %29, %struct.float_status* %30)
>   store i32 %31, i32* %1
>   br label %32
10306,10309c6799,6802
< ; <label>:156                                     ; preds = %152
<   %157 = and i32 %new_ss.0.i, 3
<   %158 = icmp eq i32 %157, %61
<   br i1 %158, label %160, label %159
---
> ; <label>:32                                      ; preds = %26, %20
>   %33 = load i32* %1
>   ret i32 %33
> }
10311,10313c6804,6845
< ; <label>:159                                     ; preds = %156
<   tail call fastcc void @raise_exception_err(i32 13, i32 %153) noreturn nounwind
<   unreachable
---
> define internal i32 @addFloat32Sigs(i32 %a, i32 %b, i8 zeroext %zSign, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca i8, align 1
>   %5 = alloca %struct.float_status*, align 4
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %bSig = alloca i32, align 4
>   %zSig = alloca i32, align 4
>   %expDiff = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store i8 %zSign, i8* %4, align 1
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load i32* %2, align 4
>   %7 = call i32 @extractFloat32Frac(i32 %6)
>   store i32 %7, i32* %aSig, align 4
>   %8 = load i32* %2, align 4
>   %9 = call i32 @extractFloat32Exp(i32 %8)
>   store i32 %9, i32* %aExp, align 4
>   %10 = load i32* %3, align 4
>   %11 = call i32 @extractFloat32Frac(i32 %10)
>   store i32 %11, i32* %bSig, align 4
>   %12 = load i32* %3, align 4
>   %13 = call i32 @extractFloat32Exp(i32 %12)
>   store i32 %13, i32* %bExp, align 4
>   %14 = load i32* %aExp, align 4
>   %15 = load i32* %bExp, align 4
>   %16 = sub nsw i32 %14, %15
>   store i32 %16, i32* %expDiff, align 4
>   %17 = load i32* %aSig, align 4
>   %18 = shl i32 %17, 6
>   store i32 %18, i32* %aSig, align 4
>   %19 = load i32* %bSig, align 4
>   %20 = shl i32 %19, 6
>   store i32 %20, i32* %bSig, align 4
>   %21 = load i32* %expDiff, align 4
>   %22 = icmp slt i32 0, %21
>   br i1 %22, label %23, label %49
10315,10326c6847,6863
< ; <label>:160                                     ; preds = %156
<   %161 = and i32 %new_ss.0.i, 4
<   %162 = icmp eq i32 %161, 0
<   %163 = load %struct.CPUX86State** @env, align 8
<   %164 = getelementptr inbounds %struct.CPUX86State* %163, i64 0, i32 11
<   %165 = getelementptr inbounds %struct.CPUX86State* %163, i64 0, i32 13
<   %dt.0.i134.i = select i1 %162, %struct.SegmentCache* %165, %struct.SegmentCache* %164
<   %166 = or i32 %new_ss.0.i, 7
<   %167 = getelementptr inbounds %struct.SegmentCache* %dt.0.i134.i, i64 0, i32 2
<   %168 = load i32* %167, align 4
<   %169 = icmp ugt i32 %166, %168
<   br i1 %169, label %170, label %171
---
> ; <label>:23                                      ; preds = %0
>   %24 = load i32* %aExp, align 4
>   %25 = icmp eq i32 %24, 255
>   br i1 %25, label %26, label %36
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load i32* %aSig, align 4
>   %28 = icmp ne i32 %27, 0
>   br i1 %28, label %29, label %34
> 
> ; <label>:29                                      ; preds = %26
>   %30 = load i32* %2, align 4
>   %31 = load i32* %3, align 4
>   %32 = load %struct.float_status** %5, align 4
>   %33 = call i32 @propagateFloat32NaN(i32 %30, i32 %31, %struct.float_status* %32)
>   store i32 %33, i32* %1
>   br label %151
10328,10330c6865,6868
< ; <label>:170                                     ; preds = %160
<   tail call fastcc void @raise_exception_err(i32 13, i32 %153) noreturn nounwind
<   unreachable
---
> ; <label>:34                                      ; preds = %26
>   %35 = load i32* %2, align 4
>   store i32 %35, i32* %1
>   br label %151
10332,10342c6870,6873
< ; <label>:171                                     ; preds = %160
<   %172 = and i32 %new_ss.0.i, -8
<   %173 = getelementptr inbounds %struct.SegmentCache* %dt.0.i134.i, i64 0, i32 1
<   %174 = load i32* %173, align 4
<   %175 = add i32 %174, %172
<   %176 = tail call fastcc i32 @ldl_kernel(i32 %175) nounwind
<   %177 = add i32 %175, 4
<   %178 = tail call fastcc i32 @ldl_kernel(i32 %177) nounwind
<   %179 = and i32 %178, 6656
<   %180 = icmp eq i32 %179, 4608
<   br i1 %180, label %182, label %181
---
> ; <label>:36                                      ; preds = %23
>   %37 = load i32* %bExp, align 4
>   %38 = icmp eq i32 %37, 0
>   br i1 %38, label %39, label %42
10344,10346c6875,6879
< ; <label>:181                                     ; preds = %171
<   tail call fastcc void @raise_exception_err(i32 13, i32 %153) noreturn nounwind
<   unreachable
---
> ; <label>:39                                      ; preds = %36
>   %40 = load i32* %expDiff, align 4
>   %41 = add nsw i32 %40, -1
>   store i32 %41, i32* %expDiff, align 4
>   br label %45
10348,10352c6881,6885
< ; <label>:182                                     ; preds = %171
<   %183 = lshr i32 %178, 13
<   %184 = and i32 %183, 3
<   %185 = icmp eq i32 %184, %61
<   br i1 %185, label %187, label %186
---
> ; <label>:42                                      ; preds = %36
>   %43 = load i32* %bSig, align 4
>   %44 = or i32 %43, 536870912
>   store i32 %44, i32* %bSig, align 4
>   br label %45
10354,10356c6887,6916
< ; <label>:186                                     ; preds = %182
<   tail call fastcc void @raise_exception_err(i32 13, i32 %153) noreturn nounwind
<   unreachable
---
> ; <label>:45                                      ; preds = %42, %39
>   %46 = load i32* %bSig, align 4
>   %47 = load i32* %expDiff, align 4
>   call void @shift32RightJamming(i32 %46, i32 %47, i32* %bSig)
>   %48 = load i32* %aExp, align 4
>   store i32 %48, i32* %zExp, align 4
>   br label %127
> 
> ; <label>:49                                      ; preds = %0
>   %50 = load i32* %expDiff, align 4
>   %51 = icmp slt i32 %50, 0
>   br i1 %51, label %52, label %80
> 
> ; <label>:52                                      ; preds = %49
>   %53 = load i32* %bExp, align 4
>   %54 = icmp eq i32 %53, 255
>   br i1 %54, label %55, label %66
> 
> ; <label>:55                                      ; preds = %52
>   %56 = load i32* %bSig, align 4
>   %57 = icmp ne i32 %56, 0
>   br i1 %57, label %58, label %63
> 
> ; <label>:58                                      ; preds = %55
>   %59 = load i32* %2, align 4
>   %60 = load i32* %3, align 4
>   %61 = load %struct.float_status** %5, align 4
>   %62 = call i32 @propagateFloat32NaN(i32 %59, i32 %60, %struct.float_status* %61)
>   store i32 %62, i32* %1
>   br label %151
10358,10361c6918,6922
< ; <label>:187                                     ; preds = %182
<   %188 = and i32 %178, 32768
<   %189 = icmp eq i32 %188, 0
<   br i1 %189, label %190, label %191
---
> ; <label>:63                                      ; preds = %55
>   %64 = load i8* %4, align 1
>   %65 = call i32 @packFloat32(i8 zeroext %64, i32 255, i32 0)
>   store i32 %65, i32* %1
>   br label %151
10363,10365c6924,6927
< ; <label>:190                                     ; preds = %187
<   tail call fastcc void @raise_exception_err(i32 11, i32 %153) noreturn nounwind
<   unreachable
---
> ; <label>:66                                      ; preds = %52
>   %67 = load i32* %aExp, align 4
>   %68 = icmp eq i32 %67, 0
>   br i1 %68, label %69, label %72
10367,10410c6929,6933
< ; <label>:191                                     ; preds = %187
<   %192 = load %struct.CPUX86State** @env, align 8
<   %193 = lshr i32 %176, 16
<   %194 = shl i32 %178, 16
<   %195 = and i32 %194, 16711680
<   %196 = and i32 %178, -16777216
<   %197 = or i32 %196, %193
<   %198 = or i32 %197, %195
<   %199 = and i32 %176, 65535
<   %200 = and i32 %178, 983040
<   %201 = or i32 %200, %199
<   %202 = and i32 %178, 8388608
<   %203 = icmp eq i32 %202, 0
<   br i1 %203, label %get_seg_limit.exit138.i, label %204
< 
< ; <label>:204                                     ; preds = %191
<   %205 = shl nuw i32 %201, 12
<   %206 = or i32 %205, 4095
<   br label %get_seg_limit.exit138.i
< 
< get_seg_limit.exit138.i:                          ; preds = %204, %191
<   %limit.0.i137.i = phi i32 [ %206, %204 ], [ %201, %191 ]
<   %207 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 10, i64 2, i32 0
<   store i32 %new_ss.0.i, i32* %207, align 4
<   %208 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 10, i64 2, i32 1
<   store i32 %198, i32* %208, align 4
<   %209 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 10, i64 2, i32 2
<   store i32 %limit.0.i137.i, i32* %209, align 4
<   %210 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 10, i64 2, i32 3
<   store i32 %178, i32* %210, align 4
<   %.phi.trans.insert.i.i = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 8
<   %.pre.i.i = load i32* %.phi.trans.insert.i.i, align 4
<   %211 = lshr i32 %178, 17
<   %212 = and i32 %211, 32
<   %213 = and i32 %.pre.i.i, 32768
<   %214 = icmp eq i32 %213, 0
<   br i1 %214, label %215, label %cpu_x86_load_seg_cache.exit140.i
< 
< ; <label>:215                                     ; preds = %get_seg_limit.exit138.i
<   %216 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 15, i64 0
<   %217 = load i32* %216, align 4
<   %218 = and i32 %217, 1
<   %219 = icmp eq i32 %218, 0
<   br i1 %219, label %228, label %220
---
> ; <label>:69                                      ; preds = %66
>   %70 = load i32* %expDiff, align 4
>   %71 = add nsw i32 %70, 1
>   store i32 %71, i32* %expDiff, align 4
>   br label %75
10412,10490c6935,6939
< ; <label>:220                                     ; preds = %215
<   %221 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 7
<   %222 = load i32* %221, align 4
<   %223 = and i32 %222, 131072
<   %224 = icmp eq i32 %223, 0
<   br i1 %224, label %225, label %228
< 
< ; <label>:225                                     ; preds = %220
<   %226 = and i32 %.pre.i.i, 16
<   %227 = icmp eq i32 %226, 0
<   br i1 %227, label %228, label %230
< 
< ; <label>:228                                     ; preds = %225, %220, %215
<   %229 = or i32 %212, 64
<   br label %cpu_x86_load_seg_cache.exit140.i
< 
< ; <label>:230                                     ; preds = %225
<   %231 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 10, i64 3, i32 1
<   %232 = load i32* %231, align 4
<   %233 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 10, i64 0, i32 1
<   %234 = load i32* %233, align 4
<   %235 = or i32 %232, %198
<   %236 = or i32 %235, %234
<   %237 = icmp ne i32 %236, 0
<   %238 = zext i1 %237 to i32
<   %239 = shl nuw nsw i32 %238, 6
<   %240 = or i32 %239, %212
<   br label %cpu_x86_load_seg_cache.exit140.i
< 
< cpu_x86_load_seg_cache.exit140.i:                 ; preds = %230, %228, %get_seg_limit.exit138.i
<   %new_hflags.0.i139.i = phi i32 [ %212, %get_seg_limit.exit138.i ], [ %229, %228 ], [ %240, %230 ]
<   %241 = and i32 %.pre.i.i, -97
<   %242 = or i32 %new_hflags.0.i139.i, %241
<   store i32 %242, i32* %.phi.trans.insert.i.i, align 4
<   %243 = load %struct.CPUX86State** @env, align 8
<   %244 = lshr i32 %50, 16
<   %245 = shl i32 %52, 16
<   %246 = and i32 %245, 16711680
<   %247 = and i32 %52, -16777216
<   %248 = or i32 %247, %244
<   %249 = or i32 %248, %246
<   %250 = and i32 %50, 65535
<   %251 = and i32 %52, 983040
<   %252 = or i32 %251, %250
<   %253 = and i32 %52, 8388608
<   %254 = icmp eq i32 %253, 0
<   br i1 %254, label %get_seg_limit.exit142.i, label %255
< 
< ; <label>:255                                     ; preds = %cpu_x86_load_seg_cache.exit140.i
<   %256 = shl nuw i32 %252, 12
<   %257 = or i32 %256, 4095
<   br label %get_seg_limit.exit142.i
< 
< get_seg_limit.exit142.i:                          ; preds = %255, %cpu_x86_load_seg_cache.exit140.i
<   %limit.0.i141.i = phi i32 [ %257, %255 ], [ %252, %cpu_x86_load_seg_cache.exit140.i ]
<   %258 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 10, i64 1, i32 0
<   store i32 %new_cs.0.i, i32* %258, align 4
<   %259 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 10, i64 1, i32 1
<   store i32 %249, i32* %259, align 4
<   %260 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 10, i64 1, i32 2
<   store i32 %limit.0.i141.i, i32* %260, align 4
<   %261 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 10, i64 1, i32 3
<   store i32 %52, i32* %261, align 4
<   %262 = lshr i32 %52, 18
<   %263 = and i32 %262, 16
<   %264 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 8
<   %265 = load i32* %264, align 4
<   %266 = and i32 %265, -32785
<   %267 = or i32 %266, %263
<   store i32 %267, i32* %264, align 4
<   %268 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 10, i64 2, i32 3
<   %269 = load i32* %268, align 4
<   %270 = lshr i32 %269, 17
<   %271 = and i32 %270, 32
<   %272 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 15, i64 0
<   %273 = load i32* %272, align 4
<   %274 = and i32 %273, 1
<   %275 = icmp eq i32 %274, 0
<   br i1 %275, label %282, label %276
---
> ; <label>:72                                      ; preds = %66
>   %73 = load i32* %aSig, align 4
>   %74 = or i32 %73, 536870912
>   store i32 %74, i32* %aSig, align 4
>   br label %75
10492,10670c6941,6953
< ; <label>:276                                     ; preds = %get_seg_limit.exit142.i
<   %277 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 7
<   %278 = load i32* %277, align 4
<   %279 = and i32 %278, 131072
<   %280 = icmp ne i32 %279, 0
<   %281 = icmp eq i32 %263, 0
<   %or.cond193.i = or i1 %280, %281
<   br i1 %or.cond193.i, label %282, label %284
< 
< ; <label>:282                                     ; preds = %276, %get_seg_limit.exit142.i
<   %283 = or i32 %271, 64
<   br label %cpu_x86_load_seg_cache.exit144.i
< 
< ; <label>:284                                     ; preds = %276
<   %285 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 10, i64 3, i32 1
<   %286 = load i32* %285, align 4
<   %287 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 10, i64 0, i32 1
<   %288 = load i32* %287, align 4
<   %289 = or i32 %288, %286
<   %290 = getelementptr inbounds %struct.CPUX86State* %243, i64 0, i32 10, i64 2, i32 1
<   %291 = load i32* %290, align 4
<   %292 = or i32 %289, %291
<   %293 = icmp ne i32 %292, 0
<   %294 = zext i1 %293 to i32
<   %295 = shl nuw nsw i32 %294, 6
<   %296 = or i32 %295, %271
<   br label %cpu_x86_load_seg_cache.exit144.i
< 
< cpu_x86_load_seg_cache.exit144.i:                 ; preds = %284, %282
<   %new_hflags.0.i143.i = phi i32 [ %283, %282 ], [ %296, %284 ]
<   %297 = and i32 %267, -32865
<   %298 = or i32 %new_hflags.0.i143.i, %297
<   store i32 %298, i32* %264, align 4
<   %299 = load %struct.CPUX86State** @env, align 8
<   %300 = getelementptr inbounds %struct.CPUX86State* %299, i64 0, i32 8
<   %301 = load i32* %300, align 4
<   %302 = and i32 %301, 3
<   tail call void @s2e_on_privilege_change(i32 %302, i32 %61) nounwind
<   %303 = load i32* %300, align 4
<   %304 = and i32 %303, -4
<   %305 = or i32 %304, %61
<   store i32 %305, i32* %300, align 4
<   %306 = lshr i32 %178, 6
<   %307 = and i32 %306, 65536
<   %308 = xor i32 %307, 65536
<   %309 = add i32 %308, -1
<   %.pre.i161.i = load %struct.CPUX86State** @env, align 8
<   %310 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 0, i32 3
<   %311 = load i32* %310, align 4
<   %312 = lshr i32 %311, 13
<   %313 = and i32 %312, 3
<   %314 = and i32 %311, 3072
<   %315 = icmp ne i32 %314, 3072
<   %316 = icmp ult i32 %313, %61
<   %or.cond10.i162.i = and i1 %315, %316
<   br i1 %or.cond10.i162.i, label %317, label %validate_seg.exit167.i
< 
< ; <label>:317                                     ; preds = %cpu_x86_load_seg_cache.exit144.i
<   %318 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 0, i32 0
<   %319 = bitcast i32* %318 to i8*
<   br label %320
< 
< ; <label>:320                                     ; preds = %323, %317
<   %321 = phi i64 [ 0, %317 ], [ %325, %323 ]
<   %322 = icmp ult i64 %321, 16
<   br i1 %322, label %323, label %326
< 
< ; <label>:323                                     ; preds = %320
<   %324 = getelementptr i8* %319, i64 %321
<   store i8 0, i8* %324, align 1
<   %325 = add i64 %321, 1
<   br label %320
< 
< ; <label>:326                                     ; preds = %320
<   %.phi.trans.insert.i.i163.i = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 8
<   %.pre.i.i164.i = load i32* %.phi.trans.insert.i.i163.i, align 4
<   %327 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 2, i32 3
<   %328 = load i32* %327, align 4
<   %329 = lshr i32 %328, 17
<   %330 = and i32 %329, 32
<   %331 = and i32 %.pre.i.i164.i, 32768
<   %332 = icmp eq i32 %331, 0
<   br i1 %332, label %333, label %cpu_x86_load_seg_cache.exit.i166.i
< 
< ; <label>:333                                     ; preds = %326
<   %334 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 15, i64 0
<   %335 = load i32* %334, align 4
<   %336 = and i32 %335, 1
<   %337 = icmp eq i32 %336, 0
<   br i1 %337, label %346, label %338
< 
< ; <label>:338                                     ; preds = %333
<   %339 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 7
<   %340 = load i32* %339, align 4
<   %341 = and i32 %340, 131072
<   %342 = icmp eq i32 %341, 0
<   br i1 %342, label %343, label %346
< 
< ; <label>:343                                     ; preds = %338
<   %344 = and i32 %.pre.i.i164.i, 16
<   %345 = icmp eq i32 %344, 0
<   br i1 %345, label %346, label %348
< 
< ; <label>:346                                     ; preds = %343, %338, %333
<   %347 = or i32 %330, 64
<   br label %cpu_x86_load_seg_cache.exit.i166.i
< 
< ; <label>:348                                     ; preds = %343
<   %349 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 3, i32 1
<   %350 = load i32* %349, align 4
<   %351 = getelementptr inbounds %struct.CPUX86State* %.pre.i161.i, i64 0, i32 10, i64 2, i32 1
<   %352 = load i32* %351, align 4
<   %353 = or i32 %352, %350
<   %354 = icmp ne i32 %353, 0
<   %355 = zext i1 %354 to i32
<   %356 = shl nuw nsw i32 %355, 6
<   %357 = or i32 %356, %330
<   br label %cpu_x86_load_seg_cache.exit.i166.i
< 
< cpu_x86_load_seg_cache.exit.i166.i:               ; preds = %348, %346, %326
<   %new_hflags.0.i.i165.i = phi i32 [ %330, %326 ], [ %347, %346 ], [ %357, %348 ]
<   %358 = and i32 %.pre.i.i164.i, -97
<   %359 = or i32 %new_hflags.0.i.i165.i, %358
<   store i32 %359, i32* %.phi.trans.insert.i.i163.i, align 4
<   %.pre.i154.pre.i = load %struct.CPUX86State** @env, align 8
<   br label %validate_seg.exit167.i
< 
< validate_seg.exit167.i:                           ; preds = %cpu_x86_load_seg_cache.exit.i166.i, %cpu_x86_load_seg_cache.exit144.i
<   %.pre.i154.i = phi %struct.CPUX86State* [ %.pre.i161.i, %cpu_x86_load_seg_cache.exit144.i ], [ %.pre.i154.pre.i, %cpu_x86_load_seg_cache.exit.i166.i ]
<   %360 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 3, i32 3
<   %361 = load i32* %360, align 4
<   %362 = lshr i32 %361, 13
<   %363 = and i32 %362, 3
<   %364 = and i32 %361, 3072
<   %365 = icmp ne i32 %364, 3072
<   %366 = icmp ult i32 %363, %61
<   %or.cond10.i155.i = and i1 %365, %366
<   br i1 %or.cond10.i155.i, label %367, label %validate_seg.exit160.i
< 
< ; <label>:367                                     ; preds = %validate_seg.exit167.i
<   %368 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 3, i32 0
<   %369 = bitcast i32* %368 to i8*
<   br label %370
< 
< ; <label>:370                                     ; preds = %373, %367
<   %371 = phi i64 [ 0, %367 ], [ %375, %373 ]
<   %372 = icmp ult i64 %371, 16
<   br i1 %372, label %373, label %376
< 
< ; <label>:373                                     ; preds = %370
<   %374 = getelementptr i8* %369, i64 %371
<   store i8 0, i8* %374, align 1
<   %375 = add i64 %371, 1
<   br label %370
< 
< ; <label>:376                                     ; preds = %370
<   %.phi.trans.insert.i.i156.i = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 8
<   %.pre.i.i157.i = load i32* %.phi.trans.insert.i.i156.i, align 4
<   %377 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 2, i32 3
<   %378 = load i32* %377, align 4
<   %379 = lshr i32 %378, 17
<   %380 = and i32 %379, 32
<   %381 = and i32 %.pre.i.i157.i, 32768
<   %382 = icmp eq i32 %381, 0
<   br i1 %382, label %383, label %cpu_x86_load_seg_cache.exit.i159.i
< 
< ; <label>:383                                     ; preds = %376
<   %384 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 15, i64 0
<   %385 = load i32* %384, align 4
<   %386 = and i32 %385, 1
<   %387 = icmp eq i32 %386, 0
<   br i1 %387, label %396, label %388
< 
< ; <label>:388                                     ; preds = %383
<   %389 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 7
<   %390 = load i32* %389, align 4
<   %391 = and i32 %390, 131072
<   %392 = icmp eq i32 %391, 0
<   br i1 %392, label %393, label %396
---
> ; <label>:75                                      ; preds = %72, %69
>   %76 = load i32* %aSig, align 4
>   %77 = load i32* %expDiff, align 4
>   %78 = sub nsw i32 0, %77
>   call void @shift32RightJamming(i32 %76, i32 %78, i32* %aSig)
>   %79 = load i32* %bExp, align 4
>   store i32 %79, i32* %zExp, align 4
>   br label %126
> 
> ; <label>:80                                      ; preds = %49
>   %81 = load i32* %aExp, align 4
>   %82 = icmp eq i32 %81, 255
>   br i1 %82, label %83, label %95
10672,10675c6955,6960
< ; <label>:393                                     ; preds = %388
<   %394 = and i32 %.pre.i.i157.i, 16
<   %395 = icmp eq i32 %394, 0
<   br i1 %395, label %396, label %398
---
> ; <label>:83                                      ; preds = %80
>   %84 = load i32* %aSig, align 4
>   %85 = load i32* %bSig, align 4
>   %86 = or i32 %84, %85
>   %87 = icmp ne i32 %86, 0
>   br i1 %87, label %88, label %93
10677,10718c6962,6968
< ; <label>:396                                     ; preds = %393, %388, %383
<   %397 = or i32 %380, 64
<   br label %cpu_x86_load_seg_cache.exit.i159.i
< 
< ; <label>:398                                     ; preds = %393
<   %399 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 0, i32 1
<   %400 = load i32* %399, align 4
<   %401 = getelementptr inbounds %struct.CPUX86State* %.pre.i154.i, i64 0, i32 10, i64 2, i32 1
<   %402 = load i32* %401, align 4
<   %403 = or i32 %402, %400
<   %404 = icmp ne i32 %403, 0
<   %405 = zext i1 %404 to i32
<   %406 = shl nuw nsw i32 %405, 6
<   %407 = or i32 %406, %380
<   br label %cpu_x86_load_seg_cache.exit.i159.i
< 
< cpu_x86_load_seg_cache.exit.i159.i:               ; preds = %398, %396, %376
<   %new_hflags.0.i.i158.i = phi i32 [ %380, %376 ], [ %397, %396 ], [ %407, %398 ]
<   %408 = and i32 %.pre.i.i157.i, -97
<   %409 = or i32 %new_hflags.0.i.i158.i, %408
<   store i32 %409, i32* %.phi.trans.insert.i.i156.i, align 4
<   %.pre.i = load %struct.CPUX86State** @env, align 8
<   br label %validate_seg.exit160.i
< 
< validate_seg.exit160.i:                           ; preds = %cpu_x86_load_seg_cache.exit.i159.i, %validate_seg.exit167.i
<   %410 = phi %struct.CPUX86State* [ %.pre.i154.i, %validate_seg.exit167.i ], [ %.pre.i, %cpu_x86_load_seg_cache.exit.i159.i ]
<   %411 = getelementptr inbounds %struct.CPUX86State* %410, i64 0, i32 10, i64 4, i32 0
<   %412 = load i32* %411, align 4
<   %413 = and i32 %412, 65532
<   %414 = icmp eq i32 %413, 0
<   br i1 %414, label %validate_seg.exit153.i, label %415
< 
< ; <label>:415                                     ; preds = %validate_seg.exit160.i
<   %416 = getelementptr inbounds %struct.CPUX86State* %410, i64 0, i32 10, i64 4, i32 3
<   %417 = load i32* %416, align 4
<   %418 = lshr i32 %417, 13
<   %419 = and i32 %418, 3
<   %420 = and i32 %417, 3072
<   %421 = icmp ne i32 %420, 3072
<   %422 = icmp ult i32 %419, %61
<   %or.cond10.i148.i = and i1 %421, %422
<   br i1 %or.cond10.i148.i, label %423, label %validate_seg.exit153.i
---
> ; <label>:88                                      ; preds = %83
>   %89 = load i32* %2, align 4
>   %90 = load i32* %3, align 4
>   %91 = load %struct.float_status** %5, align 4
>   %92 = call i32 @propagateFloat32NaN(i32 %89, i32 %90, %struct.float_status* %91)
>   store i32 %92, i32* %1
>   br label %151
10720,10722c6970,6973
< ; <label>:423                                     ; preds = %415
<   %424 = bitcast i32* %411 to i8*
<   br label %425
---
> ; <label>:93                                      ; preds = %83
>   %94 = load i32* %2, align 4
>   store i32 %94, i32* %1
>   br label %151
10724,10901c6975,7003
< ; <label>:425                                     ; preds = %428, %423
<   %426 = phi i64 [ 0, %423 ], [ %430, %428 ]
<   %427 = icmp ult i64 %426, 16
<   br i1 %427, label %428, label %431
< 
< ; <label>:428                                     ; preds = %425
<   %429 = getelementptr i8* %424, i64 %426
<   store i8 0, i8* %429, align 1
<   %430 = add i64 %426, 1
<   br label %425
< 
< ; <label>:431                                     ; preds = %425
<   %.phi.trans.insert.i.i149.i = getelementptr inbounds %struct.CPUX86State* %410, i64 0, i32 8
<   %.pre.i.i150.i = load i32* %.phi.trans.insert.i.i149.i, align 4
<   %432 = getelementptr inbounds %struct.CPUX86State* %410, i64 0, i32 10, i64 2, i32 3
<   %433 = load i32* %432, align 4
<   %434 = lshr i32 %433, 17
<   %435 = and i32 %434, 32
<   %436 = and i32 %.pre.i.i150.i, 32768
<   %437 = icmp eq i32 %436, 0
<   br i1 %437, label %438, label %cpu_x86_load_seg_cache.exit.i152.i
< 
< ; <label>:438                                     ; preds = %431
<   %439 = getelementptr inbounds %struct.CPUX86State* %410, i64 0, i32 15, i64 0
<   %440 = load i32* %439, align 4
<   %441 = and i32 %440, 1
<   %442 = icmp eq i32 %441, 0
<   br i1 %442, label %451, label %443
< 
< ; <label>:443                                     ; preds = %438
<   %444 = getelementptr inbounds %struct.CPUX86State* %410, i64 0, i32 7
<   %445 = load i32* %444, align 4
<   %446 = and i32 %445, 131072
<   %447 = icmp eq i32 %446, 0
<   br i1 %447, label %448, label %451
< 
< ; <label>:448                                     ; preds = %443
<   %449 = and i32 %.pre.i.i150.i, 16
<   %450 = icmp eq i32 %449, 0
<   br i1 %450, label %451, label %453
< 
< ; <label>:451                                     ; preds = %448, %443, %438
<   %452 = or i32 %435, 64
<   br label %cpu_x86_load_seg_cache.exit.i152.i
< 
< ; <label>:453                                     ; preds = %448
<   %454 = getelementptr inbounds %struct.CPUX86State* %410, i64 0, i32 10, i64 3, i32 1
<   %455 = load i32* %454, align 4
<   %456 = getelementptr inbounds %struct.CPUX86State* %410, i64 0, i32 10, i64 0, i32 1
<   %457 = load i32* %456, align 4
<   %458 = or i32 %457, %455
<   %459 = getelementptr inbounds %struct.CPUX86State* %410, i64 0, i32 10, i64 2, i32 1
<   %460 = load i32* %459, align 4
<   %461 = or i32 %458, %460
<   %462 = icmp ne i32 %461, 0
<   %463 = zext i1 %462 to i32
<   %464 = shl nuw nsw i32 %463, 6
<   %465 = or i32 %464, %435
<   br label %cpu_x86_load_seg_cache.exit.i152.i
< 
< cpu_x86_load_seg_cache.exit.i152.i:               ; preds = %453, %451, %431
<   %new_hflags.0.i.i151.i = phi i32 [ %435, %431 ], [ %452, %451 ], [ %465, %453 ]
<   %466 = and i32 %.pre.i.i150.i, -97
<   %467 = or i32 %new_hflags.0.i.i151.i, %466
<   store i32 %467, i32* %.phi.trans.insert.i.i149.i, align 4
<   %.pre195.i = load %struct.CPUX86State** @env, align 8
<   br label %validate_seg.exit153.i
< 
< validate_seg.exit153.i:                           ; preds = %cpu_x86_load_seg_cache.exit.i152.i, %415, %validate_seg.exit160.i
<   %468 = phi %struct.CPUX86State* [ %410, %validate_seg.exit160.i ], [ %410, %415 ], [ %.pre195.i, %cpu_x86_load_seg_cache.exit.i152.i ]
<   %469 = getelementptr inbounds %struct.CPUX86State* %468, i64 0, i32 10, i64 5, i32 0
<   %470 = load i32* %469, align 4
<   %471 = and i32 %470, 65532
<   %472 = icmp eq i32 %471, 0
<   br i1 %472, label %validate_seg.exit.i, label %473
< 
< ; <label>:473                                     ; preds = %validate_seg.exit153.i
<   %474 = getelementptr inbounds %struct.CPUX86State* %468, i64 0, i32 10, i64 5, i32 3
<   %475 = load i32* %474, align 4
<   %476 = lshr i32 %475, 13
<   %477 = and i32 %476, 3
<   %478 = and i32 %475, 3072
<   %479 = icmp ne i32 %478, 3072
<   %480 = icmp ult i32 %477, %61
<   %or.cond10.i.i = and i1 %479, %480
<   br i1 %or.cond10.i.i, label %481, label %validate_seg.exit.i
< 
< ; <label>:481                                     ; preds = %473
<   %482 = bitcast i32* %469 to i8*
<   br label %483
< 
< ; <label>:483                                     ; preds = %486, %481
<   %484 = phi i64 [ 0, %481 ], [ %488, %486 ]
<   %485 = icmp ult i64 %484, 16
<   br i1 %485, label %486, label %489
< 
< ; <label>:486                                     ; preds = %483
<   %487 = getelementptr i8* %482, i64 %484
<   store i8 0, i8* %487, align 1
<   %488 = add i64 %484, 1
<   br label %483
< 
< ; <label>:489                                     ; preds = %483
<   %.phi.trans.insert.i.i145.i = getelementptr inbounds %struct.CPUX86State* %468, i64 0, i32 8
<   %.pre.i.i146.i = load i32* %.phi.trans.insert.i.i145.i, align 4
<   %490 = getelementptr inbounds %struct.CPUX86State* %468, i64 0, i32 10, i64 2, i32 3
<   %491 = load i32* %490, align 4
<   %492 = lshr i32 %491, 17
<   %493 = and i32 %492, 32
<   %494 = and i32 %.pre.i.i146.i, 32768
<   %495 = icmp eq i32 %494, 0
<   br i1 %495, label %496, label %cpu_x86_load_seg_cache.exit.i.i
< 
< ; <label>:496                                     ; preds = %489
<   %497 = getelementptr inbounds %struct.CPUX86State* %468, i64 0, i32 15, i64 0
<   %498 = load i32* %497, align 4
<   %499 = and i32 %498, 1
<   %500 = icmp eq i32 %499, 0
<   br i1 %500, label %509, label %501
< 
< ; <label>:501                                     ; preds = %496
<   %502 = getelementptr inbounds %struct.CPUX86State* %468, i64 0, i32 7
<   %503 = load i32* %502, align 4
<   %504 = and i32 %503, 131072
<   %505 = icmp eq i32 %504, 0
<   br i1 %505, label %506, label %509
< 
< ; <label>:506                                     ; preds = %501
<   %507 = and i32 %.pre.i.i146.i, 16
<   %508 = icmp eq i32 %507, 0
<   br i1 %508, label %509, label %511
< 
< ; <label>:509                                     ; preds = %506, %501, %496
<   %510 = or i32 %493, 64
<   br label %cpu_x86_load_seg_cache.exit.i.i
< 
< ; <label>:511                                     ; preds = %506
<   %512 = getelementptr inbounds %struct.CPUX86State* %468, i64 0, i32 10, i64 3, i32 1
<   %513 = load i32* %512, align 4
<   %514 = getelementptr inbounds %struct.CPUX86State* %468, i64 0, i32 10, i64 0, i32 1
<   %515 = load i32* %514, align 4
<   %516 = or i32 %515, %513
<   %517 = getelementptr inbounds %struct.CPUX86State* %468, i64 0, i32 10, i64 2, i32 1
<   %518 = load i32* %517, align 4
<   %519 = or i32 %516, %518
<   %520 = icmp ne i32 %519, 0
<   %521 = zext i1 %520 to i32
<   %522 = shl nuw nsw i32 %521, 6
<   %523 = or i32 %522, %493
<   br label %cpu_x86_load_seg_cache.exit.i.i
< 
< cpu_x86_load_seg_cache.exit.i.i:                  ; preds = %511, %509, %489
<   %new_hflags.0.i.i147.i = phi i32 [ %493, %489 ], [ %510, %509 ], [ %523, %511 ]
<   %524 = and i32 %.pre.i.i146.i, -97
<   %525 = or i32 %new_hflags.0.i.i147.i, %524
<   store i32 %525, i32* %.phi.trans.insert.i.i145.i, align 4
<   br label %validate_seg.exit.i
< 
< validate_seg.exit.i:                              ; preds = %cpu_x86_load_seg_cache.exit.i.i, %473, %validate_seg.exit153.i
<   %526 = add i32 %new_esp.0.i, %addend
<   br label %helper_ret_protected.exit
< 
< helper_ret_protected.exit:                        ; preds = %validate_seg.exit.i, %cpu_x86_load_seg_cache.exit.i
<   %sp.1.i = phi i32 [ %526, %validate_seg.exit.i ], [ %80, %cpu_x86_load_seg_cache.exit.i ]
<   %sp_mask.0.i = phi i32 [ %309, %validate_seg.exit.i ], [ %7, %cpu_x86_load_seg_cache.exit.i ]
<   %527 = load %struct.CPUX86State** @env, align 8
<   %528 = getelementptr inbounds %struct.CPUX86State* %527, i64 0, i32 0, i64 4
<   %529 = load i32* %528, align 4
<   %530 = xor i32 %sp_mask.0.i, -1
<   %531 = and i32 %529, %530
<   %532 = and i32 %sp_mask.0.i, %sp.1.i
<   %533 = or i32 %531, %532
<   store i32 %533, i32* %528, align 4
<   %534 = load %struct.CPUX86State** @env, align 8
<   %535 = getelementptr inbounds %struct.CPUX86State* %534, i64 0, i32 5
<   store i32 %new_eip.0.i, i32* %535, align 4
<   ret void
< }
---
> ; <label>:95                                      ; preds = %80
>   %96 = load i32* %aExp, align 4
>   %97 = icmp eq i32 %96, 0
>   br i1 %97, label %98, label %120
> 
> ; <label>:98                                      ; preds = %95
>   %99 = load %struct.float_status** %5, align 4
>   %100 = getelementptr inbounds %struct.float_status* %99, i32 0, i32 4
>   %101 = load i8* %100, align 1
>   %102 = icmp ne i8 %101, 0
>   br i1 %102, label %103, label %113
> 
> ; <label>:103                                     ; preds = %98
>   %104 = load i32* %aSig, align 4
>   %105 = load i32* %bSig, align 4
>   %106 = or i32 %104, %105
>   %107 = icmp ne i32 %106, 0
>   br i1 %107, label %108, label %110
> 
> ; <label>:108                                     ; preds = %103
>   %109 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext -128, %struct.float_status* %109)
>   br label %110
> 
> ; <label>:110                                     ; preds = %108, %103
>   %111 = load i8* %4, align 1
>   %112 = call i32 @packFloat32(i8 zeroext %111, i32 0, i32 0)
>   store i32 %112, i32* %1
>   br label %151
10903,10908c7005,7013
< define void @helper_sysenter() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 33
<   %3 = load i32* %2, align 4
<   %4 = icmp eq i32 %3, 0
<   br i1 %4, label %5, label %6
---
> ; <label>:113                                     ; preds = %98
>   %114 = load i8* %4, align 1
>   %115 = load i32* %aSig, align 4
>   %116 = load i32* %bSig, align 4
>   %117 = add i32 %115, %116
>   %118 = lshr i32 %117, 6
>   %119 = call i32 @packFloat32(i8 zeroext %114, i32 0, i32 %118)
>   store i32 %119, i32* %1
>   br label %151
10910,10912c7015,7023
< ; <label>:5                                       ; preds = %0
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn
<   unreachable
---
> ; <label>:120                                     ; preds = %95
>   %121 = load i32* %aSig, align 4
>   %122 = add i32 1073741824, %121
>   %123 = load i32* %bSig, align 4
>   %124 = add i32 %122, %123
>   store i32 %124, i32* %zSig, align 4
>   %125 = load i32* %aExp, align 4
>   store i32 %125, i32* %zExp, align 4
>   br label %145
10914,10952c7025,7026
< ; <label>:6                                       ; preds = %0
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 7
<   %8 = load i32* %7, align 4
<   %9 = and i32 %8, -197121
<   store i32 %9, i32* %7, align 4
<   %10 = load %struct.CPUX86State** @env, align 8
<   %11 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 8
<   %12 = load i32* %11, align 4
<   %13 = and i32 %12, 3
<   tail call void @s2e_on_privilege_change(i32 %13, i32 0) nounwind
<   %14 = load i32* %11, align 4
<   %15 = and i32 %14, -4
<   store i32 %15, i32* %11, align 4
<   %16 = load %struct.CPUX86State** @env, align 8
<   %17 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 33
<   %18 = load i32* %17, align 4
<   %19 = and i32 %18, 65532
<   %20 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 10, i64 1, i32 0
<   store i32 %19, i32* %20, align 4
<   %21 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 10, i64 1, i32 1
<   store i32 0, i32* %21, align 4
<   %22 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 10, i64 1, i32 2
<   store i32 -1, i32* %22, align 4
<   %23 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 10, i64 1, i32 3
<   store i32 12622592, i32* %23, align 4
<   %24 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 8
<   %25 = load i32* %24, align 4
<   %26 = and i32 %25, -32785
<   %27 = or i32 %26, 16
<   store i32 %27, i32* %24, align 4
<   %28 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 10, i64 2, i32 3
<   %29 = load i32* %28, align 4
<   %30 = lshr i32 %29, 17
<   %31 = and i32 %30, 32
<   %32 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 15, i64 0
<   %33 = load i32* %32, align 4
<   %34 = and i32 %33, 1
<   %35 = icmp eq i32 %34, 0
<   br i1 %35, label %41, label %36
---
> ; <label>:126                                     ; preds = %75
>   br label %127
10954,10959c7028,7052
< ; <label>:36                                      ; preds = %6
<   %37 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 7
<   %38 = load i32* %37, align 4
<   %39 = and i32 %38, 131072
<   %40 = icmp eq i32 %39, 0
<   br i1 %40, label %43, label %41
---
> ; <label>:127                                     ; preds = %126, %45
>   %128 = load i32* %aSig, align 4
>   %129 = or i32 %128, 536870912
>   store i32 %129, i32* %aSig, align 4
>   %130 = load i32* %aSig, align 4
>   %131 = load i32* %bSig, align 4
>   %132 = add i32 %130, %131
>   %133 = shl i32 %132, 1
>   store i32 %133, i32* %zSig, align 4
>   %134 = load i32* %zExp, align 4
>   %135 = add nsw i32 %134, -1
>   store i32 %135, i32* %zExp, align 4
>   %136 = load i32* %zSig, align 4
>   %137 = icmp slt i32 %136, 0
>   br i1 %137, label %138, label %144
> 
> ; <label>:138                                     ; preds = %127
>   %139 = load i32* %aSig, align 4
>   %140 = load i32* %bSig, align 4
>   %141 = add i32 %139, %140
>   store i32 %141, i32* %zSig, align 4
>   %142 = load i32* %zExp, align 4
>   %143 = add nsw i32 %142, 1
>   store i32 %143, i32* %zExp, align 4
>   br label %144
10961,11002c7054,7055
< ; <label>:41                                      ; preds = %36, %6
<   %42 = or i32 %31, 64
<   br label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:43                                      ; preds = %36
<   %44 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 10, i64 3, i32 1
<   %45 = load i32* %44, align 4
<   %46 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 10, i64 0, i32 1
<   %47 = load i32* %46, align 4
<   %48 = or i32 %47, %45
<   %49 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 10, i64 2, i32 1
<   %50 = load i32* %49, align 4
<   %51 = or i32 %48, %50
<   %52 = icmp ne i32 %51, 0
<   %53 = zext i1 %52 to i32
<   %54 = shl nuw nsw i32 %53, 6
<   %55 = or i32 %54, %31
<   br label %cpu_x86_load_seg_cache.exit
< 
< cpu_x86_load_seg_cache.exit:                      ; preds = %43, %41
<   %new_hflags.0.i = phi i32 [ %42, %41 ], [ %55, %43 ]
<   %56 = and i32 %27, -32865
<   %57 = or i32 %new_hflags.0.i, %56
<   store i32 %57, i32* %24, align 4
<   %58 = load %struct.CPUX86State** @env, align 8
<   %59 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 33
<   %60 = load i32* %59, align 4
<   %61 = add i32 %60, 8
<   %62 = and i32 %61, 65532
<   %63 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 2, i32 0
<   store i32 %62, i32* %63, align 4
<   %64 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 2, i32 1
<   store i32 0, i32* %64, align 4
<   %65 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 2, i32 2
<   store i32 -1, i32* %65, align 4
<   %66 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 2, i32 3
<   store i32 12620544, i32* %66, align 4
<   %.phi.trans.insert.i = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 8
<   %.pre.i = load i32* %.phi.trans.insert.i, align 4
<   %67 = and i32 %.pre.i, 32768
<   %68 = icmp eq i32 %67, 0
<   br i1 %68, label %69, label %cpu_x86_load_seg_cache.exit2
---
> ; <label>:144                                     ; preds = %138, %127
>   br label %145
11004,11009c7057,7064
< ; <label>:69                                      ; preds = %cpu_x86_load_seg_cache.exit
<   %70 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 15, i64 0
<   %71 = load i32* %70, align 4
<   %72 = and i32 %71, 1
<   %73 = icmp eq i32 %72, 0
<   br i1 %73, label %cpu_x86_load_seg_cache.exit2, label %74
---
> ; <label>:145                                     ; preds = %144, %120
>   %146 = load i8* %4, align 1
>   %147 = load i32* %zExp, align 4
>   %148 = load i32* %zSig, align 4
>   %149 = load %struct.float_status** %5, align 4
>   %150 = call i32 @roundAndPackFloat32(i8 zeroext %146, i32 %147, i32 %148, %struct.float_status* %149)
>   store i32 %150, i32* %1
>   br label %151
11011,11016c7066,7069
< ; <label>:74                                      ; preds = %69
<   %75 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 7
<   %76 = load i32* %75, align 4
<   %77 = and i32 %76, 131072
<   %78 = icmp eq i32 %77, 0
<   br i1 %78, label %79, label %cpu_x86_load_seg_cache.exit2
---
> ; <label>:151                                     ; preds = %145, %113, %110, %93, %88, %63, %58, %34, %29
>   %152 = load i32* %1
>   ret i32 %152
> }
11018,11021c7071,7112
< ; <label>:79                                      ; preds = %74
<   %80 = and i32 %.pre.i, 16
<   %81 = icmp eq i32 %80, 0
<   br i1 %81, label %cpu_x86_load_seg_cache.exit2, label %82
---
> define internal i32 @subFloat32Sigs(i32 %a, i32 %b, i8 zeroext %zSign, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca i8, align 1
>   %5 = alloca %struct.float_status*, align 4
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %bSig = alloca i32, align 4
>   %zSig = alloca i32, align 4
>   %expDiff = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store i8 %zSign, i8* %4, align 1
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load i32* %2, align 4
>   %7 = call i32 @extractFloat32Frac(i32 %6)
>   store i32 %7, i32* %aSig, align 4
>   %8 = load i32* %2, align 4
>   %9 = call i32 @extractFloat32Exp(i32 %8)
>   store i32 %9, i32* %aExp, align 4
>   %10 = load i32* %3, align 4
>   %11 = call i32 @extractFloat32Frac(i32 %10)
>   store i32 %11, i32* %bSig, align 4
>   %12 = load i32* %3, align 4
>   %13 = call i32 @extractFloat32Exp(i32 %12)
>   store i32 %13, i32* %bExp, align 4
>   %14 = load i32* %aExp, align 4
>   %15 = load i32* %bExp, align 4
>   %16 = sub nsw i32 %14, %15
>   store i32 %16, i32* %expDiff, align 4
>   %17 = load i32* %aSig, align 4
>   %18 = shl i32 %17, 7
>   store i32 %18, i32* %aSig, align 4
>   %19 = load i32* %bSig, align 4
>   %20 = shl i32 %19, 7
>   store i32 %20, i32* %bSig, align 4
>   %21 = load i32* %expDiff, align 4
>   %22 = icmp slt i32 0, %21
>   br i1 %22, label %23, label %24
11023,11051c7114,7115
< ; <label>:82                                      ; preds = %79
<   %83 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 3, i32 1
<   %84 = load i32* %83, align 4
<   %85 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 0, i32 1
<   %86 = load i32* %85, align 4
<   %87 = or i32 %86, %84
<   %88 = icmp ne i32 %87, 0
<   %89 = zext i1 %88 to i32
<   %90 = shl nuw nsw i32 %89, 6
<   %91 = or i32 %90, 32
<   br label %cpu_x86_load_seg_cache.exit2
< 
< cpu_x86_load_seg_cache.exit2:                     ; preds = %82, %79, %74, %69, %cpu_x86_load_seg_cache.exit
<   %new_hflags.0.i1 = phi i32 [ 32, %cpu_x86_load_seg_cache.exit ], [ %91, %82 ], [ 96, %79 ], [ 96, %74 ], [ 96, %69 ]
<   %92 = and i32 %.pre.i, -97
<   %93 = or i32 %new_hflags.0.i1, %92
<   store i32 %93, i32* %.phi.trans.insert.i, align 4
<   %94 = load %struct.CPUX86State** @env, align 8
<   %95 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 34
<   %96 = load i32* %95, align 4
<   %97 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 0, i64 4
<   store i32 %96, i32* %97, align 4
<   %98 = load %struct.CPUX86State** @env, align 8
<   %99 = getelementptr inbounds %struct.CPUX86State* %98, i64 0, i32 35
<   %100 = load i32* %99, align 4
<   %101 = getelementptr inbounds %struct.CPUX86State* %98, i64 0, i32 5
<   store i32 %100, i32* %101, align 4
<   ret void
< }
---
> ; <label>:23                                      ; preds = %0
>   br label %107
11053,11058c7117,7120
< define void @helper_sysexit(i32 %dflag) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 33
<   %3 = load i32* %2, align 4
<   %4 = icmp eq i32 %3, 0
<   br i1 %4, label %10, label %5
---
> ; <label>:24                                      ; preds = %0
>   %25 = load i32* %expDiff, align 4
>   %26 = icmp slt i32 %25, 0
>   br i1 %26, label %27, label %28
11060,11065c7122,7123
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %7 = load i32* %6, align 4
<   %8 = and i32 %7, 3
<   %9 = icmp eq i32 %8, 0
<   br i1 %9, label %11, label %10
---
> ; <label>:27                                      ; preds = %24
>   br label %66
11067,11069c7125,7143
< ; <label>:10                                      ; preds = %5, %0
<   tail call fastcc void @raise_exception_err(i32 13, i32 0) noreturn
<   unreachable
---
> ; <label>:28                                      ; preds = %24
>   %29 = load i32* %aExp, align 4
>   %30 = icmp eq i32 %29, 255
>   br i1 %30, label %31, label %43
> 
> ; <label>:31                                      ; preds = %28
>   %32 = load i32* %aSig, align 4
>   %33 = load i32* %bSig, align 4
>   %34 = or i32 %32, %33
>   %35 = icmp ne i32 %34, 0
>   br i1 %35, label %36, label %41
> 
> ; <label>:36                                      ; preds = %31
>   %37 = load i32* %2, align 4
>   %38 = load i32* %3, align 4
>   %39 = load %struct.float_status** %5, align 4
>   %40 = call i32 @propagateFloat32NaN(i32 %37, i32 %38, %struct.float_status* %39)
>   store i32 %40, i32* %1
>   br label %147
11071,11103c7145,7149
< ; <label>:11                                      ; preds = %5
<   tail call void @s2e_on_privilege_change(i32 0, i32 3) nounwind
<   %12 = load i32* %6, align 4
<   %13 = or i32 %12, 3
<   store i32 %13, i32* %6, align 4
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 33
<   %16 = load i32* %15, align 4
<   %17 = add i32 %16, 16
<   %18 = and i32 %17, 65532
<   %19 = or i32 %18, 3
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 10, i64 1, i32 0
<   store i32 %19, i32* %20, align 4
<   %21 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 10, i64 1, i32 1
<   store i32 0, i32* %21, align 4
<   %22 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 10, i64 1, i32 2
<   store i32 -1, i32* %22, align 4
<   %23 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 10, i64 1, i32 3
<   store i32 12647168, i32* %23, align 4
<   %24 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %25 = load i32* %24, align 4
<   %26 = and i32 %25, -32785
<   %27 = or i32 %26, 16
<   store i32 %27, i32* %24, align 4
<   %28 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 10, i64 2, i32 3
<   %29 = load i32* %28, align 4
<   %30 = lshr i32 %29, 17
<   %31 = and i32 %30, 32
<   %32 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 15, i64 0
<   %33 = load i32* %32, align 4
<   %34 = and i32 %33, 1
<   %35 = icmp eq i32 %34, 0
<   br i1 %35, label %41, label %36
---
> ; <label>:41                                      ; preds = %31
>   %42 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %42)
>   store i32 -4194304, i32* %1
>   br label %147
11105,11110c7151,7154
< ; <label>:36                                      ; preds = %11
<   %37 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 7
<   %38 = load i32* %37, align 4
<   %39 = and i32 %38, 131072
<   %40 = icmp eq i32 %39, 0
<   br i1 %40, label %43, label %41
---
> ; <label>:43                                      ; preds = %28
>   %44 = load i32* %aExp, align 4
>   %45 = icmp eq i32 %44, 0
>   br i1 %45, label %46, label %47
11112,11154c7156,7159
< ; <label>:41                                      ; preds = %36, %11
<   %42 = or i32 %31, 64
<   br label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:43                                      ; preds = %36
<   %44 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 10, i64 3, i32 1
<   %45 = load i32* %44, align 4
<   %46 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 10, i64 0, i32 1
<   %47 = load i32* %46, align 4
<   %48 = or i32 %47, %45
<   %49 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 10, i64 2, i32 1
<   %50 = load i32* %49, align 4
<   %51 = or i32 %48, %50
<   %52 = icmp ne i32 %51, 0
<   %53 = zext i1 %52 to i32
<   %54 = shl nuw nsw i32 %53, 6
<   %55 = or i32 %54, %31
<   br label %cpu_x86_load_seg_cache.exit
< 
< cpu_x86_load_seg_cache.exit:                      ; preds = %43, %41
<   %new_hflags.0.i = phi i32 [ %42, %41 ], [ %55, %43 ]
<   %56 = and i32 %27, -32865
<   %57 = or i32 %new_hflags.0.i, %56
<   store i32 %57, i32* %24, align 4
<   %58 = load %struct.CPUX86State** @env, align 8
<   %59 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 33
<   %60 = load i32* %59, align 4
<   %61 = add i32 %60, 24
<   %62 = and i32 %61, 65532
<   %63 = or i32 %62, 3
<   %64 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 2, i32 0
<   store i32 %63, i32* %64, align 4
<   %65 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 2, i32 1
<   store i32 0, i32* %65, align 4
<   %66 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 2, i32 2
<   store i32 -1, i32* %66, align 4
<   %67 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 2, i32 3
<   store i32 12645120, i32* %67, align 4
<   %.phi.trans.insert.i = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 8
<   %.pre.i = load i32* %.phi.trans.insert.i, align 4
<   %68 = and i32 %.pre.i, 32768
<   %69 = icmp eq i32 %68, 0
<   br i1 %69, label %70, label %cpu_x86_load_seg_cache.exit2
---
> ; <label>:46                                      ; preds = %43
>   store i32 1, i32* %aExp, align 4
>   store i32 1, i32* %bExp, align 4
>   br label %47
11156,11161c7161,7165
< ; <label>:70                                      ; preds = %cpu_x86_load_seg_cache.exit
<   %71 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 15, i64 0
<   %72 = load i32* %71, align 4
<   %73 = and i32 %72, 1
<   %74 = icmp eq i32 %73, 0
<   br i1 %74, label %cpu_x86_load_seg_cache.exit2, label %75
---
> ; <label>:47                                      ; preds = %46, %43
>   %48 = load i32* %bSig, align 4
>   %49 = load i32* %aSig, align 4
>   %50 = icmp ult i32 %48, %49
>   br i1 %50, label %51, label %52
11163,11168c7167,7168
< ; <label>:75                                      ; preds = %70
<   %76 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 7
<   %77 = load i32* %76, align 4
<   %78 = and i32 %77, 131072
<   %79 = icmp eq i32 %78, 0
<   br i1 %79, label %80, label %cpu_x86_load_seg_cache.exit2
---
> ; <label>:51                                      ; preds = %47
>   br label %134
11170,11173c7170,7189
< ; <label>:80                                      ; preds = %75
<   %81 = and i32 %.pre.i, 16
<   %82 = icmp eq i32 %81, 0
<   br i1 %82, label %cpu_x86_load_seg_cache.exit2, label %83
---
> ; <label>:52                                      ; preds = %47
>   %53 = load i32* %aSig, align 4
>   %54 = load i32* %bSig, align 4
>   %55 = icmp ult i32 %53, %54
>   br i1 %55, label %56, label %57
> 
> ; <label>:56                                      ; preds = %52
>   br label %98
> 
> ; <label>:57                                      ; preds = %52
>   %58 = load %struct.float_status** %5, align 4
>   %59 = getelementptr inbounds %struct.float_status* %58, i32 0, i32 1
>   %60 = load i8* %59, align 1
>   %61 = sext i8 %60 to i32
>   %62 = icmp eq i32 %61, 1
>   %63 = zext i1 %62 to i32
>   %64 = trunc i32 %63 to i8
>   %65 = call i32 @packFloat32(i8 zeroext %64, i32 0, i32 0)
>   store i32 %65, i32* %1
>   br label %147
11175,11203c7191,7199
< ; <label>:83                                      ; preds = %80
<   %84 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 3, i32 1
<   %85 = load i32* %84, align 4
<   %86 = getelementptr inbounds %struct.CPUX86State* %58, i64 0, i32 10, i64 0, i32 1
<   %87 = load i32* %86, align 4
<   %88 = or i32 %87, %85
<   %89 = icmp ne i32 %88, 0
<   %90 = zext i1 %89 to i32
<   %91 = shl nuw nsw i32 %90, 6
<   %92 = or i32 %91, 32
<   br label %cpu_x86_load_seg_cache.exit2
< 
< cpu_x86_load_seg_cache.exit2:                     ; preds = %83, %80, %75, %70, %cpu_x86_load_seg_cache.exit
<   %new_hflags.0.i1 = phi i32 [ 32, %cpu_x86_load_seg_cache.exit ], [ %92, %83 ], [ 96, %80 ], [ 96, %75 ], [ 96, %70 ]
<   %93 = and i32 %.pre.i, -97
<   %94 = or i32 %new_hflags.0.i1, %93
<   store i32 %94, i32* %.phi.trans.insert.i, align 4
<   %95 = load %struct.CPUX86State** @env, align 8
<   %96 = getelementptr inbounds %struct.CPUX86State* %95, i64 0, i32 0, i64 1
<   %97 = load i32* %96, align 4
<   %98 = getelementptr inbounds %struct.CPUX86State* %95, i64 0, i32 0, i64 4
<   store i32 %97, i32* %98, align 4
<   %99 = load %struct.CPUX86State** @env, align 8
<   %100 = getelementptr inbounds %struct.CPUX86State* %99, i64 0, i32 0, i64 2
<   %101 = load i32* %100, align 4
<   %102 = getelementptr inbounds %struct.CPUX86State* %99, i64 0, i32 5
<   store i32 %101, i32* %102, align 4
<   ret void
< }
---
> ; <label>:66                                      ; preds = %27
>   %67 = load i32* %bExp, align 4
>   %68 = icmp eq i32 %67, 255
>   br i1 %68, label %69, label %83
> 
> ; <label>:69                                      ; preds = %66
>   %70 = load i32* %bSig, align 4
>   %71 = icmp ne i32 %70, 0
>   br i1 %71, label %72, label %77
11205,11208c7201,7207
< define i32 @helper_read_crN(i32 %reg) nounwind uwtable {
<   tail call void @helper_svm_check_intercept_param(i32 %reg, i64 0)
<   %cond = icmp eq i32 %reg, 8
<   br i1 %cond, label %6, label %1
---
> ; <label>:72                                      ; preds = %69
>   %73 = load i32* %2, align 4
>   %74 = load i32* %3, align 4
>   %75 = load %struct.float_status** %5, align 4
>   %76 = call i32 @propagateFloat32NaN(i32 %73, i32 %74, %struct.float_status* %75)
>   store i32 %76, i32* %1
>   br label %147
11210,11215c7209,7216
< ; <label>:1                                       ; preds = %0
<   %2 = sext i32 %reg to i64
<   %3 = load %struct.CPUX86State** @env, align 8
<   %4 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 15, i64 %2
<   %5 = load i32* %4, align 4
<   br label %21
---
> ; <label>:77                                      ; preds = %69
>   %78 = load i8* %4, align 1
>   %79 = zext i8 %78 to i32
>   %80 = xor i32 %79, 1
>   %81 = trunc i32 %80 to i8
>   %82 = call i32 @packFloat32(i8 zeroext %81, i32 255, i32 0)
>   store i32 %82, i32* %1
>   br label %147
11217,11223c7218,7275
< ; <label>:6                                       ; preds = %0
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 9
<   %9 = load i32* %8, align 4
<   %10 = and i32 %9, 8
<   %11 = icmp eq i32 %10, 0
<   br i1 %11, label %12, label %17
---
> ; <label>:83                                      ; preds = %66
>   %84 = load i32* %aExp, align 4
>   %85 = icmp eq i32 %84, 0
>   br i1 %85, label %86, label %89
> 
> ; <label>:86                                      ; preds = %83
>   %87 = load i32* %expDiff, align 4
>   %88 = add nsw i32 %87, 1
>   store i32 %88, i32* %expDiff, align 4
>   br label %92
> 
> ; <label>:89                                      ; preds = %83
>   %90 = load i32* %aSig, align 4
>   %91 = or i32 %90, 1073741824
>   store i32 %91, i32* %aSig, align 4
>   br label %92
> 
> ; <label>:92                                      ; preds = %89, %86
>   %93 = load i32* %aSig, align 4
>   %94 = load i32* %expDiff, align 4
>   %95 = sub nsw i32 0, %94
>   call void @shift32RightJamming(i32 %93, i32 %95, i32* %aSig)
>   %96 = load i32* %bSig, align 4
>   %97 = or i32 %96, 1073741824
>   store i32 %97, i32* %bSig, align 4
>   br label %98
> 
> ; <label>:98                                      ; preds = %92, %56
>   %99 = load i32* %bSig, align 4
>   %100 = load i32* %aSig, align 4
>   %101 = sub i32 %99, %100
>   store i32 %101, i32* %zSig, align 4
>   %102 = load i32* %bExp, align 4
>   store i32 %102, i32* %zExp, align 4
>   %103 = load i8* %4, align 1
>   %104 = zext i8 %103 to i32
>   %105 = xor i32 %104, 1
>   %106 = trunc i32 %105 to i8
>   store i8 %106, i8* %4, align 1
>   br label %139
> 
> ; <label>:107                                     ; preds = %23
>   %108 = load i32* %aExp, align 4
>   %109 = icmp eq i32 %108, 255
>   br i1 %109, label %110, label %120
> 
> ; <label>:110                                     ; preds = %107
>   %111 = load i32* %aSig, align 4
>   %112 = icmp ne i32 %111, 0
>   br i1 %112, label %113, label %118
> 
> ; <label>:113                                     ; preds = %110
>   %114 = load i32* %2, align 4
>   %115 = load i32* %3, align 4
>   %116 = load %struct.float_status** %5, align 4
>   %117 = call i32 @propagateFloat32NaN(i32 %114, i32 %115, %struct.float_status* %116)
>   store i32 %117, i32* %1
>   br label %147
11225,11230c7277,7280
< ; <label>:12                                      ; preds = %6
<   %13 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 145
<   %14 = load %struct.DeviceState** %13, align 8
<   %15 = tail call zeroext i8 @cpu_get_apic_tpr(%struct.DeviceState* %14) nounwind
<   %16 = zext i8 %15 to i32
<   br label %21
---
> ; <label>:118                                     ; preds = %110
>   %119 = load i32* %2, align 4
>   store i32 %119, i32* %1
>   br label %147
11232,11236c7282,7291
< ; <label>:17                                      ; preds = %6
<   %18 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 47
<   %19 = load i8* %18, align 1
<   %20 = zext i8 %19 to i32
<   br label %21
---
> ; <label>:120                                     ; preds = %107
>   %121 = load i32* %bExp, align 4
>   %122 = icmp eq i32 %121, 0
>   br i1 %122, label %123, label %126
> 
> ; <label>:123                                     ; preds = %120
>   %124 = load i32* %expDiff, align 4
>   %125 = add nsw i32 %124, -1
>   store i32 %125, i32* %expDiff, align 4
>   br label %129
11238,11241c7293,7297
< ; <label>:21                                      ; preds = %17, %12, %1
<   %val.0 = phi i32 [ %20, %17 ], [ %16, %12 ], [ %5, %1 ]
<   ret i32 %val.0
< }
---
> ; <label>:126                                     ; preds = %120
>   %127 = load i32* %bSig, align 4
>   %128 = or i32 %127, 1073741824
>   store i32 %128, i32* %bSig, align 4
>   br label %129
11243,11253c7299,7306
< declare zeroext i8 @cpu_get_apic_tpr(%struct.DeviceState*)
< 
< define void @helper_write_crN(i32 %reg, i32 %t0) nounwind uwtable {
<   %1 = add nsw i32 %reg, 16
<   tail call void @helper_svm_check_intercept_param(i32 %1, i64 0)
<   switch i32 %reg, label %22 [
<     i32 0, label %2
<     i32 3, label %4
<     i32 4, label %6
<     i32 8, label %8
<   ]
---
> ; <label>:129                                     ; preds = %126, %123
>   %130 = load i32* %bSig, align 4
>   %131 = load i32* %expDiff, align 4
>   call void @shift32RightJamming(i32 %130, i32 %131, i32* %bSig)
>   %132 = load i32* %aSig, align 4
>   %133 = or i32 %132, 1073741824
>   store i32 %133, i32* %aSig, align 4
>   br label %134
11255,11258c7308,7327
< ; <label>:2                                       ; preds = %0
<   %3 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_x86_update_cr0(%struct.CPUX86State* %3, i32 %t0) nounwind
<   br label %26
---
> ; <label>:134                                     ; preds = %129, %51
>   %135 = load i32* %aSig, align 4
>   %136 = load i32* %bSig, align 4
>   %137 = sub i32 %135, %136
>   store i32 %137, i32* %zSig, align 4
>   %138 = load i32* %aExp, align 4
>   store i32 %138, i32* %zExp, align 4
>   br label %139
> 
> ; <label>:139                                     ; preds = %134, %98
>   %140 = load i32* %zExp, align 4
>   %141 = add nsw i32 %140, -1
>   store i32 %141, i32* %zExp, align 4
>   %142 = load i8* %4, align 1
>   %143 = load i32* %zExp, align 4
>   %144 = load i32* %zSig, align 4
>   %145 = load %struct.float_status** %5, align 4
>   %146 = call i32 @normalizeRoundAndPackFloat32(i8 zeroext %142, i32 %143, i32 %144, %struct.float_status* %145)
>   store i32 %146, i32* %1
>   br label %147
11260,11263c7329,7332
< ; <label>:4                                       ; preds = %0
<   %5 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_x86_update_cr3(%struct.CPUX86State* %5, i32 %t0) nounwind
<   br label %26
---
> ; <label>:147                                     ; preds = %139, %118, %113, %77, %72, %57, %41, %36
>   %148 = load i32* %1
>   ret i32 %148
> }
11265,11268c7334,7363
< ; <label>:6                                       ; preds = %0
<   %7 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_x86_update_cr4(%struct.CPUX86State* %7, i32 %t0) nounwind
<   br label %26
---
> define internal i32 @float32_sub(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %3, align 4
>   %14 = call zeroext i8 @extractFloat32Sign(i32 %13)
>   store i8 %14, i8* %bSign, align 1
>   %15 = load i8* %aSign, align 1
>   %16 = zext i8 %15 to i32
>   %17 = load i8* %bSign, align 1
>   %18 = zext i8 %17 to i32
>   %19 = icmp eq i32 %16, %18
>   br i1 %19, label %20, label %26
11270,11276c7365,7372
< ; <label>:8                                       ; preds = %0
<   %9 = load %struct.CPUX86State** @env, align 8
<   %10 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 9
<   %11 = load i32* %10, align 4
<   %12 = and i32 %11, 8
<   %13 = icmp eq i32 %12, 0
<   br i1 %13, label %14, label %._crit_edge
---
> ; <label>:20                                      ; preds = %0
>   %21 = load i32* %2, align 4
>   %22 = load i32* %3, align 4
>   %23 = load i8* %aSign, align 1
>   %24 = load %struct.float_status** %4, align 4
>   %25 = call i32 @subFloat32Sigs(i32 %21, i32 %22, i8 zeroext %23, %struct.float_status* %24)
>   store i32 %25, i32* %1
>   br label %32
11278,11280c7374,7381
< ._crit_edge:                                      ; preds = %8
<   %t0.tr.pre = trunc i32 %t0 to i8
<   br label %18
---
> ; <label>:26                                      ; preds = %0
>   %27 = load i32* %2, align 4
>   %28 = load i32* %3, align 4
>   %29 = load i8* %aSign, align 1
>   %30 = load %struct.float_status** %4, align 4
>   %31 = call i32 @addFloat32Sigs(i32 %27, i32 %28, i8 zeroext %29, %struct.float_status* %30)
>   store i32 %31, i32* %1
>   br label %32
11282,11288c7383,7386
< ; <label>:14                                      ; preds = %8
<   %15 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 145
<   %16 = load %struct.DeviceState** %15, align 8
<   %17 = trunc i32 %t0 to i8
<   tail call void @cpu_set_apic_tpr(%struct.DeviceState* %16, i8 zeroext %17) nounwind
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %18
---
> ; <label>:32                                      ; preds = %26, %20
>   %33 = load i32* %1
>   ret i32 %33
> }
11290,11296c7388,7446
< ; <label>:18                                      ; preds = %14, %._crit_edge
<   %t0.tr.pre-phi = phi i8 [ %t0.tr.pre, %._crit_edge ], [ %17, %14 ]
<   %19 = phi %struct.CPUX86State* [ %9, %._crit_edge ], [ %.pre, %14 ]
<   %20 = and i8 %t0.tr.pre-phi, 15
<   %21 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 47
<   store i8 %20, i8* %21, align 1
<   br label %26
---
> define internal i32 @float32_mul(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %bSig = alloca i32, align 4
>   %zSig64 = alloca i64, align 8
>   %zSig = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Frac(i32 %11)
>   store i32 %12, i32* %aSig, align 4
>   %13 = load i32* %2, align 4
>   %14 = call i32 @extractFloat32Exp(i32 %13)
>   store i32 %14, i32* %aExp, align 4
>   %15 = load i32* %2, align 4
>   %16 = call zeroext i8 @extractFloat32Sign(i32 %15)
>   store i8 %16, i8* %aSign, align 1
>   %17 = load i32* %3, align 4
>   %18 = call i32 @extractFloat32Frac(i32 %17)
>   store i32 %18, i32* %bSig, align 4
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   store i32 %20, i32* %bExp, align 4
>   %21 = load i32* %3, align 4
>   %22 = call zeroext i8 @extractFloat32Sign(i32 %21)
>   store i8 %22, i8* %bSign, align 1
>   %23 = load i8* %aSign, align 1
>   %24 = zext i8 %23 to i32
>   %25 = load i8* %bSign, align 1
>   %26 = zext i8 %25 to i32
>   %27 = xor i32 %24, %26
>   %28 = trunc i32 %27 to i8
>   store i8 %28, i8* %zSign, align 1
>   %29 = load i32* %aExp, align 4
>   %30 = icmp eq i32 %29, 255
>   br i1 %30, label %31, label %55
> 
> ; <label>:31                                      ; preds = %0
>   %32 = load i32* %aSig, align 4
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %40, label %34
11298,11303c7448,7451
< ; <label>:22                                      ; preds = %0
<   %23 = sext i32 %reg to i64
<   %24 = load %struct.CPUX86State** @env, align 8
<   %25 = getelementptr inbounds %struct.CPUX86State* %24, i64 0, i32 15, i64 %23
<   store i32 %t0, i32* %25, align 4
<   br label %26
---
> ; <label>:34                                      ; preds = %31
>   %35 = load i32* %bExp, align 4
>   %36 = icmp eq i32 %35, 255
>   br i1 %36, label %37, label %45
11305,11307c7453,7471
< ; <label>:26                                      ; preds = %22, %18, %6, %4, %2
<   ret void
< }
---
> ; <label>:37                                      ; preds = %34
>   %38 = load i32* %bSig, align 4
>   %39 = icmp ne i32 %38, 0
>   br i1 %39, label %40, label %45
> 
> ; <label>:40                                      ; preds = %37, %31
>   %41 = load i32* %2, align 4
>   %42 = load i32* %3, align 4
>   %43 = load %struct.float_status** %4, align 4
>   %44 = call i32 @propagateFloat32NaN(i32 %41, i32 %42, %struct.float_status* %43)
>   store i32 %44, i32* %1
>   br label %130
> 
> ; <label>:45                                      ; preds = %37, %34
>   %46 = load i32* %bExp, align 4
>   %47 = load i32* %bSig, align 4
>   %48 = or i32 %46, %47
>   %49 = icmp eq i32 %48, 0
>   br i1 %49, label %50, label %52
11309c7473,7493
< declare void @cpu_set_apic_tpr(%struct.DeviceState*, i8 zeroext)
---
> ; <label>:50                                      ; preds = %45
>   %51 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %51)
>   store i32 -4194304, i32* %1
>   br label %130
> 
> ; <label>:52                                      ; preds = %45
>   %53 = load i8* %zSign, align 1
>   %54 = call i32 @packFloat32(i8 zeroext %53, i32 255, i32 0)
>   store i32 %54, i32* %1
>   br label %130
> 
> ; <label>:55                                      ; preds = %0
>   %56 = load i32* %bExp, align 4
>   %57 = icmp eq i32 %56, 255
>   br i1 %57, label %58, label %76
> 
> ; <label>:58                                      ; preds = %55
>   %59 = load i32* %bSig, align 4
>   %60 = icmp ne i32 %59, 0
>   br i1 %60, label %61, label %66
11311,11324c7495,7508
< define void @helper_movl_drN_T0(i32 %reg, i32 %t0) nounwind uwtable {
<   %1 = icmp slt i32 %reg, 4
<   br i1 %1, label %2, label %8
< 
< ; <label>:2                                       ; preds = %0
<   %3 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_remove(%struct.CPUX86State* %3, i32 %reg) nounwind
<   %4 = sext i32 %reg to i64
<   %5 = load %struct.CPUX86State** @env, align 8
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 58, i64 %4
<   store i32 %t0, i32* %6, align 4
<   %7 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_insert(%struct.CPUX86State* %7, i32 %reg) nounwind
<   br label %24
---
> ; <label>:61                                      ; preds = %58
>   %62 = load i32* %2, align 4
>   %63 = load i32* %3, align 4
>   %64 = load %struct.float_status** %4, align 4
>   %65 = call i32 @propagateFloat32NaN(i32 %62, i32 %63, %struct.float_status* %64)
>   store i32 %65, i32* %1
>   br label %130
> 
> ; <label>:66                                      ; preds = %58
>   %67 = load i32* %aExp, align 4
>   %68 = load i32* %aSig, align 4
>   %69 = or i32 %67, %68
>   %70 = icmp eq i32 %69, 0
>   br i1 %70, label %71, label %73
11326,11328c7510,7520
< ; <label>:8                                       ; preds = %0
<   %9 = icmp eq i32 %reg, 7
<   br i1 %9, label %.preheader, label %20
---
> ; <label>:71                                      ; preds = %66
>   %72 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %72)
>   store i32 -4194304, i32* %1
>   br label %130
> 
> ; <label>:73                                      ; preds = %66
>   %74 = load i8* %zSign, align 1
>   %75 = call i32 @packFloat32(i8 zeroext %74, i32 255, i32 0)
>   store i32 %75, i32* %1
>   br label %130
11330,11350c7522,7525
< .preheader:                                       ; preds = %8
<   %10 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_remove(%struct.CPUX86State* %10, i32 0) nounwind
<   %11 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_remove(%struct.CPUX86State* %11, i32 1) nounwind
<   %12 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_remove(%struct.CPUX86State* %12, i32 2) nounwind
<   %13 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_remove(%struct.CPUX86State* %13, i32 3) nounwind
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 58, i64 7
<   store i32 %t0, i32* %15, align 4
<   %16 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_insert(%struct.CPUX86State* %16, i32 0) nounwind
<   %17 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_insert(%struct.CPUX86State* %17, i32 1) nounwind
<   %18 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_insert(%struct.CPUX86State* %18, i32 2) nounwind
<   %19 = load %struct.CPUX86State** @env, align 8
<   tail call void @hw_breakpoint_insert(%struct.CPUX86State* %19, i32 3) nounwind
<   br label %24
---
> ; <label>:76                                      ; preds = %55
>   %77 = load i32* %aExp, align 4
>   %78 = icmp eq i32 %77, 0
>   br i1 %78, label %79, label %87
11352,11357c7527,7530
< ; <label>:20                                      ; preds = %8
<   %21 = sext i32 %reg to i64
<   %22 = load %struct.CPUX86State** @env, align 8
<   %23 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 58, i64 %21
<   store i32 %t0, i32* %23, align 4
<   br label %24
---
> ; <label>:79                                      ; preds = %76
>   %80 = load i32* %aSig, align 4
>   %81 = icmp eq i32 %80, 0
>   br i1 %81, label %82, label %85
11359,11361c7532,7541
< ; <label>:24                                      ; preds = %20, %.preheader, %2
<   ret void
< }
---
> ; <label>:82                                      ; preds = %79
>   %83 = load i8* %zSign, align 1
>   %84 = call i32 @packFloat32(i8 zeroext %83, i32 0, i32 0)
>   store i32 %84, i32* %1
>   br label %130
> 
> ; <label>:85                                      ; preds = %79
>   %86 = load i32* %aSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %86, i32* %aExp, i32* %aSig)
>   br label %87
11363c7543,7546
< declare void @hw_breakpoint_remove(%struct.CPUX86State*, i32)
---
> ; <label>:87                                      ; preds = %85, %76
>   %88 = load i32* %bExp, align 4
>   %89 = icmp eq i32 %88, 0
>   br i1 %89, label %90, label %98
11365c7548,7551
< declare void @hw_breakpoint_insert(%struct.CPUX86State*, i32)
---
> ; <label>:90                                      ; preds = %87
>   %91 = load i32* %bSig, align 4
>   %92 = icmp eq i32 %91, 0
>   br i1 %92, label %93, label %96
11367,11378c7553,7599
< define void @helper_lmsw(i32 %t0) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 15, i64 0
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, -15
<   %5 = and i32 %t0, 15
<   %6 = or i32 %4, %5
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %8 = load i32* %7, align 4
<   %.lobit.i = and i32 %8, 2097152
<   %9 = icmp eq i32 %.lobit.i, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10, !prof !0
---
> ; <label>:93                                      ; preds = %90
>   %94 = load i8* %zSign, align 1
>   %95 = call i32 @packFloat32(i8 zeroext %94, i32 0, i32 0)
>   store i32 %95, i32* %1
>   br label %130
> 
> ; <label>:96                                      ; preds = %90
>   %97 = load i32* %bSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %97, i32* %bExp, i32* %bSig)
>   br label %98
> 
> ; <label>:98                                      ; preds = %96, %87
>   %99 = load i32* %aExp, align 4
>   %100 = load i32* %bExp, align 4
>   %101 = add nsw i32 %99, %100
>   %102 = sub nsw i32 %101, 127
>   store i32 %102, i32* %zExp, align 4
>   %103 = load i32* %aSig, align 4
>   %104 = or i32 %103, 8388608
>   %105 = shl i32 %104, 7
>   store i32 %105, i32* %aSig, align 4
>   %106 = load i32* %bSig, align 4
>   %107 = or i32 %106, 8388608
>   %108 = shl i32 %107, 8
>   store i32 %108, i32* %bSig, align 4
>   %109 = load i32* %aSig, align 4
>   %110 = zext i32 %109 to i64
>   %111 = load i32* %bSig, align 4
>   %112 = zext i32 %111 to i64
>   %113 = mul i64 %110, %112
>   call void @shift64RightJamming(i64 %113, i32 32, i64* %zSig64)
>   %114 = load i64* %zSig64, align 8
>   %115 = trunc i64 %114 to i32
>   store i32 %115, i32* %zSig, align 4
>   %116 = load i32* %zSig, align 4
>   %117 = shl i32 %116, 1
>   %118 = icmp sle i32 0, %117
>   br i1 %118, label %119, label %124
> 
> ; <label>:119                                     ; preds = %98
>   %120 = load i32* %zSig, align 4
>   %121 = shl i32 %120, 1
>   store i32 %121, i32* %zSig, align 4
>   %122 = load i32* %zExp, align 4
>   %123 = add nsw i32 %122, -1
>   store i32 %123, i32* %zExp, align 4
>   br label %124
11380,11385c7601,7613
< ; <label>:10                                      ; preds = %0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 43
<   %12 = load i16* %11, align 2
<   %13 = and i16 %12, 1
<   %14 = icmp eq i16 %13, 0
<   br i1 %14, label %helper_svm_check_intercept_param.exit, label %15
---
> ; <label>:124                                     ; preds = %119, %98
>   %125 = load i8* %zSign, align 1
>   %126 = load i32* %zExp, align 4
>   %127 = load i32* %zSig, align 4
>   %128 = load %struct.float_status** %4, align 4
>   %129 = call i32 @roundAndPackFloat32(i8 zeroext %125, i32 %126, i32 %127, %struct.float_status* %128)
>   store i32 %129, i32* %1
>   br label %130
> 
> ; <label>:130                                     ; preds = %124, %93, %82, %73, %71, %61, %52, %50, %40
>   %131 = load i32* %1
>   ret i32 %131
> }
11387,11389c7615,7672
< ; <label>:15                                      ; preds = %10
<   tail call void @helper_vmexit(i32 16, i64 0) nounwind
<   unreachable
---
> define internal i32 @float32_div(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %bSig = alloca i32, align 4
>   %zSig = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Frac(i32 %11)
>   store i32 %12, i32* %aSig, align 4
>   %13 = load i32* %2, align 4
>   %14 = call i32 @extractFloat32Exp(i32 %13)
>   store i32 %14, i32* %aExp, align 4
>   %15 = load i32* %2, align 4
>   %16 = call zeroext i8 @extractFloat32Sign(i32 %15)
>   store i8 %16, i8* %aSign, align 1
>   %17 = load i32* %3, align 4
>   %18 = call i32 @extractFloat32Frac(i32 %17)
>   store i32 %18, i32* %bSig, align 4
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   store i32 %20, i32* %bExp, align 4
>   %21 = load i32* %3, align 4
>   %22 = call zeroext i8 @extractFloat32Sign(i32 %21)
>   store i8 %22, i8* %bSign, align 1
>   %23 = load i8* %aSign, align 1
>   %24 = zext i8 %23 to i32
>   %25 = load i8* %bSign, align 1
>   %26 = zext i8 %25 to i32
>   %27 = xor i32 %24, %26
>   %28 = trunc i32 %27 to i8
>   store i8 %28, i8* %zSign, align 1
>   %29 = load i32* %aExp, align 4
>   %30 = icmp eq i32 %29, 255
>   br i1 %30, label %31, label %55
> 
> ; <label>:31                                      ; preds = %0
>   %32 = load i32* %aSig, align 4
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %39
11391,11394c7674,7680
< helper_svm_check_intercept_param.exit:            ; preds = %10, %0
<   tail call void @cpu_x86_update_cr0(%struct.CPUX86State* %1, i32 %6) nounwind
<   ret void
< }
---
> ; <label>:34                                      ; preds = %31
>   %35 = load i32* %2, align 4
>   %36 = load i32* %3, align 4
>   %37 = load %struct.float_status** %4, align 4
>   %38 = call i32 @propagateFloat32NaN(i32 %35, i32 %36, %struct.float_status* %37)
>   store i32 %38, i32* %1
>   br label %150
11396,11408c7682,7685
< define void @helper_clts() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 15, i64 0
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, -9
<   store i32 %4, i32* %2, align 4
<   %5 = load %struct.CPUX86State** @env, align 8
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 8
<   %7 = load i32* %6, align 4
<   %8 = and i32 %7, -2049
<   store i32 %8, i32* %6, align 4
<   ret void
< }
---
> ; <label>:39                                      ; preds = %31
>   %40 = load i32* %bExp, align 4
>   %41 = icmp eq i32 %40, 255
>   br i1 %41, label %42, label %52
11410,11416c7687,7690
< define void @helper_invlpg(i32 %addr) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
---
> ; <label>:42                                      ; preds = %39
>   %43 = load i32* %bSig, align 4
>   %44 = icmp ne i32 %43, 0
>   br i1 %44, label %45, label %50
11418,11423c7692,7698
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 33554432
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
---
> ; <label>:45                                      ; preds = %42
>   %46 = load i32* %2, align 4
>   %47 = load i32* %3, align 4
>   %48 = load %struct.float_status** %4, align 4
>   %49 = call i32 @propagateFloat32NaN(i32 %46, i32 %47, %struct.float_status* %48)
>   store i32 %49, i32* %1
>   br label %150
11425,11427c7700,7704
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 121, i64 0) nounwind
<   unreachable
---
> ; <label>:50                                      ; preds = %42
>   %51 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %51)
>   store i32 -4194304, i32* %1
>   br label %150
11429,11432c7706,7710
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   tail call void @tlb_flush_page(%struct.CPUX86State* %1, i32 %addr) nounwind
<   ret void
< }
---
> ; <label>:52                                      ; preds = %39
>   %53 = load i8* %zSign, align 1
>   %54 = call i32 @packFloat32(i8 zeroext %53, i32 255, i32 0)
>   store i32 %54, i32* %1
>   br label %150
11434c7712,7720
< declare void @tlb_flush_page(%struct.CPUX86State*, i32)
---
> ; <label>:55                                      ; preds = %0
>   %56 = load i32* %bExp, align 4
>   %57 = icmp eq i32 %56, 255
>   br i1 %57, label %58, label %69
> 
> ; <label>:58                                      ; preds = %55
>   %59 = load i32* %bSig, align 4
>   %60 = icmp ne i32 %59, 0
>   br i1 %60, label %61, label %66
11436,11444c7722,7728
< define void @helper_rdtsc() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 15, i64 4
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, 4
<   %5 = icmp eq i32 %4, 0
<   %.phi.trans.insert = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %.pre = load i32* %.phi.trans.insert, align 4
<   br i1 %5, label %._crit_edge, label %6
---
> ; <label>:61                                      ; preds = %58
>   %62 = load i32* %2, align 4
>   %63 = load i32* %3, align 4
>   %64 = load %struct.float_status** %4, align 4
>   %65 = call i32 @propagateFloat32NaN(i32 %62, i32 %63, %struct.float_status* %64)
>   store i32 %65, i32* %1
>   br label %150
11446,11449c7730,7734
< ; <label>:6                                       ; preds = %0
<   %7 = and i32 %.pre, 3
<   %8 = icmp eq i32 %7, 0
<   br i1 %8, label %._crit_edge, label %9
---
> ; <label>:66                                      ; preds = %58
>   %67 = load i8* %zSign, align 1
>   %68 = call i32 @packFloat32(i8 zeroext %67, i32 0, i32 0)
>   store i32 %68, i32* %1
>   br label %150
11451,11453c7736,7739
< ; <label>:9                                       ; preds = %6
<   tail call fastcc void @raise_exception(i32 13) noreturn
<   unreachable
---
> ; <label>:69                                      ; preds = %55
>   %70 = load i32* %bExp, align 4
>   %71 = icmp eq i32 %70, 0
>   br i1 %71, label %72, label %88
11455,11465c7741,7744
< ._crit_edge:                                      ; preds = %6, %0
<   %.lobit.i = and i32 %.pre, 2097152
<   %10 = icmp eq i32 %.lobit.i, 0
<   br i1 %10, label %helper_svm_check_intercept_param.exit, label %11, !prof !0
< 
< ; <label>:11                                      ; preds = %._crit_edge
<   %12 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %13 = load i64* %12, align 8
<   %14 = and i64 %13, 16384
<   %15 = icmp eq i64 %14, 0
<   br i1 %15, label %helper_svm_check_intercept_param.exit, label %16
---
> ; <label>:72                                      ; preds = %69
>   %73 = load i32* %bSig, align 4
>   %74 = icmp eq i32 %73, 0
>   br i1 %74, label %75, label %86
11467,11469c7746,7751
< ; <label>:16                                      ; preds = %11
<   tail call void @helper_vmexit(i32 110, i64 0) nounwind
<   unreachable
---
> ; <label>:75                                      ; preds = %72
>   %76 = load i32* %aExp, align 4
>   %77 = load i32* %aSig, align 4
>   %78 = or i32 %76, %77
>   %79 = icmp eq i32 %78, 0
>   br i1 %79, label %80, label %82
11471,11486c7753,7757
< helper_svm_check_intercept_param.exit:            ; preds = %11, %._crit_edge
<   %17 = tail call i64 @cpu_get_tsc(%struct.CPUX86State* %1) nounwind
<   %18 = load %struct.CPUX86State** @env, align 8
<   %19 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 40
<   %20 = load i64* %19, align 8
<   %21 = add i64 %20, %17
<   %22 = trunc i64 %21 to i32
<   %23 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 0, i64 0
<   store i32 %22, i32* %23, align 4
<   %24 = lshr i64 %21, 32
<   %25 = trunc i64 %24 to i32
<   %26 = load %struct.CPUX86State** @env, align 8
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 0, i64 2
<   store i32 %25, i32* %27, align 4
<   ret void
< }
---
> ; <label>:80                                      ; preds = %75
>   %81 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %81)
>   store i32 -4194304, i32* %1
>   br label %150
11488c7759,7765
< declare i64 @cpu_get_tsc(%struct.CPUX86State*)
---
> ; <label>:82                                      ; preds = %75
>   %83 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 4, %struct.float_status* %83)
>   %84 = load i8* %zSign, align 1
>   %85 = call i32 @packFloat32(i8 zeroext %84, i32 255, i32 0)
>   store i32 %85, i32* %1
>   br label %150
11490,11499c7767,7770
< define void @helper_rdtscp() nounwind uwtable {
<   tail call void @helper_rdtsc()
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 149
<   %3 = load i64* %2, align 8
<   %4 = trunc i64 %3 to i32
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 1
<   store i32 %4, i32* %5, align 4
<   ret void
< }
---
> ; <label>:86                                      ; preds = %72
>   %87 = load i32* %bSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %87, i32* %bExp, i32* %bSig)
>   br label %88
11501,11509c7772,7775
< define void @helper_rdpmc() noreturn nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 15, i64 4
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, 256
<   %5 = icmp eq i32 %4, 0
<   %.phi.trans.insert = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %.pre = load i32* %.phi.trans.insert, align 4
<   br i1 %5, label %._crit_edge, label %6
---
> ; <label>:88                                      ; preds = %86, %69
>   %89 = load i32* %aExp, align 4
>   %90 = icmp eq i32 %89, 0
>   br i1 %90, label %91, label %99
11511,11514c7777,7780
< ; <label>:6                                       ; preds = %0
<   %7 = and i32 %.pre, 3
<   %8 = icmp eq i32 %7, 0
<   br i1 %8, label %._crit_edge, label %9
---
> ; <label>:91                                      ; preds = %88
>   %92 = load i32* %aSig, align 4
>   %93 = icmp eq i32 %92, 0
>   br i1 %93, label %94, label %97
11516,11518c7782,7786
< ; <label>:9                                       ; preds = %6
<   tail call fastcc void @raise_exception(i32 13) noreturn
<   unreachable
---
> ; <label>:94                                      ; preds = %91
>   %95 = load i8* %zSign, align 1
>   %96 = call i32 @packFloat32(i8 zeroext %95, i32 0, i32 0)
>   store i32 %96, i32* %1
>   br label %150
11520,11530c7788,7835
< ._crit_edge:                                      ; preds = %6, %0
<   %.lobit.i = and i32 %.pre, 2097152
<   %10 = icmp eq i32 %.lobit.i, 0
<   br i1 %10, label %helper_svm_check_intercept_param.exit, label %11, !prof !0
< 
< ; <label>:11                                      ; preds = %._crit_edge
<   %12 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %13 = load i64* %12, align 8
<   %14 = and i64 %13, 32768
<   %15 = icmp eq i64 %14, 0
<   br i1 %15, label %helper_svm_check_intercept_param.exit, label %16
---
> ; <label>:97                                      ; preds = %91
>   %98 = load i32* %aSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %98, i32* %aExp, i32* %aSig)
>   br label %99
> 
> ; <label>:99                                      ; preds = %97, %88
>   %100 = load i32* %aExp, align 4
>   %101 = load i32* %bExp, align 4
>   %102 = sub nsw i32 %100, %101
>   %103 = add nsw i32 %102, 125
>   store i32 %103, i32* %zExp, align 4
>   %104 = load i32* %aSig, align 4
>   %105 = or i32 %104, 8388608
>   %106 = shl i32 %105, 7
>   store i32 %106, i32* %aSig, align 4
>   %107 = load i32* %bSig, align 4
>   %108 = or i32 %107, 8388608
>   %109 = shl i32 %108, 8
>   store i32 %109, i32* %bSig, align 4
>   %110 = load i32* %bSig, align 4
>   %111 = load i32* %aSig, align 4
>   %112 = load i32* %aSig, align 4
>   %113 = add i32 %111, %112
>   %114 = icmp ule i32 %110, %113
>   br i1 %114, label %115, label %120
> 
> ; <label>:115                                     ; preds = %99
>   %116 = load i32* %aSig, align 4
>   %117 = lshr i32 %116, 1
>   store i32 %117, i32* %aSig, align 4
>   %118 = load i32* %zExp, align 4
>   %119 = add nsw i32 %118, 1
>   store i32 %119, i32* %zExp, align 4
>   br label %120
> 
> ; <label>:120                                     ; preds = %115, %99
>   %121 = load i32* %aSig, align 4
>   %122 = zext i32 %121 to i64
>   %123 = shl i64 %122, 32
>   %124 = load i32* %bSig, align 4
>   %125 = zext i32 %124 to i64
>   %126 = udiv i64 %123, %125
>   %127 = trunc i64 %126 to i32
>   store i32 %127, i32* %zSig, align 4
>   %128 = load i32* %zSig, align 4
>   %129 = and i32 %128, 63
>   %130 = icmp eq i32 %129, 0
>   br i1 %130, label %131, label %144
11532,11534c7837,7860
< ; <label>:16                                      ; preds = %11
<   tail call void @helper_vmexit(i32 111, i64 0) nounwind
<   unreachable
---
> ; <label>:131                                     ; preds = %120
>   %132 = load i32* %bSig, align 4
>   %133 = zext i32 %132 to i64
>   %134 = load i32* %zSig, align 4
>   %135 = zext i32 %134 to i64
>   %136 = mul i64 %133, %135
>   %137 = load i32* %aSig, align 4
>   %138 = zext i32 %137 to i64
>   %139 = shl i64 %138, 32
>   %140 = icmp ne i64 %136, %139
>   %141 = zext i1 %140 to i32
>   %142 = load i32* %zSig, align 4
>   %143 = or i32 %142, %141
>   store i32 %143, i32* %zSig, align 4
>   br label %144
> 
> ; <label>:144                                     ; preds = %131, %120
>   %145 = load i8* %zSign, align 1
>   %146 = load i32* %zExp, align 4
>   %147 = load i32* %zSig, align 4
>   %148 = load %struct.float_status** %4, align 4
>   %149 = call i32 @roundAndPackFloat32(i8 zeroext %145, i32 %146, i32 %147, %struct.float_status* %148)
>   store i32 %149, i32* %1
>   br label %150
11536,11538c7862,7864
< helper_svm_check_intercept_param.exit:            ; preds = %11, %._crit_edge
<   tail call fastcc void @raise_exception_err(i32 6, i32 0) noreturn
<   unreachable
---
> ; <label>:150                                     ; preds = %144, %94, %82, %80, %66, %61, %52, %50, %45, %34
>   %151 = load i32* %1
>   ret i32 %151
11541,11595c7867,7913
< define void @helper_wrmsr() nounwind uwtable {
<   tail call void @helper_svm_check_intercept_param(i32 124, i64 1)
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 2
<   %6 = load i32* %5, align 4
<   %7 = zext i32 %6 to i64
<   %8 = shl nuw i64 %7, 32
<   %9 = or i64 %8, %4
<   %10 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 1
<   %11 = load i32* %10, align 4
<   switch i32 %11, label %98 [
<     i32 372, label %12
<     i32 373, label %15
<     i32 374, label %17
<     i32 27, label %19
<     i32 -1073741696, label %22
<     i32 -1073741695, label %56
<     i32 631, label %58
<     i32 -1073676009, label %60
<     i32 512, label %62
<     i32 514, label %62
<     i32 516, label %62
<     i32 518, label %62
<     i32 520, label %62
<     i32 522, label %62
<     i32 524, label %62
<     i32 526, label %62
<     i32 513, label %67
<     i32 515, label %67
<     i32 517, label %67
<     i32 519, label %67
<     i32 521, label %67
<     i32 523, label %67
<     i32 525, label %67
<     i32 527, label %67
<     i32 592, label %72
<     i32 600, label %74
<     i32 601, label %74
<     i32 616, label %78
<     i32 617, label %78
<     i32 618, label %78
<     i32 619, label %78
<     i32 620, label %78
<     i32 621, label %78
<     i32 622, label %78
<     i32 623, label %78
<     i32 767, label %82
<     i32 378, label %84
<     i32 379, label %86
<     i32 -1073741565, label %94
<     i32 416, label %96
<   ]
---
> define internal i32 @float32_rem(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %expDiff = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %bSig = alloca i32, align 4
>   %q = alloca i32, align 4
>   %aSig64 = alloca i64, align 8
>   %bSig64 = alloca i64, align 8
>   %q64 = alloca i64, align 8
>   %alternateASig = alloca i32, align 4
>   %sigMean = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Frac(i32 %11)
>   store i32 %12, i32* %aSig, align 4
>   %13 = load i32* %2, align 4
>   %14 = call i32 @extractFloat32Exp(i32 %13)
>   store i32 %14, i32* %aExp, align 4
>   %15 = load i32* %2, align 4
>   %16 = call zeroext i8 @extractFloat32Sign(i32 %15)
>   store i8 %16, i8* %aSign, align 1
>   %17 = load i32* %3, align 4
>   %18 = call i32 @extractFloat32Frac(i32 %17)
>   store i32 %18, i32* %bSig, align 4
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   store i32 %20, i32* %bExp, align 4
>   %21 = load i32* %aExp, align 4
>   %22 = icmp eq i32 %21, 255
>   br i1 %22, label %23, label %39
11597,11601c7915,7928
< ; <label>:12                                      ; preds = %0
<   %13 = and i32 %3, 65535
<   %14 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 33
<   store i32 %13, i32* %14, align 4
<   br label %116
---
> ; <label>:23                                      ; preds = %0
>   %24 = load i32* %aSig, align 4
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %32, label %26
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load i32* %bExp, align 4
>   %28 = icmp eq i32 %27, 255
>   br i1 %28, label %29, label %37
> 
> ; <label>:29                                      ; preds = %26
>   %30 = load i32* %bSig, align 4
>   %31 = icmp ne i32 %30, 0
>   br i1 %31, label %32, label %37
11603,11606c7930,7942
< ; <label>:15                                      ; preds = %0
<   %16 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 34
<   store i32 %3, i32* %16, align 4
<   br label %116
---
> ; <label>:32                                      ; preds = %29, %23
>   %33 = load i32* %2, align 4
>   %34 = load i32* %3, align 4
>   %35 = load %struct.float_status** %4, align 4
>   %36 = call i32 @propagateFloat32NaN(i32 %33, i32 %34, %struct.float_status* %35)
>   store i32 %36, i32* %1
>   br label %261
> 
> ; <label>:37                                      ; preds = %29, %26
>   %38 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %38)
>   store i32 -4194304, i32* %1
>   br label %261
11608,11611c7944,7947
< ; <label>:17                                      ; preds = %0
<   %18 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 35
<   store i32 %3, i32* %18, align 4
<   br label %116
---
> ; <label>:39                                      ; preds = %0
>   %40 = load i32* %bExp, align 4
>   %41 = icmp eq i32 %40, 255
>   br i1 %41, label %42, label %52
11613,11617c7949,7952
< ; <label>:19                                      ; preds = %0
<   %20 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 145
<   %21 = load %struct.DeviceState** %20, align 8
<   tail call void @cpu_set_apic_base(%struct.DeviceState* %21, i64 %9) nounwind
<   br label %116
---
> ; <label>:42                                      ; preds = %39
>   %43 = load i32* %bSig, align 4
>   %44 = icmp ne i32 %43, 0
>   br i1 %44, label %45, label %50
11619,11664c7954,7965
< ; <label>:22                                      ; preds = %0
<   %23 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 125
<   %24 = load i32* %23, align 4
<   %25 = lshr i32 %24, 11
<   %.lobit = and i32 %25, 1
<   %. = zext i32 %.lobit to i64
<   %26 = and i32 %24, 536870912
<   %27 = icmp eq i32 %26, 0
<   %28 = or i64 %., 256
<   %update_mask.1 = select i1 %27, i64 %., i64 %28
<   %29 = and i32 %24, 33554432
<   %30 = icmp eq i32 %29, 0
<   %31 = or i64 %update_mask.1, 16384
<   %update_mask.1. = select i1 %30, i64 %update_mask.1, i64 %31
<   %32 = and i32 %24, 1048576
<   %33 = icmp eq i32 %32, 0
<   %34 = or i64 %update_mask.1., 2048
<   %update_mask.3 = select i1 %33, i64 %update_mask.1., i64 %34
<   %35 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 126
<   %36 = load i32* %35, align 4
<   %37 = and i32 %36, 4
<   %38 = icmp eq i32 %37, 0
<   %39 = or i64 %update_mask.3, 4096
<   %update_mask.3. = select i1 %38, i64 %update_mask.3, i64 %39
<   %40 = or i64 %update_mask.3., 16384
<   %update_mask.5 = select i1 %30, i64 %update_mask.3., i64 %40
<   %41 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 36
<   %42 = load i64* %41, align 8
<   %43 = xor i64 %update_mask.5, -1
<   %44 = and i64 %42, %43
<   %45 = and i64 %update_mask.5, %9
<   %46 = or i64 %44, %45
<   store i64 %46, i64* %41, align 8
<   %47 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %48 = load i32* %47, align 4
<   %49 = and i32 %48, -1064961
<   %50 = and i64 %46, 1024
<   %51 = icmp eq i64 %50, 0
<   %52 = or i32 %49, 16384
<   %storemerge.i = select i1 %51, i32 %49, i32 %52
<   %53 = and i64 %46, 4096
<   %54 = icmp eq i64 %53, 0
<   %55 = or i32 %storemerge.i, 1048576
<   %storemerge..i = select i1 %54, i32 %storemerge.i, i32 %55
<   store i32 %storemerge..i, i32* %47, align 4
<   br label %116
---
> ; <label>:45                                      ; preds = %42
>   %46 = load i32* %2, align 4
>   %47 = load i32* %3, align 4
>   %48 = load %struct.float_status** %4, align 4
>   %49 = call i32 @propagateFloat32NaN(i32 %46, i32 %47, %struct.float_status* %48)
>   store i32 %49, i32* %1
>   br label %261
> 
> ; <label>:50                                      ; preds = %42
>   %51 = load i32* %2, align 4
>   store i32 %51, i32* %1
>   br label %261
11666,11669c7967,7970
< ; <label>:56                                      ; preds = %0
<   %57 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 37
<   store i64 %9, i64* %57, align 8
<   br label %116
---
> ; <label>:52                                      ; preds = %39
>   %53 = load i32* %bExp, align 4
>   %54 = icmp eq i32 %53, 0
>   br i1 %54, label %55, label %62
11671,11674c7972,7975
< ; <label>:58                                      ; preds = %0
<   %59 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 115
<   store i64 %9, i64* %59, align 8
<   br label %116
---
> ; <label>:55                                      ; preds = %52
>   %56 = load i32* %bSig, align 4
>   %57 = icmp eq i32 %56, 0
>   br i1 %57, label %58, label %60
11676,11679c7977,7981
< ; <label>:60                                      ; preds = %0
<   %61 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 38
<   store i64 %9, i64* %61, align 8
<   br label %116
---
> ; <label>:58                                      ; preds = %55
>   %59 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %59)
>   store i32 -4194304, i32* %1
>   br label %261
11681,11687c7983,7986
< ; <label>:62                                      ; preds = %0, %0, %0, %0, %0, %0, %0, %0
<   %63 = add i32 %11, -512
<   %64 = lshr i32 %63, 1
<   %65 = zext i32 %64 to i64
<   %66 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 133, i64 %65, i32 0
<   store i64 %9, i64* %66, align 8
<   br label %116
---
> ; <label>:60                                      ; preds = %55
>   %61 = load i32* %bSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %61, i32* %bExp, i32* %bSig)
>   br label %62
11689,11695c7988,7991
< ; <label>:67                                      ; preds = %0, %0, %0, %0, %0, %0, %0, %0
<   %68 = add i32 %11, -513
<   %69 = lshr i32 %68, 1
<   %70 = zext i32 %69 to i64
<   %71 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 133, i64 %70, i32 1
<   store i64 %9, i64* %71, align 8
<   br label %116
---
> ; <label>:62                                      ; preds = %60, %52
>   %63 = load i32* %aExp, align 4
>   %64 = icmp eq i32 %63, 0
>   br i1 %64, label %65, label %72
11697,11700c7993,7996
< ; <label>:72                                      ; preds = %0
<   %73 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 131, i64 0
<   store i64 %9, i64* %73, align 8
<   br label %116
---
> ; <label>:65                                      ; preds = %62
>   %66 = load i32* %aSig, align 4
>   %67 = icmp eq i32 %66, 0
>   br i1 %67, label %68, label %70
11702,11707c7998,8048
< ; <label>:74                                      ; preds = %0, %0
<   %75 = add i32 %11, -599
<   %76 = zext i32 %75 to i64
<   %77 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 131, i64 %76
<   store i64 %9, i64* %77, align 8
<   br label %116
---
> ; <label>:68                                      ; preds = %65
>   %69 = load i32* %2, align 4
>   store i32 %69, i32* %1
>   br label %261
> 
> ; <label>:70                                      ; preds = %65
>   %71 = load i32* %aSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %71, i32* %aExp, i32* %aSig)
>   br label %72
> 
> ; <label>:72                                      ; preds = %70, %62
>   %73 = load i32* %aExp, align 4
>   %74 = load i32* %bExp, align 4
>   %75 = sub nsw i32 %73, %74
>   store i32 %75, i32* %expDiff, align 4
>   %76 = load i32* %aSig, align 4
>   %77 = or i32 %76, 8388608
>   store i32 %77, i32* %aSig, align 4
>   %78 = load i32* %bSig, align 4
>   %79 = or i32 %78, 8388608
>   store i32 %79, i32* %bSig, align 4
>   %80 = load i32* %expDiff, align 4
>   %81 = icmp slt i32 %80, 32
>   br i1 %81, label %82, label %140
> 
> ; <label>:82                                      ; preds = %72
>   %83 = load i32* %aSig, align 4
>   %84 = shl i32 %83, 8
>   store i32 %84, i32* %aSig, align 4
>   %85 = load i32* %bSig, align 4
>   %86 = shl i32 %85, 8
>   store i32 %86, i32* %bSig, align 4
>   %87 = load i32* %expDiff, align 4
>   %88 = icmp slt i32 %87, 0
>   br i1 %88, label %89, label %97
> 
> ; <label>:89                                      ; preds = %82
>   %90 = load i32* %expDiff, align 4
>   %91 = icmp slt i32 %90, -1
>   br i1 %91, label %92, label %94
> 
> ; <label>:92                                      ; preds = %89
>   %93 = load i32* %2, align 4
>   store i32 %93, i32* %1
>   br label %261
> 
> ; <label>:94                                      ; preds = %89
>   %95 = load i32* %aSig, align 4
>   %96 = lshr i32 %95, 1
>   store i32 %96, i32* %aSig, align 4
>   br label %97
11709,11714c8050,8070
< ; <label>:78                                      ; preds = %0, %0, %0, %0, %0, %0, %0, %0
<   %79 = add i32 %11, -613
<   %80 = zext i32 %79 to i64
<   %81 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 131, i64 %80
<   store i64 %9, i64* %81, align 8
<   br label %116
---
> ; <label>:97                                      ; preds = %94, %82
>   %98 = load i32* %bSig, align 4
>   %99 = load i32* %aSig, align 4
>   %100 = icmp ule i32 %98, %99
>   %101 = zext i1 %100 to i32
>   store i32 %101, i32* %q, align 4
>   %102 = load i32* %q, align 4
>   %103 = icmp ne i32 %102, 0
>   br i1 %103, label %104, label %108
> 
> ; <label>:104                                     ; preds = %97
>   %105 = load i32* %bSig, align 4
>   %106 = load i32* %aSig, align 4
>   %107 = sub i32 %106, %105
>   store i32 %107, i32* %aSig, align 4
>   br label %108
> 
> ; <label>:108                                     ; preds = %104, %97
>   %109 = load i32* %expDiff, align 4
>   %110 = icmp slt i32 0, %109
>   br i1 %110, label %111, label %134
11716,11719c8072,8124
< ; <label>:82                                      ; preds = %0
<   %83 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 132
<   store i64 %9, i64* %83, align 8
<   br label %116
---
> ; <label>:111                                     ; preds = %108
>   %112 = load i32* %aSig, align 4
>   %113 = zext i32 %112 to i64
>   %114 = shl i64 %113, 32
>   %115 = load i32* %bSig, align 4
>   %116 = zext i32 %115 to i64
>   %117 = udiv i64 %114, %116
>   %118 = trunc i64 %117 to i32
>   store i32 %118, i32* %q, align 4
>   %119 = load i32* %expDiff, align 4
>   %120 = sub nsw i32 32, %119
>   %121 = load i32* %q, align 4
>   %122 = lshr i32 %121, %120
>   store i32 %122, i32* %q, align 4
>   %123 = load i32* %bSig, align 4
>   %124 = lshr i32 %123, 2
>   store i32 %124, i32* %bSig, align 4
>   %125 = load i32* %aSig, align 4
>   %126 = lshr i32 %125, 1
>   %127 = load i32* %expDiff, align 4
>   %128 = sub nsw i32 %127, 1
>   %129 = shl i32 %126, %128
>   %130 = load i32* %bSig, align 4
>   %131 = load i32* %q, align 4
>   %132 = mul i32 %130, %131
>   %133 = sub i32 %129, %132
>   store i32 %133, i32* %aSig, align 4
>   br label %139
> 
> ; <label>:134                                     ; preds = %108
>   %135 = load i32* %aSig, align 4
>   %136 = lshr i32 %135, 2
>   store i32 %136, i32* %aSig, align 4
>   %137 = load i32* %bSig, align 4
>   %138 = lshr i32 %137, 2
>   store i32 %138, i32* %bSig, align 4
>   br label %139
> 
> ; <label>:139                                     ; preds = %134, %111
>   br label %214
> 
> ; <label>:140                                     ; preds = %72
>   %141 = load i32* %bSig, align 4
>   %142 = load i32* %aSig, align 4
>   %143 = icmp ule i32 %141, %142
>   br i1 %143, label %144, label %148
> 
> ; <label>:144                                     ; preds = %140
>   %145 = load i32* %bSig, align 4
>   %146 = load i32* %aSig, align 4
>   %147 = sub i32 %146, %145
>   store i32 %147, i32* %aSig, align 4
>   br label %148
11721,11724c8126,8138
< ; <label>:84                                      ; preds = %0
<   %85 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 53
<   store i64 %9, i64* %85, align 8
<   br label %116
---
> ; <label>:148                                     ; preds = %144, %140
>   %149 = load i32* %aSig, align 4
>   %150 = zext i32 %149 to i64
>   %151 = shl i64 %150, 40
>   store i64 %151, i64* %aSig64, align 8
>   %152 = load i32* %bSig, align 4
>   %153 = zext i32 %152 to i64
>   %154 = shl i64 %153, 40
>   store i64 %154, i64* %bSig64, align 8
>   %155 = load i32* %expDiff, align 4
>   %156 = sub nsw i32 %155, 64
>   store i32 %156, i32* %expDiff, align 4
>   br label %157
11726,11731c8140,8143
< ; <label>:86                                      ; preds = %0
<   %87 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 146
<   %88 = load i64* %87, align 8
<   %89 = and i64 %88, 256
<   %90 = icmp eq i64 %89, 0
<   br i1 %90, label %116, label %91
---
> ; <label>:157                                     ; preds = %170, %148
>   %158 = load i32* %expDiff, align 4
>   %159 = icmp slt i32 0, %158
>   br i1 %159, label %160, label %180
11733,11737c8145,8175
< ; <label>:91                                      ; preds = %86
<   switch i64 %9, label %116 [
<     i64 -1, label %92
<     i64 0, label %92
<   ]
---
> ; <label>:160                                     ; preds = %157
>   %161 = load i64* %aSig64, align 8
>   %162 = load i64* %bSig64, align 8
>   %163 = call i64 @estimateDiv128To64(i64 %161, i64 0, i64 %162)
>   store i64 %163, i64* %q64, align 8
>   %164 = load i64* %q64, align 8
>   %165 = icmp ult i64 2, %164
>   br i1 %165, label %166, label %169
> 
> ; <label>:166                                     ; preds = %160
>   %167 = load i64* %q64, align 8
>   %168 = sub i64 %167, 2
>   br label %170
> 
> ; <label>:169                                     ; preds = %160
>   br label %170
> 
> ; <label>:170                                     ; preds = %169, %166
>   %171 = phi i64 [ %168, %166 ], [ 0, %169 ]
>   store i64 %171, i64* %q64, align 8
>   %172 = load i32* %bSig, align 4
>   %173 = zext i32 %172 to i64
>   %174 = load i64* %q64, align 8
>   %175 = mul i64 %173, %174
>   %176 = shl i64 %175, 38
>   %177 = sub i64 0, %176
>   store i64 %177, i64* %aSig64, align 8
>   %178 = load i32* %expDiff, align 4
>   %179 = sub nsw i32 %178, 62
>   store i32 %179, i32* %expDiff, align 4
>   br label %157
11739,11742c8177,8263
< ; <label>:92                                      ; preds = %91, %91
<   %93 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 147
<   store i64 %9, i64* %93, align 8
<   br label %116
---
> ; <label>:180                                     ; preds = %157
>   %181 = load i32* %expDiff, align 4
>   %182 = add nsw i32 %181, 64
>   store i32 %182, i32* %expDiff, align 4
>   %183 = load i64* %aSig64, align 8
>   %184 = load i64* %bSig64, align 8
>   %185 = call i64 @estimateDiv128To64(i64 %183, i64 0, i64 %184)
>   store i64 %185, i64* %q64, align 8
>   %186 = load i64* %q64, align 8
>   %187 = icmp ult i64 2, %186
>   br i1 %187, label %188, label %191
> 
> ; <label>:188                                     ; preds = %180
>   %189 = load i64* %q64, align 8
>   %190 = sub i64 %189, 2
>   br label %192
> 
> ; <label>:191                                     ; preds = %180
>   br label %192
> 
> ; <label>:192                                     ; preds = %191, %188
>   %193 = phi i64 [ %190, %188 ], [ 0, %191 ]
>   store i64 %193, i64* %q64, align 8
>   %194 = load i64* %q64, align 8
>   %195 = load i32* %expDiff, align 4
>   %196 = sub nsw i32 64, %195
>   %197 = zext i32 %196 to i64
>   %198 = lshr i64 %194, %197
>   %199 = trunc i64 %198 to i32
>   store i32 %199, i32* %q, align 4
>   %200 = load i32* %bSig, align 4
>   %201 = shl i32 %200, 6
>   store i32 %201, i32* %bSig, align 4
>   %202 = load i64* %aSig64, align 8
>   %203 = lshr i64 %202, 33
>   %204 = load i32* %expDiff, align 4
>   %205 = sub nsw i32 %204, 1
>   %206 = zext i32 %205 to i64
>   %207 = shl i64 %203, %206
>   %208 = load i32* %bSig, align 4
>   %209 = load i32* %q, align 4
>   %210 = mul i32 %208, %209
>   %211 = zext i32 %210 to i64
>   %212 = sub i64 %207, %211
>   %213 = trunc i64 %212 to i32
>   store i32 %213, i32* %aSig, align 4
>   br label %214
> 
> ; <label>:214                                     ; preds = %192, %139
>   br label %215
> 
> ; <label>:215                                     ; preds = %222, %214
>   %216 = load i32* %aSig, align 4
>   store i32 %216, i32* %alternateASig, align 4
>   %217 = load i32* %q, align 4
>   %218 = add i32 %217, 1
>   store i32 %218, i32* %q, align 4
>   %219 = load i32* %bSig, align 4
>   %220 = load i32* %aSig, align 4
>   %221 = sub i32 %220, %219
>   store i32 %221, i32* %aSig, align 4
>   br label %222
> 
> ; <label>:222                                     ; preds = %215
>   %223 = load i32* %aSig, align 4
>   %224 = icmp sle i32 0, %223
>   br i1 %224, label %215, label %225
> 
> ; <label>:225                                     ; preds = %222
>   %226 = load i32* %aSig, align 4
>   %227 = load i32* %alternateASig, align 4
>   %228 = add i32 %226, %227
>   store i32 %228, i32* %sigMean, align 4
>   %229 = load i32* %sigMean, align 4
>   %230 = icmp slt i32 %229, 0
>   br i1 %230, label %238, label %231
> 
> ; <label>:231                                     ; preds = %225
>   %232 = load i32* %sigMean, align 4
>   %233 = icmp eq i32 %232, 0
>   br i1 %233, label %234, label %240
> 
> ; <label>:234                                     ; preds = %231
>   %235 = load i32* %q, align 4
>   %236 = and i32 %235, 1
>   %237 = icmp ne i32 %236, 0
>   br i1 %237, label %238, label %240
11744,11747c8265,8323
< ; <label>:94                                      ; preds = %0
<   %95 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 149
<   store i64 %9, i64* %95, align 8
<   br label %116
---
> ; <label>:238                                     ; preds = %234, %225
>   %239 = load i32* %alternateASig, align 4
>   store i32 %239, i32* %aSig, align 4
>   br label %240
> 
> ; <label>:240                                     ; preds = %238, %234, %231
>   %241 = load i32* %aSig, align 4
>   %242 = icmp slt i32 %241, 0
>   %243 = zext i1 %242 to i32
>   %244 = trunc i32 %243 to i8
>   store i8 %244, i8* %zSign, align 1
>   %245 = load i8* %zSign, align 1
>   %246 = icmp ne i8 %245, 0
>   br i1 %246, label %247, label %250
> 
> ; <label>:247                                     ; preds = %240
>   %248 = load i32* %aSig, align 4
>   %249 = sub i32 0, %248
>   store i32 %249, i32* %aSig, align 4
>   br label %250
> 
> ; <label>:250                                     ; preds = %247, %240
>   %251 = load i8* %aSign, align 1
>   %252 = zext i8 %251 to i32
>   %253 = load i8* %zSign, align 1
>   %254 = zext i8 %253 to i32
>   %255 = xor i32 %252, %254
>   %256 = trunc i32 %255 to i8
>   %257 = load i32* %bExp, align 4
>   %258 = load i32* %aSig, align 4
>   %259 = load %struct.float_status** %4, align 4
>   %260 = call i32 @normalizeRoundAndPackFloat32(i8 zeroext %256, i32 %257, i32 %258, %struct.float_status* %259)
>   store i32 %260, i32* %1
>   br label %261
> 
> ; <label>:261                                     ; preds = %250, %92, %68, %58, %50, %45, %37, %32
>   %262 = load i32* %1
>   ret i32 %262
> }
> 
> define internal i64 @estimateDiv128To64(i64 %a0, i64 %a1, i64 %b) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %b0 = alloca i64, align 8
>   %b1 = alloca i64, align 8
>   %rem0 = alloca i64, align 8
>   %rem1 = alloca i64, align 8
>   %term0 = alloca i64, align 8
>   %term1 = alloca i64, align 8
>   %z = alloca i64, align 8
>   store i64 %a0, i64* %2, align 8
>   store i64 %a1, i64* %3, align 8
>   store i64 %b, i64* %4, align 8
>   %5 = load i64* %4, align 8
>   %6 = load i64* %2, align 8
>   %7 = icmp ule i64 %5, %6
>   br i1 %7, label %8, label %9
11749,11752c8325,8327
< ; <label>:96                                      ; preds = %0
<   %97 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 54
<   store i64 %9, i64* %97, align 8
<   br label %116
---
> ; <label>:8                                       ; preds = %0
>   store i64 -1, i64* %1
>   br label %62
11754,11778c8329,8337
< ; <label>:98                                      ; preds = %0
<   %99 = icmp ugt i32 %11, 1023
<   br i1 %99, label %100, label %116
< 
< ; <label>:100                                     ; preds = %98
<   %101 = zext i32 %11 to i64
<   %102 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 146
<   %103 = load i64* %102, align 8
<   %104 = shl i64 %103, 2
<   %105 = and i64 %104, 252
<   %106 = or i64 %105, 1024
<   %107 = icmp ult i64 %101, %106
<   br i1 %107, label %108, label %116
< 
< ; <label>:108                                     ; preds = %100
<   %109 = add i32 %11, -1024
<   %110 = and i32 %109, 3
<   %111 = icmp eq i32 %110, 0
<   br i1 %111, label %112, label %113
< 
< ; <label>:112                                     ; preds = %108
<   switch i64 %9, label %116 [
<     i64 -1, label %113
<     i64 0, label %113
<   ]
---
> ; <label>:9                                       ; preds = %0
>   %10 = load i64* %4, align 8
>   %11 = lshr i64 %10, 32
>   store i64 %11, i64* %b0, align 8
>   %12 = load i64* %b0, align 8
>   %13 = shl i64 %12, 32
>   %14 = load i64* %2, align 8
>   %15 = icmp ule i64 %13, %14
>   br i1 %15, label %16, label %17
11780,11784c8339,8340
< ; <label>:113                                     ; preds = %112, %112, %108
<   %114 = zext i32 %109 to i64
<   %115 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 148, i64 %114
<   store i64 %9, i64* %115, align 8
<   br label %116
---
> ; <label>:16                                      ; preds = %9
>   br label %22
11786,11788c8342,8360
< ; <label>:116                                     ; preds = %113, %112, %100, %98, %96, %94, %92, %91, %86, %84, %82, %78, %74, %72, %67, %62, %60, %58, %56, %22, %19, %17, %15, %12
<   ret void
< }
---
> ; <label>:17                                      ; preds = %9
>   %18 = load i64* %2, align 8
>   %19 = load i64* %b0, align 8
>   %20 = udiv i64 %18, %19
>   %21 = shl i64 %20, 32
>   br label %22
> 
> ; <label>:22                                      ; preds = %17, %16
>   %23 = phi i64 [ -4294967296, %16 ], [ %21, %17 ]
>   store i64 %23, i64* %z, align 8
>   %24 = load i64* %4, align 8
>   %25 = load i64* %z, align 8
>   call void @mul64To128(i64 %24, i64 %25, i64* %term0, i64* %term1)
>   %26 = load i64* %2, align 8
>   %27 = load i64* %3, align 8
>   %28 = load i64* %term0, align 8
>   %29 = load i64* %term1, align 8
>   call void @sub128(i64 %26, i64 %27, i64 %28, i64 %29, i64* %rem0, i64* %rem1)
>   br label %30
11790c8362,8365
< declare void @cpu_set_apic_base(%struct.DeviceState*, i64)
---
> ; <label>:30                                      ; preds = %33, %22
>   %31 = load i64* %rem0, align 8
>   %32 = icmp slt i64 %31, 0
>   br i1 %32, label %33, label %42
11792,11846c8367,8379
< define void @helper_rdmsr() nounwind uwtable {
<   tail call void @helper_svm_check_intercept_param(i32 124, i64 0)
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 1
<   %3 = load i32* %2, align 4
<   switch i32 %3, label %82 [
<     i32 372, label %4
<     i32 373, label %8
<     i32 374, label %12
<     i32 27, label %16
<     i32 -1073741696, label %20
<     i32 -1073741695, label %23
<     i32 631, label %26
<     i32 -1073676009, label %29
<     i32 408, label %97
<     i32 512, label %32
<     i32 514, label %32
<     i32 516, label %32
<     i32 518, label %32
<     i32 520, label %32
<     i32 522, label %32
<     i32 524, label %32
<     i32 526, label %32
<     i32 513, label %38
<     i32 515, label %38
<     i32 517, label %38
<     i32 519, label %38
<     i32 521, label %38
<     i32 523, label %38
<     i32 525, label %38
<     i32 527, label %38
<     i32 592, label %44
<     i32 600, label %47
<     i32 601, label %47
<     i32 616, label %52
<     i32 617, label %52
<     i32 618, label %52
<     i32 619, label %52
<     i32 620, label %52
<     i32 621, label %52
<     i32 622, label %52
<     i32 623, label %52
<     i32 767, label %57
<     i32 254, label %60
<     i32 377, label %65
<     i32 379, label %68
<     i32 378, label %76
<     i32 416, label %79
<   ]
< 
< ; <label>:4                                       ; preds = %0
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 33
<   %6 = load i32* %5, align 4
<   %7 = zext i32 %6 to i64
<   br label %97
---
> ; <label>:33                                      ; preds = %30
>   %34 = load i64* %z, align 8
>   %35 = sub i64 %34, 4294967296
>   store i64 %35, i64* %z, align 8
>   %36 = load i64* %4, align 8
>   %37 = shl i64 %36, 32
>   store i64 %37, i64* %b1, align 8
>   %38 = load i64* %rem0, align 8
>   %39 = load i64* %rem1, align 8
>   %40 = load i64* %b0, align 8
>   %41 = load i64* %b1, align 8
>   call void @add128(i64 %38, i64 %39, i64 %40, i64 %41, i64* %rem0, i64* %rem1)
>   br label %30
11848,11852c8381,8392
< ; <label>:8                                       ; preds = %0
<   %9 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 34
<   %10 = load i32* %9, align 4
<   %11 = zext i32 %10 to i64
<   br label %97
---
> ; <label>:42                                      ; preds = %30
>   %43 = load i64* %rem0, align 8
>   %44 = shl i64 %43, 32
>   %45 = load i64* %rem1, align 8
>   %46 = lshr i64 %45, 32
>   %47 = or i64 %44, %46
>   store i64 %47, i64* %rem0, align 8
>   %48 = load i64* %b0, align 8
>   %49 = shl i64 %48, 32
>   %50 = load i64* %rem0, align 8
>   %51 = icmp ule i64 %49, %50
>   br i1 %51, label %52, label %53
11854,11858c8394,8395
< ; <label>:12                                      ; preds = %0
<   %13 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 35
<   %14 = load i32* %13, align 4
<   %15 = zext i32 %14 to i64
<   br label %97
---
> ; <label>:52                                      ; preds = %42
>   br label %57
11860,11865c8397,8401
< ; <label>:16                                      ; preds = %0
<   %17 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 145
<   %18 = load %struct.DeviceState** %17, align 8
<   %19 = tail call i64 @cpu_get_apic_base(%struct.DeviceState* %18) nounwind
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %97
---
> ; <label>:53                                      ; preds = %42
>   %54 = load i64* %rem0, align 8
>   %55 = load i64* %b0, align 8
>   %56 = udiv i64 %54, %55
>   br label %57
11867,11870c8403,8415
< ; <label>:20                                      ; preds = %0
<   %21 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 36
<   %22 = load i64* %21, align 8
<   br label %97
---
> ; <label>:57                                      ; preds = %53, %52
>   %58 = phi i64 [ 4294967295, %52 ], [ %56, %53 ]
>   %59 = load i64* %z, align 8
>   %60 = or i64 %59, %58
>   store i64 %60, i64* %z, align 8
>   %61 = load i64* %z, align 8
>   store i64 %61, i64* %1
>   br label %62
> 
> ; <label>:62                                      ; preds = %57, %8
>   %63 = load i64* %1
>   ret i64 %63
> }
11872,11875c8417,8493
< ; <label>:23                                      ; preds = %0
<   %24 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 37
<   %25 = load i64* %24, align 8
<   br label %97
---
> define internal i32 @float32_muladd(i32 %a, i32 %b, i32 %c, i32 %flags, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca i32, align 4
>   %5 = alloca i32, align 4
>   %6 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %cSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %cExp = alloca i32, align 4
>   %pExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %expDiff = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %bSig = alloca i32, align 4
>   %cSig = alloca i32, align 4
>   %pInf = alloca i8, align 1
>   %pZero = alloca i8, align 1
>   %pSign = alloca i8, align 1
>   %pSig64 = alloca i64, align 8
>   %cSig64 = alloca i64, align 8
>   %zSig64 = alloca i64, align 8
>   %pSig = alloca i32, align 4
>   %shiftcount = alloca i32, align 4
>   %signflip = alloca i8, align 1
>   %infzero = alloca i8, align 1
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store i32 %c, i32* %4, align 4
>   store i32 %flags, i32* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %6, align 4
>   %7 = load i32* %2, align 4
>   %8 = load %struct.float_status** %6, align 4
>   %9 = call i32 @float32_squash_input_denormal(i32 %7, %struct.float_status* %8)
>   store i32 %9, i32* %2, align 4
>   %10 = load i32* %3, align 4
>   %11 = load %struct.float_status** %6, align 4
>   %12 = call i32 @float32_squash_input_denormal(i32 %10, %struct.float_status* %11)
>   store i32 %12, i32* %3, align 4
>   %13 = load i32* %4, align 4
>   %14 = load %struct.float_status** %6, align 4
>   %15 = call i32 @float32_squash_input_denormal(i32 %13, %struct.float_status* %14)
>   store i32 %15, i32* %4, align 4
>   %16 = load i32* %2, align 4
>   %17 = call i32 @extractFloat32Frac(i32 %16)
>   store i32 %17, i32* %aSig, align 4
>   %18 = load i32* %2, align 4
>   %19 = call i32 @extractFloat32Exp(i32 %18)
>   store i32 %19, i32* %aExp, align 4
>   %20 = load i32* %2, align 4
>   %21 = call zeroext i8 @extractFloat32Sign(i32 %20)
>   store i8 %21, i8* %aSign, align 1
>   %22 = load i32* %3, align 4
>   %23 = call i32 @extractFloat32Frac(i32 %22)
>   store i32 %23, i32* %bSig, align 4
>   %24 = load i32* %3, align 4
>   %25 = call i32 @extractFloat32Exp(i32 %24)
>   store i32 %25, i32* %bExp, align 4
>   %26 = load i32* %3, align 4
>   %27 = call zeroext i8 @extractFloat32Sign(i32 %26)
>   store i8 %27, i8* %bSign, align 1
>   %28 = load i32* %4, align 4
>   %29 = call i32 @extractFloat32Frac(i32 %28)
>   store i32 %29, i32* %cSig, align 4
>   %30 = load i32* %4, align 4
>   %31 = call i32 @extractFloat32Exp(i32 %30)
>   store i32 %31, i32* %cExp, align 4
>   %32 = load i32* %4, align 4
>   %33 = call zeroext i8 @extractFloat32Sign(i32 %32)
>   store i8 %33, i8* %cSign, align 1
>   %34 = load i32* %aExp, align 4
>   %35 = icmp eq i32 %34, 0
>   br i1 %35, label %36, label %45
11877,11880c8495,8498
< ; <label>:26                                      ; preds = %0
<   %27 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 115
<   %28 = load i64* %27, align 8
<   br label %97
---
> ; <label>:36                                      ; preds = %0
>   %37 = load i32* %aSig, align 4
>   %38 = icmp eq i32 %37, 0
>   br i1 %38, label %39, label %45
11882,11885c8500,8503
< ; <label>:29                                      ; preds = %0
<   %30 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 38
<   %31 = load i64* %30, align 8
<   br label %97
---
> ; <label>:39                                      ; preds = %36
>   %40 = load i32* %bExp, align 4
>   %41 = icmp eq i32 %40, 255
>   br i1 %41, label %42, label %45
11887,11893c8505,8508
< ; <label>:32                                      ; preds = %0, %0, %0, %0, %0, %0, %0, %0
<   %33 = add i32 %3, -512
<   %34 = lshr i32 %33, 1
<   %35 = zext i32 %34 to i64
<   %36 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 133, i64 %35, i32 0
<   %37 = load i64* %36, align 8
<   br label %97
---
> ; <label>:42                                      ; preds = %39
>   %43 = load i32* %bSig, align 4
>   %44 = icmp eq i32 %43, 0
>   br i1 %44, label %59, label %45
11895,11901c8510,8513
< ; <label>:38                                      ; preds = %0, %0, %0, %0, %0, %0, %0, %0
<   %39 = add i32 %3, -513
<   %40 = lshr i32 %39, 1
<   %41 = zext i32 %40 to i64
<   %42 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 133, i64 %41, i32 1
<   %43 = load i64* %42, align 8
<   br label %97
---
> ; <label>:45                                      ; preds = %42, %39, %36, %0
>   %46 = load i32* %aExp, align 4
>   %47 = icmp eq i32 %46, 255
>   br i1 %47, label %48, label %57
11903,11906c8515,8518
< ; <label>:44                                      ; preds = %0
<   %45 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 131, i64 0
<   %46 = load i64* %45, align 8
<   br label %97
---
> ; <label>:48                                      ; preds = %45
>   %49 = load i32* %aSig, align 4
>   %50 = icmp eq i32 %49, 0
>   br i1 %50, label %51, label %57
11908,11913c8520,8523
< ; <label>:47                                      ; preds = %0, %0
<   %48 = add i32 %3, -599
<   %49 = zext i32 %48 to i64
<   %50 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 131, i64 %49
<   %51 = load i64* %50, align 8
<   br label %97
---
> ; <label>:51                                      ; preds = %48
>   %52 = load i32* %bExp, align 4
>   %53 = icmp eq i32 %52, 0
>   br i1 %53, label %54, label %57
11915,11920c8525,8528
< ; <label>:52                                      ; preds = %0, %0, %0, %0, %0, %0, %0, %0
<   %53 = add i32 %3, -613
<   %54 = zext i32 %53 to i64
<   %55 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 131, i64 %54
<   %56 = load i64* %55, align 8
<   br label %97
---
> ; <label>:54                                      ; preds = %51
>   %55 = load i32* %bSig, align 4
>   %56 = icmp eq i32 %55, 0
>   br label %57
11922,11925c8530,8532
< ; <label>:57                                      ; preds = %0
<   %58 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 132
<   %59 = load i64* %58, align 8
<   br label %97
---
> ; <label>:57                                      ; preds = %54, %51, %48, %45
>   %58 = phi i1 [ false, %51 ], [ false, %48 ], [ false, %45 ], [ %56, %54 ]
>   br label %59
11927,11933c8534,8561
< ; <label>:60                                      ; preds = %0
<   %61 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 121
<   %62 = load i32* %61, align 4
<   %63 = and i32 %62, 4096
<   %64 = icmp eq i32 %63, 0
<   %. = select i1 %64, i64 0, i64 1288
<   br label %97
---
> ; <label>:59                                      ; preds = %57, %42
>   %60 = phi i1 [ true, %42 ], [ %58, %57 ]
>   %61 = zext i1 %60 to i32
>   %62 = trunc i32 %61 to i8
>   store i8 %62, i8* %infzero, align 1
>   %63 = load i32* %aExp, align 4
>   %64 = icmp eq i32 %63, 255
>   br i1 %64, label %65, label %68
> 
> ; <label>:65                                      ; preds = %59
>   %66 = load i32* %aSig, align 4
>   %67 = icmp ne i32 %66, 0
>   br i1 %67, label %80, label %68
> 
> ; <label>:68                                      ; preds = %65, %59
>   %69 = load i32* %bExp, align 4
>   %70 = icmp eq i32 %69, 255
>   br i1 %70, label %71, label %74
> 
> ; <label>:71                                      ; preds = %68
>   %72 = load i32* %bSig, align 4
>   %73 = icmp ne i32 %72, 0
>   br i1 %73, label %80, label %74
> 
> ; <label>:74                                      ; preds = %71, %68
>   %75 = load i32* %cExp, align 4
>   %76 = icmp eq i32 %75, 255
>   br i1 %76, label %77, label %87
11935,11938c8563,8628
< ; <label>:65                                      ; preds = %0
<   %66 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 146
<   %67 = load i64* %66, align 8
<   br label %97
---
> ; <label>:77                                      ; preds = %74
>   %78 = load i32* %cSig, align 4
>   %79 = icmp ne i32 %78, 0
>   br i1 %79, label %80, label %87
> 
> ; <label>:80                                      ; preds = %77, %71, %65
>   %81 = load i32* %2, align 4
>   %82 = load i32* %3, align 4
>   %83 = load i32* %4, align 4
>   %84 = load i8* %infzero, align 1
>   %85 = load %struct.float_status** %6, align 4
>   %86 = call i32 @propagateFloat32MulAddNaN(i32 %81, i32 %82, i32 %83, i8 zeroext %84, %struct.float_status* %85)
>   store i32 %86, i32* %1
>   br label %421
> 
> ; <label>:87                                      ; preds = %77, %74
>   %88 = load i8* %infzero, align 1
>   %89 = icmp ne i8 %88, 0
>   br i1 %89, label %90, label %92
> 
> ; <label>:90                                      ; preds = %87
>   %91 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %91)
>   store i32 -4194304, i32* %1
>   br label %421
> 
> ; <label>:92                                      ; preds = %87
>   %93 = load i32* %5, align 4
>   %94 = and i32 %93, 1
>   %95 = icmp ne i32 %94, 0
>   br i1 %95, label %96, label %101
> 
> ; <label>:96                                      ; preds = %92
>   %97 = load i8* %cSign, align 1
>   %98 = zext i8 %97 to i32
>   %99 = xor i32 %98, 1
>   %100 = trunc i32 %99 to i8
>   store i8 %100, i8* %cSign, align 1
>   br label %101
> 
> ; <label>:101                                     ; preds = %96, %92
>   %102 = load i32* %5, align 4
>   %103 = and i32 %102, 3
>   %104 = icmp ne i32 %103, 0
>   %105 = select i1 %104, i32 1, i32 0
>   %106 = trunc i32 %105 to i8
>   store i8 %106, i8* %signflip, align 1
>   %107 = load i8* %aSign, align 1
>   %108 = zext i8 %107 to i32
>   %109 = load i8* %bSign, align 1
>   %110 = zext i8 %109 to i32
>   %111 = xor i32 %108, %110
>   %112 = trunc i32 %111 to i8
>   store i8 %112, i8* %pSign, align 1
>   %113 = load i32* %5, align 4
>   %114 = and i32 %113, 2
>   %115 = icmp ne i32 %114, 0
>   br i1 %115, label %116, label %121
> 
> ; <label>:116                                     ; preds = %101
>   %117 = load i8* %pSign, align 1
>   %118 = zext i8 %117 to i32
>   %119 = xor i32 %118, 1
>   %120 = trunc i32 %119 to i8
>   store i8 %120, i8* %pSign, align 1
>   br label %121
11940,11945c8630,8656
< ; <label>:68                                      ; preds = %0
<   %69 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 146
<   %70 = load i64* %69, align 8
<   %71 = and i64 %70, 256
<   %72 = icmp eq i64 %71, 0
<   br i1 %72, label %97, label %73
---
> ; <label>:121                                     ; preds = %116, %101
>   %122 = load i32* %aExp, align 4
>   %123 = icmp eq i32 %122, 255
>   br i1 %123, label %127, label %124
> 
> ; <label>:124                                     ; preds = %121
>   %125 = load i32* %bExp, align 4
>   %126 = icmp eq i32 %125, 255
>   br label %127
> 
> ; <label>:127                                     ; preds = %124, %121
>   %128 = phi i1 [ true, %121 ], [ %126, %124 ]
>   %129 = zext i1 %128 to i32
>   %130 = trunc i32 %129 to i8
>   store i8 %130, i8* %pInf, align 1
>   %131 = load i32* %aExp, align 4
>   %132 = load i32* %aSig, align 4
>   %133 = or i32 %131, %132
>   %134 = icmp eq i32 %133, 0
>   br i1 %134, label %140, label %135
> 
> ; <label>:135                                     ; preds = %127
>   %136 = load i32* %bExp, align 4
>   %137 = load i32* %bSig, align 4
>   %138 = or i32 %136, %137
>   %139 = icmp eq i32 %138, 0
>   br label %140
11947,11950c8658,8718
< ; <label>:73                                      ; preds = %68
<   %74 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 147
<   %75 = load i64* %74, align 8
<   br label %97
---
> ; <label>:140                                     ; preds = %135, %127
>   %141 = phi i1 [ true, %127 ], [ %139, %135 ]
>   %142 = zext i1 %141 to i32
>   %143 = trunc i32 %142 to i8
>   store i8 %143, i8* %pZero, align 1
>   %144 = load i32* %cExp, align 4
>   %145 = icmp eq i32 %144, 255
>   br i1 %145, label %146, label %167
> 
> ; <label>:146                                     ; preds = %140
>   %147 = load i8* %pInf, align 1
>   %148 = zext i8 %147 to i32
>   %149 = icmp ne i32 %148, 0
>   br i1 %149, label %150, label %159
> 
> ; <label>:150                                     ; preds = %146
>   %151 = load i8* %pSign, align 1
>   %152 = zext i8 %151 to i32
>   %153 = load i8* %cSign, align 1
>   %154 = zext i8 %153 to i32
>   %155 = xor i32 %152, %154
>   %156 = icmp ne i32 %155, 0
>   br i1 %156, label %157, label %159
> 
> ; <label>:157                                     ; preds = %150
>   %158 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %158)
>   store i32 -4194304, i32* %1
>   br label %421
> 
> ; <label>:159                                     ; preds = %150, %146
>   %160 = load i8* %cSign, align 1
>   %161 = zext i8 %160 to i32
>   %162 = load i8* %signflip, align 1
>   %163 = zext i8 %162 to i32
>   %164 = xor i32 %161, %163
>   %165 = trunc i32 %164 to i8
>   %166 = call i32 @packFloat32(i8 zeroext %165, i32 255, i32 0)
>   store i32 %166, i32* %1
>   br label %421
> 
> ; <label>:167                                     ; preds = %140
>   %168 = load i8* %pInf, align 1
>   %169 = icmp ne i8 %168, 0
>   br i1 %169, label %170, label %178
> 
> ; <label>:170                                     ; preds = %167
>   %171 = load i8* %pSign, align 1
>   %172 = zext i8 %171 to i32
>   %173 = load i8* %signflip, align 1
>   %174 = zext i8 %173 to i32
>   %175 = xor i32 %172, %174
>   %176 = trunc i32 %175 to i8
>   %177 = call i32 @packFloat32(i8 zeroext %176, i32 255, i32 0)
>   store i32 %177, i32* %1
>   br label %421
> 
> ; <label>:178                                     ; preds = %167
>   %179 = load i8* %pZero, align 1
>   %180 = icmp ne i8 %179, 0
>   br i1 %180, label %181, label %233
11952,11955c8720,8723
< ; <label>:76                                      ; preds = %0
<   %77 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 53
<   %78 = load i64* %77, align 8
<   br label %97
---
> ; <label>:181                                     ; preds = %178
>   %182 = load i32* %cExp, align 4
>   %183 = icmp eq i32 %182, 0
>   br i1 %183, label %184, label %227
11957,11960c8725,8728
< ; <label>:79                                      ; preds = %0
<   %80 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 54
<   %81 = load i64* %80, align 8
<   br label %97
---
> ; <label>:184                                     ; preds = %181
>   %185 = load i32* %cSig, align 4
>   %186 = icmp eq i32 %185, 0
>   br i1 %186, label %187, label %212
11962,11974c8730,8869
< ; <label>:82                                      ; preds = %0
<   %83 = icmp ugt i32 %3, 1023
<   br i1 %83, label %84, label %97
< 
< ; <label>:84                                      ; preds = %82
<   %85 = zext i32 %3 to i64
<   %86 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 146
<   %87 = load i64* %86, align 8
<   %88 = shl i64 %87, 2
<   %89 = and i64 %88, 252
<   %90 = or i64 %89, 1024
<   %91 = icmp ult i64 %85, %90
<   br i1 %91, label %92, label %97
---
> ; <label>:187                                     ; preds = %184
>   %188 = load i8* %pSign, align 1
>   %189 = zext i8 %188 to i32
>   %190 = load i8* %cSign, align 1
>   %191 = zext i8 %190 to i32
>   %192 = icmp eq i32 %189, %191
>   br i1 %192, label %193, label %195
> 
> ; <label>:193                                     ; preds = %187
>   %194 = load i8* %pSign, align 1
>   store i8 %194, i8* %zSign, align 1
>   br label %204
> 
> ; <label>:195                                     ; preds = %187
>   %196 = load %struct.float_status** %6, align 4
>   %197 = getelementptr inbounds %struct.float_status* %196, i32 0, i32 1
>   %198 = load i8* %197, align 1
>   %199 = sext i8 %198 to i32
>   %200 = icmp eq i32 %199, 1
>   br i1 %200, label %201, label %202
> 
> ; <label>:201                                     ; preds = %195
>   store i8 1, i8* %zSign, align 1
>   br label %203
> 
> ; <label>:202                                     ; preds = %195
>   store i8 0, i8* %zSign, align 1
>   br label %203
> 
> ; <label>:203                                     ; preds = %202, %201
>   br label %204
> 
> ; <label>:204                                     ; preds = %203, %193
>   %205 = load i8* %zSign, align 1
>   %206 = zext i8 %205 to i32
>   %207 = load i8* %signflip, align 1
>   %208 = zext i8 %207 to i32
>   %209 = xor i32 %206, %208
>   %210 = trunc i32 %209 to i8
>   %211 = call i32 @packFloat32(i8 zeroext %210, i32 0, i32 0)
>   store i32 %211, i32* %1
>   br label %421
> 
> ; <label>:212                                     ; preds = %184
>   %213 = load %struct.float_status** %6, align 4
>   %214 = getelementptr inbounds %struct.float_status* %213, i32 0, i32 4
>   %215 = load i8* %214, align 1
>   %216 = icmp ne i8 %215, 0
>   br i1 %216, label %217, label %226
> 
> ; <label>:217                                     ; preds = %212
>   %218 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext -128, %struct.float_status* %218)
>   %219 = load i8* %cSign, align 1
>   %220 = zext i8 %219 to i32
>   %221 = load i8* %signflip, align 1
>   %222 = zext i8 %221 to i32
>   %223 = xor i32 %220, %222
>   %224 = trunc i32 %223 to i8
>   %225 = call i32 @packFloat32(i8 zeroext %224, i32 0, i32 0)
>   store i32 %225, i32* %1
>   br label %421
> 
> ; <label>:226                                     ; preds = %212
>   br label %227
> 
> ; <label>:227                                     ; preds = %226, %181
>   %228 = load i32* %4, align 4
>   %229 = load i8* %signflip, align 1
>   %230 = zext i8 %229 to i32
>   %231 = shl i32 %230, 31
>   %232 = xor i32 %228, %231
>   store i32 %232, i32* %1
>   br label %421
> 
> ; <label>:233                                     ; preds = %178
>   %234 = load i32* %aExp, align 4
>   %235 = icmp eq i32 %234, 0
>   br i1 %235, label %236, label %238
> 
> ; <label>:236                                     ; preds = %233
>   %237 = load i32* %aSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %237, i32* %aExp, i32* %aSig)
>   br label %238
> 
> ; <label>:238                                     ; preds = %236, %233
>   %239 = load i32* %bExp, align 4
>   %240 = icmp eq i32 %239, 0
>   br i1 %240, label %241, label %243
> 
> ; <label>:241                                     ; preds = %238
>   %242 = load i32* %bSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %242, i32* %bExp, i32* %bSig)
>   br label %243
> 
> ; <label>:243                                     ; preds = %241, %238
>   %244 = load i32* %aExp, align 4
>   %245 = load i32* %bExp, align 4
>   %246 = add nsw i32 %244, %245
>   %247 = sub nsw i32 %246, 126
>   store i32 %247, i32* %pExp, align 4
>   %248 = load i32* %aSig, align 4
>   %249 = or i32 %248, 8388608
>   %250 = shl i32 %249, 7
>   store i32 %250, i32* %aSig, align 4
>   %251 = load i32* %bSig, align 4
>   %252 = or i32 %251, 8388608
>   %253 = shl i32 %252, 8
>   store i32 %253, i32* %bSig, align 4
>   %254 = load i32* %aSig, align 4
>   %255 = zext i32 %254 to i64
>   %256 = load i32* %bSig, align 4
>   %257 = zext i32 %256 to i64
>   %258 = mul i64 %255, %257
>   store i64 %258, i64* %pSig64, align 8
>   %259 = load i64* %pSig64, align 8
>   %260 = shl i64 %259, 1
>   %261 = icmp sge i64 %260, 0
>   br i1 %261, label %262, label %267
> 
> ; <label>:262                                     ; preds = %243
>   %263 = load i64* %pSig64, align 8
>   %264 = shl i64 %263, 1
>   store i64 %264, i64* %pSig64, align 8
>   %265 = load i32* %pExp, align 4
>   %266 = add nsw i32 %265, -1
>   store i32 %266, i32* %pExp, align 4
>   br label %267
> 
> ; <label>:267                                     ; preds = %262, %243
>   %268 = load i8* %pSign, align 1
>   %269 = zext i8 %268 to i32
>   %270 = load i8* %signflip, align 1
>   %271 = zext i8 %270 to i32
>   %272 = xor i32 %269, %271
>   %273 = trunc i32 %272 to i8
>   store i8 %273, i8* %zSign, align 1
>   %274 = load i32* %cExp, align 4
>   %275 = icmp eq i32 %274, 0
>   br i1 %275, label %276, label %291
11976,11981c8871,9019
< ; <label>:92                                      ; preds = %84
<   %93 = add i32 %3, -1024
<   %94 = zext i32 %93 to i64
<   %95 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 148, i64 %94
<   %96 = load i64* %95, align 8
<   br label %97
---
> ; <label>:276                                     ; preds = %267
>   %277 = load i32* %cSig, align 4
>   %278 = icmp ne i32 %277, 0
>   br i1 %278, label %289, label %279
> 
> ; <label>:279                                     ; preds = %276
>   %280 = load i64* %pSig64, align 8
>   call void @shift64RightJamming(i64 %280, i32 32, i64* %pSig64)
>   %281 = load i64* %pSig64, align 8
>   %282 = trunc i64 %281 to i32
>   store i32 %282, i32* %pSig, align 4
>   %283 = load i8* %zSign, align 1
>   %284 = load i32* %pExp, align 4
>   %285 = sub nsw i32 %284, 1
>   %286 = load i32* %pSig, align 4
>   %287 = load %struct.float_status** %6, align 4
>   %288 = call i32 @roundAndPackFloat32(i8 zeroext %283, i32 %285, i32 %286, %struct.float_status* %287)
>   store i32 %288, i32* %1
>   br label %421
> 
> ; <label>:289                                     ; preds = %276
>   %290 = load i32* %cSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %290, i32* %cExp, i32* %cSig)
>   br label %291
> 
> ; <label>:291                                     ; preds = %289, %267
>   %292 = load i32* %cSig, align 4
>   %293 = zext i32 %292 to i64
>   %294 = shl i64 %293, 39
>   store i64 %294, i64* %cSig64, align 8
>   %295 = load i64* %cSig64, align 8
>   %296 = or i64 %295, 4611686018427387904
>   store i64 %296, i64* %cSig64, align 8
>   %297 = load i32* %pExp, align 4
>   %298 = load i32* %cExp, align 4
>   %299 = sub nsw i32 %297, %298
>   store i32 %299, i32* %expDiff, align 4
>   %300 = load i8* %pSign, align 1
>   %301 = zext i8 %300 to i32
>   %302 = load i8* %cSign, align 1
>   %303 = zext i8 %302 to i32
>   %304 = icmp eq i32 %301, %303
>   br i1 %304, label %305, label %335
> 
> ; <label>:305                                     ; preds = %291
>   %306 = load i32* %expDiff, align 4
>   %307 = icmp sgt i32 %306, 0
>   br i1 %307, label %308, label %312
> 
> ; <label>:308                                     ; preds = %305
>   %309 = load i64* %cSig64, align 8
>   %310 = load i32* %expDiff, align 4
>   call void @shift64RightJamming(i64 %309, i32 %310, i64* %cSig64)
>   %311 = load i32* %pExp, align 4
>   store i32 %311, i32* %zExp, align 4
>   br label %323
> 
> ; <label>:312                                     ; preds = %305
>   %313 = load i32* %expDiff, align 4
>   %314 = icmp slt i32 %313, 0
>   br i1 %314, label %315, label %320
> 
> ; <label>:315                                     ; preds = %312
>   %316 = load i64* %pSig64, align 8
>   %317 = load i32* %expDiff, align 4
>   %318 = sub nsw i32 0, %317
>   call void @shift64RightJamming(i64 %316, i32 %318, i64* %pSig64)
>   %319 = load i32* %cExp, align 4
>   store i32 %319, i32* %zExp, align 4
>   br label %322
> 
> ; <label>:320                                     ; preds = %312
>   %321 = load i32* %cExp, align 4
>   store i32 %321, i32* %zExp, align 4
>   br label %322
> 
> ; <label>:322                                     ; preds = %320, %315
>   br label %323
> 
> ; <label>:323                                     ; preds = %322, %308
>   %324 = load i64* %pSig64, align 8
>   %325 = load i64* %cSig64, align 8
>   %326 = add i64 %324, %325
>   store i64 %326, i64* %zSig64, align 8
>   %327 = load i64* %zSig64, align 8
>   %328 = icmp slt i64 %327, 0
>   br i1 %328, label %329, label %331
> 
> ; <label>:329                                     ; preds = %323
>   %330 = load i64* %zSig64, align 8
>   call void @shift64RightJamming(i64 %330, i32 1, i64* %zSig64)
>   br label %334
> 
> ; <label>:331                                     ; preds = %323
>   %332 = load i32* %zExp, align 4
>   %333 = add nsw i32 %332, -1
>   store i32 %333, i32* %zExp, align 4
>   br label %334
> 
> ; <label>:334                                     ; preds = %331, %329
>   br label %413
> 
> ; <label>:335                                     ; preds = %291
>   %336 = load i32* %expDiff, align 4
>   %337 = icmp sgt i32 %336, 0
>   br i1 %337, label %338, label %345
> 
> ; <label>:338                                     ; preds = %335
>   %339 = load i64* %cSig64, align 8
>   %340 = load i32* %expDiff, align 4
>   call void @shift64RightJamming(i64 %339, i32 %340, i64* %cSig64)
>   %341 = load i64* %pSig64, align 8
>   %342 = load i64* %cSig64, align 8
>   %343 = sub i64 %341, %342
>   store i64 %343, i64* %zSig64, align 8
>   %344 = load i32* %pExp, align 4
>   store i32 %344, i32* %zExp, align 4
>   br label %399
> 
> ; <label>:345                                     ; preds = %335
>   %346 = load i32* %expDiff, align 4
>   %347 = icmp slt i32 %346, 0
>   br i1 %347, label %348, label %360
> 
> ; <label>:348                                     ; preds = %345
>   %349 = load i64* %pSig64, align 8
>   %350 = load i32* %expDiff, align 4
>   %351 = sub nsw i32 0, %350
>   call void @shift64RightJamming(i64 %349, i32 %351, i64* %pSig64)
>   %352 = load i64* %cSig64, align 8
>   %353 = load i64* %pSig64, align 8
>   %354 = sub i64 %352, %353
>   store i64 %354, i64* %zSig64, align 8
>   %355 = load i32* %cExp, align 4
>   store i32 %355, i32* %zExp, align 4
>   %356 = load i8* %zSign, align 1
>   %357 = zext i8 %356 to i32
>   %358 = xor i32 %357, 1
>   %359 = trunc i32 %358 to i8
>   store i8 %359, i8* %zSign, align 1
>   br label %398
> 
> ; <label>:360                                     ; preds = %345
>   %361 = load i32* %pExp, align 4
>   store i32 %361, i32* %zExp, align 4
>   %362 = load i64* %cSig64, align 8
>   %363 = load i64* %pSig64, align 8
>   %364 = icmp ult i64 %362, %363
>   br i1 %364, label %365, label %369
11983,11994c9021,9113
< ; <label>:97                                      ; preds = %92, %84, %82, %79, %76, %73, %68, %65, %60, %57, %52, %47, %44, %38, %32, %29, %26, %23, %20, %16, %12, %8, %4, %0
<   %98 = phi %struct.CPUX86State* [ %1, %92 ], [ %1, %79 ], [ %1, %76 ], [ %1, %73 ], [ %1, %65 ], [ %1, %57 ], [ %1, %52 ], [ %1, %47 ], [ %1, %44 ], [ %1, %38 ], [ %1, %32 ], [ %1, %29 ], [ %1, %26 ], [ %1, %23 ], [ %1, %20 ], [ %.pre, %16 ], [ %1, %12 ], [ %1, %8 ], [ %1, %4 ], [ %1, %0 ], [ %1, %60 ], [ %1, %68 ], [ %1, %84 ], [ %1, %82 ]
<   %val.0 = phi i64 [ %96, %92 ], [ %81, %79 ], [ %78, %76 ], [ %75, %73 ], [ %67, %65 ], [ %59, %57 ], [ %56, %52 ], [ %51, %47 ], [ %46, %44 ], [ %43, %38 ], [ %37, %32 ], [ %31, %29 ], [ %28, %26 ], [ %25, %23 ], [ %22, %20 ], [ %19, %16 ], [ %15, %12 ], [ %11, %8 ], [ %7, %4 ], [ 4398046512104, %0 ], [ %., %60 ], [ 0, %68 ], [ 0, %84 ], [ 0, %82 ]
<   %99 = trunc i64 %val.0 to i32
<   %100 = getelementptr inbounds %struct.CPUX86State* %98, i64 0, i32 0, i64 0
<   store i32 %99, i32* %100, align 4
<   %101 = lshr i64 %val.0, 32
<   %102 = trunc i64 %101 to i32
<   %103 = load %struct.CPUX86State** @env, align 8
<   %104 = getelementptr inbounds %struct.CPUX86State* %103, i64 0, i32 0, i64 2
<   store i32 %102, i32* %104, align 4
<   ret void
---
> ; <label>:365                                     ; preds = %360
>   %366 = load i64* %pSig64, align 8
>   %367 = load i64* %cSig64, align 8
>   %368 = sub i64 %366, %367
>   store i64 %368, i64* %zSig64, align 8
>   br label %397
> 
> ; <label>:369                                     ; preds = %360
>   %370 = load i64* %pSig64, align 8
>   %371 = load i64* %cSig64, align 8
>   %372 = icmp ult i64 %370, %371
>   br i1 %372, label %373, label %381
> 
> ; <label>:373                                     ; preds = %369
>   %374 = load i64* %cSig64, align 8
>   %375 = load i64* %pSig64, align 8
>   %376 = sub i64 %374, %375
>   store i64 %376, i64* %zSig64, align 8
>   %377 = load i8* %zSign, align 1
>   %378 = zext i8 %377 to i32
>   %379 = xor i32 %378, 1
>   %380 = trunc i32 %379 to i8
>   store i8 %380, i8* %zSign, align 1
>   br label %396
> 
> ; <label>:381                                     ; preds = %369
>   %382 = load i8* %signflip, align 1
>   store i8 %382, i8* %zSign, align 1
>   %383 = load %struct.float_status** %6, align 4
>   %384 = getelementptr inbounds %struct.float_status* %383, i32 0, i32 1
>   %385 = load i8* %384, align 1
>   %386 = sext i8 %385 to i32
>   %387 = icmp eq i32 %386, 1
>   br i1 %387, label %388, label %393
> 
> ; <label>:388                                     ; preds = %381
>   %389 = load i8* %zSign, align 1
>   %390 = zext i8 %389 to i32
>   %391 = xor i32 %390, 1
>   %392 = trunc i32 %391 to i8
>   store i8 %392, i8* %zSign, align 1
>   br label %393
> 
> ; <label>:393                                     ; preds = %388, %381
>   %394 = load i8* %zSign, align 1
>   %395 = call i32 @packFloat32(i8 zeroext %394, i32 0, i32 0)
>   store i32 %395, i32* %1
>   br label %421
> 
> ; <label>:396                                     ; preds = %373
>   br label %397
> 
> ; <label>:397                                     ; preds = %396, %365
>   br label %398
> 
> ; <label>:398                                     ; preds = %397, %348
>   br label %399
> 
> ; <label>:399                                     ; preds = %398, %338
>   %400 = load i32* %zExp, align 4
>   %401 = add nsw i32 %400, -1
>   store i32 %401, i32* %zExp, align 4
>   %402 = load i64* %zSig64, align 8
>   %403 = call signext i8 @countLeadingZeros64(i64 %402)
>   %404 = sext i8 %403 to i32
>   %405 = sub nsw i32 %404, 1
>   store i32 %405, i32* %shiftcount, align 4
>   %406 = load i32* %shiftcount, align 4
>   %407 = load i64* %zSig64, align 8
>   %408 = zext i32 %406 to i64
>   %409 = shl i64 %407, %408
>   store i64 %409, i64* %zSig64, align 8
>   %410 = load i32* %shiftcount, align 4
>   %411 = load i32* %zExp, align 4
>   %412 = sub nsw i32 %411, %410
>   store i32 %412, i32* %zExp, align 4
>   br label %413
> 
> ; <label>:413                                     ; preds = %399, %334
>   %414 = load i64* %zSig64, align 8
>   call void @shift64RightJamming(i64 %414, i32 32, i64* %zSig64)
>   %415 = load i8* %zSign, align 1
>   %416 = load i32* %zExp, align 4
>   %417 = load i64* %zSig64, align 8
>   %418 = trunc i64 %417 to i32
>   %419 = load %struct.float_status** %6, align 4
>   %420 = call i32 @roundAndPackFloat32(i8 zeroext %415, i32 %416, i32 %418, %struct.float_status* %419)
>   store i32 %420, i32* %1
>   br label %421
> 
> ; <label>:421                                     ; preds = %413, %393, %279, %227, %217, %204, %170, %159, %157, %90, %80
>   %422 = load i32* %1
>   ret i32 %422
11997,12037c9116,9168
< declare i64 @cpu_get_apic_base(%struct.DeviceState*)
< 
< define i32 @helper_lsl(i32 %selector1) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = and i32 %selector1, 65532
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %load_segment.exit.thread18, label %7
< 
< ; <label>:7                                       ; preds = %0
<   %8 = and i32 %selector1, 65528
<   %9 = and i32 %selector1, 4
<   %10 = icmp eq i32 %9, 0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 11
<   %12 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 13
<   %dt.0.i = select i1 %10, %struct.SegmentCache* %12, %struct.SegmentCache* %11
<   %13 = or i32 %8, 7
<   %14 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 2
<   %15 = load i32* %14, align 4
<   %16 = icmp ugt i32 %13, %15
<   br i1 %16, label %load_segment.exit.thread18, label %17
< 
< ; <label>:17                                      ; preds = %7
<   %18 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 1
<   %19 = load i32* %18, align 4
<   %20 = add i32 %19, %8
<   %21 = tail call fastcc i32 @ldl_kernel(i32 %20) nounwind
<   %22 = add i32 %20, 4
<   %23 = tail call fastcc i32 @ldl_kernel(i32 %22) nounwind
<   %24 = and i32 %selector1, 3
<   %25 = lshr i32 %23, 13
<   %26 = and i32 %25, 3
<   %27 = load %struct.CPUX86State** @env, align 8
<   %28 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 8
<   %29 = load i32* %28, align 4
<   %30 = and i32 %29, 3
<   %31 = and i32 %23, 4096
<   %32 = icmp eq i32 %31, 0
<   br i1 %32, label %39, label %33
---
> define internal i32 @propagateFloat32MulAddNaN(i32 %a, i32 %b, i32 %c, i8 zeroext %infzero, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca i32, align 4
>   %5 = alloca i8, align 1
>   %6 = alloca %struct.float_status*, align 4
>   %aIsQuietNaN = alloca i8, align 1
>   %aIsSignalingNaN = alloca i8, align 1
>   %bIsQuietNaN = alloca i8, align 1
>   %bIsSignalingNaN = alloca i8, align 1
>   %cIsQuietNaN = alloca i8, align 1
>   %cIsSignalingNaN = alloca i8, align 1
>   %which = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store i32 %c, i32* %4, align 4
>   store i8 %infzero, i8* %5, align 1
>   store %struct.float_status* %status, %struct.float_status** %6, align 4
>   %7 = load i32* %2, align 4
>   %8 = call i32 @float32_is_quiet_nan(i32 %7)
>   %9 = trunc i32 %8 to i8
>   store i8 %9, i8* %aIsQuietNaN, align 1
>   %10 = load i32* %2, align 4
>   %11 = call i32 @float32_is_signaling_nan(i32 %10)
>   %12 = trunc i32 %11 to i8
>   store i8 %12, i8* %aIsSignalingNaN, align 1
>   %13 = load i32* %3, align 4
>   %14 = call i32 @float32_is_quiet_nan(i32 %13)
>   %15 = trunc i32 %14 to i8
>   store i8 %15, i8* %bIsQuietNaN, align 1
>   %16 = load i32* %3, align 4
>   %17 = call i32 @float32_is_signaling_nan(i32 %16)
>   %18 = trunc i32 %17 to i8
>   store i8 %18, i8* %bIsSignalingNaN, align 1
>   %19 = load i32* %4, align 4
>   %20 = call i32 @float32_is_quiet_nan(i32 %19)
>   %21 = trunc i32 %20 to i8
>   store i8 %21, i8* %cIsQuietNaN, align 1
>   %22 = load i32* %4, align 4
>   %23 = call i32 @float32_is_signaling_nan(i32 %22)
>   %24 = trunc i32 %23 to i8
>   store i8 %24, i8* %cIsSignalingNaN, align 1
>   %25 = load i8* %aIsSignalingNaN, align 1
>   %26 = zext i8 %25 to i32
>   %27 = load i8* %bIsSignalingNaN, align 1
>   %28 = zext i8 %27 to i32
>   %29 = or i32 %26, %28
>   %30 = load i8* %cIsSignalingNaN, align 1
>   %31 = zext i8 %30 to i32
>   %32 = or i32 %29, %31
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
12039,12042c9170,9173
< ; <label>:33                                      ; preds = %17
<   %34 = and i32 %23, 3072
<   %35 = icmp eq i32 %34, 3072
<   br i1 %35, label %48, label %36
---
> ; <label>:34                                      ; preds = %0
>   %35 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
12044,12058c9175,9202
< ; <label>:36                                      ; preds = %33
<   %37 = icmp ult i32 %26, %30
<   %38 = icmp ult i32 %26, %24
<   %or.cond11 = or i1 %37, %38
<   br i1 %or.cond11, label %load_segment.exit.thread18, label %48
< 
< ; <label>:39                                      ; preds = %17
<   %40 = lshr i32 %23, 8
<   %41 = and i32 %40, 15
<   switch i32 %41, label %load_segment.exit.thread18 [
<     i32 1, label %42
<     i32 2, label %42
<     i32 3, label %42
<     i32 9, label %42
<     i32 11, label %42
---
> ; <label>:36                                      ; preds = %34, %0
>   %37 = load i8* %aIsQuietNaN, align 1
>   %38 = load i8* %aIsSignalingNaN, align 1
>   %39 = load i8* %bIsQuietNaN, align 1
>   %40 = load i8* %bIsSignalingNaN, align 1
>   %41 = load i8* %cIsQuietNaN, align 1
>   %42 = load i8* %cIsSignalingNaN, align 1
>   %43 = load i8* %5, align 1
>   %44 = load %struct.float_status** %6, align 4
>   %45 = call i32 @pickNaNMulAdd(i8 zeroext %37, i8 zeroext %38, i8 zeroext %39, i8 zeroext %40, i8 zeroext %41, i8 zeroext %42, i8 zeroext %43, %struct.float_status* %44)
>   store i32 %45, i32* %which, align 4
>   %46 = load %struct.float_status** %6, align 4
>   %47 = getelementptr inbounds %struct.float_status* %46, i32 0, i32 6
>   %48 = load i8* %47, align 1
>   %49 = icmp ne i8 %48, 0
>   br i1 %49, label %50, label %51
> 
> ; <label>:50                                      ; preds = %36
>   store i32 -4194304, i32* %1
>   br label %64
> 
> ; <label>:51                                      ; preds = %36
>   %52 = load i32* %which, align 4
>   switch i32 %52, label %63 [
>     i32 0, label %53
>     i32 1, label %56
>     i32 2, label %59
>     i32 3, label %62
12061,12072c9205,9221
< ; <label>:42                                      ; preds = %39, %39, %39, %39, %39
<   %43 = icmp ult i32 %26, %30
<   %44 = icmp ult i32 %26, %24
<   %or.cond12 = or i1 %43, %44
<   br i1 %or.cond12, label %load_segment.exit.thread18, label %48
< 
< load_segment.exit.thread18:                       ; preds = %42, %39, %36, %7, %0
<   %45 = phi %struct.CPUX86State* [ %1, %7 ], [ %27, %42 ], [ %27, %39 ], [ %27, %36 ], [ %1, %0 ]
<   %46 = and i32 %4, -65
<   %47 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 2
<   store i32 %46, i32* %47, align 4
<   br label %59
---
> ; <label>:53                                      ; preds = %51
>   %54 = load i32* %2, align 4
>   %55 = call i32 @float32_maybe_silence_nan(i32 %54)
>   store i32 %55, i32* %1
>   br label %64
> 
> ; <label>:56                                      ; preds = %51
>   %57 = load i32* %3, align 4
>   %58 = call i32 @float32_maybe_silence_nan(i32 %57)
>   store i32 %58, i32* %1
>   br label %64
> 
> ; <label>:59                                      ; preds = %51
>   %60 = load i32* %4, align 4
>   %61 = call i32 @float32_maybe_silence_nan(i32 %60)
>   store i32 %61, i32* %1
>   br label %64
12074,12080c9223,9224
< ; <label>:48                                      ; preds = %42, %36, %33
<   %49 = and i32 %21, 65535
<   %50 = and i32 %23, 983040
<   %51 = or i32 %50, %49
<   %52 = and i32 %23, 8388608
<   %53 = icmp eq i32 %52, 0
<   br i1 %53, label %get_seg_limit.exit, label %54
---
> ; <label>:62                                      ; preds = %51
>   br label %63
12082,12092c9226,9228
< ; <label>:54                                      ; preds = %48
<   %55 = shl nuw i32 %51, 12
<   %56 = or i32 %55, 4095
<   br label %get_seg_limit.exit
< 
< get_seg_limit.exit:                               ; preds = %54, %48
<   %limit.0.i = phi i32 [ %56, %54 ], [ %51, %48 ]
<   %57 = or i32 %4, 64
<   %58 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 2
<   store i32 %57, i32* %58, align 4
<   br label %59
---
> ; <label>:63                                      ; preds = %62, %51
>   store i32 -4194304, i32* %1
>   br label %64
12094,12096c9230,9232
< ; <label>:59                                      ; preds = %get_seg_limit.exit, %load_segment.exit.thread18
<   %.0 = phi i32 [ 0, %load_segment.exit.thread18 ], [ %limit.0.i, %get_seg_limit.exit ]
<   ret i32 %.0
---
> ; <label>:64                                      ; preds = %63, %59, %56, %53, %50
>   %65 = load i32* %1
>   ret i32 %65
12099,12106c9235,9263
< define i32 @helper_lar(i32 %selector1) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = and i32 %selector1, 65532
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %load_segment.exit.thread16, label %7
---
> define internal i32 @float32_sqrt(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %zSig = alloca i32, align 4
>   %rem = alloca i64, align 8
>   %term = alloca i64, align 8
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i32 @float32_squash_input_denormal(i32 %4, %struct.float_status* %5)
>   store i32 %6, i32* %2, align 4
>   %7 = load i32* %2, align 4
>   %8 = call i32 @extractFloat32Frac(i32 %7)
>   store i32 %8, i32* %aSig, align 4
>   %9 = load i32* %2, align 4
>   %10 = call i32 @extractFloat32Exp(i32 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i32* %2, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 255
>   br i1 %14, label %15, label %29
12108,12119c9265,9275
< ; <label>:7                                       ; preds = %0
<   %8 = and i32 %selector1, 65528
<   %9 = and i32 %selector1, 4
<   %10 = icmp eq i32 %9, 0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 11
<   %12 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 13
<   %dt.0.i = select i1 %10, %struct.SegmentCache* %12, %struct.SegmentCache* %11
<   %13 = or i32 %8, 7
<   %14 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 2
<   %15 = load i32* %14, align 4
<   %16 = icmp ugt i32 %13, %15
<   br i1 %16, label %load_segment.exit.thread16, label %17
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %aSig, align 4
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %18, label %22
> 
> ; <label>:18                                      ; preds = %15
>   %19 = load i32* %2, align 4
>   %20 = load %struct.float_status** %3, align 4
>   %21 = call i32 @propagateFloat32NaN(i32 %19, i32 0, %struct.float_status* %20)
>   store i32 %21, i32* %1
>   br label %109
12121,12137c9277,9285
< ; <label>:17                                      ; preds = %7
<   %18 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 1
<   %19 = load i32* %18, align 4
<   %20 = add i32 %19, %8
<   %21 = tail call fastcc i32 @ldl_kernel(i32 %20) nounwind
<   %22 = add i32 %20, 4
<   %23 = tail call fastcc i32 @ldl_kernel(i32 %22) nounwind
<   %24 = and i32 %selector1, 3
<   %25 = lshr i32 %23, 13
<   %26 = and i32 %25, 3
<   %27 = load %struct.CPUX86State** @env, align 8
<   %28 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 8
<   %29 = load i32* %28, align 4
<   %30 = and i32 %29, 3
<   %31 = and i32 %23, 4096
<   %32 = icmp eq i32 %31, 0
<   br i1 %32, label %39, label %33
---
> ; <label>:22                                      ; preds = %15
>   %23 = load i8* %aSign, align 1
>   %24 = icmp ne i8 %23, 0
>   br i1 %24, label %27, label %25
> 
> ; <label>:25                                      ; preds = %22
>   %26 = load i32* %2, align 4
>   store i32 %26, i32* %1
>   br label %109
12139,12142c9287,9291
< ; <label>:33                                      ; preds = %17
<   %34 = and i32 %23, 3072
<   %35 = icmp eq i32 %34, 3072
<   br i1 %35, label %48, label %36
---
> ; <label>:27                                      ; preds = %22
>   %28 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %28)
>   store i32 -4194304, i32* %1
>   br label %109
12144,12162c9293,9296
< ; <label>:36                                      ; preds = %33
<   %37 = icmp ult i32 %26, %30
<   %38 = icmp ult i32 %26, %24
<   %or.cond11 = or i1 %37, %38
<   br i1 %or.cond11, label %load_segment.exit.thread16, label %48
< 
< ; <label>:39                                      ; preds = %17
<   %40 = lshr i32 %23, 8
<   %41 = and i32 %40, 15
<   switch i32 %41, label %load_segment.exit.thread16 [
<     i32 1, label %42
<     i32 2, label %42
<     i32 3, label %42
<     i32 4, label %42
<     i32 5, label %42
<     i32 9, label %42
<     i32 11, label %42
<     i32 12, label %42
<   ]
---
> ; <label>:29                                      ; preds = %0
>   %30 = load i8* %aSign, align 1
>   %31 = icmp ne i8 %30, 0
>   br i1 %31, label %32, label %41
12164,12175c9298,9303
< ; <label>:42                                      ; preds = %39, %39, %39, %39, %39, %39, %39, %39
<   %43 = icmp ult i32 %26, %30
<   %44 = icmp ult i32 %26, %24
<   %or.cond12 = or i1 %43, %44
<   br i1 %or.cond12, label %load_segment.exit.thread16, label %48
< 
< load_segment.exit.thread16:                       ; preds = %42, %39, %36, %7, %0
<   %45 = phi %struct.CPUX86State* [ %1, %7 ], [ %27, %42 ], [ %27, %39 ], [ %27, %36 ], [ %1, %0 ]
<   %46 = and i32 %4, -65
<   %47 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 2
<   store i32 %46, i32* %47, align 4
<   br label %52
---
> ; <label>:32                                      ; preds = %29
>   %33 = load i32* %aExp, align 4
>   %34 = load i32* %aSig, align 4
>   %35 = or i32 %33, %34
>   %36 = icmp eq i32 %35, 0
>   br i1 %36, label %37, label %39
12177,12182c9305,9308
< ; <label>:48                                      ; preds = %42, %36, %33
<   %49 = or i32 %4, 64
<   %50 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 2
<   store i32 %49, i32* %50, align 4
<   %51 = and i32 %23, 15793920
<   br label %52
---
> ; <label>:37                                      ; preds = %32
>   %38 = load i32* %2, align 4
>   store i32 %38, i32* %1
>   br label %109
12184,12187c9310,9314
< ; <label>:52                                      ; preds = %48, %load_segment.exit.thread16
<   %.0 = phi i32 [ 0, %load_segment.exit.thread16 ], [ %51, %48 ]
<   ret i32 %.0
< }
---
> ; <label>:39                                      ; preds = %32
>   %40 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %40)
>   store i32 -4194304, i32* %1
>   br label %109
12189,12196c9316,9319
< define void @helper_verr(i32 %selector1) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = and i32 %selector1, 65532
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %load_segment.exit.thread12, label %7
---
> ; <label>:41                                      ; preds = %29
>   %42 = load i32* %aExp, align 4
>   %43 = icmp eq i32 %42, 0
>   br i1 %43, label %44, label %50
12198,12209c9321,9324
< ; <label>:7                                       ; preds = %0
<   %8 = and i32 %selector1, 65528
<   %9 = and i32 %selector1, 4
<   %10 = icmp eq i32 %9, 0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 11
<   %12 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 13
<   %dt.0.i = select i1 %10, %struct.SegmentCache* %12, %struct.SegmentCache* %11
<   %13 = or i32 %8, 7
<   %14 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 2
<   %15 = load i32* %14, align 4
<   %16 = icmp ugt i32 %13, %15
<   br i1 %16, label %load_segment.exit.thread12, label %17
---
> ; <label>:44                                      ; preds = %41
>   %45 = load i32* %aSig, align 4
>   %46 = icmp eq i32 %45, 0
>   br i1 %46, label %47, label %48
12211,12236c9326,9328
< ; <label>:17                                      ; preds = %7
<   %18 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 1
<   %19 = load i32* %18, align 4
<   %20 = add i32 %19, %8
<   %21 = tail call fastcc i32 @ldl_kernel(i32 %20) nounwind
<   %22 = add i32 %20, 4
<   %23 = tail call fastcc i32 @ldl_kernel(i32 %22) nounwind
<   %24 = and i32 %23, 4096
<   %25 = icmp eq i32 %24, 0
<   br i1 %25, label %.load_segment.exit.thread12_crit_edge, label %26
< 
< .load_segment.exit.thread12_crit_edge:            ; preds = %17
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %load_segment.exit.thread12
< 
< ; <label>:26                                      ; preds = %17
<   %27 = and i32 %selector1, 3
<   %28 = lshr i32 %23, 13
<   %29 = and i32 %28, 3
<   %30 = load %struct.CPUX86State** @env, align 8
<   %31 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 8
<   %32 = load i32* %31, align 4
<   %33 = and i32 %32, 3
<   %34 = and i32 %23, 2048
<   %35 = icmp eq i32 %34, 0
<   br i1 %35, label %45, label %36
---
> ; <label>:47                                      ; preds = %44
>   store i32 0, i32* %1
>   br label %109
12238,12241c9330,9333
< ; <label>:36                                      ; preds = %26
<   %37 = and i32 %23, 512
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %load_segment.exit.thread12, label %39
---
> ; <label>:48                                      ; preds = %44
>   %49 = load i32* %aSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %49, i32* %aExp, i32* %aSig)
>   br label %50
12243,12246c9335,9358
< ; <label>:39                                      ; preds = %36
<   %40 = and i32 %23, 1024
<   %41 = icmp eq i32 %40, 0
<   br i1 %41, label %42, label %51
---
> ; <label>:50                                      ; preds = %48, %41
>   %51 = load i32* %aExp, align 4
>   %52 = sub nsw i32 %51, 127
>   %53 = ashr i32 %52, 1
>   %54 = add nsw i32 %53, 126
>   store i32 %54, i32* %zExp, align 4
>   %55 = load i32* %aSig, align 4
>   %56 = or i32 %55, 8388608
>   %57 = shl i32 %56, 8
>   store i32 %57, i32* %aSig, align 4
>   %58 = load i32* %aExp, align 4
>   %59 = load i32* %aSig, align 4
>   %60 = call i32 @estimateSqrt32(i32 %58, i32 %59)
>   %61 = add i32 %60, 2
>   store i32 %61, i32* %zSig, align 4
>   %62 = load i32* %zSig, align 4
>   %63 = and i32 %62, 127
>   %64 = icmp ule i32 %63, 5
>   br i1 %64, label %65, label %102
> 
> ; <label>:65                                      ; preds = %50
>   %66 = load i32* %zSig, align 4
>   %67 = icmp ult i32 %66, 2
>   br i1 %67, label %68, label %69
12248,12265c9360,9362
< ; <label>:42                                      ; preds = %39
<   %43 = icmp ult i32 %29, %33
<   %44 = icmp ult i32 %29, %27
<   %or.cond = or i1 %43, %44
<   br i1 %or.cond, label %load_segment.exit.thread12, label %51
< 
< ; <label>:45                                      ; preds = %26
<   %46 = icmp ult i32 %29, %33
<   %47 = icmp ult i32 %29, %27
<   %or.cond9 = or i1 %46, %47
<   br i1 %or.cond9, label %load_segment.exit.thread12, label %51
< 
< load_segment.exit.thread12:                       ; preds = %45, %42, %36, %.load_segment.exit.thread12_crit_edge, %7, %0
<   %48 = phi %struct.CPUX86State* [ %.pre, %.load_segment.exit.thread12_crit_edge ], [ %1, %7 ], [ %30, %36 ], [ %30, %45 ], [ %30, %42 ], [ %1, %0 ]
<   %49 = and i32 %4, -65
<   %50 = getelementptr inbounds %struct.CPUX86State* %48, i64 0, i32 2
<   store i32 %49, i32* %50, align 4
<   br label %54
---
> ; <label>:68                                      ; preds = %65
>   store i32 2147483647, i32* %zSig, align 4
>   br label %104
12267,12271c9364,9422
< ; <label>:51                                      ; preds = %45, %42, %39
<   %52 = or i32 %4, 64
<   %53 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 2
<   store i32 %52, i32* %53, align 4
<   br label %54
---
> ; <label>:69                                      ; preds = %65
>   %70 = load i32* %aExp, align 4
>   %71 = and i32 %70, 1
>   %72 = load i32* %aSig, align 4
>   %73 = lshr i32 %72, %71
>   store i32 %73, i32* %aSig, align 4
>   %74 = load i32* %zSig, align 4
>   %75 = zext i32 %74 to i64
>   %76 = load i32* %zSig, align 4
>   %77 = zext i32 %76 to i64
>   %78 = mul i64 %75, %77
>   store i64 %78, i64* %term, align 8
>   %79 = load i32* %aSig, align 4
>   %80 = zext i32 %79 to i64
>   %81 = shl i64 %80, 32
>   %82 = load i64* %term, align 8
>   %83 = sub i64 %81, %82
>   store i64 %83, i64* %rem, align 8
>   br label %84
> 
> ; <label>:84                                      ; preds = %87, %69
>   %85 = load i64* %rem, align 8
>   %86 = icmp slt i64 %85, 0
>   br i1 %86, label %87, label %96
> 
> ; <label>:87                                      ; preds = %84
>   %88 = load i32* %zSig, align 4
>   %89 = add i32 %88, -1
>   store i32 %89, i32* %zSig, align 4
>   %90 = load i32* %zSig, align 4
>   %91 = zext i32 %90 to i64
>   %92 = shl i64 %91, 1
>   %93 = or i64 %92, 1
>   %94 = load i64* %rem, align 8
>   %95 = add i64 %94, %93
>   store i64 %95, i64* %rem, align 8
>   br label %84
> 
> ; <label>:96                                      ; preds = %84
>   %97 = load i64* %rem, align 8
>   %98 = icmp ne i64 %97, 0
>   %99 = zext i1 %98 to i32
>   %100 = load i32* %zSig, align 4
>   %101 = or i32 %100, %99
>   store i32 %101, i32* %zSig, align 4
>   br label %102
> 
> ; <label>:102                                     ; preds = %96, %50
>   %103 = load i32* %zSig, align 4
>   call void @shift32RightJamming(i32 %103, i32 1, i32* %zSig)
>   br label %104
> 
> ; <label>:104                                     ; preds = %102, %68
>   %105 = load i32* %zExp, align 4
>   %106 = load i32* %zSig, align 4
>   %107 = load %struct.float_status** %3, align 4
>   %108 = call i32 @roundAndPackFloat32(i8 zeroext 0, i32 %105, i32 %106, %struct.float_status* %107)
>   store i32 %108, i32* %1
>   br label %109
12273,12274c9424,9426
< ; <label>:54                                      ; preds = %51, %load_segment.exit.thread12
<   ret void
---
> ; <label>:109                                     ; preds = %104, %47, %39, %37, %27, %25, %18
>   %110 = load i32* %1
>   ret i32 %110
12277,12284c9429,9445
< define void @helper_verw(i32 %selector1) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = and i32 %selector1, 65532
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %load_segment.exit.thread7, label %7
---
> define internal i32 @estimateSqrt32(i32 %aExp, i32 %a) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %index = alloca i8, align 1
>   %z = alloca i32, align 4
>   store i32 %aExp, i32* %2, align 4
>   store i32 %a, i32* %3, align 4
>   %4 = load i32* %3, align 4
>   %5 = lshr i32 %4, 27
>   %6 = and i32 %5, 15
>   %7 = trunc i32 %6 to i8
>   store i8 %7, i8* %index, align 1
>   %8 = load i32* %2, align 4
>   %9 = and i32 %8, 1
>   %10 = icmp ne i32 %9, 0
>   br i1 %10, label %11, label %30
12286,12297c9447,9469
< ; <label>:7                                       ; preds = %0
<   %8 = and i32 %selector1, 65528
<   %9 = and i32 %selector1, 4
<   %10 = icmp eq i32 %9, 0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 11
<   %12 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 13
<   %dt.0.i = select i1 %10, %struct.SegmentCache* %12, %struct.SegmentCache* %11
<   %13 = or i32 %8, 7
<   %14 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 2
<   %15 = load i32* %14, align 4
<   %16 = icmp ugt i32 %13, %15
<   br i1 %16, label %load_segment.exit.thread7, label %17
---
> ; <label>:11                                      ; preds = %0
>   %12 = load i32* %3, align 4
>   %13 = lshr i32 %12, 17
>   %14 = add i32 16384, %13
>   %15 = load i8* %index, align 1
>   %16 = sext i8 %15 to i32
>   %17 = getelementptr inbounds [16 x i16]* @estimateSqrt32.sqrtOddAdjustments, i32 0, i32 %16
>   %18 = load i16* %17, align 2
>   %19 = zext i16 %18 to i32
>   %20 = sub i32 %14, %19
>   store i32 %20, i32* %z, align 4
>   %21 = load i32* %3, align 4
>   %22 = load i32* %z, align 4
>   %23 = udiv i32 %21, %22
>   %24 = shl i32 %23, 14
>   %25 = load i32* %z, align 4
>   %26 = shl i32 %25, 15
>   %27 = add i32 %24, %26
>   store i32 %27, i32* %z, align 4
>   %28 = load i32* %3, align 4
>   %29 = lshr i32 %28, 1
>   store i32 %29, i32* %3, align 4
>   br label %60
12299,12320c9471,9490
< ; <label>:17                                      ; preds = %7
<   %18 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 1
<   %19 = load i32* %18, align 4
<   %20 = add i32 %19, %8
<   %21 = tail call fastcc i32 @ldl_kernel(i32 %20) nounwind
<   %22 = add i32 %20, 4
<   %23 = tail call fastcc i32 @ldl_kernel(i32 %22) nounwind
<   %24 = and i32 %23, 4096
<   %25 = icmp eq i32 %24, 0
<   br i1 %25, label %.load_segment.exit.thread7_crit_edge, label %26
< 
< .load_segment.exit.thread7_crit_edge:             ; preds = %17
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %load_segment.exit.thread7
< 
< ; <label>:26                                      ; preds = %17
<   %27 = lshr i32 %23, 13
<   %28 = and i32 %27, 3
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = and i32 %23, 2048
<   %31 = icmp eq i32 %30, 0
<   br i1 %31, label %32, label %load_segment.exit.thread7
---
> ; <label>:30                                      ; preds = %0
>   %31 = load i32* %3, align 4
>   %32 = lshr i32 %31, 17
>   %33 = add i32 32768, %32
>   %34 = load i8* %index, align 1
>   %35 = sext i8 %34 to i32
>   %36 = getelementptr inbounds [16 x i16]* @estimateSqrt32.sqrtEvenAdjustments, i32 0, i32 %35
>   %37 = load i16* %36, align 2
>   %38 = zext i16 %37 to i32
>   %39 = sub i32 %33, %38
>   store i32 %39, i32* %z, align 4
>   %40 = load i32* %3, align 4
>   %41 = load i32* %z, align 4
>   %42 = udiv i32 %40, %41
>   %43 = load i32* %z, align 4
>   %44 = add i32 %42, %43
>   store i32 %44, i32* %z, align 4
>   %45 = load i32* %z, align 4
>   %46 = icmp ule i32 131072, %45
>   br i1 %46, label %47, label %48
12322,12330c9492,9493
< ; <label>:32                                      ; preds = %26
<   %33 = and i32 %selector1, 3
<   %34 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 8
<   %35 = load i32* %34, align 4
<   %36 = and i32 %35, 3
<   %37 = icmp ult i32 %28, %36
<   %38 = icmp ult i32 %28, %33
<   %or.cond = or i1 %37, %38
<   br i1 %or.cond, label %load_segment.exit.thread7, label %39
---
> ; <label>:47                                      ; preds = %30
>   br label %51
12332,12335c9495,9498
< ; <label>:39                                      ; preds = %32
<   %40 = and i32 %23, 512
<   %41 = icmp eq i32 %40, 0
<   br i1 %41, label %load_segment.exit.thread7, label %45
---
> ; <label>:48                                      ; preds = %30
>   %49 = load i32* %z, align 4
>   %50 = shl i32 %49, 15
>   br label %51
12337,12342c9500,9512
< load_segment.exit.thread7:                        ; preds = %39, %32, %26, %.load_segment.exit.thread7_crit_edge, %7, %0
<   %42 = phi %struct.CPUX86State* [ %.pre, %.load_segment.exit.thread7_crit_edge ], [ %1, %7 ], [ %29, %39 ], [ %29, %26 ], [ %29, %32 ], [ %1, %0 ]
<   %43 = and i32 %4, -65
<   %44 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 2
<   store i32 %43, i32* %44, align 4
<   br label %48
---
> ; <label>:51                                      ; preds = %48, %47
>   %52 = phi i32 [ -32768, %47 ], [ %50, %48 ]
>   store i32 %52, i32* %z, align 4
>   %53 = load i32* %z, align 4
>   %54 = load i32* %3, align 4
>   %55 = icmp ule i32 %53, %54
>   br i1 %55, label %56, label %59
> 
> ; <label>:56                                      ; preds = %51
>   %57 = load i32* %3, align 4
>   %58 = ashr i32 %57, 1
>   store i32 %58, i32* %1
>   br label %71
12344,12348c9514,9515
< ; <label>:45                                      ; preds = %39
<   %46 = or i32 %4, 64
<   %47 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 2
<   store i32 %46, i32* %47, align 4
<   br label %48
---
> ; <label>:59                                      ; preds = %51
>   br label %60
12350,12352c9517,9529
< ; <label>:48                                      ; preds = %45, %load_segment.exit.thread7
<   ret void
< }
---
> ; <label>:60                                      ; preds = %59, %11
>   %61 = load i32* %3, align 4
>   %62 = zext i32 %61 to i64
>   %63 = shl i64 %62, 31
>   %64 = load i32* %z, align 4
>   %65 = zext i32 %64 to i64
>   %66 = udiv i64 %63, %65
>   %67 = trunc i64 %66 to i32
>   %68 = load i32* %z, align 4
>   %69 = lshr i32 %68, 1
>   %70 = add i32 %67, %69
>   store i32 %70, i32* %1
>   br label %71
12354,12364c9531,9533
< define void @helper_flds_FT0(i32 %val) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %3 = tail call { i64, i16 } @float32_to_floatx80(i32 %val, %struct.float_status* %2) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %3, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %3, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   store i16 %.fca.1.extract, i16* %.sroa.14.8..idx5, align 1
<   ret void
---
> ; <label>:71                                      ; preds = %60, %56
>   %72 = load i32* %1
>   ret i32 %72
12367c9536,9546
< declare { i64, i16 } @float32_to_floatx80(i32, %struct.float_status*)
---
> define internal void @shift32RightJamming(i32 %a, i32 %count, i32* %zPtr) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32*, align 4
>   %z = alloca i32, align 4
>   store i32 %a, i32* %1, align 4
>   store i32 %count, i32* %2, align 4
>   store i32* %zPtr, i32** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = icmp eq i32 %4, 0
>   br i1 %5, label %6, label %8
12369c9548,9551
< declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind
---
> ; <label>:6                                       ; preds = %0
>   %7 = load i32* %1, align 4
>   store i32 %7, i32* %z, align 4
>   br label %28
12371,12382c9553,9556
< define void @helper_fldl_FT0(i64 %val) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %3 = tail call { i64, i16 } @float64_to_floatx80(i64 %val, %struct.float_status* %2) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %3, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %3, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   store i16 %.fca.1.extract, i16* %.sroa.14.8..idx5, align 1
<   ret void
< }
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i32* %2, align 4
>   %10 = icmp slt i32 %9, 32
>   br i1 %10, label %11, label %23
12384c9558,9571
< declare { i64, i16 } @float64_to_floatx80(i64, %struct.float_status*)
---
> ; <label>:11                                      ; preds = %8
>   %12 = load i32* %1, align 4
>   %13 = load i32* %2, align 4
>   %14 = lshr i32 %12, %13
>   %15 = load i32* %1, align 4
>   %16 = load i32* %2, align 4
>   %17 = sub nsw i32 0, %16
>   %18 = and i32 %17, 31
>   %19 = shl i32 %15, %18
>   %20 = icmp ne i32 %19, 0
>   %21 = zext i1 %20 to i32
>   %22 = or i32 %14, %21
>   store i32 %22, i32* %z, align 4
>   br label %27
12386,12397c9573,9578
< define void @helper_fildl_FT0(i32 %val) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %3 = tail call { i64, i16 } @int32_to_floatx80(i32 %val, %struct.float_status* %2) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %3, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %3, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   store i16 %.fca.1.extract, i16* %.sroa.14.8..idx5, align 1
<   ret void
< }
---
> ; <label>:23                                      ; preds = %8
>   %24 = load i32* %1, align 4
>   %25 = icmp ne i32 %24, 0
>   %26 = zext i1 %25 to i32
>   store i32 %26, i32* %z, align 4
>   br label %27
12399c9580,9581
< declare { i64, i16 } @int32_to_floatx80(i32, %struct.float_status*)
---
> ; <label>:27                                      ; preds = %23, %11
>   br label %28
12401,12422c9583,9586
< define void @helper_flds_ST0(i32 %val) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 7
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %8 = tail call { i64, i16 } @float32_to_floatx80(i32 %val, %struct.float_status* %7) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %8, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %8, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.14.8..idx5 to i16*
<   store i16 %.fca.1.extract, i16* %9, align 1
<   %10 = load %struct.CPUX86State** @env, align 8
<   %11 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 17
<   store i32 %5, i32* %11, align 4
<   %12 = load %struct.CPUX86State** @env, align 8
<   %13 = getelementptr inbounds %struct.CPUX86State* %12, i64 0, i32 20, i64 %6
<   store i8 0, i8* %13, align 1
---
> ; <label>:28                                      ; preds = %27, %6
>   %29 = load i32* %z, align 4
>   %30 = load i32** %3, align 4
>   store i32 %29, i32* %30, align 4
12426,12449c9590,9619
< define void @helper_fldl_ST0(i64 %val) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 7
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %8 = tail call { i64, i16 } @float64_to_floatx80(i64 %val, %struct.float_status* %7) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %8, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %8, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.14.8..idx5 to i16*
<   store i16 %.fca.1.extract, i16* %9, align 1
<   %10 = load %struct.CPUX86State** @env, align 8
<   %11 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 17
<   store i32 %5, i32* %11, align 4
<   %12 = load %struct.CPUX86State** @env, align 8
<   %13 = getelementptr inbounds %struct.CPUX86State* %12, i64 0, i32 20, i64 %6
<   store i8 0, i8* %13, align 1
<   ret void
< }
---
> define internal i32 @float32_exp2(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %r = alloca i64, align 8
>   %x = alloca i64, align 8
>   %xn = alloca i64, align 8
>   %i = alloca i32, align 4
>   %f = alloca i64, align 8
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i32 @float32_squash_input_denormal(i32 %4, %struct.float_status* %5)
>   store i32 %6, i32* %2, align 4
>   %7 = load i32* %2, align 4
>   %8 = call i32 @extractFloat32Frac(i32 %7)
>   store i32 %8, i32* %aSig, align 4
>   %9 = load i32* %2, align 4
>   %10 = call i32 @extractFloat32Exp(i32 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i32* %2, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 255
>   br i1 %14, label %15, label %31
12451,12474c9621,9631
< define void @helper_fildl_ST0(i32 %val) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 7
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %8 = tail call { i64, i16 } @int32_to_floatx80(i32 %val, %struct.float_status* %7) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %8, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %8, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.14.8..idx5 to i16*
<   store i16 %.fca.1.extract, i16* %9, align 1
<   %10 = load %struct.CPUX86State** @env, align 8
<   %11 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 17
<   store i32 %5, i32* %11, align 4
<   %12 = load %struct.CPUX86State** @env, align 8
<   %13 = getelementptr inbounds %struct.CPUX86State* %12, i64 0, i32 20, i64 %6
<   store i8 0, i8* %13, align 1
<   ret void
< }
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %aSig, align 4
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %18, label %22
> 
> ; <label>:18                                      ; preds = %15
>   %19 = load i32* %2, align 4
>   %20 = load %struct.float_status** %3, align 4
>   %21 = call i32 @propagateFloat32NaN(i32 %19, i32 0, %struct.float_status* %20)
>   store i32 %21, i32* %1
>   br label %73
12476,12499c9633,9637
< define void @helper_fildll_ST0(i64 %val) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 7
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %8 = tail call { i64, i16 } @int64_to_floatx80(i64 %val, %struct.float_status* %7) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %8, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %8, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.14.8..idx5 to i16*
<   store i16 %.fca.1.extract, i16* %9, align 1
<   %10 = load %struct.CPUX86State** @env, align 8
<   %11 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 17
<   store i32 %5, i32* %11, align 4
<   %12 = load %struct.CPUX86State** @env, align 8
<   %13 = getelementptr inbounds %struct.CPUX86State* %12, i64 0, i32 20, i64 %6
<   store i8 0, i8* %13, align 1
<   ret void
< }
---
> ; <label>:22                                      ; preds = %15
>   %23 = load i8* %aSign, align 1
>   %24 = zext i8 %23 to i32
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %27
12501c9639,9640
< declare { i64, i16 } @int64_to_floatx80(i64, %struct.float_status*)
---
> ; <label>:26                                      ; preds = %22
>   br label %29
12503,12516c9642,9644
< define i32 @helper_fsts_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %6, align 1
<   %7 = tail call i32 @floatx80_to_float32(i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   ret i32 %7
< }
---
> ; <label>:27                                      ; preds = %22
>   %28 = load i32* %2, align 4
>   br label %29
12518c9646,9649
< declare i32 @floatx80_to_float32(i64, i16, %struct.float_status*)
---
> ; <label>:29                                      ; preds = %27, %26
>   %30 = phi i32 [ 0, %26 ], [ %28, %27 ]
>   store i32 %30, i32* %1
>   br label %73
12520,12533c9651,9654
< define i64 @helper_fstl_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %6, align 1
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   ret i64 %7
< }
---
> ; <label>:31                                      ; preds = %0
>   %32 = load i32* %aExp, align 4
>   %33 = icmp eq i32 %32, 0
>   br i1 %33, label %34, label %39
12535c9656,9659
< declare i64 @floatx80_to_float64(i64, i16, %struct.float_status*)
---
> ; <label>:34                                      ; preds = %31
>   %35 = load i32* %aSig, align 4
>   %36 = icmp eq i32 %35, 0
>   br i1 %36, label %37, label %38
12537,12571c9661,9663
< define i32 @helper_fist_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %6, align 1
<   %7 = tail call i32 @floatx80_to_int32(i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   %sext = shl i32 %7, 16
<   %8 = ashr exact i32 %sext, 16
<   %9 = icmp eq i32 %7, %8
<   %. = select i1 %9, i32 %7, i32 -32768
<   ret i32 %.
< }
< 
< declare i32 @floatx80_to_int32(i64, i16, %struct.float_status*)
< 
< define i32 @helper_fistl_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %6, align 1
<   %7 = tail call i32 @floatx80_to_int32(i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   ret i32 %7
< }
---
> ; <label>:37                                      ; preds = %34
>   store i32 1065353216, i32* %1
>   br label %73
12573,12586c9665,9666
< define i64 @helper_fistll_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %6, align 1
<   %7 = tail call i64 @floatx80_to_int64(i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   ret i64 %7
< }
---
> ; <label>:38                                      ; preds = %34
>   br label %39
12588c9668,9683
< declare i64 @floatx80_to_int64(i64, i16, %struct.float_status*)
---
> ; <label>:39                                      ; preds = %38, %31
>   %40 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 32, %struct.float_status* %40)
>   %41 = load i32* %2, align 4
>   %42 = load %struct.float_status** %3, align 4
>   %43 = call i64 @float32_to_float64(i32 %41, %struct.float_status* %42)
>   store i64 %43, i64* %x, align 8
>   %44 = load i64* %x, align 8
>   %45 = load %struct.float_status** %3, align 4
>   %46 = call i64 @float64_mul(i64 %44, i64 4604418534313441775, %struct.float_status* %45)
>   store i64 %46, i64* %x, align 8
>   %47 = load i64* %x, align 8
>   store i64 %47, i64* %xn, align 8
>   store i64 4607182418800017408, i64* %r, align 8
>   store i32 0, i32* %i, align 4
>   br label %48
12590,12607c9685,9688
< define i32 @helper_fistt_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %6, align 1
<   %7 = tail call i32 @floatx80_to_int32_round_to_zero(i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   %sext = shl i32 %7, 16
<   %8 = ashr exact i32 %sext, 16
<   %9 = icmp eq i32 %7, %8
<   %. = select i1 %9, i32 %7, i32 -32768
<   ret i32 %.
< }
---
> ; <label>:48                                      ; preds = %66, %39
>   %49 = load i32* %i, align 4
>   %50 = icmp slt i32 %49, 15
>   br i1 %50, label %51, label %69
12609c9690,9714
< declare i32 @floatx80_to_int32_round_to_zero(i64, i16, %struct.float_status*)
---
> ; <label>:51                                      ; preds = %48
>   %52 = load i64* %xn, align 8
>   %53 = load i32* %i, align 4
>   %54 = getelementptr inbounds [15 x i64]* @float32_exp2_coefficients, i32 0, i32 %53
>   %55 = load i64* %54, align 4
>   %56 = load %struct.float_status** %3, align 4
>   %57 = call i64 @float64_mul(i64 %52, i64 %55, %struct.float_status* %56)
>   store i64 %57, i64* %f, align 8
>   %58 = load i64* %r, align 8
>   %59 = load i64* %f, align 8
>   %60 = load %struct.float_status** %3, align 4
>   %61 = call i64 @float64_add(i64 %58, i64 %59, %struct.float_status* %60)
>   store i64 %61, i64* %r, align 8
>   %62 = load i64* %xn, align 8
>   %63 = load i64* %x, align 8
>   %64 = load %struct.float_status** %3, align 4
>   %65 = call i64 @float64_mul(i64 %62, i64 %63, %struct.float_status* %64)
>   store i64 %65, i64* %xn, align 8
>   br label %66
> 
> ; <label>:66                                      ; preds = %51
>   %67 = load i32* %i, align 4
>   %68 = add nsw i32 %67, 1
>   store i32 %68, i32* %i, align 4
>   br label %48
12611,12624c9716,9721
< define i32 @helper_fisttl_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %6, align 1
<   %7 = tail call i32 @floatx80_to_int32_round_to_zero(i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   ret i32 %7
< }
---
> ; <label>:69                                      ; preds = %48
>   %70 = load i64* %r, align 8
>   %71 = load %struct.float_status** %3, align 4
>   %72 = call i32 @float64_to_float32(i64 %70, %struct.float_status* %71)
>   store i32 %72, i32* %1
>   br label %73
12626,12638c9723,9725
< define i64 @helper_fisttll_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %6, align 1
<   %7 = tail call i64 @floatx80_to_int64_round_to_zero(i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   ret i64 %7
---
> ; <label>:73                                      ; preds = %69, %37, %29, %18
>   %74 = load i32* %1
>   ret i32 %74
12641c9728,9786
< declare i64 @floatx80_to_int64_round_to_zero(i64, i16, %struct.float_status*)
---
> define internal i64 @float64_mul(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i64 @extractFloat64Frac(i64 %11)
>   store i64 %12, i64* %aSig, align 8
>   %13 = load i64* %2, align 8
>   %14 = call i32 @extractFloat64Exp(i64 %13)
>   store i32 %14, i32* %aExp, align 4
>   %15 = load i64* %2, align 8
>   %16 = call zeroext i8 @extractFloat64Sign(i64 %15)
>   store i8 %16, i8* %aSign, align 1
>   %17 = load i64* %3, align 8
>   %18 = call i64 @extractFloat64Frac(i64 %17)
>   store i64 %18, i64* %bSig, align 8
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   store i32 %20, i32* %bExp, align 4
>   %21 = load i64* %3, align 8
>   %22 = call zeroext i8 @extractFloat64Sign(i64 %21)
>   store i8 %22, i8* %bSign, align 1
>   %23 = load i8* %aSign, align 1
>   %24 = zext i8 %23 to i32
>   %25 = load i8* %bSign, align 1
>   %26 = zext i8 %25 to i32
>   %27 = xor i32 %24, %26
>   %28 = trunc i32 %27 to i8
>   store i8 %28, i8* %zSign, align 1
>   %29 = load i32* %aExp, align 4
>   %30 = icmp eq i32 %29, 2047
>   br i1 %30, label %31, label %56
> 
> ; <label>:31                                      ; preds = %0
>   %32 = load i64* %aSig, align 8
>   %33 = icmp ne i64 %32, 0
>   br i1 %33, label %40, label %34
12643,12666c9788,9791
< define void @helper_fldt_ST0(i32 %ptr) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 7
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = tail call fastcc i64 @ldq_data(i32 %ptr) nounwind
<   %8 = add i32 %ptr, 8
<   %9 = tail call fastcc i32 @lduw_data(i32 %8) nounwind
<   %10 = trunc i32 %9 to i16
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   store i64 %7, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %11 = bitcast [8 x i8]* %.sroa.14.8..idx5 to i16*
<   store i16 %10, i16* %11, align 1
<   %12 = load %struct.CPUX86State** @env, align 8
<   %13 = getelementptr inbounds %struct.CPUX86State* %12, i64 0, i32 17
<   store i32 %5, i32* %13, align 4
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 20, i64 %6
<   store i8 0, i8* %15, align 1
<   ret void
< }
---
> ; <label>:34                                      ; preds = %31
>   %35 = load i32* %bExp, align 4
>   %36 = icmp eq i32 %35, 2047
>   br i1 %36, label %37, label %45
12668,12683c9793,9824
< define void @helper_fstt_ST0(i32 %ptr) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %5, align 1
<   tail call fastcc void @stq_data(i32 %ptr, i64 %.sroa.0.0.copyload) nounwind
<   %6 = add i32 %ptr, 8
<   %7 = zext i16 %.sroa.1.8.copyload to i32
<   tail call fastcc void @stw_data(i32 %6, i32 %7) nounwind
<   ret void
< }
---
> ; <label>:37                                      ; preds = %34
>   %38 = load i64* %bSig, align 8
>   %39 = icmp ne i64 %38, 0
>   br i1 %39, label %40, label %45
> 
> ; <label>:40                                      ; preds = %37, %31
>   %41 = load i64* %2, align 8
>   %42 = load i64* %3, align 8
>   %43 = load %struct.float_status** %4, align 4
>   %44 = call i64 @propagateFloat64NaN(i64 %41, i64 %42, %struct.float_status* %43)
>   store i64 %44, i64* %1
>   br label %133
> 
> ; <label>:45                                      ; preds = %37, %34
>   %46 = load i32* %bExp, align 4
>   %47 = sext i32 %46 to i64
>   %48 = load i64* %bSig, align 8
>   %49 = or i64 %47, %48
>   %50 = icmp eq i64 %49, 0
>   br i1 %50, label %51, label %53
> 
> ; <label>:51                                      ; preds = %45
>   %52 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %52)
>   store i64 -2251799813685248, i64* %1
>   br label %133
> 
> ; <label>:53                                      ; preds = %45
>   %54 = load i8* %zSign, align 1
>   %55 = call i64 @packFloat64(i8 zeroext %54, i32 2047, i64 0)
>   store i64 %55, i64* %1
>   br label %133
12685,12699c9826,9834
< define void @helper_fpush() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 7
<   %5 = and i32 %4, 7
<   store i32 %5, i32* %2, align 4
<   %6 = load %struct.CPUX86State** @env, align 8
<   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 17
<   %8 = load i32* %7, align 4
<   %9 = zext i32 %8 to i64
<   %10 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 20, i64 %9
<   store i8 0, i8* %10, align 1
<   ret void
< }
---
> ; <label>:56                                      ; preds = %0
>   %57 = load i32* %bExp, align 4
>   %58 = icmp eq i32 %57, 2047
>   br i1 %58, label %59, label %78
> 
> ; <label>:59                                      ; preds = %56
>   %60 = load i64* %bSig, align 8
>   %61 = icmp ne i64 %60, 0
>   br i1 %61, label %62, label %67
12701,12715c9836,9850
< define void @helper_fpop() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 20, i64 %4
<   store i8 1, i8* %5, align 1
<   %6 = load %struct.CPUX86State** @env, align 8
<   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 17
<   %8 = load i32* %7, align 4
<   %9 = add i32 %8, 1
<   %10 = and i32 %9, 7
<   store i32 %10, i32* %7, align 4
<   ret void
< }
---
> ; <label>:62                                      ; preds = %59
>   %63 = load i64* %2, align 8
>   %64 = load i64* %3, align 8
>   %65 = load %struct.float_status** %4, align 4
>   %66 = call i64 @propagateFloat64NaN(i64 %63, i64 %64, %struct.float_status* %65)
>   store i64 %66, i64* %1
>   br label %133
> 
> ; <label>:67                                      ; preds = %59
>   %68 = load i32* %aExp, align 4
>   %69 = sext i32 %68 to i64
>   %70 = load i64* %aSig, align 8
>   %71 = or i64 %69, %70
>   %72 = icmp eq i64 %71, 0
>   br i1 %72, label %73, label %75
12717,12730c9852,9862
< define void @helper_fdecstp() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 7
<   %5 = and i32 %4, 7
<   store i32 %5, i32* %2, align 4
<   %6 = load %struct.CPUX86State** @env, align 8
<   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 18
<   %8 = load i16* %7, align 2
<   %9 = and i16 %8, -18177
<   store i16 %9, i16* %7, align 2
<   ret void
< }
---
> ; <label>:73                                      ; preds = %67
>   %74 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %74)
>   store i64 -2251799813685248, i64* %1
>   br label %133
> 
> ; <label>:75                                      ; preds = %67
>   %76 = load i8* %zSign, align 1
>   %77 = call i64 @packFloat64(i8 zeroext %76, i32 2047, i64 0)
>   store i64 %77, i64* %1
>   br label %133
12732,12745c9864,9867
< define void @helper_fincstp() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 1
<   %5 = and i32 %4, 7
<   store i32 %5, i32* %2, align 4
<   %6 = load %struct.CPUX86State** @env, align 8
<   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 18
<   %8 = load i16* %7, align 2
<   %9 = and i16 %8, -18177
<   store i16 %9, i16* %7, align 2
<   ret void
< }
---
> ; <label>:78                                      ; preds = %56
>   %79 = load i32* %aExp, align 4
>   %80 = icmp eq i32 %79, 0
>   br i1 %80, label %81, label %89
12747,12757c9869,9883
< define void @helper_ffree_STN(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %st_index
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 20, i64 %6
<   store i8 1, i8* %7, align 1
<   ret void
< }
---
> ; <label>:81                                      ; preds = %78
>   %82 = load i64* %aSig, align 8
>   %83 = icmp eq i64 %82, 0
>   br i1 %83, label %84, label %87
> 
> ; <label>:84                                      ; preds = %81
>   %85 = load i8* %zSign, align 1
>   %86 = call i64 @packFloat64(i8 zeroext %85, i32 0, i64 0)
>   store i64 %86, i64* %1
>   br label %133
> 
> ; <label>:87                                      ; preds = %81
>   %88 = load i64* %aSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %88, i32* %aExp, i64* %aSig)
>   br label %89
12759,12773c9885,9888
< define void @helper_fmov_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26
<   %7 = bitcast %union.FPReg* %5 to i8*
<   %8 = bitcast %struct.floatx80* %6 to i8*
<   br label %9
< 
< ; <label>:9                                       ; preds = %12, %0
<   %10 = phi i64 [ 0, %0 ], [ %16, %12 ]
<   %11 = icmp ult i64 %10, 10
<   br i1 %11, label %12, label %17
---
> ; <label>:89                                      ; preds = %87, %78
>   %90 = load i32* %bExp, align 4
>   %91 = icmp eq i32 %90, 0
>   br i1 %91, label %92, label %100
12775,12781c9890,9987
< ; <label>:12                                      ; preds = %9
<   %13 = getelementptr i8* %8, i64 %10
<   %14 = load i8* %13, align 1
<   %15 = getelementptr i8* %7, i64 %10
<   store i8 %14, i8* %15, align 1
<   %16 = add i64 %10, 1
<   br label %9
---
> ; <label>:92                                      ; preds = %89
>   %93 = load i64* %bSig, align 8
>   %94 = icmp eq i64 %93, 0
>   br i1 %94, label %95, label %98
> 
> ; <label>:95                                      ; preds = %92
>   %96 = load i8* %zSign, align 1
>   %97 = call i64 @packFloat64(i8 zeroext %96, i32 0, i64 0)
>   store i64 %97, i64* %1
>   br label %133
> 
> ; <label>:98                                      ; preds = %92
>   %99 = load i64* %bSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %99, i32* %bExp, i64* %bSig)
>   br label %100
> 
> ; <label>:100                                     ; preds = %98, %89
>   %101 = load i32* %aExp, align 4
>   %102 = load i32* %bExp, align 4
>   %103 = add nsw i32 %101, %102
>   %104 = sub nsw i32 %103, 1023
>   store i32 %104, i32* %zExp, align 4
>   %105 = load i64* %aSig, align 8
>   %106 = or i64 %105, 4503599627370496
>   %107 = shl i64 %106, 10
>   store i64 %107, i64* %aSig, align 8
>   %108 = load i64* %bSig, align 8
>   %109 = or i64 %108, 4503599627370496
>   %110 = shl i64 %109, 11
>   store i64 %110, i64* %bSig, align 8
>   %111 = load i64* %aSig, align 8
>   %112 = load i64* %bSig, align 8
>   call void @mul64To128(i64 %111, i64 %112, i64* %zSig0, i64* %zSig1)
>   %113 = load i64* %zSig1, align 8
>   %114 = icmp ne i64 %113, 0
>   %115 = zext i1 %114 to i32
>   %116 = sext i32 %115 to i64
>   %117 = load i64* %zSig0, align 8
>   %118 = or i64 %117, %116
>   store i64 %118, i64* %zSig0, align 8
>   %119 = load i64* %zSig0, align 8
>   %120 = shl i64 %119, 1
>   %121 = icmp sle i64 0, %120
>   br i1 %121, label %122, label %127
> 
> ; <label>:122                                     ; preds = %100
>   %123 = load i64* %zSig0, align 8
>   %124 = shl i64 %123, 1
>   store i64 %124, i64* %zSig0, align 8
>   %125 = load i32* %zExp, align 4
>   %126 = add nsw i32 %125, -1
>   store i32 %126, i32* %zExp, align 4
>   br label %127
> 
> ; <label>:127                                     ; preds = %122, %100
>   %128 = load i8* %zSign, align 1
>   %129 = load i32* %zExp, align 4
>   %130 = load i64* %zSig0, align 8
>   %131 = load %struct.float_status** %4, align 4
>   %132 = call i64 @roundAndPackFloat64(i8 zeroext %128, i32 %129, i64 %130, %struct.float_status* %131)
>   store i64 %132, i64* %1
>   br label %133
> 
> ; <label>:133                                     ; preds = %127, %95, %84, %75, %73, %62, %53, %51, %40
>   %134 = load i64* %1
>   ret i64 %134
> }
> 
> define internal i64 @float64_add(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call zeroext i8 @extractFloat64Sign(i64 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i64* %3, align 8
>   %14 = call zeroext i8 @extractFloat64Sign(i64 %13)
>   store i8 %14, i8* %bSign, align 1
>   %15 = load i8* %aSign, align 1
>   %16 = zext i8 %15 to i32
>   %17 = load i8* %bSign, align 1
>   %18 = zext i8 %17 to i32
>   %19 = icmp eq i32 %16, %18
>   br i1 %19, label %20, label %26
12783,12785c9989,9996
< ; <label>:17                                      ; preds = %9
<   ret void
< }
---
> ; <label>:20                                      ; preds = %0
>   %21 = load i64* %2, align 8
>   %22 = load i64* %3, align 8
>   %23 = load i8* %aSign, align 1
>   %24 = load %struct.float_status** %4, align 4
>   %25 = call i64 @addFloat64Sigs(i64 %21, i64 %22, i8 zeroext %23, %struct.float_status* %24)
>   store i64 %25, i64* %1
>   br label %32
12787,12798c9998,10005
< define void @helper_fmov_FT0_STN(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26
<   %3 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %4 = load i32* %3, align 4
<   %5 = add i32 %4, %st_index
<   %6 = and i32 %5, 7
<   %7 = zext i32 %6 to i64
<   %8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7
<   %9 = bitcast %struct.floatx80* %2 to i8*
<   %10 = bitcast %union.FPReg* %8 to i8*
<   br label %11
---
> ; <label>:26                                      ; preds = %0
>   %27 = load i64* %2, align 8
>   %28 = load i64* %3, align 8
>   %29 = load i8* %aSign, align 1
>   %30 = load %struct.float_status** %4, align 4
>   %31 = call i64 @subFloat64Sigs(i64 %27, i64 %28, i8 zeroext %29, %struct.float_status* %30)
>   store i64 %31, i64* %1
>   br label %32
12800,12803c10007,10010
< ; <label>:11                                      ; preds = %14, %0
<   %12 = phi i64 [ 0, %0 ], [ %18, %14 ]
<   %13 = icmp ult i64 %12, 10
<   br i1 %13, label %14, label %19
---
> ; <label>:32                                      ; preds = %26, %20
>   %33 = load i64* %1
>   ret i64 %33
> }
12805,12811c10012,10038
< ; <label>:14                                      ; preds = %11
<   %15 = getelementptr i8* %10, i64 %12
<   %16 = load i8* %15, align 1
<   %17 = getelementptr i8* %9, i64 %12
<   store i8 %16, i8* %17, align 1
<   %18 = add i64 %12, 1
<   br label %11
---
> define internal i32 @float64_to_float32(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %zSig = alloca i32, align 4
>   %4 = alloca %struct.commonNaNT, align 4
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %2, align 8
>   %9 = call i64 @extractFloat64Frac(i64 %8)
>   store i64 %9, i64* %aSig, align 8
>   %10 = load i64* %2, align 8
>   %11 = call i32 @extractFloat64Exp(i64 %10)
>   store i32 %11, i32* %aExp, align 4
>   %12 = load i64* %2, align 8
>   %13 = call zeroext i8 @extractFloat64Sign(i64 %12)
>   store i8 %13, i8* %aSign, align 1
>   %14 = load i32* %aExp, align 4
>   %15 = icmp eq i32 %14, 2047
>   br i1 %15, label %16, label %27
12813,12815c10040,10052
< ; <label>:19                                      ; preds = %11
<   ret void
< }
---
> ; <label>:16                                      ; preds = %0
>   %17 = load i64* %aSig, align 8
>   %18 = icmp ne i64 %17, 0
>   br i1 %18, label %19, label %24
> 
> ; <label>:19                                      ; preds = %16
>   %20 = load i64* %2, align 8
>   %21 = load %struct.float_status** %3, align 4
>   call void @float64ToCommonNaN(%struct.commonNaNT* sret %4, i64 %20, %struct.float_status* %21)
>   %22 = load %struct.float_status** %3, align 4
>   %23 = call i32 @commonNaNToFloat32(%struct.commonNaNT* byval align 4 %4, %struct.float_status* %22)
>   store i32 %23, i32* %1
>   br label %47
12817,12829c10054,10058
< define void @helper_fmov_ST0_STN(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4
<   %6 = add i32 %3, %st_index
<   %7 = and i32 %6, 7
<   %8 = zext i32 %7 to i64
<   %9 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %8
<   %10 = bitcast %union.FPReg* %5 to i8*
<   %11 = bitcast %union.FPReg* %9 to i8*
<   br label %12
---
> ; <label>:24                                      ; preds = %16
>   %25 = load i8* %aSign, align 1
>   %26 = call i32 @packFloat32(i8 zeroext %25, i32 255, i32 0)
>   store i32 %26, i32* %1
>   br label %47
12831,12834c10060,10068
< ; <label>:12                                      ; preds = %15, %0
<   %13 = phi i64 [ 0, %0 ], [ %19, %15 ]
<   %14 = icmp ult i64 %13, 10
<   br i1 %14, label %15, label %20
---
> ; <label>:27                                      ; preds = %0
>   %28 = load i64* %aSig, align 8
>   call void @shift64RightJamming(i64 %28, i32 22, i64* %aSig)
>   %29 = load i64* %aSig, align 8
>   %30 = trunc i64 %29 to i32
>   store i32 %30, i32* %zSig, align 4
>   %31 = load i32* %aExp, align 4
>   %32 = icmp ne i32 %31, 0
>   br i1 %32, label %36, label %33
12836,12842c10070,10091
< ; <label>:15                                      ; preds = %12
<   %16 = getelementptr i8* %11, i64 %13
<   %17 = load i8* %16, align 1
<   %18 = getelementptr i8* %10, i64 %13
<   store i8 %17, i8* %18, align 1
<   %19 = add i64 %13, 1
<   br label %12
---
> ; <label>:33                                      ; preds = %27
>   %34 = load i32* %zSig, align 4
>   %35 = icmp ne i32 %34, 0
>   br i1 %35, label %36, label %41
> 
> ; <label>:36                                      ; preds = %33, %27
>   %37 = load i32* %zSig, align 4
>   %38 = or i32 %37, 1073741824
>   store i32 %38, i32* %zSig, align 4
>   %39 = load i32* %aExp, align 4
>   %40 = sub nsw i32 %39, 897
>   store i32 %40, i32* %aExp, align 4
>   br label %41
> 
> ; <label>:41                                      ; preds = %36, %33
>   %42 = load i8* %aSign, align 1
>   %43 = load i32* %aExp, align 4
>   %44 = load i32* %zSig, align 4
>   %45 = load %struct.float_status** %3, align 4
>   %46 = call i32 @roundAndPackFloat32(i8 zeroext %42, i32 %43, i32 %44, %struct.float_status* %45)
>   store i32 %46, i32* %1
>   br label %47
12844,12845c10093,10095
< ; <label>:20                                      ; preds = %12
<   ret void
---
> ; <label>:47                                      ; preds = %41, %24, %19
>   %48 = load i32* %1
>   ret i32 %48
12848,12860c10098,10125
< define void @helper_fmov_STN_ST0(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %st_index
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6
<   %8 = zext i32 %3 to i64
<   %9 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %8
<   %10 = bitcast %union.FPReg* %7 to i8*
<   %11 = bitcast %union.FPReg* %9 to i8*
<   br label %12
---
> define internal i32 @float32_log2(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %zSig = alloca i32, align 4
>   %i = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %2, align 4
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i32 @float32_squash_input_denormal(i32 %4, %struct.float_status* %5)
>   store i32 %6, i32* %2, align 4
>   %7 = load i32* %2, align 4
>   %8 = call i32 @extractFloat32Frac(i32 %7)
>   store i32 %8, i32* %aSig, align 4
>   %9 = load i32* %2, align 4
>   %10 = call i32 @extractFloat32Exp(i32 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i32* %2, align 4
>   %12 = call zeroext i8 @extractFloat32Sign(i32 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 0
>   br i1 %14, label %15, label %22
12862,12865c10127,10130
< ; <label>:12                                      ; preds = %15, %0
<   %13 = phi i64 [ 0, %0 ], [ %19, %15 ]
<   %14 = icmp ult i64 %13, 10
<   br i1 %14, label %15, label %20
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %aSig, align 4
>   %17 = icmp eq i32 %16, 0
>   br i1 %17, label %18, label %20
12867,12873c10132,10135
< ; <label>:15                                      ; preds = %12
<   %16 = getelementptr i8* %11, i64 %13
<   %17 = load i8* %16, align 1
<   %18 = getelementptr i8* %10, i64 %13
<   store i8 %17, i8* %18, align 1
<   %19 = add i64 %13, 1
<   br label %12
---
> ; <label>:18                                      ; preds = %15
>   %19 = call i32 @packFloat32(i8 zeroext 1, i32 255, i32 0)
>   store i32 %19, i32* %1
>   br label %85
12875,12877c10137,10151
< ; <label>:20                                      ; preds = %12
<   ret void
< }
---
> ; <label>:20                                      ; preds = %15
>   %21 = load i32* %aSig, align 4
>   call void @normalizeFloat32Subnormal(i32 %21, i32* %aExp, i32* %aSig)
>   br label %22
> 
> ; <label>:22                                      ; preds = %20, %0
>   %23 = load i8* %aSign, align 1
>   %24 = icmp ne i8 %23, 0
>   br i1 %24, label %25, label %27
> 
> ; <label>:25                                      ; preds = %22
>   %26 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %26)
>   store i32 -4194304, i32* %1
>   br label %85
12879,12894c10153,10161
< define void @helper_fxchg_ST0_STN(i32 %st_index) nounwind uwtable {
<   %tmp2 = alloca [10 x i8], align 1
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %st_index
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6
<   %8 = bitcast %union.FPReg* %7 to i8*
<   br label %9
< 
< ; <label>:9                                       ; preds = %12, %0
<   %10 = phi i64 [ 0, %0 ], [ %16, %12 ]
<   %11 = icmp ult i64 %10, 10
<   br i1 %11, label %12, label %17
---
> ; <label>:27                                      ; preds = %22
>   %28 = load i32* %aExp, align 4
>   %29 = icmp eq i32 %28, 255
>   br i1 %29, label %30, label %39
> 
> ; <label>:30                                      ; preds = %27
>   %31 = load i32* %aSig, align 4
>   %32 = icmp ne i32 %31, 0
>   br i1 %32, label %33, label %37
12896,12902c10163,10168
< ; <label>:12                                      ; preds = %9
<   %13 = getelementptr i8* %8, i64 %10
<   %14 = load i8* %13, align 1
<   %15 = getelementptr [10 x i8]* %tmp2, i64 0, i64 %10
<   store i8 %14, i8* %15, align 1
<   %16 = add i64 %10, 1
<   br label %9
---
> ; <label>:33                                      ; preds = %30
>   %34 = load i32* %2, align 4
>   %35 = load %struct.float_status** %3, align 4
>   %36 = call i32 @propagateFloat32NaN(i32 %34, i32 0, %struct.float_status* %35)
>   store i32 %36, i32* %1
>   br label %85
12904,12908c10170,10173
< ; <label>:17                                      ; preds = %9
<   %18 = zext i32 %3 to i64
<   %19 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %18
<   %20 = bitcast %union.FPReg* %19 to i8*
<   br label %21
---
> ; <label>:37                                      ; preds = %30
>   %38 = load i32* %2, align 4
>   store i32 %38, i32* %1
>   br label %85
12910,12913c10175,10191
< ; <label>:21                                      ; preds = %24, %17
<   %22 = phi i64 [ 0, %17 ], [ %28, %24 ]
<   %23 = icmp ult i64 %22, 10
<   br i1 %23, label %24, label %29
---
> ; <label>:39                                      ; preds = %27
>   %40 = load i32* %aExp, align 4
>   %41 = sub nsw i32 %40, 127
>   store i32 %41, i32* %aExp, align 4
>   %42 = load i32* %aSig, align 4
>   %43 = or i32 %42, 8388608
>   store i32 %43, i32* %aSig, align 4
>   %44 = load i32* %aExp, align 4
>   %45 = icmp slt i32 %44, 0
>   %46 = zext i1 %45 to i32
>   %47 = trunc i32 %46 to i8
>   store i8 %47, i8* %zSign, align 1
>   %48 = load i32* %aExp, align 4
>   %49 = shl i32 %48, 23
>   store i32 %49, i32* %zSig, align 4
>   store i32 4194304, i32* %i, align 4
>   br label %50
12915,12921c10193,10196
< ; <label>:24                                      ; preds = %21
<   %25 = getelementptr i8* %20, i64 %22
<   %26 = load i8* %25, align 1
<   %27 = getelementptr i8* %8, i64 %22
<   store i8 %26, i8* %27, align 1
<   %28 = add i64 %22, 1
<   br label %21
---
> ; <label>:50                                      ; preds = %71, %39
>   %51 = load i32* %i, align 4
>   %52 = icmp ugt i32 %51, 0
>   br i1 %52, label %53, label %74
12923,12926c10198,10229
< ; <label>:29                                      ; preds = %21, %32
<   %30 = phi i64 [ %36, %32 ], [ 0, %21 ]
<   %31 = icmp ult i64 %30, 10
<   br i1 %31, label %32, label %37
---
> ; <label>:53                                      ; preds = %50
>   %54 = load i32* %aSig, align 4
>   %55 = zext i32 %54 to i64
>   %56 = load i32* %aSig, align 4
>   %57 = zext i32 %56 to i64
>   %58 = mul i64 %55, %57
>   %59 = lshr i64 %58, 23
>   %60 = trunc i64 %59 to i32
>   store i32 %60, i32* %aSig, align 4
>   %61 = load i32* %aSig, align 4
>   %62 = and i32 %61, 16777216
>   %63 = icmp ne i32 %62, 0
>   br i1 %63, label %64, label %70
> 
> ; <label>:64                                      ; preds = %53
>   %65 = load i32* %aSig, align 4
>   %66 = lshr i32 %65, 1
>   store i32 %66, i32* %aSig, align 4
>   %67 = load i32* %i, align 4
>   %68 = load i32* %zSig, align 4
>   %69 = or i32 %68, %67
>   store i32 %69, i32* %zSig, align 4
>   br label %70
> 
> ; <label>:70                                      ; preds = %64, %53
>   br label %71
> 
> ; <label>:71                                      ; preds = %70
>   %72 = load i32* %i, align 4
>   %73 = lshr i32 %72, 1
>   store i32 %73, i32* %i, align 4
>   br label %50
12928,12934c10231,10234
< ; <label>:32                                      ; preds = %29
<   %33 = getelementptr [10 x i8]* %tmp2, i64 0, i64 %30
<   %34 = load i8* %33, align 1
<   %35 = getelementptr i8* %20, i64 %30
<   store i8 %34, i8* %35, align 1
<   %36 = add i64 %30, 1
<   br label %29
---
> ; <label>:74                                      ; preds = %50
>   %75 = load i8* %zSign, align 1
>   %76 = icmp ne i8 %75, 0
>   br i1 %76, label %77, label %80
12936,12938c10236,10248
< ; <label>:37                                      ; preds = %29
<   ret void
< }
---
> ; <label>:77                                      ; preds = %74
>   %78 = load i32* %zSig, align 4
>   %79 = sub i32 0, %78
>   store i32 %79, i32* %zSig, align 4
>   br label %80
> 
> ; <label>:80                                      ; preds = %77, %74
>   %81 = load i8* %zSign, align 1
>   %82 = load i32* %zSig, align 4
>   %83 = load %struct.float_status** %3, align 4
>   %84 = call i32 @normalizeRoundAndPackFloat32(i8 zeroext %81, i32 133, i32 %82, %struct.float_status* %83)
>   store i32 %84, i32* %1
>   br label %85
12940,12968c10250,10252
< define void @helper_fcom_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.02.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.02.0.copyload = load i64* %.sroa.02.0..idx, align 1
<   %.sroa.13.8..idx4 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.13.8..idx4 to i16*
<   %.sroa.13.8.copyload = load i16* %6, align 1
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.1.8.copyload = load i16* %.sroa.1.8..idx1, align 1
<   %7 = tail call i32 @floatx80_compare(i64 %.sroa.02.0.copyload, i16 %.sroa.13.8.copyload, i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   %8 = load %struct.CPUX86State** @env, align 8
<   %9 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 18
<   %10 = load i16* %9, align 2
<   %11 = zext i16 %10 to i32
<   %12 = and i32 %11, 47871
<   %13 = add nsw i32 %7, 1
<   %14 = sext i32 %13 to i64
<   %15 = getelementptr inbounds [4 x i32]* @fcom_ccval, i64 0, i64 %14
<   %16 = load i32* %15, align 4
<   %17 = or i32 %12, %16
<   %18 = trunc i32 %17 to i16
<   store i16 %18, i16* %9, align 2
<   ret void
---
> ; <label>:85                                      ; preds = %80, %37, %33, %25, %18
>   %86 = load i32* %1
>   ret i32 %86
12971c10255,10276
< declare i32 @floatx80_compare(i64, i16, i64, i16, %struct.float_status*)
---
> define internal i32 @float32_eq(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %av = alloca i32, align 4
>   %bv = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Exp(i32 %11)
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %18
12973,13002c10278,10288
< define void @helper_fucom_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.02.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.02.0.copyload = load i64* %.sroa.02.0..idx, align 1
<   %.sroa.13.8..idx4 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.13.8..idx4 to i16*
<   %.sroa.13.8.copyload = load i16* %6, align 1
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.1.8.copyload = load i16* %.sroa.1.8..idx1, align 1
<   %7 = tail call i32 @floatx80_compare_quiet(i64 %.sroa.02.0.copyload, i16 %.sroa.13.8.copyload, i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   %8 = load %struct.CPUX86State** @env, align 8
<   %9 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 18
<   %10 = load i16* %9, align 2
<   %11 = zext i16 %10 to i32
<   %12 = and i32 %11, 47871
<   %13 = add nsw i32 %7, 1
<   %14 = sext i32 %13 to i64
<   %15 = getelementptr inbounds [4 x i32]* @fcom_ccval, i64 0, i64 %14
<   %16 = load i32* %15, align 4
<   %17 = or i32 %12, %16
<   %18 = trunc i32 %17 to i16
<   store i16 %18, i16* %9, align 2
<   ret void
< }
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %2, align 4
>   %16 = call i32 @extractFloat32Frac(i32 %15)
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   %21 = icmp eq i32 %20, 255
>   br i1 %21, label %22, label %28
13004c10290,10300
< declare i32 @floatx80_compare_quiet(i64, i16, i64, i16, %struct.float_status*)
---
> ; <label>:22                                      ; preds = %18
>   %23 = load i32* %3, align 4
>   %24 = call i32 @extractFloat32Frac(i32 %23)
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   store i32 0, i32* %1
>   br label %43
13006,13035c10302,10318
< define void @helper_fcomi_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.02.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.02.0.copyload = load i64* %.sroa.02.0..idx, align 1
<   %.sroa.13.8..idx4 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.13.8..idx4 to i16*
<   %.sroa.13.8.copyload = load i16* %6, align 1
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.1.8.copyload = load i16* %.sroa.1.8..idx1, align 1
<   %7 = tail call i32 @floatx80_compare(i64 %.sroa.02.0.copyload, i16 %.sroa.13.8.copyload, i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   %8 = load %struct.CPUX86State** @env, align 8
<   %9 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 1
<   %10 = load i32* %9, align 4
<   %11 = tail call i32 @helper_cc_compute_all(i32 %10)
<   %12 = and i32 %11, -70
<   %13 = add nsw i32 %7, 1
<   %14 = sext i32 %13 to i64
<   %15 = getelementptr inbounds [4 x i32]* @fcomi_ccval, i64 0, i64 %14
<   %16 = load i32* %15, align 4
<   %17 = or i32 %12, %16
<   %18 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 2
<   store i32 %17, i32* %18, align 4
<   ret void
< }
---
> ; <label>:28                                      ; preds = %22, %18
>   %29 = load i32* %2, align 4
>   store i32 %29, i32* %av, align 4
>   %30 = load i32* %3, align 4
>   store i32 %30, i32* %bv, align 4
>   %31 = load i32* %av, align 4
>   %32 = load i32* %bv, align 4
>   %33 = icmp eq i32 %31, %32
>   br i1 %33, label %40, label %34
> 
> ; <label>:34                                      ; preds = %28
>   %35 = load i32* %av, align 4
>   %36 = load i32* %bv, align 4
>   %37 = or i32 %35, %36
>   %38 = shl i32 %37, 1
>   %39 = icmp eq i32 %38, 0
>   br label %40
13037,13066c10320,10324
< define void @helper_fucomi_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.02.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.02.0.copyload = load i64* %.sroa.02.0..idx, align 1
<   %.sroa.13.8..idx4 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.13.8..idx4 to i16*
<   %.sroa.13.8.copyload = load i16* %6, align 1
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.1.8.copyload = load i16* %.sroa.1.8..idx1, align 1
<   %7 = tail call i32 @floatx80_compare_quiet(i64 %.sroa.02.0.copyload, i16 %.sroa.13.8.copyload, i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   %8 = load %struct.CPUX86State** @env, align 8
<   %9 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 1
<   %10 = load i32* %9, align 4
<   %11 = tail call i32 @helper_cc_compute_all(i32 %10)
<   %12 = and i32 %11, -70
<   %13 = add nsw i32 %7, 1
<   %14 = sext i32 %13 to i64
<   %15 = getelementptr inbounds [4 x i32]* @fcomi_ccval, i64 0, i64 %14
<   %16 = load i32* %15, align 4
<   %17 = or i32 %12, %16
<   %18 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 2
<   store i32 %17, i32* %18, align 4
<   ret void
< }
---
> ; <label>:40                                      ; preds = %34, %28
>   %41 = phi i1 [ true, %28 ], [ %39, %34 ]
>   %42 = zext i1 %41 to i32
>   store i32 %42, i32* %1
>   br label %43
13068,13088c10326,10328
< define void @helper_fadd_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %6, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.17.8.copyload = load i16* %.sroa.17.8..idx8, align 1
<   %7 = tail call { i64, i16 } @floatx80_add(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %5) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %7, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %7, 1
<   store i64 %.fca.0.extract, i64* %.sroa.09.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %6, align 1
<   ret void
---
> ; <label>:43                                      ; preds = %40, %26
>   %44 = load i32* %1
>   ret i32 %44
13091,13114c10331,10354
< declare { i64, i16 } @floatx80_add(i64, i16, i64, i16, %struct.float_status*)
< 
< define void @helper_fmul_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %6, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.17.8.copyload = load i16* %.sroa.17.8..idx8, align 1
<   %7 = tail call { i64, i16 } @floatx80_mul(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %5) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %7, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %7, 1
<   store i64 %.fca.0.extract, i64* %.sroa.09.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %6, align 1
<   ret void
< }
---
> define internal i32 @float32_le(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i32, align 4
>   %bv = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Exp(i32 %11)
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %18
13116c10356,10366
< declare { i64, i16 } @floatx80_mul(i64, i16, i64, i16, %struct.float_status*)
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %2, align 4
>   %16 = call i32 @extractFloat32Frac(i32 %15)
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   %21 = icmp eq i32 %20, 255
>   br i1 %21, label %22, label %28
13118,13139c10368,10378
< define void @helper_fsub_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %6, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.17.8.copyload = load i16* %.sroa.17.8..idx8, align 1
<   %7 = tail call { i64, i16 } @floatx80_sub(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %5) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %7, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %7, 1
<   store i64 %.fca.0.extract, i64* %.sroa.09.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %6, align 1
<   ret void
< }
---
> ; <label>:22                                      ; preds = %18
>   %23 = load i32* %3, align 4
>   %24 = call i32 @extractFloat32Frac(i32 %23)
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   store i32 0, i32* %1
>   br label %69
13141c10380,10396
< declare { i64, i16 } @floatx80_sub(i64, i16, i64, i16, %struct.float_status*)
---
> ; <label>:28                                      ; preds = %22, %18
>   %29 = load i32* %2, align 4
>   %30 = call zeroext i8 @extractFloat32Sign(i32 %29)
>   store i8 %30, i8* %aSign, align 1
>   %31 = load i32* %3, align 4
>   %32 = call zeroext i8 @extractFloat32Sign(i32 %31)
>   store i8 %32, i8* %bSign, align 1
>   %33 = load i32* %2, align 4
>   store i32 %33, i32* %av, align 4
>   %34 = load i32* %3, align 4
>   store i32 %34, i32* %bv, align 4
>   %35 = load i8* %aSign, align 1
>   %36 = zext i8 %35 to i32
>   %37 = load i8* %bSign, align 1
>   %38 = zext i8 %37 to i32
>   %39 = icmp ne i32 %36, %38
>   br i1 %39, label %40, label %53
13143,13164c10398,10410
< define void @helper_fsubr_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.110.8.copyload = load i16* %.sroa.110.8..idx11, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %6, align 1
<   %7 = tail call { i64, i16 } @floatx80_sub(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %5) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %7, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %7, 1
<   store i64 %.fca.0.extract, i64* %.sroa.06.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %6, align 1
<   ret void
< }
---
> ; <label>:40                                      ; preds = %28
>   %41 = load i8* %aSign, align 1
>   %42 = zext i8 %41 to i32
>   %43 = icmp ne i32 %42, 0
>   br i1 %43, label %50, label %44
> 
> ; <label>:44                                      ; preds = %40
>   %45 = load i32* %av, align 4
>   %46 = load i32* %bv, align 4
>   %47 = or i32 %45, %46
>   %48 = shl i32 %47, 1
>   %49 = icmp eq i32 %48, 0
>   br label %50
13166,13184c10412,10416
< define void @helper_fdiv_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %5, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.17.8.copyload = load i16* %.sroa.17.8..idx8, align 1
<   %6 = and i16 %.sroa.17.8.copyload, 32767
<   %7 = icmp eq i16 %6, 0
<   %8 = icmp eq i64 %.sroa.06.0.copyload, 0
<   %.demorgan.i = and i1 %7, %8
<   br i1 %.demorgan.i, label %9, label %helper_fdiv.exit
---
> ; <label>:50                                      ; preds = %44, %40
>   %51 = phi i1 [ true, %40 ], [ %49, %44 ]
>   %52 = zext i1 %51 to i32
>   store i32 %52, i32* %1
>   br label %69
13186,13219c10418,10433
< ; <label>:9                                       ; preds = %0
<   %10 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %11 = load i16* %10, align 2
<   %12 = or i16 %11, 4
<   store i16 %12, i16* %10, align 2
<   %13 = load %struct.CPUX86State** @env, align 8
<   %14 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 18
<   %15 = load i16* %14, align 2
<   %16 = zext i16 %15 to i32
<   %17 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 19
<   %18 = load i16* %17, align 2
<   %19 = zext i16 %18 to i32
<   %20 = and i32 %19, 63
<   %21 = xor i32 %20, 63
<   %22 = and i32 %21, %16
<   %23 = icmp eq i32 %22, 0
<   br i1 %23, label %helper_fdiv.exit, label %24
< 
< ; <label>:24                                      ; preds = %9
<   %25 = or i16 %15, -32640
<   store i16 %25, i16* %14, align 2
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %helper_fdiv.exit
< 
< helper_fdiv.exit:                                 ; preds = %24, %9, %0
<   %26 = phi %struct.CPUX86State* [ %1, %0 ], [ %13, %9 ], [ %.pre, %24 ]
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 25
<   %28 = tail call { i64, i16 } @floatx80_div(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %27) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %28, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %28, 1
<   store i64 %.fca.0.extract, i64* %.sroa.09.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %5, align 1
<   ret void
< }
---
> ; <label>:53                                      ; preds = %28
>   %54 = load i32* %av, align 4
>   %55 = load i32* %bv, align 4
>   %56 = icmp eq i32 %54, %55
>   br i1 %56, label %66, label %57
> 
> ; <label>:57                                      ; preds = %53
>   %58 = load i8* %aSign, align 1
>   %59 = zext i8 %58 to i32
>   %60 = load i32* %av, align 4
>   %61 = load i32* %bv, align 4
>   %62 = icmp ult i32 %60, %61
>   %63 = zext i1 %62 to i32
>   %64 = xor i32 %59, %63
>   %65 = icmp ne i32 %64, 0
>   br label %66
13221,13239c10435,10439
< define void @helper_fdivr_ST0_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   %.sroa.110.8.copyload = load i16* %.sroa.110.8..idx11, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %5, align 1
<   %6 = and i16 %.sroa.17.8.copyload, 32767
<   %7 = icmp eq i16 %6, 0
<   %8 = icmp eq i64 %.sroa.06.0.copyload, 0
<   %.demorgan.i = and i1 %7, %8
<   br i1 %.demorgan.i, label %9, label %helper_fdiv.exit
---
> ; <label>:66                                      ; preds = %57, %53
>   %67 = phi i1 [ true, %53 ], [ %65, %57 ]
>   %68 = zext i1 %67 to i32
>   store i32 %68, i32* %1
>   br label %69
13241,13273c10441,10443
< ; <label>:9                                       ; preds = %0
<   %10 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %11 = load i16* %10, align 2
<   %12 = or i16 %11, 4
<   store i16 %12, i16* %10, align 2
<   %13 = load %struct.CPUX86State** @env, align 8
<   %14 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 18
<   %15 = load i16* %14, align 2
<   %16 = zext i16 %15 to i32
<   %17 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 19
<   %18 = load i16* %17, align 2
<   %19 = zext i16 %18 to i32
<   %20 = and i32 %19, 63
<   %21 = xor i32 %20, 63
<   %22 = and i32 %21, %16
<   %23 = icmp eq i32 %22, 0
<   br i1 %23, label %helper_fdiv.exit, label %24
< 
< ; <label>:24                                      ; preds = %9
<   %25 = or i16 %15, -32640
<   store i16 %25, i16* %14, align 2
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %helper_fdiv.exit
< 
< helper_fdiv.exit:                                 ; preds = %24, %9, %0
<   %26 = phi %struct.CPUX86State* [ %1, %0 ], [ %13, %9 ], [ %.pre, %24 ]
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 25
<   %28 = tail call { i64, i16 } @floatx80_div(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %27) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %28, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %28, 1
<   store i64 %.fca.0.extract, i64* %.sroa.06.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %5, align 1
<   ret void
---
> ; <label>:69                                      ; preds = %66, %50, %26
>   %70 = load i32* %1
>   ret i32 %70
13276,13301c10446,10469
< define void @helper_fadd_STN_ST0(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %st_index
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = zext i32 %3 to i64
<   %8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %9, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 1
<   %10 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %10, align 1
<   %11 = tail call { i64, i16 } @floatx80_add(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %8) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %11, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %11, 1
<   store i64 %.fca.0.extract, i64* %.sroa.09.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %9, align 1
<   ret void
< }
---
> define internal i32 @float32_lt(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i32, align 4
>   %bv = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Exp(i32 %11)
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %18
13303,13328c10471,10481
< define void @helper_fmul_STN_ST0(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %st_index
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = zext i32 %3 to i64
<   %8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %9, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 1
<   %10 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %10, align 1
<   %11 = tail call { i64, i16 } @floatx80_mul(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %8) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %11, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %11, 1
<   store i64 %.fca.0.extract, i64* %.sroa.09.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %9, align 1
<   ret void
< }
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %2, align 4
>   %16 = call i32 @extractFloat32Frac(i32 %15)
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   %21 = icmp eq i32 %20, 255
>   br i1 %21, label %22, label %28
13330,13355c10483,10493
< define void @helper_fsub_STN_ST0(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %st_index
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = zext i32 %3 to i64
<   %8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %9, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 1
<   %10 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %10, align 1
<   %11 = tail call { i64, i16 } @floatx80_sub(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %8) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %11, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %11, 1
<   store i64 %.fca.0.extract, i64* %.sroa.09.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %9, align 1
<   ret void
< }
---
> ; <label>:22                                      ; preds = %18
>   %23 = load i32* %3, align 4
>   %24 = call i32 @extractFloat32Frac(i32 %23)
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   store i32 0, i32* %1
>   br label %69
13357,13382c10495,10511
< define void @helper_fsubr_STN_ST0(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %st_index
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = zext i32 %3 to i64
<   %8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %9, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %10 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %10, align 1
<   %11 = tail call { i64, i16 } @floatx80_sub(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %8) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %11, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %11, 1
<   store i64 %.fca.0.extract, i64* %.sroa.06.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %10, align 1
<   ret void
< }
---
> ; <label>:28                                      ; preds = %22, %18
>   %29 = load i32* %2, align 4
>   %30 = call zeroext i8 @extractFloat32Sign(i32 %29)
>   store i8 %30, i8* %aSign, align 1
>   %31 = load i32* %3, align 4
>   %32 = call zeroext i8 @extractFloat32Sign(i32 %31)
>   store i8 %32, i8* %bSign, align 1
>   %33 = load i32* %2, align 4
>   store i32 %33, i32* %av, align 4
>   %34 = load i32* %3, align 4
>   store i32 %34, i32* %bv, align 4
>   %35 = load i8* %aSign, align 1
>   %36 = zext i8 %35 to i32
>   %37 = load i8* %bSign, align 1
>   %38 = zext i8 %37 to i32
>   %39 = icmp ne i32 %36, %38
>   br i1 %39, label %40, label %53
13384,13406c10513,10525
< define void @helper_fdiv_STN_ST0(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %st_index
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = zext i32 %3 to i64
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %8 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %8, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %9, align 1
<   %10 = and i16 %.sroa.17.8.copyload, 32767
<   %11 = icmp eq i16 %10, 0
<   %12 = icmp eq i64 %.sroa.06.0.copyload, 0
<   %.demorgan.i = and i1 %11, %12
<   br i1 %.demorgan.i, label %13, label %helper_fdiv.exit
---
> ; <label>:40                                      ; preds = %28
>   %41 = load i8* %aSign, align 1
>   %42 = zext i8 %41 to i32
>   %43 = icmp ne i32 %42, 0
>   br i1 %43, label %44, label %50
> 
> ; <label>:44                                      ; preds = %40
>   %45 = load i32* %av, align 4
>   %46 = load i32* %bv, align 4
>   %47 = or i32 %45, %46
>   %48 = shl i32 %47, 1
>   %49 = icmp ne i32 %48, 0
>   br label %50
13408,13424c10527,10531
< ; <label>:13                                      ; preds = %0
<   %14 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %15 = load i16* %14, align 2
<   %16 = or i16 %15, 4
<   store i16 %16, i16* %14, align 2
<   %17 = load %struct.CPUX86State** @env, align 8
<   %18 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 18
<   %19 = load i16* %18, align 2
<   %20 = zext i16 %19 to i32
<   %21 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 19
<   %22 = load i16* %21, align 2
<   %23 = zext i16 %22 to i32
<   %24 = and i32 %23, 63
<   %25 = xor i32 %24, 63
<   %26 = and i32 %25, %20
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %helper_fdiv.exit, label %28
---
> ; <label>:50                                      ; preds = %44, %40
>   %51 = phi i1 [ false, %40 ], [ %49, %44 ]
>   %52 = zext i1 %51 to i32
>   store i32 %52, i32* %1
>   br label %69
13426,13440c10533,10558
< ; <label>:28                                      ; preds = %13
<   %29 = or i16 %19, -32640
<   store i16 %29, i16* %18, align 2
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %helper_fdiv.exit
< 
< helper_fdiv.exit:                                 ; preds = %28, %13, %0
<   %30 = phi %struct.CPUX86State* [ %1, %0 ], [ %17, %13 ], [ %.pre, %28 ]
<   %31 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 25
<   %32 = tail call { i64, i16 } @floatx80_div(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %31) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %32, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %32, 1
<   store i64 %.fca.0.extract, i64* %.sroa.09.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %8, align 1
<   ret void
---
> ; <label>:53                                      ; preds = %28
>   %54 = load i32* %av, align 4
>   %55 = load i32* %bv, align 4
>   %56 = icmp ne i32 %54, %55
>   br i1 %56, label %57, label %66
> 
> ; <label>:57                                      ; preds = %53
>   %58 = load i8* %aSign, align 1
>   %59 = zext i8 %58 to i32
>   %60 = load i32* %av, align 4
>   %61 = load i32* %bv, align 4
>   %62 = icmp ult i32 %60, %61
>   %63 = zext i1 %62 to i32
>   %64 = xor i32 %59, %63
>   %65 = icmp ne i32 %64, 0
>   br label %66
> 
> ; <label>:66                                      ; preds = %57, %53
>   %67 = phi i1 [ false, %53 ], [ %65, %57 ]
>   %68 = zext i1 %67 to i32
>   store i32 %68, i32* %1
>   br label %69
> 
> ; <label>:69                                      ; preds = %66, %50, %26
>   %70 = load i32* %1
>   ret i32 %70
13443,13465c10561,10580
< define void @helper_fdivr_STN_ST0(i32 %st_index) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, %st_index
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %7 = zext i32 %3 to i64
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %7, i32 1
<   %8 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %8, align 1
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %9 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %9, align 1
<   %10 = and i16 %.sroa.17.8.copyload, 32767
<   %11 = icmp eq i16 %10, 0
<   %12 = icmp eq i64 %.sroa.06.0.copyload, 0
<   %.demorgan.i = and i1 %11, %12
<   br i1 %.demorgan.i, label %13, label %helper_fdiv.exit
---
> define internal i32 @float32_unordered(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Exp(i32 %11)
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %18
13467,13483c10582,10592
< ; <label>:13                                      ; preds = %0
<   %14 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %15 = load i16* %14, align 2
<   %16 = or i16 %15, 4
<   store i16 %16, i16* %14, align 2
<   %17 = load %struct.CPUX86State** @env, align 8
<   %18 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 18
<   %19 = load i16* %18, align 2
<   %20 = zext i16 %19 to i32
<   %21 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 19
<   %22 = load i16* %21, align 2
<   %23 = zext i16 %22 to i32
<   %24 = and i32 %23, 63
<   %25 = xor i32 %24, 63
<   %26 = and i32 %25, %20
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %helper_fdiv.exit, label %28
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %2, align 4
>   %16 = call i32 @extractFloat32Frac(i32 %15)
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   %21 = icmp eq i32 %20, 255
>   br i1 %21, label %22, label %28
13485,13500c10594,10604
< ; <label>:28                                      ; preds = %13
<   %29 = or i16 %19, -32640
<   store i16 %29, i16* %18, align 2
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %helper_fdiv.exit
< 
< helper_fdiv.exit:                                 ; preds = %28, %13, %0
<   %30 = phi %struct.CPUX86State* [ %1, %0 ], [ %17, %13 ], [ %.pre, %28 ]
<   %31 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 25
<   %32 = tail call { i64, i16 } @floatx80_div(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %31) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %32, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %32, 1
<   store i64 %.fca.0.extract, i64* %.sroa.06.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %9, align 1
<   ret void
< }
---
> ; <label>:22                                      ; preds = %18
>   %23 = load i32* %3, align 4
>   %24 = call i32 @extractFloat32Frac(i32 %23)
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   store i32 1, i32* %1
>   br label %29
13502,13513c10606,10608
< define void @helper_fchs_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %5, align 1
<   %6 = xor i16 %.sroa.17.8.copyload, -32768
<   store i16 %6, i16* %5, align 1
<   ret void
< }
---
> ; <label>:28                                      ; preds = %22, %18
>   store i32 0, i32* %1
>   br label %29
13515,13525c10610,10612
< define void @helper_fabs_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %5, align 1
<   %6 = and i16 %.sroa.17.8.copyload, 32767
<   store i16 %6, i16* %5, align 1
<   ret void
---
> ; <label>:29                                      ; preds = %28, %26
>   %30 = load i32* %1
>   ret i32 %30
13528,13539c10615,10634
< define void @helper_fld1_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   store i64 -9223372036854775808, i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   store i16 16383, i16* %5, align 1
<   ret void
< }
---
> define internal i32 @float32_eq_quiet(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Exp(i32 %11)
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %18
13541,13552c10636,10646
< define void @helper_fldl2t_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   store i64 -3127054724296373506, i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   store i16 16384, i16* %5, align 1
<   ret void
< }
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %2, align 4
>   %16 = call i32 @extractFloat32Frac(i32 %15)
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   %21 = icmp eq i32 %20, 255
>   br i1 %21, label %22, label %37
13554,13565c10648,10669
< define void @helper_fldl2e_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   store i64 -5140230975865229124, i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   store i16 16383, i16* %5, align 1
<   ret void
< }
---
> ; <label>:22                                      ; preds = %18
>   %23 = load i32* %3, align 4
>   %24 = call i32 @extractFloat32Frac(i32 %23)
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %37
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load i32* %2, align 4
>   %28 = call i32 @float32_is_signaling_nan(i32 %27)
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %34, label %30
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load i32* %3, align 4
>   %32 = call i32 @float32_is_signaling_nan(i32 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
> 
> ; <label>:34                                      ; preds = %30, %26
>   %35 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
13567,13578c10671,10673
< define void @helper_fldpi_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   store i64 -3958705157555305931, i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   store i16 16384, i16* %5, align 1
<   ret void
< }
---
> ; <label>:36                                      ; preds = %34, %30
>   store i32 0, i32* %1
>   br label %50
13580,13591c10675,10679
< define void @helper_fldlg2_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   store i64 -7340697496662837351, i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   store i16 16381, i16* %5, align 1
<   ret void
< }
---
> ; <label>:37                                      ; preds = %22, %18
>   %38 = load i32* %2, align 4
>   %39 = load i32* %3, align 4
>   %40 = icmp eq i32 %38, %39
>   br i1 %40, label %47, label %41
13593,13604c10681,10687
< define void @helper_fldln2_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   store i64 -5660435428506895956, i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   store i16 16382, i16* %5, align 1
<   ret void
< }
---
> ; <label>:41                                      ; preds = %37
>   %42 = load i32* %2, align 4
>   %43 = load i32* %3, align 4
>   %44 = or i32 %42, %43
>   %45 = shl i32 %44, 1
>   %46 = icmp eq i32 %45, 0
>   br label %47
13606,13617c10689,10693
< define void @helper_fldz_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   store i64 0, i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   store i16 0, i16* %5, align 1
<   ret void
< }
---
> ; <label>:47                                      ; preds = %41, %37
>   %48 = phi i1 [ true, %37 ], [ %46, %41 ]
>   %49 = zext i1 %48 to i32
>   store i32 %49, i32* %1
>   br label %50
13619,13625c10695,10697
< define void @helper_fldz_FT0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 0
<   store i64 0, i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 26, i32 1
<   store i16 0, i16* %.sroa.1.8..idx1, align 1
<   ret void
---
> ; <label>:50                                      ; preds = %47, %36
>   %51 = load i32* %1
>   ret i32 %51
13628,13640c10700,10723
< define i32 @helper_fnstsw() nounwind uwtable readonly {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %3 = load i16* %2, align 2
<   %4 = zext i16 %3 to i32
<   %5 = and i32 %4, 51199
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %7 = load i32* %6, align 4
<   %8 = shl i32 %7, 11
<   %9 = and i32 %8, 14336
<   %10 = or i32 %9, %5
<   ret i32 %10
< }
---
> define internal i32 @float32_le_quiet(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i32, align 4
>   %bv = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Exp(i32 %11)
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %18
13642,13648c10725,10735
< define i32 @helper_fnstcw() nounwind uwtable readonly {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 19
<   %3 = load i16* %2, align 2
<   %4 = zext i16 %3 to i32
<   ret i32 %4
< }
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %2, align 4
>   %16 = call i32 @extractFloat32Frac(i32 %15)
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   %21 = icmp eq i32 %20, 255
>   br i1 %21, label %22, label %37
13650,13664c10737,10758
< define void @helper_fldcw(i32 %val) nounwind uwtable {
<   %1 = trunc i32 %val to i16
<   %2 = load %struct.CPUX86State** @env, align 8
<   %3 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 19
<   store i16 %1, i16* %3, align 2
<   %4 = load %struct.CPUX86State** @env, align 8
<   %5 = getelementptr inbounds %struct.CPUX86State* %4, i64 0, i32 19
<   %6 = load i16* %5, align 2
<   %7 = zext i16 %6 to i32
<   %8 = and i32 %7, 3072
<   switch i32 %8, label %12 [
<     i32 3072, label %11
<     i32 1024, label %9
<     i32 2048, label %10
<   ]
---
> ; <label>:22                                      ; preds = %18
>   %23 = load i32* %3, align 4
>   %24 = call i32 @extractFloat32Frac(i32 %23)
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %37
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load i32* %2, align 4
>   %28 = call i32 @float32_is_signaling_nan(i32 %27)
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %34, label %30
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load i32* %3, align 4
>   %32 = call i32 @float32_is_signaling_nan(i32 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
> 
> ; <label>:34                                      ; preds = %30, %26
>   %35 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
13666,13667c10760,10762
< ; <label>:9                                       ; preds = %0
<   br label %12
---
> ; <label>:36                                      ; preds = %34, %30
>   store i32 0, i32* %1
>   br label %78
13669,13670c10764,10786
< ; <label>:10                                      ; preds = %0
<   br label %12
---
> ; <label>:37                                      ; preds = %22, %18
>   %38 = load i32* %2, align 4
>   %39 = call zeroext i8 @extractFloat32Sign(i32 %38)
>   store i8 %39, i8* %aSign, align 1
>   %40 = load i32* %3, align 4
>   %41 = call zeroext i8 @extractFloat32Sign(i32 %40)
>   store i8 %41, i8* %bSign, align 1
>   %42 = load i32* %2, align 4
>   store i32 %42, i32* %av, align 4
>   %43 = load i32* %3, align 4
>   store i32 %43, i32* %bv, align 4
>   %44 = load i8* %aSign, align 1
>   %45 = zext i8 %44 to i32
>   %46 = load i8* %bSign, align 1
>   %47 = zext i8 %46 to i32
>   %48 = icmp ne i32 %45, %47
>   br i1 %48, label %49, label %62
> 
> ; <label>:49                                      ; preds = %37
>   %50 = load i8* %aSign, align 1
>   %51 = zext i8 %50 to i32
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %59, label %53
13672,13673c10788,10794
< ; <label>:11                                      ; preds = %0
<   br label %12
---
> ; <label>:53                                      ; preds = %49
>   %54 = load i32* %av, align 4
>   %55 = load i32* %bv, align 4
>   %56 = or i32 %54, %55
>   %57 = shl i32 %56, 1
>   %58 = icmp eq i32 %57, 0
>   br label %59
13675,13688c10796,10800
< ; <label>:12                                      ; preds = %11, %10, %9, %0
<   %rnd_type.0.i = phi i32 [ 2, %10 ], [ 1, %9 ], [ 3, %11 ], [ 0, %0 ]
<   %13 = getelementptr inbounds %struct.CPUX86State* %4, i64 0, i32 25
<   tail call void @set_float_rounding_mode(i32 %rnd_type.0.i, %struct.float_status* %13) nounwind
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 19
<   %16 = load i16* %15, align 2
<   %17 = zext i16 %16 to i32
<   %18 = lshr i32 %17, 8
<   %19 = and i32 %18, 3
<   switch i32 %19, label %21 [
<     i32 0, label %update_fp_status.exit
<     i32 2, label %20
<   ]
---
> ; <label>:59                                      ; preds = %53, %49
>   %60 = phi i1 [ true, %49 ], [ %58, %53 ]
>   %61 = zext i1 %60 to i32
>   store i32 %61, i32* %1
>   br label %78
13690,13691c10802,10817
< ; <label>:20                                      ; preds = %12
<   br label %update_fp_status.exit
---
> ; <label>:62                                      ; preds = %37
>   %63 = load i32* %av, align 4
>   %64 = load i32* %bv, align 4
>   %65 = icmp eq i32 %63, %64
>   br i1 %65, label %75, label %66
> 
> ; <label>:66                                      ; preds = %62
>   %67 = load i8* %aSign, align 1
>   %68 = zext i8 %67 to i32
>   %69 = load i32* %av, align 4
>   %70 = load i32* %bv, align 4
>   %71 = icmp ult i32 %69, %70
>   %72 = zext i1 %71 to i32
>   %73 = xor i32 %68, %72
>   %74 = icmp ne i32 %73, 0
>   br label %75
13693,13694c10819,10823
< ; <label>:21                                      ; preds = %12
<   br label %update_fp_status.exit
---
> ; <label>:75                                      ; preds = %66, %62
>   %76 = phi i1 [ true, %62 ], [ %74, %66 ]
>   %77 = zext i1 %76 to i32
>   store i32 %77, i32* %1
>   br label %78
13696,13700c10825,10827
< update_fp_status.exit:                            ; preds = %21, %20, %12
<   %rnd_type.1.i = phi i32 [ 80, %21 ], [ 64, %20 ], [ 32, %12 ]
<   %22 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 25
<   tail call void @set_floatx80_rounding_precision(i32 %rnd_type.1.i, %struct.float_status* %22) nounwind
<   ret void
---
> ; <label>:78                                      ; preds = %75, %59, %36
>   %79 = load i32* %1
>   ret i32 %79
13703,13710c10830,10853
< define void @helper_fclex() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %3 = load i16* %2, align 2
<   %4 = and i16 %3, 32512
<   store i16 %4, i16* %2, align 2
<   ret void
< }
---
> define internal i32 @float32_lt_quiet(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i32, align 4
>   %bv = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Exp(i32 %11)
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %18
13712,13718c10855,10865
< define void @helper_fwait() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %3 = load i16* %2, align 2
<   %4 = and i16 %3, 128
<   %5 = icmp eq i16 %4, 0
<   br i1 %5, label %12, label %6
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %2, align 4
>   %16 = call i32 @extractFloat32Frac(i32 %15)
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   %21 = icmp eq i32 %20, 255
>   br i1 %21, label %22, label %37
13720,13725c10867,10888
< ; <label>:6                                       ; preds = %0
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 15, i64 0
<   %8 = load i32* %7, align 4
<   %9 = and i32 %8, 32
<   %10 = icmp eq i32 %9, 0
<   br i1 %10, label %fpu_raise_exception.exit, label %11
---
> ; <label>:22                                      ; preds = %18
>   %23 = load i32* %3, align 4
>   %24 = call i32 @extractFloat32Frac(i32 %23)
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %37
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load i32* %2, align 4
>   %28 = call i32 @float32_is_signaling_nan(i32 %27)
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %34, label %30
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load i32* %3, align 4
>   %32 = call i32 @float32_is_signaling_nan(i32 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
> 
> ; <label>:34                                      ; preds = %30, %26
>   %35 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
13727,13729c10890,10892
< ; <label>:11                                      ; preds = %6
<   tail call fastcc void @raise_exception(i32 16) noreturn nounwind
<   unreachable
---
> ; <label>:36                                      ; preds = %34, %30
>   store i32 0, i32* %1
>   br label %78
13731,13733c10894,10916
< fpu_raise_exception.exit:                         ; preds = %6
<   tail call void @cpu_set_ferr(%struct.CPUX86State* %1) nounwind
<   br label %12
---
> ; <label>:37                                      ; preds = %22, %18
>   %38 = load i32* %2, align 4
>   %39 = call zeroext i8 @extractFloat32Sign(i32 %38)
>   store i8 %39, i8* %aSign, align 1
>   %40 = load i32* %3, align 4
>   %41 = call zeroext i8 @extractFloat32Sign(i32 %40)
>   store i8 %41, i8* %bSign, align 1
>   %42 = load i32* %2, align 4
>   store i32 %42, i32* %av, align 4
>   %43 = load i32* %3, align 4
>   store i32 %43, i32* %bv, align 4
>   %44 = load i8* %aSign, align 1
>   %45 = zext i8 %44 to i32
>   %46 = load i8* %bSign, align 1
>   %47 = zext i8 %46 to i32
>   %48 = icmp ne i32 %45, %47
>   br i1 %48, label %49, label %62
> 
> ; <label>:49                                      ; preds = %37
>   %50 = load i8* %aSign, align 1
>   %51 = zext i8 %50 to i32
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %53, label %59
13735,13737c10918,10924
< ; <label>:12                                      ; preds = %fpu_raise_exception.exit, %0
<   ret void
< }
---
> ; <label>:53                                      ; preds = %49
>   %54 = load i32* %av, align 4
>   %55 = load i32* %bv, align 4
>   %56 = or i32 %54, %55
>   %57 = shl i32 %56, 1
>   %58 = icmp ne i32 %57, 0
>   br label %59
13739,13774c10926,10930
< define void @helper_fninit() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   store i16 0, i16* %2, align 2
<   %3 = load %struct.CPUX86State** @env, align 8
<   %4 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 17
<   store i32 0, i32* %4, align 4
<   %5 = load %struct.CPUX86State** @env, align 8
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 19
<   store i16 895, i16* %6, align 2
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 20, i64 0
<   store i8 1, i8* %8, align 1
<   %9 = load %struct.CPUX86State** @env, align 8
<   %10 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 20, i64 1
<   store i8 1, i8* %10, align 1
<   %11 = load %struct.CPUX86State** @env, align 8
<   %12 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 20, i64 2
<   store i8 1, i8* %12, align 1
<   %13 = load %struct.CPUX86State** @env, align 8
<   %14 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 20, i64 3
<   store i8 1, i8* %14, align 1
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 20, i64 4
<   store i8 1, i8* %16, align 1
<   %17 = load %struct.CPUX86State** @env, align 8
<   %18 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 20, i64 5
<   store i8 1, i8* %18, align 1
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 20, i64 6
<   store i8 1, i8* %20, align 1
<   %21 = load %struct.CPUX86State** @env, align 8
<   %22 = getelementptr inbounds %struct.CPUX86State* %21, i64 0, i32 20, i64 7
<   store i8 1, i8* %22, align 1
<   ret void
< }
---
> ; <label>:59                                      ; preds = %53, %49
>   %60 = phi i1 [ false, %49 ], [ %58, %53 ]
>   %61 = zext i1 %60 to i32
>   store i32 %61, i32* %1
>   br label %78
13776,13892c10932,10957
< define void @helper_fbld_ST0(i32 %ptr) nounwind uwtable {
<   %1 = add i32 %ptr, 8
<   %2 = tail call fastcc i32 @ldub_data(i32 %1)
<   %3 = lshr i32 %2, 4
<   %4 = mul i32 %3, 10
<   %5 = zext i32 %4 to i64
<   %6 = and i32 %2, 15
<   %7 = zext i32 %6 to i64
<   %8 = add i64 %5, %7
<   %9 = add i32 %ptr, 7
<   %10 = tail call fastcc i32 @ldub_data(i32 %9)
<   %11 = mul i64 %8, 100
<   %12 = lshr i32 %10, 4
<   %13 = mul i32 %12, 10
<   %14 = zext i32 %13 to i64
<   %15 = and i32 %10, 15
<   %16 = zext i32 %15 to i64
<   %17 = add i64 %14, %16
<   %18 = add i64 %17, %11
<   %19 = add i32 %ptr, 6
<   %20 = tail call fastcc i32 @ldub_data(i32 %19)
<   %21 = mul i64 %18, 100
<   %22 = lshr i32 %20, 4
<   %23 = mul i32 %22, 10
<   %24 = zext i32 %23 to i64
<   %25 = and i32 %20, 15
<   %26 = zext i32 %25 to i64
<   %27 = add i64 %24, %26
<   %28 = add i64 %27, %21
<   %29 = add i32 %ptr, 5
<   %30 = tail call fastcc i32 @ldub_data(i32 %29)
<   %31 = mul i64 %28, 100
<   %32 = lshr i32 %30, 4
<   %33 = mul i32 %32, 10
<   %34 = zext i32 %33 to i64
<   %35 = and i32 %30, 15
<   %36 = zext i32 %35 to i64
<   %37 = add i64 %34, %36
<   %38 = add i64 %37, %31
<   %39 = add i32 %ptr, 4
<   %40 = tail call fastcc i32 @ldub_data(i32 %39)
<   %41 = mul i64 %38, 100
<   %42 = lshr i32 %40, 4
<   %43 = mul i32 %42, 10
<   %44 = zext i32 %43 to i64
<   %45 = and i32 %40, 15
<   %46 = zext i32 %45 to i64
<   %47 = add i64 %44, %46
<   %48 = add i64 %47, %41
<   %49 = add i32 %ptr, 3
<   %50 = tail call fastcc i32 @ldub_data(i32 %49)
<   %51 = mul i64 %48, 100
<   %52 = lshr i32 %50, 4
<   %53 = mul i32 %52, 10
<   %54 = zext i32 %53 to i64
<   %55 = and i32 %50, 15
<   %56 = zext i32 %55 to i64
<   %57 = add i64 %54, %56
<   %58 = add i64 %57, %51
<   %59 = add i32 %ptr, 2
<   %60 = tail call fastcc i32 @ldub_data(i32 %59)
<   %61 = mul i64 %58, 100
<   %62 = lshr i32 %60, 4
<   %63 = mul i32 %62, 10
<   %64 = zext i32 %63 to i64
<   %65 = and i32 %60, 15
<   %66 = zext i32 %65 to i64
<   %67 = add i64 %64, %66
<   %68 = add i64 %67, %61
<   %69 = add i32 %ptr, 1
<   %70 = tail call fastcc i32 @ldub_data(i32 %69)
<   %71 = mul i64 %68, 100
<   %72 = lshr i32 %70, 4
<   %73 = mul i32 %72, 10
<   %74 = zext i32 %73 to i64
<   %75 = and i32 %70, 15
<   %76 = zext i32 %75 to i64
<   %77 = add i64 %74, %76
<   %78 = add i64 %77, %71
<   %79 = tail call fastcc i32 @ldub_data(i32 %ptr)
<   %80 = mul i64 %78, 100
<   %81 = lshr i32 %79, 4
<   %82 = mul i32 %81, 10
<   %83 = zext i32 %82 to i64
<   %84 = and i32 %79, 15
<   %85 = zext i32 %84 to i64
<   %86 = add i64 %83, %85
<   %87 = add i64 %86, %80
<   %88 = load %struct.CPUX86State** @env, align 8
<   %89 = getelementptr inbounds %struct.CPUX86State* %88, i64 0, i32 25
<   %90 = tail call { i64, i16 } @int64_to_floatx80(i64 %87, %struct.float_status* %89) nounwind
<   %.fca.0.extract8 = extractvalue { i64, i16 } %90, 0
<   %.fca.1.extract9 = extractvalue { i64, i16 } %90, 1
<   %91 = add i32 %ptr, 9
<   %92 = tail call fastcc i32 @ldub_data(i32 %91)
<   %93 = load %struct.CPUX86State** @env, align 8
<   %94 = getelementptr inbounds %struct.CPUX86State* %93, i64 0, i32 17
<   %95 = load i32* %94, align 4
<   %96 = add i32 %95, 7
<   %97 = and i32 %96, 7
<   store i32 %97, i32* %94, align 4
<   %98 = load %struct.CPUX86State** @env, align 8
<   %99 = getelementptr inbounds %struct.CPUX86State* %98, i64 0, i32 17
<   %100 = load i32* %99, align 4
<   %101 = zext i32 %100 to i64
<   %102 = getelementptr inbounds %struct.CPUX86State* %98, i64 0, i32 20, i64 %101
<   store i8 0, i8* %102, align 1
<   %103 = load %struct.CPUX86State** @env, align 8
<   %104 = getelementptr inbounds %struct.CPUX86State* %103, i64 0, i32 17
<   %105 = load i32* %104, align 4
<   %106 = zext i32 %105 to i64
<   %tmp.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %103, i64 0, i32 21, i64 %106, i32 0, i32 0
<   store i64 %.fca.0.extract8, i64* %tmp.sroa.0.0..idx, align 1
<   %tmp.sroa.1.8..idx23 = getelementptr inbounds %struct.CPUX86State* %103, i64 0, i32 21, i64 %106, i32 1
<   %107 = bitcast [8 x i8]* %tmp.sroa.1.8..idx23 to i16*
<   store i16 %.fca.1.extract9, i16* %107, align 1
<   ret void
---
> ; <label>:62                                      ; preds = %37
>   %63 = load i32* %av, align 4
>   %64 = load i32* %bv, align 4
>   %65 = icmp ne i32 %63, %64
>   br i1 %65, label %66, label %75
> 
> ; <label>:66                                      ; preds = %62
>   %67 = load i8* %aSign, align 1
>   %68 = zext i8 %67 to i32
>   %69 = load i32* %av, align 4
>   %70 = load i32* %bv, align 4
>   %71 = icmp ult i32 %69, %70
>   %72 = zext i1 %71 to i32
>   %73 = xor i32 %68, %72
>   %74 = icmp ne i32 %73, 0
>   br label %75
> 
> ; <label>:75                                      ; preds = %66, %62
>   %76 = phi i1 [ false, %62 ], [ %74, %66 ]
>   %77 = zext i1 %76 to i32
>   store i32 %77, i32* %1
>   br label %78
> 
> ; <label>:78                                      ; preds = %75, %59, %36
>   %79 = load i32* %1
>   ret i32 %79
13895,13899c10960,10979
< define internal fastcc i32 @ldub_data(i32 %ptr) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> define internal i32 @float32_unordered_quiet(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %3, align 4
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i32 @float32_squash_input_denormal(i32 %8, %struct.float_status* %9)
>   store i32 %10, i32* %3, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Exp(i32 %11)
>   %13 = icmp eq i32 %12, 255
>   br i1 %13, label %14, label %18
13901,13903c10981,10991
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i32* %2, align 4
>   %16 = call i32 @extractFloat32Frac(i32 %15)
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i32* %3, align 4
>   %20 = call i32 @extractFloat32Exp(i32 %19)
>   %21 = icmp eq i32 %20, 255
>   br i1 %21, label %22, label %37
13905,13928c10993,11014
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = icmp eq i32 %17, 3
<   %19 = zext i1 %18 to i64
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 0
<   %21 = load i32* %20, align 4
<   %22 = and i32 %8, -4096
<   %23 = icmp eq i32 %21, %22
<   br i1 %23, label %27, label %24, !prof !0
< 
< ; <label>:24                                      ; preds = %6
<   %25 = zext i1 %18 to i32
<   %26 = tail call zeroext i8 @__ldb_mmu(i32 %8, i32 %25)
<   br label %35
---
> ; <label>:22                                      ; preds = %18
>   %23 = load i32* %3, align 4
>   %24 = call i32 @extractFloat32Frac(i32 %23)
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %37
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load i32* %2, align 4
>   %28 = call i32 @float32_is_signaling_nan(i32 %27)
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %34, label %30
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load i32* %3, align 4
>   %32 = call i32 @float32_is_signaling_nan(i32 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
> 
> ; <label>:34                                      ; preds = %30, %26
>   %35 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
13930,13939c11016,11018
< ; <label>:27                                      ; preds = %6
<   %28 = and i64 %7, 4294967295
<   %29 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 3
<   %30 = load i64* %29, align 8
<   %31 = add i64 %30, %28
<   %32 = inttoptr i64 %31 to i8*
<   %33 = load i8* %32, align 1
<   %34 = zext i8 %33 to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %28, i64 %31, i64 %34, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %35
---
> ; <label>:36                                      ; preds = %34, %30
>   store i32 1, i32* %1
>   br label %38
13941,13944c11020,11026
< ; <label>:35                                      ; preds = %27, %24
<   %res.0.in = phi i8 [ %26, %24 ], [ %33, %27 ]
<   %res.0 = zext i8 %res.0.in to i32
<   ret i32 %res.0
---
> ; <label>:37                                      ; preds = %22, %18
>   store i32 0, i32* %1
>   br label %38
> 
> ; <label>:38                                      ; preds = %37, %36
>   %39 = load i32* %1
>   ret i32 %39
13947,13961c11029,11053
< define void @helper_fbst_ST0(i32 %ptr) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.0.0.copyload = load i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx1 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.1.8..idx1 to i16*
<   %.sroa.1.8.copyload = load i16* %6, align 1
<   %7 = tail call i64 @floatx80_to_int64(i64 %.sroa.0.0.copyload, i16 %.sroa.1.8.copyload, %struct.float_status* %5) nounwind
<   %8 = add i32 %ptr, 9
<   %9 = icmp slt i64 %7, 0
<   br i1 %9, label %10, label %12
---
> define internal i32 @float64_to_int32(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i64* %1, align 8
>   %4 = load %struct.float_status** %2, align 4
>   %5 = call i64 @float64_squash_input_denormal(i64 %3, %struct.float_status* %4)
>   store i64 %5, i64* %1, align 8
>   %6 = load i64* %1, align 8
>   %7 = call i64 @extractFloat64Frac(i64 %6)
>   store i64 %7, i64* %aSig, align 8
>   %8 = load i64* %1, align 8
>   %9 = call i32 @extractFloat64Exp(i64 %8)
>   store i32 %9, i32* %aExp, align 4
>   %10 = load i64* %1, align 8
>   %11 = call zeroext i8 @extractFloat64Sign(i64 %10)
>   store i8 %11, i8* %aSign, align 1
>   %12 = load i32* %aExp, align 4
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %18
13963,13966c11055,11058
< ; <label>:10                                      ; preds = %0
<   tail call fastcc void @stb_data(i32 %8, i32 128)
<   %11 = sub nsw i64 0, %7
<   br label %.preheader15
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %aSig, align 8
>   %16 = icmp ne i64 %15, 0
>   br i1 %16, label %17, label %18
13968,13970c11060,11062
< ; <label>:12                                      ; preds = %0
<   tail call fastcc void @stb_data(i32 %8, i32 0)
<   br label %.preheader15
---
> ; <label>:17                                      ; preds = %14
>   store i8 0, i8* %aSign, align 1
>   br label %18
13972,14007c11064,11067
< .preheader15:                                     ; preds = %12, %10
<   %val.0.ph = phi i64 [ %11, %10 ], [ %7, %12 ]
<   %13 = icmp ugt i32 %ptr, -10
<   %14 = icmp eq i64 %val.0.ph, 0
<   %or.cond16 = or i1 %13, %14
<   br i1 %or.cond16, label %.preheader, label %.lr.ph19
< 
< .preheader:                                       ; preds = %.lr.ph19, %.preheader15
<   %mem_ref.0.lcssa = phi i32 [ %ptr, %.preheader15 ], [ %23, %.lr.ph19 ]
<   %15 = icmp ult i32 %mem_ref.0.lcssa, %8
<   br i1 %15, label %.lr.ph, label %._crit_edge
< 
< .lr.ph19:                                         ; preds = %.lr.ph19, %.preheader15
<   %mem_ref.018 = phi i32 [ %23, %.lr.ph19 ], [ %ptr, %.preheader15 ]
<   %val.017 = phi i64 [ %18, %.lr.ph19 ], [ %val.0.ph, %.preheader15 ]
<   %16 = srem i64 %val.017, 100
<   %17 = trunc i64 %16 to i32
<   %18 = sdiv i64 %val.017, 100
<   %19 = sdiv i32 %17, 10
<   %20 = shl i32 %19, 4
<   %21 = srem i32 %17, 10
<   %22 = or i32 %20, %21
<   %23 = add i32 %mem_ref.018, 1
<   tail call fastcc void @stb_data(i32 %mem_ref.018, i32 %22)
<   %24 = icmp uge i32 %23, %8
<   %val.017.off = add i64 %val.017, 99
<   %25 = icmp ult i64 %val.017.off, 199
<   %or.cond = or i1 %24, %25
<   br i1 %or.cond, label %.preheader, label %.lr.ph19
< 
< .lr.ph:                                           ; preds = %.lr.ph, %.preheader
<   %mem_ref.114 = phi i32 [ %26, %.lr.ph ], [ %mem_ref.0.lcssa, %.preheader ]
<   %26 = add i32 %mem_ref.114, 1
<   tail call fastcc void @stb_data(i32 %mem_ref.114, i32 0)
<   %exitcond = icmp eq i32 %26, %8
<   br i1 %exitcond, label %._crit_edge, label %.lr.ph
---
> ; <label>:18                                      ; preds = %17, %14, %0
>   %19 = load i32* %aExp, align 4
>   %20 = icmp ne i32 %19, 0
>   br i1 %20, label %21, label %24
14009,14011c11069,11073
< ._crit_edge:                                      ; preds = %.lr.ph, %.preheader
<   ret void
< }
---
> ; <label>:21                                      ; preds = %18
>   %22 = load i64* %aSig, align 8
>   %23 = or i64 %22, 4503599627370496
>   store i64 %23, i64* %aSig, align 8
>   br label %24
14013,14017c11075,11087
< define internal fastcc void @stb_data(i32 %ptr, i32 %v) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:24                                      ; preds = %21, %18
>   %25 = load i32* %aExp, align 4
>   %26 = sub nsw i32 1068, %25
>   store i32 %26, i32* %shiftCount, align 4
>   %27 = load i32* %shiftCount, align 4
>   %28 = icmp slt i32 0, %27
>   br i1 %28, label %29, label %32
> 
> ; <label>:29                                      ; preds = %24
>   %30 = load i64* %aSig, align 8
>   %31 = load i32* %shiftCount, align 4
>   call void @shift64RightJamming(i64 %30, i32 %31, i64* %aSig)
>   br label %32
14019,14021c11089,11107
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:32                                      ; preds = %29, %24
>   %33 = load i8* %aSign, align 1
>   %34 = load i64* %aSig, align 8
>   %35 = load %struct.float_status** %2, align 4
>   %36 = call i32 @roundAndPackInt32(i8 zeroext %33, i64 %34, %struct.float_status* %35)
>   ret i32 %36
> }
> 
> define internal i64 @float64_squash_input_denormal(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load %struct.float_status** %3, align 4
>   %5 = getelementptr inbounds %struct.float_status* %4, i32 0, i32 5
>   %6 = load i8* %5, align 1
>   %7 = icmp ne i8 %6, 0
>   br i1 %7, label %8, label %21
14023,14047c11109,11113
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = icmp eq i32 %17, 3
<   %19 = zext i1 %18 to i64
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 1
<   %21 = load i32* %20, align 4
<   %22 = and i32 %8, -4096
<   %23 = icmp eq i32 %21, %22
<   br i1 %23, label %27, label %24, !prof !0
< 
< ; <label>:24                                      ; preds = %6
<   %25 = zext i1 %18 to i32
<   %26 = trunc i32 %v to i8
<   tail call void @__stb_mmu(i32 %8, i8 zeroext %26, i32 %25)
<   br label %35
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i64* %2, align 8
>   %10 = call i32 @extractFloat64Exp(i64 %9)
>   %11 = icmp eq i32 %10, 0
>   br i1 %11, label %12, label %20
14049,14059c11115,11119
< ; <label>:27                                      ; preds = %6
<   %28 = and i64 %7, 4294967295
<   %29 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 3
<   %30 = load i64* %29, align 8
<   %31 = add i64 %30, %28
<   %32 = inttoptr i64 %31 to i8*
<   %33 = trunc i32 %v to i8
<   store i8 %33, i8* %32, align 1
<   %34 = zext i32 %v to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %28, i64 %31, i64 %34, i32 32, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %35
---
> ; <label>:12                                      ; preds = %8
>   %13 = load i64* %2, align 8
>   %14 = call i64 @extractFloat64Frac(i64 %13)
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %20
14061,14062c11121,11139
< ; <label>:35                                      ; preds = %27, %24
<   ret void
---
> ; <label>:16                                      ; preds = %12
>   %17 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 64, %struct.float_status* %17)
>   %18 = load i64* %2, align 8
>   %19 = and i64 %18, -9223372036854775808
>   store i64 %19, i64* %1
>   br label %23
> 
> ; <label>:20                                      ; preds = %12, %8
>   br label %21
> 
> ; <label>:21                                      ; preds = %20, %0
>   %22 = load i64* %2, align 8
>   store i64 %22, i64* %1
>   br label %23
> 
> ; <label>:23                                      ; preds = %21, %16
>   %24 = load i64* %1
>   ret i64 %24
14065,14094c11142,11147
< define void @helper_f2xm1() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %6) nounwind
<   %8 = bitcast i64 %7 to double
<   %exp2 = tail call double @exp2(double %8) nounwind
<   %9 = fadd double %exp2, -1.000000e+00
<   %10 = load %struct.CPUX86State** @env, align 8
<   %11 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 17
<   %12 = load i32* %11, align 4
<   %13 = zext i32 %12 to i64
<   %14 = bitcast double %9 to i64
<   %15 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 25
<   %16 = tail call { i64, i16 } @float64_to_floatx80(i64 %14, %struct.float_status* %15) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %16, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %16, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 21, i64 %13, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %10, i64 0, i32 21, i64 %13, i32 1
<   %17 = bitcast [8 x i8]* %.sroa.14.8..idx5 to i16*
<   store i16 %.fca.1.extract, i16* %17, align 1
<   ret void
---
> define internal i64 @extractFloat64Frac(i64 %a) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   %2 = load i64* %1, align 8
>   %3 = and i64 %2, 4503599627370495
>   ret i64 %3
14097,14111c11150,11158
< define void @helper_fyl2x() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, %struct.float_status* %6) nounwind
<   %8 = bitcast i64 %7 to double
<   %9 = fcmp ogt double %8, 0.000000e+00
<   br i1 %9, label %10, label %44
---
> define internal i32 @extractFloat64Exp(i64 %a) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   %2 = load i64* %1, align 8
>   %3 = lshr i64 %2, 52
>   %4 = and i64 %3, 2047
>   %5 = trunc i64 %4 to i32
>   ret i32 %5
> }
14113,14159c11160,11167
< ; <label>:10                                      ; preds = %0
<   %11 = tail call double @log(double %8) nounwind
<   %12 = fdiv double %11, 0x3FE62E42FEFA39EF
<   %13 = load %struct.CPUX86State** @env, align 8
<   %14 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 17
<   %15 = load i32* %14, align 4
<   %16 = add i32 %15, 1
<   %17 = and i32 %16, 7
<   %18 = zext i32 %17 to i64
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 21, i64 %18, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 21, i64 %18, i32 1
<   %19 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %19, align 1
<   %20 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 25
<   %21 = tail call i64 @floatx80_to_float64(i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %20) nounwind
<   %22 = bitcast i64 %21 to double
<   %23 = fmul double %12, %22
<   %24 = load %struct.CPUX86State** @env, align 8
<   %25 = getelementptr inbounds %struct.CPUX86State* %24, i64 0, i32 17
<   %26 = load i32* %25, align 4
<   %27 = add i32 %26, 1
<   %28 = and i32 %27, 7
<   %29 = zext i32 %28 to i64
<   %30 = bitcast double %23 to i64
<   %31 = getelementptr inbounds %struct.CPUX86State* %24, i64 0, i32 25
<   %32 = tail call { i64, i16 } @float64_to_floatx80(i64 %30, %struct.float_status* %31) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %32, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %32, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %24, i64 0, i32 21, i64 %29, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %24, i64 0, i32 21, i64 %29, i32 1
<   %33 = bitcast [8 x i8]* %.sroa.14.8..idx5 to i16*
<   store i16 %.fca.1.extract, i16* %33, align 1
<   %34 = load %struct.CPUX86State** @env, align 8
<   %35 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 17
<   %36 = load i32* %35, align 4
<   %37 = zext i32 %36 to i64
<   %38 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 20, i64 %37
<   store i8 1, i8* %38, align 1
<   %39 = load %struct.CPUX86State** @env, align 8
<   %40 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 17
<   %41 = load i32* %40, align 4
<   %42 = add i32 %41, 1
<   %43 = and i32 %42, 7
<   store i32 %43, i32* %40, align 4
<   br label %53
---
> define internal zeroext i8 @extractFloat64Sign(i64 %a) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   %2 = load i64* %1, align 8
>   %3 = lshr i64 %2, 63
>   %4 = trunc i64 %3 to i8
>   ret i8 %4
> }
14161,14172c11169,11196
< ; <label>:44                                      ; preds = %0
<   %45 = load %struct.CPUX86State** @env, align 8
<   %46 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 18
<   %47 = load i16* %46, align 2
<   %48 = and i16 %47, -18177
<   store i16 %48, i16* %46, align 2
<   %49 = load %struct.CPUX86State** @env, align 8
<   %50 = getelementptr inbounds %struct.CPUX86State* %49, i64 0, i32 18
<   %51 = load i16* %50, align 2
<   %52 = or i16 %51, 1024
<   store i16 %52, i16* %50, align 2
<   br label %53
---
> define internal i32 @float64_to_int32_round_to_zero(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %savedASig = alloca i64, align 8
>   %z = alloca i32, align 4
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i64 @float64_squash_input_denormal(i64 %4, %struct.float_status* %5)
>   store i64 %6, i64* %2, align 8
>   %7 = load i64* %2, align 8
>   %8 = call i64 @extractFloat64Frac(i64 %7)
>   store i64 %8, i64* %aSig, align 8
>   %9 = load i64* %2, align 8
>   %10 = call i32 @extractFloat64Exp(i64 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i64* %2, align 8
>   %12 = call zeroext i8 @extractFloat64Sign(i64 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp slt i32 1054, %13
>   br i1 %14, label %15, label %23
14174,14176c11198,11206
< ; <label>:53                                      ; preds = %44, %10
<   ret void
< }
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %aExp, align 4
>   %17 = icmp eq i32 %16, 2047
>   br i1 %17, label %18, label %22
> 
> ; <label>:18                                      ; preds = %15
>   %19 = load i64* %aSig, align 8
>   %20 = icmp ne i64 %19, 0
>   br i1 %20, label %21, label %22
14178c11208,11210
< declare double @log(double) nounwind
---
> ; <label>:21                                      ; preds = %18
>   store i8 0, i8* %aSign, align 1
>   br label %22
14180,14196c11212,11213
< define void @helper_fptan() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.010.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.010.0.copyload = load i64* %.sroa.010.0..idx, align 1
<   %.sroa.111.8..idx12 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.111.8..idx12 to i16*
<   %.sroa.111.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.010.0.copyload, i16 %.sroa.111.8.copyload, %struct.float_status* %6) nounwind
<   %8 = bitcast i64 %7 to double
<   %9 = fcmp ogt double %8, 0x43E0000000000000
<   %10 = fcmp olt double %8, 0xC3E0000000000000
<   %or.cond = or i1 %9, %10
<   br i1 %or.cond, label %11, label %16
---
> ; <label>:22                                      ; preds = %21, %18, %15
>   br label %67
14198,14204c11215,11238
< ; <label>:11                                      ; preds = %0
<   %12 = load %struct.CPUX86State** @env, align 8
<   %13 = getelementptr inbounds %struct.CPUX86State* %12, i64 0, i32 18
<   %14 = load i16* %13, align 2
<   %15 = or i16 %14, 1024
<   store i16 %15, i16* %13, align 2
<   br label %45
---
> ; <label>:23                                      ; preds = %0
>   %24 = load i32* %aExp, align 4
>   %25 = icmp slt i32 %24, 1023
>   br i1 %25, label %26, label %40
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load i32* %aExp, align 4
>   %28 = icmp ne i32 %27, 0
>   br i1 %28, label %32, label %29
> 
> ; <label>:29                                      ; preds = %26
>   %30 = load i64* %aSig, align 8
>   %31 = icmp ne i64 %30, 0
>   br i1 %31, label %32, label %39
> 
> ; <label>:32                                      ; preds = %29, %26
>   %33 = load %struct.float_status** %3, align 4
>   %34 = getelementptr inbounds %struct.float_status* %33, i32 0, i32 2
>   %35 = load i8* %34, align 1
>   %36 = sext i8 %35 to i32
>   %37 = or i32 %36, 32
>   %38 = trunc i32 %37 to i8
>   store i8 %38, i8* %34, align 1
>   br label %39
14206,14248c11240,11242
< ; <label>:16                                      ; preds = %0
<   %17 = tail call double @tan(double %8) nounwind
<   %18 = load %struct.CPUX86State** @env, align 8
<   %19 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 17
<   %20 = load i32* %19, align 4
<   %21 = zext i32 %20 to i64
<   %22 = bitcast double %17 to i64
<   %23 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 25
<   %24 = tail call { i64, i16 } @float64_to_floatx80(i64 %22, %struct.float_status* %23) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %24, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %24, 1
<   %.sroa.07.0..idx = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 21, i64 %21, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.07.0..idx, align 1
<   %.sroa.18.8..idx9 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 21, i64 %21, i32 1
<   %25 = bitcast [8 x i8]* %.sroa.18.8..idx9 to i16*
<   store i16 %.fca.1.extract, i16* %25, align 1
<   %26 = load %struct.CPUX86State** @env, align 8
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 17
<   %28 = load i32* %27, align 4
<   %29 = add i32 %28, 7
<   %30 = and i32 %29, 7
<   store i32 %30, i32* %27, align 4
<   %31 = load %struct.CPUX86State** @env, align 8
<   %32 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 17
<   %33 = load i32* %32, align 4
<   %34 = zext i32 %33 to i64
<   %35 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 20, i64 %34
<   store i8 0, i8* %35, align 1
<   %36 = load %struct.CPUX86State** @env, align 8
<   %37 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 17
<   %38 = load i32* %37, align 4
<   %39 = zext i32 %38 to i64
<   %.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 21, i64 %39, i32 0, i32 0
<   store i64 -9223372036854775808, i64* %.sroa.0.0..idx, align 1
<   %.sroa.1.8..idx2 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 21, i64 %39, i32 1
<   %40 = bitcast [8 x i8]* %.sroa.1.8..idx2 to i16*
<   store i16 16383, i16* %40, align 1
<   %41 = load %struct.CPUX86State** @env, align 8
<   %42 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 18
<   %43 = load i16* %42, align 2
<   %44 = and i16 %43, -1025
<   store i16 %44, i16* %42, align 2
<   br label %45
---
> ; <label>:39                                      ; preds = %32, %29
>   store i32 0, i32* %1
>   br label %89
14250,14252c11244,11245
< ; <label>:45                                      ; preds = %16, %11
<   ret void
< }
---
> ; <label>:40                                      ; preds = %23
>   br label %41
14254c11247,11272
< declare double @tan(double) nounwind
---
> ; <label>:41                                      ; preds = %40
>   %42 = load i64* %aSig, align 8
>   %43 = or i64 %42, 4503599627370496
>   store i64 %43, i64* %aSig, align 8
>   %44 = load i32* %aExp, align 4
>   %45 = sub nsw i32 1075, %44
>   store i32 %45, i32* %shiftCount, align 4
>   %46 = load i64* %aSig, align 8
>   store i64 %46, i64* %savedASig, align 8
>   %47 = load i32* %shiftCount, align 4
>   %48 = load i64* %aSig, align 8
>   %49 = zext i32 %47 to i64
>   %50 = lshr i64 %48, %49
>   store i64 %50, i64* %aSig, align 8
>   %51 = load i64* %aSig, align 8
>   %52 = trunc i64 %51 to i32
>   store i32 %52, i32* %z, align 4
>   %53 = load i8* %aSign, align 1
>   %54 = icmp ne i8 %53, 0
>   br i1 %54, label %55, label %58
> 
> ; <label>:55                                      ; preds = %41
>   %56 = load i32* %z, align 4
>   %57 = sub nsw i32 0, %56
>   store i32 %57, i32* %z, align 4
>   br label %58
14256,14314c11274,11282
< define void @helper_fpatan() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 1
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %7 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %7, align 1
<   %8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %9 = tail call i64 @floatx80_to_float64(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, %struct.float_status* %8) nounwind
<   %10 = bitcast i64 %9 to double
<   %11 = load %struct.CPUX86State** @env, align 8
<   %12 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 17
<   %13 = load i32* %12, align 4
<   %14 = zext i32 %13 to i64
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 21, i64 %14, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 21, i64 %14, i32 1
<   %15 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %15, align 1
<   %16 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 25
<   %17 = tail call i64 @floatx80_to_float64(i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %16) nounwind
<   %18 = bitcast i64 %17 to double
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 17
<   %21 = load i32* %20, align 4
<   %22 = add i32 %21, 1
<   %23 = and i32 %22, 7
<   %24 = zext i32 %23 to i64
<   %25 = tail call double @atan2(double %10, double %18) nounwind
<   %26 = bitcast double %25 to i64
<   %27 = load %struct.CPUX86State** @env, align 8
<   %28 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 25
<   %29 = tail call { i64, i16 } @float64_to_floatx80(i64 %26, %struct.float_status* %28) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %29, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %29, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 21, i64 %24, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 21, i64 %24, i32 1
<   %30 = bitcast [8 x i8]* %.sroa.14.8..idx5 to i16*
<   store i16 %.fca.1.extract, i16* %30, align 1
<   %31 = load %struct.CPUX86State** @env, align 8
<   %32 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 17
<   %33 = load i32* %32, align 4
<   %34 = zext i32 %33 to i64
<   %35 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 20, i64 %34
<   store i8 1, i8* %35, align 1
<   %36 = load %struct.CPUX86State** @env, align 8
<   %37 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 17
<   %38 = load i32* %37, align 4
<   %39 = add i32 %38, 1
<   %40 = and i32 %39, 7
<   store i32 %40, i32* %37, align 4
<   ret void
< }
---
> ; <label>:58                                      ; preds = %55, %41
>   %59 = load i32* %z, align 4
>   %60 = icmp slt i32 %59, 0
>   %61 = zext i1 %60 to i32
>   %62 = load i8* %aSign, align 1
>   %63 = zext i8 %62 to i32
>   %64 = xor i32 %61, %63
>   %65 = icmp ne i32 %64, 0
>   br i1 %65, label %66, label %73
14316c11284,11285
< declare double @atan2(double, double) nounwind
---
> ; <label>:66                                      ; preds = %58
>   br label %67
14318,14332c11287,11295
< define void @helper_fxtract() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %temp.sroa.0.0..idx45 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %temp.sroa.0.0.copyload46 = load i64* %temp.sroa.0.0..idx45, align 1
<   %temp.sroa.1.8..idx51 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %temp.sroa.1.8..idx51 to i16*
<   %temp.sroa.1.8.copyload52 = load i16* %5, align 1
<   %6 = and i16 %temp.sroa.1.8.copyload52, 32767
<   %7 = icmp eq i16 %6, 0
<   %8 = icmp eq i64 %temp.sroa.0.0.copyload46, 0
<   %.demorgan = and i1 %7, %8
<   br i1 %.demorgan, label %9, label %27
---
> ; <label>:67                                      ; preds = %66, %22
>   %68 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %68)
>   %69 = load i8* %aSign, align 1
>   %70 = zext i8 %69 to i32
>   %71 = icmp ne i32 %70, 0
>   %72 = select i1 %71, i32 -2147483648, i32 2147483647
>   store i32 %72, i32* %1
>   br label %89
14334,14362c11297,11314
< ; <label>:9                                       ; preds = %0
<   %10 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %11 = tail call { i64, i16 } @floatx80_div(i64 -9223372036854775808, i16 -16385, i64 0, i16 0, %struct.float_status* %10) nounwind
<   %.fca.0.extract6 = extractvalue { i64, i16 } %11, 0
<   %.fca.1.extract7 = extractvalue { i64, i16 } %11, 1
<   store i64 %.fca.0.extract6, i64* %temp.sroa.0.0..idx45, align 1
<   store i16 %.fca.1.extract7, i16* %5, align 1
<   %12 = load %struct.CPUX86State** @env, align 8
<   %13 = getelementptr inbounds %struct.CPUX86State* %12, i64 0, i32 17
<   %14 = load i32* %13, align 4
<   %15 = add i32 %14, 7
<   %16 = and i32 %15, 7
<   store i32 %16, i32* %13, align 4
<   %17 = load %struct.CPUX86State** @env, align 8
<   %18 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 17
<   %19 = load i32* %18, align 4
<   %20 = zext i32 %19 to i64
<   %21 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 20, i64 %20
<   store i8 0, i8* %21, align 1
<   %22 = load %struct.CPUX86State** @env, align 8
<   %23 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 17
<   %24 = load i32* %23, align 4
<   %25 = zext i32 %24 to i64
<   %temp.sroa.0.0..idx43 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 21, i64 %25, i32 0, i32 0
<   store i64 0, i64* %temp.sroa.0.0..idx43, align 1
<   %temp.sroa.1.8..idx49 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 21, i64 %25, i32 1
<   %26 = bitcast [8 x i8]* %temp.sroa.1.8..idx49 to i16*
<   store i16 %temp.sroa.1.8.copyload52, i16* %26, align 1
<   br label %50
---
> ; <label>:73                                      ; preds = %58
>   %74 = load i64* %aSig, align 8
>   %75 = load i32* %shiftCount, align 4
>   %76 = zext i32 %75 to i64
>   %77 = shl i64 %74, %76
>   %78 = load i64* %savedASig, align 8
>   %79 = icmp ne i64 %77, %78
>   br i1 %79, label %80, label %87
> 
> ; <label>:80                                      ; preds = %73
>   %81 = load %struct.float_status** %3, align 4
>   %82 = getelementptr inbounds %struct.float_status* %81, i32 0, i32 2
>   %83 = load i8* %82, align 1
>   %84 = sext i8 %83 to i32
>   %85 = or i32 %84, 32
>   %86 = trunc i32 %85 to i8
>   store i8 %86, i8* %82, align 1
>   br label %87
14364,14397c11316,11319
< ; <label>:27                                      ; preds = %0
<   %28 = zext i16 %temp.sroa.1.8.copyload52 to i32
<   %29 = and i32 %28, 32767
<   %30 = add nsw i32 %29, -16383
<   %31 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %32 = tail call { i64, i16 } @int32_to_floatx80(i32 %30, %struct.float_status* %31) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %32, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %32, 1
<   store i64 %.fca.0.extract, i64* %temp.sroa.0.0..idx45, align 1
<   store i16 %.fca.1.extract, i16* %5, align 1
<   %33 = load %struct.CPUX86State** @env, align 8
<   %34 = getelementptr inbounds %struct.CPUX86State* %33, i64 0, i32 17
<   %35 = load i32* %34, align 4
<   %36 = add i32 %35, 7
<   %37 = and i32 %36, 7
<   store i32 %37, i32* %34, align 4
<   %38 = load %struct.CPUX86State** @env, align 8
<   %39 = getelementptr inbounds %struct.CPUX86State* %38, i64 0, i32 17
<   %40 = load i32* %39, align 4
<   %41 = zext i32 %40 to i64
<   %42 = getelementptr inbounds %struct.CPUX86State* %38, i64 0, i32 20, i64 %41
<   store i8 0, i8* %42, align 1
<   %43 = and i16 %temp.sroa.1.8.copyload52, -32768
<   %44 = or i16 %43, 16383
<   %45 = load %struct.CPUX86State** @env, align 8
<   %46 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 17
<   %47 = load i32* %46, align 4
<   %48 = zext i32 %47 to i64
<   %temp.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 21, i64 %48, i32 0, i32 0
<   store i64 %temp.sroa.0.0.copyload46, i64* %temp.sroa.0.0..idx, align 1
<   %temp.sroa.1.8..idx47 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 21, i64 %48, i32 1
<   %49 = bitcast [8 x i8]* %temp.sroa.1.8..idx47 to i16*
<   store i16 %44, i16* %49, align 1
<   br label %50
---
> ; <label>:87                                      ; preds = %80, %73
>   %88 = load i32* %z, align 4
>   store i32 %88, i32* %1
>   br label %89
14399,14400c11321,11323
< ; <label>:50                                      ; preds = %27, %9
<   ret void
---
> ; <label>:89                                      ; preds = %87, %67, %39
>   %90 = load i32* %1
>   ret i32 %90
14403,14434c11326,11349
< declare { i64, i16 } @floatx80_div(i64, i16, i64, i16, %struct.float_status*)
< 
< define void @helper_fprem1() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.021.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.021.0.copyload = load i64* %.sroa.021.0..idx, align 1
<   %.sroa.122.8..idx23 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.122.8..idx23 to i16*
<   %.sroa.122.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.021.0.copyload, i16 %.sroa.122.8.copyload, %struct.float_status* %6) nounwind
<   %8 = bitcast i64 %7 to double
<   %9 = load %struct.CPUX86State** @env, align 8
<   %10 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 17
<   %11 = load i32* %10, align 4
<   %12 = add i32 %11, 1
<   %13 = and i32 %12, 7
<   %14 = zext i32 %13 to i64
<   %.sroa.018.0..idx = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 21, i64 %14, i32 0, i32 0
<   %.sroa.018.0.copyload = load i64* %.sroa.018.0..idx, align 1
<   %.sroa.119.8..idx20 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 21, i64 %14, i32 1
<   %15 = bitcast [8 x i8]* %.sroa.119.8..idx20 to i16*
<   %.sroa.119.8.copyload = load i16* %15, align 1
<   %16 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 25
<   %17 = tail call i64 @floatx80_to_float64(i64 %.sroa.018.0.copyload, i16 %.sroa.119.8.copyload, %struct.float_status* %16) nounwind
<   %18 = bitcast i64 %17 to double
<   %19 = tail call i32 @__isinf(double %8) nounwind readnone
<   %20 = icmp eq i32 %19, 0
<   br i1 %20, label %21, label %28
---
> define internal i32 @float64_to_int16_round_to_zero(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %savedASig = alloca i64, align 8
>   %z = alloca i32, align 4
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = call i64 @extractFloat64Frac(i64 %4)
>   store i64 %5, i64* %aSig, align 8
>   %6 = load i64* %2, align 8
>   %7 = call i32 @extractFloat64Exp(i64 %6)
>   store i32 %7, i32* %aExp, align 4
>   %8 = load i64* %2, align 8
>   %9 = call zeroext i8 @extractFloat64Sign(i64 %8)
>   store i8 %9, i8* %aSign, align 1
>   %10 = load i32* %aExp, align 4
>   %11 = icmp slt i32 1038, %10
>   br i1 %11, label %12, label %20
14436,14439c11351,11354
< ; <label>:21                                      ; preds = %0
<   %22 = tail call i32 @__isnan(double %8) nounwind readnone
<   %23 = icmp eq i32 %22, 0
<   br i1 %23, label %24, label %28
---
> ; <label>:12                                      ; preds = %0
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 2047
>   br i1 %14, label %15, label %19
14441,14467c11356,11359
< ; <label>:24                                      ; preds = %21
<   %25 = tail call i32 @__isnan(double %18) nounwind readnone
<   %26 = icmp ne i32 %25, 0
<   %27 = fcmp oeq double %18, 0.000000e+00
<   %or.cond = or i1 %26, %27
<   br i1 %or.cond, label %28, label %40
< 
< ; <label>:28                                      ; preds = %24, %21, %0
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 17
<   %31 = load i32* %30, align 4
<   %32 = zext i32 %31 to i64
<   %33 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 25
<   %34 = tail call { i64, i16 } @float64_to_floatx80(i64 9221120237041090560, %struct.float_status* %33) nounwind
<   %.fca.0.extract7 = extractvalue { i64, i16 } %34, 0
<   %.fca.1.extract8 = extractvalue { i64, i16 } %34, 1
<   %.sroa.015.0..idx = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 21, i64 %32, i32 0, i32 0
<   store i64 %.fca.0.extract7, i64* %.sroa.015.0..idx, align 1
<   %.sroa.116.8..idx17 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 21, i64 %32, i32 1
<   %35 = bitcast [8 x i8]* %.sroa.116.8..idx17 to i16*
<   store i16 %.fca.1.extract8, i16* %35, align 1
<   %36 = load %struct.CPUX86State** @env, align 8
<   %37 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 18
<   %38 = load i16* %37, align 2
<   %39 = and i16 %38, -18177
<   store i16 %39, i16* %37, align 2
<   br label %124
---
> ; <label>:15                                      ; preds = %12
>   %16 = load i64* %aSig, align 8
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %18, label %19
14469,14496c11361,11363
< ; <label>:40                                      ; preds = %24
<   %41 = load %struct.CPUX86State** @env, align 8
<   %42 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 17
<   %43 = load i32* %42, align 4
<   %44 = zext i32 %43 to i64
<   %fpsrcop1.sroa.1.8..idx29 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 21, i64 %44, i32 1
<   %45 = bitcast [8 x i8]* %fpsrcop1.sroa.1.8..idx29 to i16*
<   %fpsrcop1.sroa.1.8.copyload = load i16* %45, align 1
<   %46 = add i32 %43, 1
<   %47 = and i32 %46, 7
<   %48 = zext i32 %47 to i64
<   %fptemp1.sroa.1.8..idx28 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 21, i64 %48, i32 1
<   %49 = bitcast [8 x i8]* %fptemp1.sroa.1.8..idx28 to i16*
<   %fptemp1.sroa.1.8.copyload = load i16* %49, align 1
<   %50 = zext i16 %fpsrcop1.sroa.1.8.copyload to i32
<   %51 = and i32 %50, 32767
<   %52 = zext i16 %fptemp1.sroa.1.8.copyload to i32
<   %53 = and i32 %52, 32767
<   %54 = sub nsw i32 %51, %53
<   %55 = icmp slt i32 %54, 0
<   br i1 %55, label %56, label %60
< 
< ; <label>:56                                      ; preds = %40
<   %57 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 18
<   %58 = load i16* %57, align 2
<   %59 = and i16 %58, -18177
<   store i16 %59, i16* %57, align 2
<   br label %124
---
> ; <label>:18                                      ; preds = %15
>   store i8 0, i8* %aSign, align 1
>   br label %19
14498,14507c11365,11366
< ; <label>:60                                      ; preds = %40
<   %61 = icmp slt i32 %54, 53
<   br i1 %61, label %62, label %97
< 
< ; <label>:62                                      ; preds = %60
<   %63 = fdiv double %8, %18
<   %64 = tail call double @rint(double %63) nounwind readnone
<   %65 = fmul double %18, %64
<   %66 = fcmp olt double %64, 0.000000e+00
<   br i1 %66, label %67, label %69
---
> ; <label>:19                                      ; preds = %18, %15, %12
>   br label %66
14509,14511c11368,11391
< ; <label>:67                                      ; preds = %62
<   %68 = fsub double -0.000000e+00, %64
<   br label %69
---
> ; <label>:20                                      ; preds = %0
>   %21 = load i32* %aExp, align 4
>   %22 = icmp slt i32 %21, 1023
>   br i1 %22, label %23, label %37
> 
> ; <label>:23                                      ; preds = %20
>   %24 = load i32* %aExp, align 4
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %29, label %26
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load i64* %aSig, align 8
>   %28 = icmp ne i64 %27, 0
>   br i1 %28, label %29, label %36
> 
> ; <label>:29                                      ; preds = %26, %23
>   %30 = load %struct.float_status** %3, align 4
>   %31 = getelementptr inbounds %struct.float_status* %30, i32 0, i32 2
>   %32 = load i8* %31, align 1
>   %33 = sext i8 %32 to i32
>   %34 = or i32 %33, 32
>   %35 = trunc i32 %34 to i8
>   store i8 %35, i8* %31, align 1
>   br label %36
14513,14547c11393,11395
< ; <label>:69                                      ; preds = %67, %62
<   %q.0.in = phi double [ %68, %67 ], [ %64, %62 ]
<   %q.0 = fptosi double %q.0.in to i64
<   %70 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 18
<   %71 = load i16* %70, align 2
<   %72 = and i16 %71, -18177
<   store i16 %72, i16* %70, align 2
<   %73 = shl i64 %q.0, 6
<   %74 = and i64 %73, 256
<   %75 = load %struct.CPUX86State** @env, align 8
<   %76 = getelementptr inbounds %struct.CPUX86State* %75, i64 0, i32 18
<   %77 = load i16* %76, align 2
<   %78 = zext i16 %77 to i64
<   %79 = or i64 %78, %74
<   %80 = trunc i64 %79 to i16
<   store i16 %80, i16* %76, align 2
<   %81 = shl i64 %q.0, 13
<   %82 = and i64 %81, 16384
<   %83 = load %struct.CPUX86State** @env, align 8
<   %84 = getelementptr inbounds %struct.CPUX86State* %83, i64 0, i32 18
<   %85 = load i16* %84, align 2
<   %86 = zext i16 %85 to i64
<   %87 = or i64 %86, %82
<   %88 = trunc i64 %87 to i16
<   store i16 %88, i16* %84, align 2
<   %89 = shl i64 %q.0, 9
<   %90 = and i64 %89, 512
<   %91 = load %struct.CPUX86State** @env, align 8
<   %92 = getelementptr inbounds %struct.CPUX86State* %91, i64 0, i32 18
<   %93 = load i16* %92, align 2
<   %94 = zext i16 %93 to i64
<   %95 = or i64 %94, %90
<   %96 = trunc i64 %95 to i16
<   store i16 %96, i16* %92, align 2
<   br label %115
---
> ; <label>:36                                      ; preds = %29, %26
>   store i32 0, i32* %1
>   br label %88
14549,14565c11397,11398
< ; <label>:97                                      ; preds = %60
<   %98 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 18
<   %99 = load i16* %98, align 2
<   %100 = or i16 %99, 1024
<   store i16 %100, i16* %98, align 2
<   %101 = add nsw i32 %54, -50
<   %exp2 = tail call double @ldexp(double 1.000000e+00, i32 %101) nounwind
<   %102 = fdiv double %8, %18
<   %103 = fdiv double %102, %exp2
<   %104 = fcmp olt double %103, 0.000000e+00
<   br i1 %104, label %105, label %109
< 
< ; <label>:105                                     ; preds = %97
<   %106 = tail call double @fabs(double %103) nounwind readnone
<   %107 = tail call double @floor(double %106) nounwind readnone
<   %108 = fsub double -0.000000e+00, %107
<   br label %111
---
> ; <label>:37                                      ; preds = %20
>   br label %38
14567,14569c11400,11450
< ; <label>:109                                     ; preds = %97
<   %110 = tail call double @floor(double %103) nounwind readnone
<   br label %111
---
> ; <label>:38                                      ; preds = %37
>   %39 = load i64* %aSig, align 8
>   %40 = or i64 %39, 4503599627370496
>   store i64 %40, i64* %aSig, align 8
>   %41 = load i32* %aExp, align 4
>   %42 = sub nsw i32 1075, %41
>   store i32 %42, i32* %shiftCount, align 4
>   %43 = load i64* %aSig, align 8
>   store i64 %43, i64* %savedASig, align 8
>   %44 = load i32* %shiftCount, align 4
>   %45 = load i64* %aSig, align 8
>   %46 = zext i32 %44 to i64
>   %47 = lshr i64 %45, %46
>   store i64 %47, i64* %aSig, align 8
>   %48 = load i64* %aSig, align 8
>   %49 = trunc i64 %48 to i32
>   store i32 %49, i32* %z, align 4
>   %50 = load i8* %aSign, align 1
>   %51 = icmp ne i8 %50, 0
>   br i1 %51, label %52, label %55
> 
> ; <label>:52                                      ; preds = %38
>   %53 = load i32* %z, align 4
>   %54 = sub nsw i32 0, %53
>   store i32 %54, i32* %z, align 4
>   br label %55
> 
> ; <label>:55                                      ; preds = %52, %38
>   %56 = load i32* %z, align 4
>   %57 = trunc i32 %56 to i16
>   %58 = sext i16 %57 to i32
>   %59 = icmp slt i32 %58, 0
>   %60 = zext i1 %59 to i32
>   %61 = load i8* %aSign, align 1
>   %62 = zext i8 %61 to i32
>   %63 = xor i32 %60, %62
>   %64 = icmp ne i32 %63, 0
>   br i1 %64, label %65, label %72
> 
> ; <label>:65                                      ; preds = %55
>   br label %66
> 
> ; <label>:66                                      ; preds = %65, %19
>   %67 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %67)
>   %68 = load i8* %aSign, align 1
>   %69 = zext i8 %68 to i32
>   %70 = icmp ne i32 %69, 0
>   %71 = select i1 %70, i32 -32768, i32 32767
>   store i32 %71, i32* %1
>   br label %88
14571,14575c11452,11469
< ; <label>:111                                     ; preds = %109, %105
<   %112 = phi double [ %108, %105 ], [ %110, %109 ]
<   %113 = fmul double %18, %112
<   %114 = fmul double %exp2, %113
<   br label %115
---
> ; <label>:72                                      ; preds = %55
>   %73 = load i64* %aSig, align 8
>   %74 = load i32* %shiftCount, align 4
>   %75 = zext i32 %74 to i64
>   %76 = shl i64 %73, %75
>   %77 = load i64* %savedASig, align 8
>   %78 = icmp ne i64 %76, %77
>   br i1 %78, label %79, label %86
> 
> ; <label>:79                                      ; preds = %72
>   %80 = load %struct.float_status** %3, align 4
>   %81 = getelementptr inbounds %struct.float_status* %80, i32 0, i32 2
>   %82 = load i8* %81, align 1
>   %83 = sext i8 %82 to i32
>   %84 = or i32 %83, 32
>   %85 = trunc i32 %84 to i8
>   store i8 %85, i8* %81, align 1
>   br label %86
14577,14594c11471,11474
< ; <label>:115                                     ; preds = %111, %69
<   %.pn = phi double [ %65, %69 ], [ %114, %111 ]
<   %st0.0 = fsub double %8, %.pn
<   %116 = load %struct.CPUX86State** @env, align 8
<   %117 = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 17
<   %118 = load i32* %117, align 4
<   %119 = zext i32 %118 to i64
<   %120 = bitcast double %st0.0 to i64
<   %121 = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 25
<   %122 = tail call { i64, i16 } @float64_to_floatx80(i64 %120, %struct.float_status* %121) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %122, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %122, 1
<   %.sroa.04.0..idx = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 21, i64 %119, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.04.0..idx, align 1
<   %.sroa.15.8..idx6 = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 21, i64 %119, i32 1
<   %123 = bitcast [8 x i8]* %.sroa.15.8..idx6 to i16*
<   store i16 %.fca.1.extract, i16* %123, align 1
<   br label %124
---
> ; <label>:86                                      ; preds = %79, %72
>   %87 = load i32* %z, align 4
>   store i32 %87, i32* %1
>   br label %88
14596,14598c11476,11507
< ; <label>:124                                     ; preds = %115, %56, %28
<   ret void
< }
---
> ; <label>:88                                      ; preds = %86, %66, %36
>   %89 = load i32* %1
>   ret i32 %89
> }
> 
> define internal i64 @float64_to_int64(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %aSigExtra = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i64 @float64_squash_input_denormal(i64 %4, %struct.float_status* %5)
>   store i64 %6, i64* %2, align 8
>   %7 = load i64* %2, align 8
>   %8 = call i64 @extractFloat64Frac(i64 %7)
>   store i64 %8, i64* %aSig, align 8
>   %9 = load i64* %2, align 8
>   %10 = call i32 @extractFloat64Exp(i64 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i64* %2, align 8
>   %12 = call zeroext i8 @extractFloat64Sign(i64 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp ne i32 %13, 0
>   br i1 %14, label %15, label %18
14600c11509,11513
< declare i32 @__isinf(double) nounwind readnone
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i64* %aSig, align 8
>   %17 = or i64 %16, 4503599627370496
>   store i64 %17, i64* %aSig, align 8
>   br label %18
14602c11515,11538
< declare i32 @__isnan(double) nounwind readnone
---
> ; <label>:18                                      ; preds = %15, %0
>   %19 = load i32* %aExp, align 4
>   %20 = sub nsw i32 1075, %19
>   store i32 %20, i32* %shiftCount, align 4
>   %21 = load i32* %shiftCount, align 4
>   %22 = icmp sle i32 %21, 0
>   br i1 %22, label %23, label %44
> 
> ; <label>:23                                      ; preds = %18
>   %24 = load i32* %aExp, align 4
>   %25 = icmp slt i32 1086, %24
>   br i1 %25, label %26, label %38
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   %28 = load i8* %aSign, align 1
>   %29 = icmp ne i8 %28, 0
>   br i1 %29, label %30, label %36
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load i32* %aExp, align 4
>   %32 = icmp eq i32 %31, 2047
>   br i1 %32, label %33, label %37
14604c11540,11543
< declare double @rint(double) nounwind readnone
---
> ; <label>:33                                      ; preds = %30
>   %34 = load i64* %aSig, align 8
>   %35 = icmp ne i64 %34, 4503599627370496
>   br i1 %35, label %36, label %37
14606c11545,11547
< declare double @floor(double) nounwind readnone
---
> ; <label>:36                                      ; preds = %33, %26
>   store i64 9223372036854775807, i64* %1
>   br label %53
14608c11549,11551
< declare double @fabs(double) nounwind readnone
---
> ; <label>:37                                      ; preds = %33, %30
>   store i64 -9223372036854775808, i64* %1
>   br label %53
14610,14639c11553,11561
< define void @helper_fprem() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.021.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.021.0.copyload = load i64* %.sroa.021.0..idx, align 1
<   %.sroa.122.8..idx23 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.122.8..idx23 to i16*
<   %.sroa.122.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.021.0.copyload, i16 %.sroa.122.8.copyload, %struct.float_status* %6) nounwind
<   %8 = bitcast i64 %7 to double
<   %9 = load %struct.CPUX86State** @env, align 8
<   %10 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 17
<   %11 = load i32* %10, align 4
<   %12 = add i32 %11, 1
<   %13 = and i32 %12, 7
<   %14 = zext i32 %13 to i64
<   %.sroa.018.0..idx = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 21, i64 %14, i32 0, i32 0
<   %.sroa.018.0.copyload = load i64* %.sroa.018.0..idx, align 1
<   %.sroa.119.8..idx20 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 21, i64 %14, i32 1
<   %15 = bitcast [8 x i8]* %.sroa.119.8..idx20 to i16*
<   %.sroa.119.8.copyload = load i16* %15, align 1
<   %16 = getelementptr inbounds %struct.CPUX86State* %9, i64 0, i32 25
<   %17 = tail call i64 @floatx80_to_float64(i64 %.sroa.018.0.copyload, i16 %.sroa.119.8.copyload, %struct.float_status* %16) nounwind
<   %18 = bitcast i64 %17 to double
<   %19 = tail call i32 @__isinf(double %8) nounwind readnone
<   %20 = icmp eq i32 %19, 0
<   br i1 %20, label %21, label %28
---
> ; <label>:38                                      ; preds = %23
>   store i64 0, i64* %aSigExtra, align 8
>   %39 = load i32* %shiftCount, align 4
>   %40 = sub nsw i32 0, %39
>   %41 = load i64* %aSig, align 8
>   %42 = zext i32 %40 to i64
>   %43 = shl i64 %41, %42
>   store i64 %43, i64* %aSig, align 8
>   br label %47
14641,14644c11563,11567
< ; <label>:21                                      ; preds = %0
<   %22 = tail call i32 @__isnan(double %8) nounwind readnone
<   %23 = icmp eq i32 %22, 0
<   br i1 %23, label %24, label %28
---
> ; <label>:44                                      ; preds = %18
>   %45 = load i64* %aSig, align 8
>   %46 = load i32* %shiftCount, align 4
>   call void @shift64ExtraRightJamming(i64 %45, i64 0, i32 %46, i64* %aSig, i64* %aSigExtra)
>   br label %47
14646,14710c11569,11576
< ; <label>:24                                      ; preds = %21
<   %25 = tail call i32 @__isnan(double %18) nounwind readnone
<   %26 = icmp ne i32 %25, 0
<   %27 = fcmp oeq double %18, 0.000000e+00
<   %or.cond = or i1 %26, %27
<   br i1 %or.cond, label %28, label %40
< 
< ; <label>:28                                      ; preds = %24, %21, %0
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 17
<   %31 = load i32* %30, align 4
<   %32 = zext i32 %31 to i64
<   %33 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 25
<   %34 = tail call { i64, i16 } @float64_to_floatx80(i64 9221120237041090560, %struct.float_status* %33) nounwind
<   %.fca.0.extract7 = extractvalue { i64, i16 } %34, 0
<   %.fca.1.extract8 = extractvalue { i64, i16 } %34, 1
<   %.sroa.015.0..idx = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 21, i64 %32, i32 0, i32 0
<   store i64 %.fca.0.extract7, i64* %.sroa.015.0..idx, align 1
<   %.sroa.116.8..idx17 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 21, i64 %32, i32 1
<   %35 = bitcast [8 x i8]* %.sroa.116.8..idx17 to i16*
<   store i16 %.fca.1.extract8, i16* %35, align 1
<   %36 = load %struct.CPUX86State** @env, align 8
<   %37 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 18
<   %38 = load i16* %37, align 2
<   %39 = and i16 %38, -18177
<   store i16 %39, i16* %37, align 2
<   br label %131
< 
< ; <label>:40                                      ; preds = %24
<   %41 = load %struct.CPUX86State** @env, align 8
<   %42 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 17
<   %43 = load i32* %42, align 4
<   %44 = zext i32 %43 to i64
<   %fpsrcop1.sroa.1.8..idx30 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 21, i64 %44, i32 1
<   %45 = bitcast [8 x i8]* %fpsrcop1.sroa.1.8..idx30 to i16*
<   %fpsrcop1.sroa.1.8.copyload = load i16* %45, align 1
<   %46 = add i32 %43, 1
<   %47 = and i32 %46, 7
<   %48 = zext i32 %47 to i64
<   %fptemp1.sroa.1.8..idx29 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 21, i64 %48, i32 1
<   %49 = bitcast [8 x i8]* %fptemp1.sroa.1.8..idx29 to i16*
<   %fptemp1.sroa.1.8.copyload = load i16* %49, align 1
<   %50 = zext i16 %fpsrcop1.sroa.1.8.copyload to i32
<   %51 = and i32 %50, 32767
<   %52 = zext i16 %fptemp1.sroa.1.8.copyload to i32
<   %53 = and i32 %52, 32767
<   %54 = sub nsw i32 %51, %53
<   %55 = icmp slt i32 %54, 0
<   br i1 %55, label %56, label %60
< 
< ; <label>:56                                      ; preds = %40
<   %57 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 18
<   %58 = load i16* %57, align 2
<   %59 = and i16 %58, -18177
<   store i16 %59, i16* %57, align 2
<   br label %131
< 
< ; <label>:60                                      ; preds = %40
<   %61 = icmp slt i32 %54, 53
<   br i1 %61, label %62, label %103
< 
< ; <label>:62                                      ; preds = %60
<   %63 = fdiv double %8, %18
<   %64 = fcmp olt double %63, 0.000000e+00
<   br i1 %64, label %65, label %67
---
> ; <label>:47                                      ; preds = %44, %38
>   %48 = load i8* %aSign, align 1
>   %49 = load i64* %aSig, align 8
>   %50 = load i64* %aSigExtra, align 8
>   %51 = load %struct.float_status** %3, align 4
>   %52 = call i64 @roundAndPackInt64(i8 zeroext %48, i64 %49, i64 %50, %struct.float_status* %51)
>   store i64 %52, i64* %1
>   br label %53
14712,14714c11578,11609
< ; <label>:65                                      ; preds = %62
<   %66 = tail call double @ceil(double %63) nounwind readnone
<   br label %69
---
> ; <label>:53                                      ; preds = %47, %37, %36
>   %54 = load i64* %1
>   ret i64 %54
> }
> 
> define internal i64 @float64_to_int64_round_to_zero(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %z = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i64 @float64_squash_input_denormal(i64 %4, %struct.float_status* %5)
>   store i64 %6, i64* %2, align 8
>   %7 = load i64* %2, align 8
>   %8 = call i64 @extractFloat64Frac(i64 %7)
>   store i64 %8, i64* %aSig, align 8
>   %9 = load i64* %2, align 8
>   %10 = call i32 @extractFloat64Exp(i64 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i64* %2, align 8
>   %12 = call zeroext i8 @extractFloat64Sign(i64 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp ne i32 %13, 0
>   br i1 %14, label %15, label %18
14716,14718c11611,11615
< ; <label>:67                                      ; preds = %62
<   %68 = tail call double @floor(double %63) nounwind readnone
<   br label %69
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i64* %aSig, align 8
>   %17 = or i64 %16, 4503599627370496
>   store i64 %17, i64* %aSig, align 8
>   br label %18
14720,14724c11617,11640
< ; <label>:69                                      ; preds = %67, %65
<   %70 = phi double [ %66, %65 ], [ %68, %67 ]
<   %71 = fmul double %18, %70
<   %72 = fcmp olt double %70, 0.000000e+00
<   br i1 %72, label %73, label %75
---
> ; <label>:18                                      ; preds = %15, %0
>   %19 = load i32* %aExp, align 4
>   %20 = sub nsw i32 %19, 1075
>   store i32 %20, i32* %shiftCount, align 4
>   %21 = load i32* %shiftCount, align 4
>   %22 = icmp sle i32 0, %21
>   br i1 %22, label %23, label %47
> 
> ; <label>:23                                      ; preds = %18
>   %24 = load i32* %aExp, align 4
>   %25 = icmp sle i32 1086, %24
>   br i1 %25, label %26, label %42
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load i64* %2, align 8
>   %28 = icmp ne i64 %27, -4332462841530417152
>   br i1 %28, label %29, label %41
> 
> ; <label>:29                                      ; preds = %26
>   %30 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %30)
>   %31 = load i8* %aSign, align 1
>   %32 = icmp ne i8 %31, 0
>   br i1 %32, label %33, label %39
14726,14728c11642,11645
< ; <label>:73                                      ; preds = %69
<   %74 = fsub double -0.000000e+00, %70
<   br label %75
---
> ; <label>:33                                      ; preds = %29
>   %34 = load i32* %aExp, align 4
>   %35 = icmp eq i32 %34, 2047
>   br i1 %35, label %36, label %40
14730,14764c11647,11650
< ; <label>:75                                      ; preds = %73, %69
<   %q.0.in = phi double [ %74, %73 ], [ %70, %69 ]
<   %q.0 = fptosi double %q.0.in to i64
<   %76 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 18
<   %77 = load i16* %76, align 2
<   %78 = and i16 %77, -18177
<   store i16 %78, i16* %76, align 2
<   %79 = shl i64 %q.0, 6
<   %80 = and i64 %79, 256
<   %81 = load %struct.CPUX86State** @env, align 8
<   %82 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 18
<   %83 = load i16* %82, align 2
<   %84 = zext i16 %83 to i64
<   %85 = or i64 %84, %80
<   %86 = trunc i64 %85 to i16
<   store i16 %86, i16* %82, align 2
<   %87 = shl i64 %q.0, 13
<   %88 = and i64 %87, 16384
<   %89 = load %struct.CPUX86State** @env, align 8
<   %90 = getelementptr inbounds %struct.CPUX86State* %89, i64 0, i32 18
<   %91 = load i16* %90, align 2
<   %92 = zext i16 %91 to i64
<   %93 = or i64 %92, %88
<   %94 = trunc i64 %93 to i16
<   store i16 %94, i16* %90, align 2
<   %95 = shl i64 %q.0, 9
<   %96 = and i64 %95, 512
<   %97 = load %struct.CPUX86State** @env, align 8
<   %98 = getelementptr inbounds %struct.CPUX86State* %97, i64 0, i32 18
<   %99 = load i16* %98, align 2
<   %100 = zext i16 %99 to i64
<   %101 = or i64 %100, %96
<   %102 = trunc i64 %101 to i16
<   store i16 %102, i16* %98, align 2
<   br label %122
---
> ; <label>:36                                      ; preds = %33
>   %37 = load i64* %aSig, align 8
>   %38 = icmp ne i64 %37, 4503599627370496
>   br i1 %38, label %39, label %40
14766,14784c11652,11674
< ; <label>:103                                     ; preds = %60
<   %104 = srem i32 %54, 32
<   %105 = getelementptr inbounds %struct.CPUX86State* %41, i64 0, i32 18
<   %106 = load i16* %105, align 2
<   %107 = or i16 %106, 1024
<   store i16 %107, i16* %105, align 2
<   %.neg51 = add i32 %54, -32
<   %108 = sub i32 %.neg51, %104
<   %exp2 = tail call double @ldexp(double 1.000000e+00, i32 %108) nounwind
<   %109 = fdiv double %8, %18
<   %110 = fdiv double %109, %exp2
<   %111 = fcmp olt double %110, 0.000000e+00
<   br i1 %111, label %112, label %116
< 
< ; <label>:112                                     ; preds = %103
<   %113 = tail call double @fabs(double %110) nounwind readnone
<   %114 = tail call double @floor(double %113) nounwind readnone
<   %115 = fsub double -0.000000e+00, %114
<   br label %118
---
> ; <label>:39                                      ; preds = %36, %29
>   store i64 9223372036854775807, i64* %1
>   br label %92
> 
> ; <label>:40                                      ; preds = %36, %33
>   br label %41
> 
> ; <label>:41                                      ; preds = %40, %26
>   store i64 -9223372036854775808, i64* %1
>   br label %92
> 
> ; <label>:42                                      ; preds = %23
>   %43 = load i64* %aSig, align 8
>   %44 = load i32* %shiftCount, align 4
>   %45 = zext i32 %44 to i64
>   %46 = shl i64 %43, %45
>   store i64 %46, i64* %z, align 8
>   br label %84
> 
> ; <label>:47                                      ; preds = %18
>   %48 = load i32* %aExp, align 4
>   %49 = icmp slt i32 %48, 1022
>   br i1 %49, label %50, label %64
14786,14788c11676,11692
< ; <label>:116                                     ; preds = %103
<   %117 = tail call double @floor(double %110) nounwind readnone
<   br label %118
---
> ; <label>:50                                      ; preds = %47
>   %51 = load i32* %aExp, align 4
>   %52 = sext i32 %51 to i64
>   %53 = load i64* %aSig, align 8
>   %54 = or i64 %52, %53
>   %55 = icmp ne i64 %54, 0
>   br i1 %55, label %56, label %63
> 
> ; <label>:56                                      ; preds = %50
>   %57 = load %struct.float_status** %3, align 4
>   %58 = getelementptr inbounds %struct.float_status* %57, i32 0, i32 2
>   %59 = load i8* %58, align 1
>   %60 = sext i8 %59 to i32
>   %61 = or i32 %60, 32
>   %62 = trunc i32 %61 to i8
>   store i8 %62, i8* %58, align 1
>   br label %63
14790,14794c11694,11735
< ; <label>:118                                     ; preds = %116, %112
<   %119 = phi double [ %115, %112 ], [ %117, %116 ]
<   %120 = fmul double %18, %119
<   %121 = fmul double %exp2, %120
<   br label %122
---
> ; <label>:63                                      ; preds = %56, %50
>   store i64 0, i64* %1
>   br label %92
> 
> ; <label>:64                                      ; preds = %47
>   %65 = load i64* %aSig, align 8
>   %66 = load i32* %shiftCount, align 4
>   %67 = sub nsw i32 0, %66
>   %68 = zext i32 %67 to i64
>   %69 = lshr i64 %65, %68
>   store i64 %69, i64* %z, align 8
>   %70 = load i64* %aSig, align 8
>   %71 = load i32* %shiftCount, align 4
>   %72 = and i32 %71, 63
>   %73 = zext i32 %72 to i64
>   %74 = shl i64 %70, %73
>   %75 = icmp ne i64 %74, 0
>   br i1 %75, label %76, label %83
> 
> ; <label>:76                                      ; preds = %64
>   %77 = load %struct.float_status** %3, align 4
>   %78 = getelementptr inbounds %struct.float_status* %77, i32 0, i32 2
>   %79 = load i8* %78, align 1
>   %80 = sext i8 %79 to i32
>   %81 = or i32 %80, 32
>   %82 = trunc i32 %81 to i8
>   store i8 %82, i8* %78, align 1
>   br label %83
> 
> ; <label>:83                                      ; preds = %76, %64
>   br label %84
> 
> ; <label>:84                                      ; preds = %83, %42
>   %85 = load i8* %aSign, align 1
>   %86 = icmp ne i8 %85, 0
>   br i1 %86, label %87, label %90
> 
> ; <label>:87                                      ; preds = %84
>   %88 = load i64* %z, align 8
>   %89 = sub nsw i64 0, %88
>   store i64 %89, i64* %z, align 8
>   br label %90
14796,14813c11737,11740
< ; <label>:122                                     ; preds = %118, %75
<   %.pn = phi double [ %71, %75 ], [ %121, %118 ]
<   %st0.0 = fsub double %8, %.pn
<   %123 = load %struct.CPUX86State** @env, align 8
<   %124 = getelementptr inbounds %struct.CPUX86State* %123, i64 0, i32 17
<   %125 = load i32* %124, align 4
<   %126 = zext i32 %125 to i64
<   %127 = bitcast double %st0.0 to i64
<   %128 = getelementptr inbounds %struct.CPUX86State* %123, i64 0, i32 25
<   %129 = tail call { i64, i16 } @float64_to_floatx80(i64 %127, %struct.float_status* %128) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %129, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %129, 1
<   %.sroa.04.0..idx = getelementptr inbounds %struct.CPUX86State* %123, i64 0, i32 21, i64 %126, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.04.0..idx, align 1
<   %.sroa.15.8..idx6 = getelementptr inbounds %struct.CPUX86State* %123, i64 0, i32 21, i64 %126, i32 1
<   %130 = bitcast [8 x i8]* %.sroa.15.8..idx6 to i16*
<   store i16 %.fca.1.extract, i16* %130, align 1
<   br label %131
---
> ; <label>:90                                      ; preds = %87, %84
>   %91 = load i64* %z, align 8
>   store i64 %91, i64* %1
>   br label %92
14815,14816c11742,11744
< ; <label>:131                                     ; preds = %122, %56, %28
<   ret void
---
> ; <label>:92                                      ; preds = %90, %63, %41, %39
>   %93 = load i64* %1
>   ret i64 %93
14819,14836c11747,11761
< declare double @ceil(double) nounwind readnone
< 
< define void @helper_fyl2xp1() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.09.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx, align 1
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.09.0.copyload, i16 %.sroa.110.8.copyload, %struct.float_status* %6) nounwind
<   %8 = bitcast i64 %7 to double
<   %9 = fadd double %8, 1.000000e+00
<   %10 = fcmp ogt double %9, 0.000000e+00
<   br i1 %10, label %11, label %45
---
> define internal i32 @commonNaNToFloat32(%struct.commonNaNT* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %mantissa = alloca i32, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 1
>   %4 = load i64* %3, align 4
>   %5 = lshr i64 %4, 41
>   %6 = trunc i64 %5 to i32
>   store i32 %6, i32* %mantissa, align 4
>   %7 = load %struct.float_status** %2, align 4
>   %8 = getelementptr inbounds %struct.float_status* %7, i32 0, i32 6
>   %9 = load i8* %8, align 1
>   %10 = icmp ne i8 %9, 0
>   br i1 %10, label %11, label %12
14839,14884c11764,11765
<   %12 = tail call double @log(double %9) nounwind
<   %13 = fdiv double %12, 0x3FE62E42FEFA39EF
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 17
<   %16 = load i32* %15, align 4
<   %17 = add i32 %16, 1
<   %18 = and i32 %17, 7
<   %19 = zext i32 %18 to i64
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 21, i64 %19, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 21, i64 %19, i32 1
<   %20 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %20, align 1
<   %21 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 25
<   %22 = tail call i64 @floatx80_to_float64(i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %21) nounwind
<   %23 = bitcast i64 %22 to double
<   %24 = fmul double %13, %23
<   %25 = load %struct.CPUX86State** @env, align 8
<   %26 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 17
<   %27 = load i32* %26, align 4
<   %28 = add i32 %27, 1
<   %29 = and i32 %28, 7
<   %30 = zext i32 %29 to i64
<   %31 = bitcast double %24 to i64
<   %32 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 25
<   %33 = tail call { i64, i16 } @float64_to_floatx80(i64 %31, %struct.float_status* %32) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %33, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %33, 1
<   %.sroa.03.0..idx = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 21, i64 %30, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.03.0..idx, align 1
<   %.sroa.14.8..idx5 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 21, i64 %30, i32 1
<   %34 = bitcast [8 x i8]* %.sroa.14.8..idx5 to i16*
<   store i16 %.fca.1.extract, i16* %34, align 1
<   %35 = load %struct.CPUX86State** @env, align 8
<   %36 = getelementptr inbounds %struct.CPUX86State* %35, i64 0, i32 17
<   %37 = load i32* %36, align 4
<   %38 = zext i32 %37 to i64
<   %39 = getelementptr inbounds %struct.CPUX86State* %35, i64 0, i32 20, i64 %38
<   store i8 1, i8* %39, align 1
<   %40 = load %struct.CPUX86State** @env, align 8
<   %41 = getelementptr inbounds %struct.CPUX86State* %40, i64 0, i32 17
<   %42 = load i32* %41, align 4
<   %43 = add i32 %42, 1
<   %44 = and i32 %43, 7
<   store i32 %44, i32* %41, align 4
<   br label %54
---
>   store i32 -4194304, i32* %1
>   br label %28
14886,14897c11767,11770
< ; <label>:45                                      ; preds = %0
<   %46 = load %struct.CPUX86State** @env, align 8
<   %47 = getelementptr inbounds %struct.CPUX86State* %46, i64 0, i32 18
<   %48 = load i16* %47, align 2
<   %49 = and i16 %48, -18177
<   store i16 %49, i16* %47, align 2
<   %50 = load %struct.CPUX86State** @env, align 8
<   %51 = getelementptr inbounds %struct.CPUX86State* %50, i64 0, i32 18
<   %52 = load i16* %51, align 2
<   %53 = or i16 %52, 1024
<   store i16 %53, i16* %51, align 2
<   br label %54
---
> ; <label>:12                                      ; preds = %0
>   %13 = load i32* %mantissa, align 4
>   %14 = icmp ne i32 %13, 0
>   br i1 %14, label %15, label %27
14899,14900c11772,11793
< ; <label>:54                                      ; preds = %45, %11
<   ret void
---
> ; <label>:15                                      ; preds = %12
>   %16 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 0
>   %17 = load i8* %16, align 1
>   %18 = zext i8 %17 to i32
>   %19 = shl i32 %18, 31
>   %20 = or i32 %19, 2139095040
>   %21 = zext i32 %20 to i64
>   %22 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 1
>   %23 = load i64* %22, align 4
>   %24 = lshr i64 %23, 41
>   %25 = or i64 %21, %24
>   %26 = trunc i64 %25 to i32
>   store i32 %26, i32* %1
>   br label %28
> 
> ; <label>:27                                      ; preds = %12
>   store i32 -4194304, i32* %1
>   br label %28
> 
> ; <label>:28                                      ; preds = %27, %15, %11
>   %29 = load i32* %1
>   ret i32 %29
14903,14912c11796,11805
< define void @helper_fsqrt() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.110.8..idx11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.110.8..idx11 to i16*
<   %.sroa.110.8.copyload = load i16* %5, align 1
<   %6 = icmp sgt i16 %.sroa.110.8.copyload, -1
<   br i1 %6, label %15, label %7
---
> define internal void @float64ToCommonNaN(%struct.commonNaNT* noalias sret %agg.result, i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %z = alloca %struct.commonNaNT, align 4
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i64* %1, align 8
>   %4 = call i32 @float64_is_signaling_nan(i64 %3)
>   %5 = icmp ne i32 %4, 0
>   br i1 %5, label %6, label %8
14914,14931c11807,11810
< ; <label>:7                                       ; preds = %0
<   %8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %9 = load i16* %8, align 2
<   %10 = and i16 %9, -18177
<   store i16 %10, i16* %8, align 2
<   %11 = load %struct.CPUX86State** @env, align 8
<   %12 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 18
<   %13 = load i16* %12, align 2
<   %14 = or i16 %13, 1024
<   store i16 %14, i16* %12, align 2
<   %.pre = load %struct.CPUX86State** @env, align 8
<   %.phi.trans.insert = getelementptr inbounds %struct.CPUX86State* %.pre, i64 0, i32 17
<   %.pre12 = load i32* %.phi.trans.insert, align 4
<   %.phi.trans.insert13 = zext i32 %.pre12 to i64
<   %.sroa.17.8..idx8.phi.trans.insert = getelementptr inbounds %struct.CPUX86State* %.pre, i64 0, i32 21, i64 %.phi.trans.insert13, i32 1
<   %.phi.trans.insert14 = bitcast [8 x i8]* %.sroa.17.8..idx8.phi.trans.insert to i16*
<   %.sroa.17.8.copyload.pre = load i16* %.phi.trans.insert14, align 1
<   br label %15
---
> ; <label>:6                                       ; preds = %0
>   %7 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %7)
>   br label %8
14933,14947c11812,11826
< ; <label>:15                                      ; preds = %7, %0
<   %.sroa.17.8.copyload = phi i16 [ %.sroa.110.8.copyload, %0 ], [ %.sroa.17.8.copyload.pre, %7 ]
<   %16 = phi i32 [ %3, %0 ], [ %.pre12, %7 ]
<   %17 = phi %struct.CPUX86State* [ %1, %0 ], [ %.pre, %7 ]
<   %18 = zext i32 %16 to i64
<   %19 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 25
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 21, i64 %18, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 21, i64 %18, i32 1
<   %20 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %21 = tail call { i64, i16 } @floatx80_sqrt(i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %19) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %21, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %21, 1
<   store i64 %.fca.0.extract, i64* %.sroa.06.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %20, align 1
---
> ; <label>:8                                       ; preds = %6, %0
>   %9 = load i64* %1, align 8
>   %10 = lshr i64 %9, 63
>   %11 = trunc i64 %10 to i8
>   %12 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 0
>   store i8 %11, i8* %12, align 1
>   %13 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 2
>   store i64 0, i64* %13, align 4
>   %14 = load i64* %1, align 8
>   %15 = shl i64 %14, 12
>   %16 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 1
>   store i64 %15, i64* %16, align 4
>   %17 = bitcast %struct.commonNaNT* %agg.result to i8*
>   %18 = bitcast %struct.commonNaNT* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %17, i8* %18, i32 20, i32 4, i1 false)
14951c11830,11854
< declare { i64, i16 } @floatx80_sqrt(i64, i16, %struct.float_status*)
---
> define internal i32 @float16_to_float32(i16 zeroext %a, i8 zeroext %ieee, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i16, align 2
>   %3 = alloca i8, align 1
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %5 = alloca %struct.commonNaNT, align 4
>   %shiftCount = alloca i8, align 1
>   store i16 %a, i16* %2, align 2
>   store i8 %ieee, i8* %3, align 1
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %6 = load i16* %2, align 2
>   %7 = call zeroext i8 @extractFloat16Sign(i16 zeroext %6)
>   store i8 %7, i8* %aSign, align 1
>   %8 = load i16* %2, align 2
>   %9 = call i32 @extractFloat16Exp(i16 zeroext %8)
>   store i32 %9, i32* %aExp, align 4
>   %10 = load i16* %2, align 2
>   %11 = call i32 @extractFloat16Frac(i16 zeroext %10)
>   store i32 %11, i32* %aSig, align 4
>   %12 = load i32* %aExp, align 4
>   %13 = icmp eq i32 %12, 31
>   br i1 %13, label %14, label %31
14953,14970c11856,11860
< define void @helper_fsincos() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.018.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.018.0.copyload = load i64* %.sroa.018.0..idx, align 1
<   %.sroa.119.8..idx20 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.119.8..idx20 to i16*
<   %.sroa.119.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.018.0.copyload, i16 %.sroa.119.8.copyload, %struct.float_status* %6) nounwind
<   %8 = bitcast i64 %7 to double
<   %9 = fcmp ogt double %8, 0x43E0000000000000
<   %10 = fcmp olt double %8, 0xC3E0000000000000
<   %or.cond = or i1 %9, %10
<   %11 = load %struct.CPUX86State** @env, align 8
<   br i1 %or.cond, label %12, label %16
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i8* %3, align 1
>   %16 = zext i8 %15 to i32
>   %17 = icmp ne i32 %16, 0
>   br i1 %17, label %18, label %31
14972,14977c11862,11865
< ; <label>:12                                      ; preds = %0
<   %13 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 18
<   %14 = load i16* %13, align 2
<   %15 = or i16 %14, 1024
<   store i16 %15, i16* %13, align 2
<   br label %50
---
> ; <label>:18                                      ; preds = %14
>   %19 = load i32* %aSig, align 4
>   %20 = icmp ne i32 %19, 0
>   br i1 %20, label %21, label %26
14979,15028c11867,11874
< ; <label>:16                                      ; preds = %0
<   %17 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 17
<   %18 = load i32* %17, align 4
<   %19 = zext i32 %18 to i64
<   %20 = tail call double @sin(double %8) nounwind
<   %21 = bitcast double %20 to i64
<   %22 = load %struct.CPUX86State** @env, align 8
<   %23 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 25
<   %24 = tail call { i64, i16 } @float64_to_floatx80(i64 %21, %struct.float_status* %23) nounwind
<   %.fca.0.extract7 = extractvalue { i64, i16 } %24, 0
<   %.fca.1.extract8 = extractvalue { i64, i16 } %24, 1
<   %.sroa.015.0..idx = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 21, i64 %19, i32 0, i32 0
<   store i64 %.fca.0.extract7, i64* %.sroa.015.0..idx, align 1
<   %.sroa.116.8..idx17 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 21, i64 %19, i32 1
<   %25 = bitcast [8 x i8]* %.sroa.116.8..idx17 to i16*
<   store i16 %.fca.1.extract8, i16* %25, align 1
<   %26 = load %struct.CPUX86State** @env, align 8
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 17
<   %28 = load i32* %27, align 4
<   %29 = add i32 %28, 7
<   %30 = and i32 %29, 7
<   store i32 %30, i32* %27, align 4
<   %31 = load %struct.CPUX86State** @env, align 8
<   %32 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 17
<   %33 = load i32* %32, align 4
<   %34 = zext i32 %33 to i64
<   %35 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 20, i64 %34
<   store i8 0, i8* %35, align 1
<   %36 = load %struct.CPUX86State** @env, align 8
<   %37 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 17
<   %38 = load i32* %37, align 4
<   %39 = zext i32 %38 to i64
<   %40 = tail call double @cos(double %8) nounwind
<   %41 = bitcast double %40 to i64
<   %42 = load %struct.CPUX86State** @env, align 8
<   %43 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 25
<   %44 = tail call { i64, i16 } @float64_to_floatx80(i64 %41, %struct.float_status* %43) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %44, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %44, 1
<   %.sroa.04.0..idx = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 21, i64 %39, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.04.0..idx, align 1
<   %.sroa.15.8..idx6 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 21, i64 %39, i32 1
<   %45 = bitcast [8 x i8]* %.sroa.15.8..idx6 to i16*
<   store i16 %.fca.1.extract, i16* %45, align 1
<   %46 = load %struct.CPUX86State** @env, align 8
<   %47 = getelementptr inbounds %struct.CPUX86State* %46, i64 0, i32 18
<   %48 = load i16* %47, align 2
<   %49 = and i16 %48, -1025
<   store i16 %49, i16* %47, align 2
<   br label %50
---
> ; <label>:21                                      ; preds = %18
>   %22 = load i16* %2, align 2
>   %23 = load %struct.float_status** %4, align 4
>   call void @float16ToCommonNaN(%struct.commonNaNT* sret %5, i16 zeroext %22, %struct.float_status* %23)
>   %24 = load %struct.float_status** %4, align 4
>   %25 = call i32 @commonNaNToFloat32(%struct.commonNaNT* byval align 4 %5, %struct.float_status* %24)
>   store i32 %25, i32* %1
>   br label %60
15030,15032c11876,11882
< ; <label>:50                                      ; preds = %16, %12
<   ret void
< }
---
> ; <label>:26                                      ; preds = %18
>   %27 = load i8* %aSign, align 1
>   %28 = load i32* %aSig, align 4
>   %29 = shl i32 %28, 13
>   %30 = call i32 @packFloat32(i8 zeroext %27, i32 255, i32 %29)
>   store i32 %30, i32* %1
>   br label %60
15034c11884,11887
< declare double @sin(double) nounwind
---
> ; <label>:31                                      ; preds = %14, %0
>   %32 = load i32* %aExp, align 4
>   %33 = icmp eq i32 %32, 0
>   br i1 %33, label %34, label %53
15036c11889,11892
< declare double @cos(double) nounwind
---
> ; <label>:34                                      ; preds = %31
>   %35 = load i32* %aSig, align 4
>   %36 = icmp eq i32 %35, 0
>   br i1 %36, label %37, label %40
15038,15055c11894,11898
< define void @helper_frndint() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %6 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %6, align 1
<   %7 = tail call { i64, i16 } @floatx80_round_to_int(i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, %struct.float_status* %5) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %7, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %7, 1
<   store i64 %.fca.0.extract, i64* %.sroa.06.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %6, align 1
<   ret void
< }
---
> ; <label>:37                                      ; preds = %34
>   %38 = load i8* %aSign, align 1
>   %39 = call i32 @packFloat32(i8 zeroext %38, i32 0, i32 0)
>   store i32 %39, i32* %1
>   br label %60
15057c11900,11916
< declare { i64, i16 } @floatx80_round_to_int(i64, i16, %struct.float_status*)
---
> ; <label>:40                                      ; preds = %34
>   %41 = load i32* %aSig, align 4
>   %42 = call signext i8 @countLeadingZeros32(i32 %41)
>   %43 = sext i8 %42 to i32
>   %44 = sub nsw i32 %43, 21
>   %45 = trunc i32 %44 to i8
>   store i8 %45, i8* %shiftCount, align 1
>   %46 = load i32* %aSig, align 4
>   %47 = load i8* %shiftCount, align 1
>   %48 = sext i8 %47 to i32
>   %49 = shl i32 %46, %48
>   store i32 %49, i32* %aSig, align 4
>   %50 = load i8* %shiftCount, align 1
>   %51 = sext i8 %50 to i32
>   %52 = sub nsw i32 0, %51
>   store i32 %52, i32* %aExp, align 4
>   br label %53
15059,15086c11918,11926
< define void @helper_fscale() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = add i32 %3, 1
<   %5 = and i32 %4, 7
<   %6 = zext i32 %5 to i64
<   %.sroa.113.8..idx14 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 1
<   %7 = bitcast [8 x i8]* %.sroa.113.8..idx14 to i16*
<   %.sroa.113.8.copyload = load i16* %7, align 1
<   %8 = and i16 %.sroa.113.8.copyload, 32767
<   %9 = icmp eq i16 %8, 32767
<   %.sroa.012.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6, i32 0, i32 0
<   br i1 %9, label %floatx80_is_any_nan.exit, label %floatx80_is_any_nan.exit.thread
< 
< floatx80_is_any_nan.exit:                         ; preds = %0
<   %.sroa.012.0.copyload = load i64* %.sroa.012.0..idx, align 1
<   %.mask.i = and i64 %.sroa.012.0.copyload, 9223372036854775807
<   %10 = icmp eq i64 %.mask.i, 0
<   br i1 %10, label %floatx80_is_any_nan.exit.thread, label %11
< 
< ; <label>:11                                      ; preds = %floatx80_is_any_nan.exit
<   %12 = zext i32 %3 to i64
<   %13 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %12
<   %14 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %6
<   %15 = bitcast %union.FPReg* %13 to i8*
<   %16 = bitcast %union.FPReg* %14 to i8*
<   br label %17
---
> ; <label>:53                                      ; preds = %40, %31
>   %54 = load i8* %aSign, align 1
>   %55 = load i32* %aExp, align 4
>   %56 = add nsw i32 %55, 112
>   %57 = load i32* %aSig, align 4
>   %58 = shl i32 %57, 13
>   %59 = call i32 @packFloat32(i8 zeroext %54, i32 %56, i32 %58)
>   store i32 %59, i32* %1
>   br label %60
15088,15091c11928,11931
< ; <label>:17                                      ; preds = %20, %11
<   %18 = phi i64 [ 0, %11 ], [ %24, %20 ]
<   %19 = icmp ult i64 %18, 10
<   br i1 %19, label %20, label %34
---
> ; <label>:60                                      ; preds = %53, %37, %26, %21
>   %61 = load i32* %1
>   ret i32 %61
> }
15093,15124c11933,11940
< ; <label>:20                                      ; preds = %17
<   %21 = getelementptr i8* %16, i64 %18
<   %22 = load i8* %21, align 1
<   %23 = getelementptr i8* %15, i64 %18
<   store i8 %22, i8* %23, align 1
<   %24 = add i64 %18, 1
<   br label %17
< 
< floatx80_is_any_nan.exit.thread:                  ; preds = %0, %floatx80_is_any_nan.exit
<   %.sroa.09.0..idx.pre-phi = phi i64* [ %.sroa.012.0..idx, %floatx80_is_any_nan.exit ], [ %.sroa.012.0..idx, %0 ]
<   %25 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %.sroa.09.0.copyload = load i64* %.sroa.09.0..idx.pre-phi, align 1
<   %26 = tail call i32 @floatx80_to_int32_round_to_zero(i64 %.sroa.09.0.copyload, i16 %.sroa.113.8.copyload, %struct.float_status* %25) nounwind
<   %27 = load %struct.CPUX86State** @env, align 8
<   %28 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 17
<   %29 = load i32* %28, align 4
<   %30 = zext i32 %29 to i64
<   %31 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 25
<   %.sroa.06.0..idx = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 21, i64 %30, i32 0, i32 0
<   %.sroa.06.0.copyload = load i64* %.sroa.06.0..idx, align 1
<   %.sroa.17.8..idx8 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 21, i64 %30, i32 1
<   %32 = bitcast [8 x i8]* %.sroa.17.8..idx8 to i16*
<   %.sroa.17.8.copyload = load i16* %32, align 1
<   %33 = tail call { i64, i16 } @floatx80_scalbn(i64 %.sroa.06.0.copyload, i16 %.sroa.17.8.copyload, i32 %26, %struct.float_status* %31) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %33, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %33, 1
<   store i64 %.fca.0.extract, i64* %.sroa.06.0..idx, align 1
<   store i16 %.fca.1.extract, i16* %32, align 1
<   br label %34
< 
< ; <label>:34                                      ; preds = %17, %floatx80_is_any_nan.exit.thread
<   ret void
---
> define internal zeroext i8 @extractFloat16Sign(i16 zeroext %a) nounwind inlinehint {
>   %1 = alloca i16, align 2
>   store i16 %a, i16* %1, align 2
>   %2 = load i16* %1, align 2
>   %3 = zext i16 %2 to i32
>   %4 = ashr i32 %3, 15
>   %5 = trunc i32 %4 to i8
>   ret i8 %5
15127c11943,11951
< declare { i64, i16 } @floatx80_scalbn(i64, i16, i32, %struct.float_status*)
---
> define internal i32 @extractFloat16Exp(i16 zeroext %a) nounwind inlinehint {
>   %1 = alloca i16, align 2
>   store i16 %a, i16* %1, align 2
>   %2 = load i16* %1, align 2
>   %3 = zext i16 %2 to i32
>   %4 = ashr i32 %3, 10
>   %5 = and i32 %4, 31
>   ret i32 %5
> }
15129,15146c11953,11960
< define void @helper_fsin() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.07.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.07.0.copyload = load i64* %.sroa.07.0..idx, align 1
<   %.sroa.18.8..idx9 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.18.8..idx9 to i16*
<   %.sroa.18.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.07.0.copyload, i16 %.sroa.18.8.copyload, %struct.float_status* %6) nounwind
<   %8 = bitcast i64 %7 to double
<   %9 = fcmp ogt double %8, 0x43E0000000000000
<   %10 = fcmp olt double %8, 0xC3E0000000000000
<   %or.cond = or i1 %9, %10
<   %11 = load %struct.CPUX86State** @env, align 8
<   br i1 %or.cond, label %12, label %16
---
> define internal i32 @extractFloat16Frac(i16 zeroext %a) nounwind inlinehint {
>   %1 = alloca i16, align 2
>   store i16 %a, i16* %1, align 2
>   %2 = load i16* %1, align 2
>   %3 = zext i16 %2 to i32
>   %4 = and i32 %3, 1023
>   ret i32 %4
> }
15148,15153c11962,11971
< ; <label>:12                                      ; preds = %0
<   %13 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 18
<   %14 = load i16* %13, align 2
<   %15 = or i16 %14, 1024
<   store i16 %15, i16* %13, align 2
<   br label %30
---
> define internal void @float16ToCommonNaN(%struct.commonNaNT* noalias sret %agg.result, i16 zeroext %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i16, align 2
>   %2 = alloca %struct.float_status*, align 4
>   %z = alloca %struct.commonNaNT, align 4
>   store i16 %a, i16* %1, align 2
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i16* %1, align 2
>   %4 = call i32 @float16_is_signaling_nan(i16 zeroext %3)
>   %5 = icmp ne i32 %4, 0
>   br i1 %5, label %6, label %8
15155,15176c11973,11976
< ; <label>:16                                      ; preds = %0
<   %17 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 17
<   %18 = load i32* %17, align 4
<   %19 = zext i32 %18 to i64
<   %20 = tail call double @sin(double %8) nounwind
<   %21 = bitcast double %20 to i64
<   %22 = load %struct.CPUX86State** @env, align 8
<   %23 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 25
<   %24 = tail call { i64, i16 } @float64_to_floatx80(i64 %21, %struct.float_status* %23) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %24, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %24, 1
<   %.sroa.04.0..idx = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 21, i64 %19, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.04.0..idx, align 1
<   %.sroa.15.8..idx6 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 21, i64 %19, i32 1
<   %25 = bitcast [8 x i8]* %.sroa.15.8..idx6 to i16*
<   store i16 %.fca.1.extract, i16* %25, align 1
<   %26 = load %struct.CPUX86State** @env, align 8
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 18
<   %28 = load i16* %27, align 2
<   %29 = and i16 %28, -1025
<   store i16 %29, i16* %27, align 2
<   br label %30
---
> ; <label>:6                                       ; preds = %0
>   %7 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %7)
>   br label %8
15178c11978,11994
< ; <label>:30                                      ; preds = %16, %12
---
> ; <label>:8                                       ; preds = %6, %0
>   %9 = load i16* %1, align 2
>   %10 = zext i16 %9 to i32
>   %11 = ashr i32 %10, 15
>   %12 = trunc i32 %11 to i8
>   %13 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 0
>   store i8 %12, i8* %13, align 1
>   %14 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 2
>   store i64 0, i64* %14, align 4
>   %15 = load i16* %1, align 2
>   %16 = zext i16 %15 to i64
>   %17 = shl i64 %16, 54
>   %18 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 1
>   store i64 %17, i64* %18, align 4
>   %19 = bitcast %struct.commonNaNT* %agg.result to i8*
>   %20 = bitcast %struct.commonNaNT* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %19, i8* %20, i32 20, i32 4, i1 false)
15182,15199c11998,12029
< define void @helper_fcos() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %.sroa.07.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %.sroa.07.0.copyload = load i64* %.sroa.07.0..idx, align 1
<   %.sroa.18.8..idx9 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %.sroa.18.8..idx9 to i16*
<   %.sroa.18.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 25
<   %7 = tail call i64 @floatx80_to_float64(i64 %.sroa.07.0.copyload, i16 %.sroa.18.8.copyload, %struct.float_status* %6) nounwind
<   %8 = bitcast i64 %7 to double
<   %9 = fcmp ogt double %8, 0x43E0000000000000
<   %10 = fcmp olt double %8, 0xC3E0000000000000
<   %or.cond = or i1 %9, %10
<   %11 = load %struct.CPUX86State** @env, align 8
<   br i1 %or.cond, label %12, label %16
---
> define internal zeroext i16 @float32_to_float16(i32 %a, i8 zeroext %ieee, %struct.float_status* %status) nounwind {
>   %1 = alloca i16, align 2
>   %2 = alloca i32, align 4
>   %3 = alloca i8, align 1
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i32, align 4
>   %mask = alloca i32, align 4
>   %increment = alloca i32, align 4
>   %roundingMode = alloca i8, align 1
>   %r = alloca i16, align 2
>   %5 = alloca %struct.commonNaNT, align 4
>   store i32 %a, i32* %2, align 4
>   store i8 %ieee, i8* %3, align 1
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %6 = load i32* %2, align 4
>   %7 = load %struct.float_status** %4, align 4
>   %8 = call i32 @float32_squash_input_denormal(i32 %6, %struct.float_status* %7)
>   store i32 %8, i32* %2, align 4
>   %9 = load i32* %2, align 4
>   %10 = call i32 @extractFloat32Frac(i32 %9)
>   store i32 %10, i32* %aSig, align 4
>   %11 = load i32* %2, align 4
>   %12 = call i32 @extractFloat32Exp(i32 %11)
>   store i32 %12, i32* %aExp, align 4
>   %13 = load i32* %2, align 4
>   %14 = call zeroext i8 @extractFloat32Sign(i32 %13)
>   store i8 %14, i8* %aSign, align 1
>   %15 = load i32* %aExp, align 4
>   %16 = icmp eq i32 %15, 255
>   br i1 %16, label %17, label %42
15201,15206c12031,12034
< ; <label>:12                                      ; preds = %0
<   %13 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 18
<   %14 = load i16* %13, align 2
<   %15 = or i16 %14, 1024
<   store i16 %15, i16* %13, align 2
<   br label %30
---
> ; <label>:17                                      ; preds = %0
>   %18 = load i32* %aSig, align 4
>   %19 = icmp ne i32 %18, 0
>   br i1 %19, label %20, label %32
15208,15229c12036,12061
< ; <label>:16                                      ; preds = %0
<   %17 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 17
<   %18 = load i32* %17, align 4
<   %19 = zext i32 %18 to i64
<   %20 = tail call double @cos(double %8) nounwind
<   %21 = bitcast double %20 to i64
<   %22 = load %struct.CPUX86State** @env, align 8
<   %23 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 25
<   %24 = tail call { i64, i16 } @float64_to_floatx80(i64 %21, %struct.float_status* %23) nounwind
<   %.fca.0.extract = extractvalue { i64, i16 } %24, 0
<   %.fca.1.extract = extractvalue { i64, i16 } %24, 1
<   %.sroa.04.0..idx = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 21, i64 %19, i32 0, i32 0
<   store i64 %.fca.0.extract, i64* %.sroa.04.0..idx, align 1
<   %.sroa.15.8..idx6 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 21, i64 %19, i32 1
<   %25 = bitcast [8 x i8]* %.sroa.15.8..idx6 to i16*
<   store i16 %.fca.1.extract, i16* %25, align 1
<   %26 = load %struct.CPUX86State** @env, align 8
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 18
<   %28 = load i16* %27, align 2
<   %29 = and i16 %28, -1025
<   store i16 %29, i16* %27, align 2
<   br label %30
---
> ; <label>:20                                      ; preds = %17
>   %21 = load i32* %2, align 4
>   %22 = load %struct.float_status** %4, align 4
>   call void @float32ToCommonNaN(%struct.commonNaNT* sret %5, i32 %21, %struct.float_status* %22)
>   %23 = load %struct.float_status** %4, align 4
>   %24 = call zeroext i16 @commonNaNToFloat16(%struct.commonNaNT* byval align 4 %5, %struct.float_status* %23)
>   store i16 %24, i16* %r, align 2
>   %25 = load i8* %3, align 1
>   %26 = icmp ne i8 %25, 0
>   br i1 %26, label %30, label %27
> 
> ; <label>:27                                      ; preds = %20
>   %28 = load i8* %aSign, align 1
>   %29 = call zeroext i16 @packFloat16(i8 zeroext %28, i32 0, i16 zeroext 0)
>   store i16 %29, i16* %1
>   br label %179
> 
> ; <label>:30                                      ; preds = %20
>   %31 = load i16* %r, align 2
>   store i16 %31, i16* %1
>   br label %179
> 
> ; <label>:32                                      ; preds = %17
>   %33 = load i8* %3, align 1
>   %34 = icmp ne i8 %33, 0
>   br i1 %34, label %39, label %35
15231,15233c12063,12069
< ; <label>:30                                      ; preds = %16, %12
<   ret void
< }
---
> ; <label>:35                                      ; preds = %32
>   %36 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %36)
>   %37 = load i8* %aSign, align 1
>   %38 = call zeroext i16 @packFloat16(i8 zeroext %37, i32 31, i16 zeroext 1023)
>   store i16 %38, i16* %1
>   br label %179
15235,15252c12071,12075
< define void @helper_fxam_ST0() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %3 = load i32* %2, align 4
<   %4 = zext i32 %3 to i64
<   %temp.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 0, i32 0
<   %temp.sroa.0.0.copyload = load i64* %temp.sroa.0.0..idx, align 1
<   %temp.sroa.1.8..idx4 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %4, i32 1
<   %5 = bitcast [8 x i8]* %temp.sroa.1.8..idx4 to i16*
<   %temp.sroa.1.8.copyload = load i16* %5, align 1
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %7 = load i16* %6, align 2
<   %8 = and i16 %7, -18177
<   store i16 %8, i16* %6, align 2
<   %9 = zext i16 %temp.sroa.1.8.copyload to i32
<   %10 = and i32 %9, 32768
<   %11 = icmp eq i32 %10, 0
<   br i1 %11, label %17, label %12
---
> ; <label>:39                                      ; preds = %32
>   %40 = load i8* %aSign, align 1
>   %41 = call zeroext i16 @packFloat16(i8 zeroext %40, i32 31, i16 zeroext 0)
>   store i16 %41, i16* %1
>   br label %179
15254,15260c12077,12080
< ; <label>:12                                      ; preds = %0
<   %13 = load %struct.CPUX86State** @env, align 8
<   %14 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 18
<   %15 = load i16* %14, align 2
<   %16 = or i16 %15, 512
<   store i16 %16, i16* %14, align 2
<   br label %17
---
> ; <label>:42                                      ; preds = %0
>   %43 = load i32* %aExp, align 4
>   %44 = icmp eq i32 %43, 0
>   br i1 %44, label %45, label %51
15262,15267c12082,12085
< ; <label>:17                                      ; preds = %12, %0
<   %18 = and i32 %9, 32767
<   switch i32 %18, label %37 [
<     i32 32767, label %19
<     i32 0, label %28
<   ]
---
> ; <label>:45                                      ; preds = %42
>   %46 = load i32* %aSig, align 4
>   %47 = icmp eq i32 %46, 0
>   br i1 %47, label %48, label %51
15269,15274c12087,12116
< ; <label>:19                                      ; preds = %17
<   %20 = icmp eq i64 %temp.sroa.0.0.copyload, -9223372036854775808
<   %21 = load %struct.CPUX86State** @env, align 8
<   %22 = getelementptr inbounds %struct.CPUX86State* %21, i64 0, i32 18
<   %23 = load i16* %22, align 2
<   br i1 %20, label %24, label %26
---
> ; <label>:48                                      ; preds = %45
>   %49 = load i8* %aSign, align 1
>   %50 = call zeroext i16 @packFloat16(i8 zeroext %49, i32 0, i16 zeroext 0)
>   store i16 %50, i16* %1
>   br label %179
> 
> ; <label>:51                                      ; preds = %45, %42
>   %52 = load i32* %aSig, align 4
>   %53 = or i32 %52, 8388608
>   store i32 %53, i32* %aSig, align 4
>   %54 = load i32* %aExp, align 4
>   %55 = sub nsw i32 %54, 127
>   store i32 %55, i32* %aExp, align 4
>   %56 = load i32* %aExp, align 4
>   %57 = icmp slt i32 %56, -14
>   br i1 %57, label %58, label %67
> 
> ; <label>:58                                      ; preds = %51
>   store i32 16777215, i32* %mask, align 4
>   %59 = load i32* %aExp, align 4
>   %60 = icmp sge i32 %59, -24
>   br i1 %60, label %61, label %66
> 
> ; <label>:61                                      ; preds = %58
>   %62 = load i32* %aExp, align 4
>   %63 = add nsw i32 25, %62
>   %64 = load i32* %mask, align 4
>   %65 = lshr i32 %64, %63
>   store i32 %65, i32* %mask, align 4
>   br label %66
15276,15279c12118,12119
< ; <label>:24                                      ; preds = %19
<   %25 = or i16 %23, 1280
<   store i16 %25, i16* %22, align 2
<   br label %42
---
> ; <label>:66                                      ; preds = %61, %58
>   br label %68
15281,15284c12121,12123
< ; <label>:26                                      ; preds = %19
<   %27 = or i16 %23, 256
<   store i16 %27, i16* %22, align 2
<   br label %42
---
> ; <label>:67                                      ; preds = %51
>   store i32 8191, i32* %mask, align 4
>   br label %68
15286,15291c12125,12130
< ; <label>:28                                      ; preds = %17
<   %29 = icmp eq i64 %temp.sroa.0.0.copyload, 0
<   %30 = load %struct.CPUX86State** @env, align 8
<   %31 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 18
<   %32 = load i16* %31, align 2
<   br i1 %29, label %33, label %35
---
> ; <label>:68                                      ; preds = %67, %66
>   %69 = load i32* %aSig, align 4
>   %70 = load i32* %mask, align 4
>   %71 = and i32 %69, %70
>   %72 = icmp ne i32 %71, 0
>   br i1 %72, label %73, label %126
15293,15296c12132,12145
< ; <label>:33                                      ; preds = %28
<   %34 = or i16 %32, 16384
<   store i16 %34, i16* %31, align 2
<   br label %42
---
> ; <label>:73                                      ; preds = %68
>   %74 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 16, %struct.float_status* %74)
>   %75 = load %struct.float_status** %4, align 4
>   %76 = getelementptr inbounds %struct.float_status* %75, i32 0, i32 1
>   %77 = load i8* %76, align 1
>   store i8 %77, i8* %roundingMode, align 1
>   %78 = load i8* %roundingMode, align 1
>   %79 = sext i8 %78 to i32
>   switch i32 %79, label %113 [
>     i32 0, label %80
>     i32 2, label %95
>     i32 1, label %104
>   ]
15298,15301c12147,12174
< ; <label>:35                                      ; preds = %28
<   %36 = or i16 %32, 17408
<   store i16 %36, i16* %31, align 2
<   br label %42
---
> ; <label>:80                                      ; preds = %73
>   %81 = load i32* %mask, align 4
>   %82 = add i32 %81, 1
>   %83 = lshr i32 %82, 1
>   store i32 %83, i32* %increment, align 4
>   %84 = load i32* %aSig, align 4
>   %85 = load i32* %mask, align 4
>   %86 = and i32 %84, %85
>   %87 = load i32* %increment, align 4
>   %88 = icmp eq i32 %86, %87
>   br i1 %88, label %89, label %94
> 
> ; <label>:89                                      ; preds = %80
>   %90 = load i32* %aSig, align 4
>   %91 = load i32* %increment, align 4
>   %92 = shl i32 %91, 1
>   %93 = and i32 %90, %92
>   store i32 %93, i32* %increment, align 4
>   br label %94
> 
> ; <label>:94                                      ; preds = %89, %80
>   br label %114
> 
> ; <label>:95                                      ; preds = %73
>   %96 = load i8* %aSign, align 1
>   %97 = zext i8 %96 to i32
>   %98 = icmp ne i32 %97, 0
>   br i1 %98, label %99, label %100
15303,15309c12176,12177
< ; <label>:37                                      ; preds = %17
<   %38 = load %struct.CPUX86State** @env, align 8
<   %39 = getelementptr inbounds %struct.CPUX86State* %38, i64 0, i32 18
<   %40 = load i16* %39, align 2
<   %41 = or i16 %40, 1024
<   store i16 %41, i16* %39, align 2
<   br label %42
---
> ; <label>:99                                      ; preds = %95
>   br label %102
15311,15313c12179,12181
< ; <label>:42                                      ; preds = %37, %35, %33, %26, %24
<   ret void
< }
---
> ; <label>:100                                     ; preds = %95
>   %101 = load i32* %mask, align 4
>   br label %102
15315,15333c12183,12192
< define void @helper_fstenv(i32 %ptr, i32 %data32) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 18
<   %3 = load i16* %2, align 2
<   %4 = zext i16 %3 to i32
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   %6 = load i32* %5, align 4
<   %7 = shl i32 %6, 11
<   %8 = and i32 %7, 14336
<   br label %9
< 
< ; <label>:9                                       ; preds = %29, %0
<   %indvars.iv = phi i64 [ 7, %0 ], [ %indvars.iv.next, %29 ]
<   %fptag.030 = phi i32 [ 0, %0 ], [ %fptag.1, %29 ]
<   %10 = shl i32 %fptag.030, 2
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 20, i64 %indvars.iv
<   %12 = load i8* %11, align 1
<   %13 = icmp eq i8 %12, 0
<   br i1 %13, label %16, label %14
---
> ; <label>:102                                     ; preds = %100, %99
>   %103 = phi i32 [ 0, %99 ], [ %101, %100 ]
>   store i32 %103, i32* %increment, align 4
>   br label %114
> 
> ; <label>:104                                     ; preds = %73
>   %105 = load i8* %aSign, align 1
>   %106 = zext i8 %105 to i32
>   %107 = icmp ne i32 %106, 0
>   br i1 %107, label %108, label %110
15335,15337c12194,12196
< ; <label>:14                                      ; preds = %9
<   %15 = or i32 %10, 3
<   br label %29
---
> ; <label>:108                                     ; preds = %104
>   %109 = load i32* %mask, align 4
>   br label %111
15339,15350c12198,12199
< ; <label>:16                                      ; preds = %9
<   %tmp.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %indvars.iv, i32 0, i32 0
<   %tmp.sroa.0.0.copyload = load i64* %tmp.sroa.0.0..idx, align 1
<   %tmp.sroa.1.8..idx2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 21, i64 %indvars.iv, i32 1
<   %17 = bitcast [8 x i8]* %tmp.sroa.1.8..idx2 to i16*
<   %tmp.sroa.1.8.copyload = load i16* %17, align 1
<   %18 = zext i16 %tmp.sroa.1.8.copyload to i32
<   %19 = and i32 %18, 32767
<   %20 = icmp eq i32 %19, 0
<   %21 = icmp eq i64 %tmp.sroa.0.0.copyload, 0
<   %or.cond28 = and i1 %20, %21
<   br i1 %or.cond28, label %22, label %24
---
> ; <label>:110                                     ; preds = %104
>   br label %111
15352,15354c12201,12226
< ; <label>:22                                      ; preds = %16
<   %23 = or i32 %10, 1
<   br label %29
---
> ; <label>:111                                     ; preds = %110, %108
>   %112 = phi i32 [ %109, %108 ], [ 0, %110 ]
>   store i32 %112, i32* %increment, align 4
>   br label %114
> 
> ; <label>:113                                     ; preds = %73
>   store i32 0, i32* %increment, align 4
>   br label %114
> 
> ; <label>:114                                     ; preds = %113, %111, %102, %94
>   %115 = load i32* %increment, align 4
>   %116 = load i32* %aSig, align 4
>   %117 = add i32 %116, %115
>   store i32 %117, i32* %aSig, align 4
>   %118 = load i32* %aSig, align 4
>   %119 = icmp uge i32 %118, 16777216
>   br i1 %119, label %120, label %125
> 
> ; <label>:120                                     ; preds = %114
>   %121 = load i32* %aSig, align 4
>   %122 = lshr i32 %121, 1
>   store i32 %122, i32* %aSig, align 4
>   %123 = load i32* %aExp, align 4
>   %124 = add nsw i32 %123, 1
>   store i32 %124, i32* %aExp, align 4
>   br label %125
15356,15360c12228,12229
< ; <label>:24                                      ; preds = %16
<   switch i32 %19, label %25 [
<     i32 32767, label %27
<     i32 0, label %27
<   ]
---
> ; <label>:125                                     ; preds = %120, %114
>   br label %138
15362,15364c12231,12247
< ; <label>:25                                      ; preds = %24
<   %26 = icmp sgt i64 %tmp.sroa.0.0.copyload, -1
<   br i1 %26, label %27, label %29
---
> ; <label>:126                                     ; preds = %68
>   %127 = load i32* %aExp, align 4
>   %128 = icmp slt i32 %127, -14
>   br i1 %128, label %129, label %137
> 
> ; <label>:129                                     ; preds = %126
>   %130 = load %struct.float_status** %4, align 4
>   %131 = getelementptr inbounds %struct.float_status* %130, i32 0, i32 0
>   %132 = load i8* %131, align 1
>   %133 = sext i8 %132 to i32
>   %134 = icmp eq i32 %133, 1
>   br i1 %134, label %135, label %137
> 
> ; <label>:135                                     ; preds = %129
>   %136 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 16, %struct.float_status* %136)
>   br label %137
15366,15368c12249,12250
< ; <label>:27                                      ; preds = %25, %24, %24
<   %28 = or i32 %10, 2
<   br label %29
---
> ; <label>:137                                     ; preds = %135, %129, %126
>   br label %138
15370,15375c12252,12255
< ; <label>:29                                      ; preds = %27, %25, %22, %14
<   %fptag.1 = phi i32 [ %15, %14 ], [ %23, %22 ], [ %28, %27 ], [ %10, %25 ]
<   %indvars.iv.next = add i64 %indvars.iv, -1
<   %30 = trunc i64 %indvars.iv to i32
<   %31 = icmp sgt i32 %30, 0
<   br i1 %31, label %9, label %32
---
> ; <label>:138                                     ; preds = %137, %125
>   %139 = load i8* %3, align 1
>   %140 = icmp ne i8 %139, 0
>   br i1 %140, label %141, label %149
15377,15384c12257,12260
< ; <label>:32                                      ; preds = %29
<   %33 = and i32 %4, 51199
<   %34 = or i32 %8, %33
<   %35 = icmp eq i32 %data32, 0
<   %36 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 19
<   %37 = load i16* %36, align 2
<   %38 = zext i16 %37 to i32
<   br i1 %35, label %46, label %39
---
> ; <label>:141                                     ; preds = %138
>   %142 = load i32* %aExp, align 4
>   %143 = icmp sgt i32 %142, 15
>   br i1 %143, label %144, label %148
15386,15400c12262,12268
< ; <label>:39                                      ; preds = %32
<   tail call fastcc void @stl_data(i32 %ptr, i32 %38)
<   %40 = add i32 %ptr, 4
<   tail call fastcc void @stl_data(i32 %40, i32 %34)
<   %41 = add i32 %ptr, 8
<   tail call fastcc void @stl_data(i32 %41, i32 %fptag.1)
<   %42 = add i32 %ptr, 12
<   tail call fastcc void @stl_data(i32 %42, i32 0)
<   %43 = add i32 %ptr, 16
<   tail call fastcc void @stl_data(i32 %43, i32 0)
<   %44 = add i32 %ptr, 20
<   tail call fastcc void @stl_data(i32 %44, i32 0)
<   %45 = add i32 %ptr, 24
<   tail call fastcc void @stl_data(i32 %45, i32 0)
<   br label %53
---
> ; <label>:144                                     ; preds = %141
>   %145 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 40, %struct.float_status* %145)
>   %146 = load i8* %aSign, align 1
>   %147 = call zeroext i16 @packFloat16(i8 zeroext %146, i32 31, i16 zeroext 0)
>   store i16 %147, i16* %1
>   br label %179
15402,15416c12270,12271
< ; <label>:46                                      ; preds = %32
<   tail call fastcc void @stw_data(i32 %ptr, i32 %38)
<   %47 = add i32 %ptr, 2
<   tail call fastcc void @stw_data(i32 %47, i32 %34)
<   %48 = add i32 %ptr, 4
<   tail call fastcc void @stw_data(i32 %48, i32 %fptag.1)
<   %49 = add i32 %ptr, 6
<   tail call fastcc void @stw_data(i32 %49, i32 0)
<   %50 = add i32 %ptr, 8
<   tail call fastcc void @stw_data(i32 %50, i32 0)
<   %51 = add i32 %ptr, 10
<   tail call fastcc void @stw_data(i32 %51, i32 0)
<   %52 = add i32 %ptr, 12
<   tail call fastcc void @stw_data(i32 %52, i32 0)
<   br label %53
---
> ; <label>:148                                     ; preds = %141
>   br label %157
15418,15420c12273,12284
< ; <label>:53                                      ; preds = %46, %39
<   ret void
< }
---
> ; <label>:149                                     ; preds = %138
>   %150 = load i32* %aExp, align 4
>   %151 = icmp sgt i32 %150, 16
>   br i1 %151, label %152, label %156
> 
> ; <label>:152                                     ; preds = %149
>   %153 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 33, %struct.float_status* %153)
>   %154 = load i8* %aSign, align 1
>   %155 = call zeroext i16 @packFloat16(i8 zeroext %154, i32 31, i16 zeroext 1023)
>   store i16 %155, i16* %1
>   br label %179
15422,15429c12286,12287
< define void @helper_fldenv(i32 %ptr, i32 %data32) nounwind uwtable {
<   %1 = icmp eq i32 %data32, 0
<   %2 = tail call fastcc i32 @lduw_data(i32 %ptr)
<   %3 = trunc i32 %2 to i16
<   %4 = load %struct.CPUX86State** @env, align 8
<   %5 = getelementptr inbounds %struct.CPUX86State* %4, i64 0, i32 19
<   store i16 %3, i16* %5, align 2
<   br i1 %1, label %11, label %6
---
> ; <label>:156                                     ; preds = %149
>   br label %157
15431,15436c12289,12344
< ; <label>:6                                       ; preds = %0
<   %7 = add i32 %ptr, 4
<   %8 = tail call fastcc i32 @lduw_data(i32 %7)
<   %9 = add i32 %ptr, 8
<   %10 = tail call fastcc i32 @lduw_data(i32 %9)
<   br label %16
---
> ; <label>:157                                     ; preds = %156, %148
>   %158 = load i32* %aExp, align 4
>   %159 = icmp slt i32 %158, -24
>   br i1 %159, label %160, label %163
> 
> ; <label>:160                                     ; preds = %157
>   %161 = load i8* %aSign, align 1
>   %162 = call zeroext i16 @packFloat16(i8 zeroext %161, i32 0, i16 zeroext 0)
>   store i16 %162, i16* %1
>   br label %179
> 
> ; <label>:163                                     ; preds = %157
>   %164 = load i32* %aExp, align 4
>   %165 = icmp slt i32 %164, -14
>   br i1 %165, label %166, label %171
> 
> ; <label>:166                                     ; preds = %163
>   %167 = load i32* %aExp, align 4
>   %168 = sub nsw i32 -14, %167
>   %169 = load i32* %aSig, align 4
>   %170 = lshr i32 %169, %168
>   store i32 %170, i32* %aSig, align 4
>   store i32 -14, i32* %aExp, align 4
>   br label %171
> 
> ; <label>:171                                     ; preds = %166, %163
>   %172 = load i8* %aSign, align 1
>   %173 = load i32* %aExp, align 4
>   %174 = add nsw i32 %173, 14
>   %175 = load i32* %aSig, align 4
>   %176 = lshr i32 %175, 13
>   %177 = trunc i32 %176 to i16
>   %178 = call zeroext i16 @packFloat16(i8 zeroext %172, i32 %174, i16 zeroext %177)
>   store i16 %178, i16* %1
>   br label %179
> 
> ; <label>:179                                     ; preds = %171, %160, %152, %144, %48, %39, %35, %30, %27
>   %180 = load i16* %1
>   ret i16 %180
> }
> 
> define internal zeroext i16 @commonNaNToFloat16(%struct.commonNaNT* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i16, align 2
>   %2 = alloca %struct.float_status*, align 4
>   %mantissa = alloca i16, align 2
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 1
>   %4 = load i64* %3, align 4
>   %5 = lshr i64 %4, 54
>   %6 = trunc i64 %5 to i16
>   store i16 %6, i16* %mantissa, align 2
>   %7 = load %struct.float_status** %2, align 4
>   %8 = getelementptr inbounds %struct.float_status* %7, i32 0, i32 6
>   %9 = load i8* %8, align 1
>   %10 = icmp ne i8 %9, 0
>   br i1 %10, label %11, label %12
15439,15443c12347,12348
<   %12 = add i32 %ptr, 2
<   %13 = tail call fastcc i32 @lduw_data(i32 %12)
<   %14 = add i32 %ptr, 4
<   %15 = tail call fastcc i32 @lduw_data(i32 %14)
<   br label %16
---
>   store i16 -512, i16* %1
>   br label %27
15445,15507c12350,12353
< ; <label>:16                                      ; preds = %11, %6
<   %fpus.0 = phi i32 [ %8, %6 ], [ %13, %11 ]
<   %fptag.0 = phi i32 [ %10, %6 ], [ %15, %11 ]
<   %17 = lshr i32 %fpus.0, 11
<   %18 = and i32 %17, 7
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 17
<   store i32 %18, i32* %20, align 4
<   %fpus.0.tr = trunc i32 %fpus.0 to i16
<   %21 = and i16 %fpus.0.tr, -14337
<   %22 = load %struct.CPUX86State** @env, align 8
<   %23 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 18
<   store i16 %21, i16* %23, align 2
<   %24 = and i32 %fptag.0, 3
<   %25 = icmp eq i32 %24, 3
<   %26 = zext i1 %25 to i8
<   %27 = load %struct.CPUX86State** @env, align 8
<   %28 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 20, i64 0
<   store i8 %26, i8* %28, align 1
<   %29 = and i32 %fptag.0, 12
<   %30 = icmp eq i32 %29, 12
<   %31 = zext i1 %30 to i8
<   %32 = load %struct.CPUX86State** @env, align 8
<   %33 = getelementptr inbounds %struct.CPUX86State* %32, i64 0, i32 20, i64 1
<   store i8 %31, i8* %33, align 1
<   %34 = and i32 %fptag.0, 48
<   %35 = icmp eq i32 %34, 48
<   %36 = zext i1 %35 to i8
<   %37 = load %struct.CPUX86State** @env, align 8
<   %38 = getelementptr inbounds %struct.CPUX86State* %37, i64 0, i32 20, i64 2
<   store i8 %36, i8* %38, align 1
<   %39 = and i32 %fptag.0, 192
<   %40 = icmp eq i32 %39, 192
<   %41 = zext i1 %40 to i8
<   %42 = load %struct.CPUX86State** @env, align 8
<   %43 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 20, i64 3
<   store i8 %41, i8* %43, align 1
<   %44 = and i32 %fptag.0, 768
<   %45 = icmp eq i32 %44, 768
<   %46 = zext i1 %45 to i8
<   %47 = load %struct.CPUX86State** @env, align 8
<   %48 = getelementptr inbounds %struct.CPUX86State* %47, i64 0, i32 20, i64 4
<   store i8 %46, i8* %48, align 1
<   %49 = and i32 %fptag.0, 3072
<   %50 = icmp eq i32 %49, 3072
<   %51 = zext i1 %50 to i8
<   %52 = load %struct.CPUX86State** @env, align 8
<   %53 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 20, i64 5
<   store i8 %51, i8* %53, align 1
<   %54 = and i32 %fptag.0, 12288
<   %55 = icmp eq i32 %54, 12288
<   %56 = zext i1 %55 to i8
<   %57 = load %struct.CPUX86State** @env, align 8
<   %58 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 20, i64 6
<   store i8 %56, i8* %58, align 1
<   %59 = and i32 %fptag.0, 49152
<   %60 = icmp eq i32 %59, 49152
<   %61 = zext i1 %60 to i8
<   %62 = load %struct.CPUX86State** @env, align 8
<   %63 = getelementptr inbounds %struct.CPUX86State* %62, i64 0, i32 20, i64 7
<   store i8 %61, i8* %63, align 1
<   ret void
< }
---
> ; <label>:12                                      ; preds = %0
>   %13 = load i16* %mantissa, align 2
>   %14 = icmp ne i16 %13, 0
>   br i1 %14, label %15, label %26
15509,15538c12355,12367
< define void @helper_fsave(i32 %ptr, i32 %data32) nounwind uwtable {
<   tail call void @helper_fstenv(i32 %ptr, i32 %data32)
<   %1 = shl i32 14, %data32
<   %2 = add i32 %1, %ptr
<   %3 = load %struct.CPUX86State** @env, align 8
<   br label %4
< 
< ; <label>:4                                       ; preds = %4, %0
<   %5 = phi %struct.CPUX86State* [ %3, %0 ], [ %16, %4 ]
<   %.011 = phi i32 [ %2, %0 ], [ %14, %4 ]
<   %i.010 = phi i32 [ 0, %0 ], [ %15, %4 ]
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 17
<   %7 = load i32* %6, align 4
<   %8 = add i32 %7, %i.010
<   %9 = and i32 %8, 7
<   %10 = zext i32 %9 to i64
<   %tmp.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 21, i64 %10, i32 0, i32 0
<   %tmp.sroa.0.0.copyload = load i64* %tmp.sroa.0.0..idx, align 1
<   %tmp.sroa.1.8..idx4 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 21, i64 %10, i32 1
<   %11 = bitcast [8 x i8]* %tmp.sroa.1.8..idx4 to i16*
<   %tmp.sroa.1.8.copyload = load i16* %11, align 1
<   tail call fastcc void @stq_data(i32 %.011, i64 %tmp.sroa.0.0.copyload) nounwind
<   %12 = add i32 %.011, 8
<   %13 = zext i16 %tmp.sroa.1.8.copyload to i32
<   tail call fastcc void @stw_data(i32 %12, i32 %13) nounwind
<   %14 = add i32 %.011, 10
<   %15 = add nsw i32 %i.010, 1
<   %16 = load %struct.CPUX86State** @env, align 8
<   %exitcond = icmp eq i32 %15, 8
<   br i1 %exitcond, label %17, label %4
---
> ; <label>:15                                      ; preds = %12
>   %16 = getelementptr inbounds %struct.commonNaNT* %a, i32 0, i32 0
>   %17 = load i8* %16, align 1
>   %18 = zext i8 %17 to i16
>   %19 = zext i16 %18 to i32
>   %20 = shl i32 %19, 15
>   %21 = or i32 %20, 31744
>   %22 = load i16* %mantissa, align 2
>   %23 = zext i16 %22 to i32
>   %24 = or i32 %21, %23
>   %25 = trunc i32 %24 to i16
>   store i16 %25, i16* %1
>   br label %27
15540,15574c12369,12371
< ; <label>:17                                      ; preds = %4
<   %18 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 18
<   store i16 0, i16* %18, align 2
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 17
<   store i32 0, i32* %20, align 4
<   %21 = load %struct.CPUX86State** @env, align 8
<   %22 = getelementptr inbounds %struct.CPUX86State* %21, i64 0, i32 19
<   store i16 895, i16* %22, align 2
<   %23 = load %struct.CPUX86State** @env, align 8
<   %24 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 20, i64 0
<   store i8 1, i8* %24, align 1
<   %25 = load %struct.CPUX86State** @env, align 8
<   %26 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 20, i64 1
<   store i8 1, i8* %26, align 1
<   %27 = load %struct.CPUX86State** @env, align 8
<   %28 = getelementptr inbounds %struct.CPUX86State* %27, i64 0, i32 20, i64 2
<   store i8 1, i8* %28, align 1
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 20, i64 3
<   store i8 1, i8* %30, align 1
<   %31 = load %struct.CPUX86State** @env, align 8
<   %32 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 20, i64 4
<   store i8 1, i8* %32, align 1
<   %33 = load %struct.CPUX86State** @env, align 8
<   %34 = getelementptr inbounds %struct.CPUX86State* %33, i64 0, i32 20, i64 5
<   store i8 1, i8* %34, align 1
<   %35 = load %struct.CPUX86State** @env, align 8
<   %36 = getelementptr inbounds %struct.CPUX86State* %35, i64 0, i32 20, i64 6
<   store i8 1, i8* %36, align 1
<   %37 = load %struct.CPUX86State** @env, align 8
<   %38 = getelementptr inbounds %struct.CPUX86State* %37, i64 0, i32 20, i64 7
<   store i8 1, i8* %38, align 1
<   ret void
< }
---
> ; <label>:26                                      ; preds = %12
>   store i16 -512, i16* %1
>   br label %27
15576,15706c12373,12375
< define void @helper_frstor(i32 %ptr, i32 %data32) nounwind uwtable {
<   tail call void @helper_fldenv(i32 %ptr, i32 %data32)
<   %1 = shl i32 14, %data32
<   %2 = add i32 %1, %ptr
<   %3 = tail call fastcc i64 @ldq_data(i32 %2) nounwind
<   %4 = add i32 %2, 8
<   %5 = tail call fastcc i32 @lduw_data(i32 %4) nounwind
<   %6 = trunc i32 %5 to i16
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 17
<   %9 = load i32* %8, align 4
<   %10 = and i32 %9, 7
<   %11 = zext i32 %10 to i64
<   %tmp.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 21, i64 %11, i32 0, i32 0
<   store i64 %3, i64* %tmp.sroa.0.0..idx, align 1
<   %tmp.sroa.1.8..idx8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 21, i64 %11, i32 1
<   %12 = bitcast [8 x i8]* %tmp.sroa.1.8..idx8 to i16*
<   store i16 %6, i16* %12, align 1
<   %13 = add i32 %2, 10
<   %14 = tail call fastcc i64 @ldq_data(i32 %13) nounwind
<   %15 = add i32 %2, 18
<   %16 = tail call fastcc i32 @lduw_data(i32 %15) nounwind
<   %17 = trunc i32 %16 to i16
<   %18 = load %struct.CPUX86State** @env, align 8
<   %19 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 17
<   %20 = load i32* %19, align 4
<   %21 = add i32 %20, 1
<   %22 = and i32 %21, 7
<   %23 = zext i32 %22 to i64
<   %tmp.sroa.0.0..idx.1 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 21, i64 %23, i32 0, i32 0
<   store i64 %14, i64* %tmp.sroa.0.0..idx.1, align 1
<   %tmp.sroa.1.8..idx8.1 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 21, i64 %23, i32 1
<   %24 = bitcast [8 x i8]* %tmp.sroa.1.8..idx8.1 to i16*
<   store i16 %17, i16* %24, align 1
<   %25 = add i32 %2, 20
<   %26 = tail call fastcc i64 @ldq_data(i32 %25) nounwind
<   %27 = add i32 %2, 28
<   %28 = tail call fastcc i32 @lduw_data(i32 %27) nounwind
<   %29 = trunc i32 %28 to i16
<   %30 = load %struct.CPUX86State** @env, align 8
<   %31 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 17
<   %32 = load i32* %31, align 4
<   %33 = add i32 %32, 2
<   %34 = and i32 %33, 7
<   %35 = zext i32 %34 to i64
<   %tmp.sroa.0.0..idx.2 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 21, i64 %35, i32 0, i32 0
<   store i64 %26, i64* %tmp.sroa.0.0..idx.2, align 1
<   %tmp.sroa.1.8..idx8.2 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 21, i64 %35, i32 1
<   %36 = bitcast [8 x i8]* %tmp.sroa.1.8..idx8.2 to i16*
<   store i16 %29, i16* %36, align 1
<   %37 = add i32 %2, 30
<   %38 = tail call fastcc i64 @ldq_data(i32 %37) nounwind
<   %39 = add i32 %2, 38
<   %40 = tail call fastcc i32 @lduw_data(i32 %39) nounwind
<   %41 = trunc i32 %40 to i16
<   %42 = load %struct.CPUX86State** @env, align 8
<   %43 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 17
<   %44 = load i32* %43, align 4
<   %45 = add i32 %44, 3
<   %46 = and i32 %45, 7
<   %47 = zext i32 %46 to i64
<   %tmp.sroa.0.0..idx.3 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 21, i64 %47, i32 0, i32 0
<   store i64 %38, i64* %tmp.sroa.0.0..idx.3, align 1
<   %tmp.sroa.1.8..idx8.3 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 21, i64 %47, i32 1
<   %48 = bitcast [8 x i8]* %tmp.sroa.1.8..idx8.3 to i16*
<   store i16 %41, i16* %48, align 1
<   %49 = add i32 %2, 40
<   %50 = tail call fastcc i64 @ldq_data(i32 %49) nounwind
<   %51 = add i32 %2, 48
<   %52 = tail call fastcc i32 @lduw_data(i32 %51) nounwind
<   %53 = trunc i32 %52 to i16
<   %54 = load %struct.CPUX86State** @env, align 8
<   %55 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 17
<   %56 = load i32* %55, align 4
<   %57 = add i32 %56, 4
<   %58 = and i32 %57, 7
<   %59 = zext i32 %58 to i64
<   %tmp.sroa.0.0..idx.4 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 21, i64 %59, i32 0, i32 0
<   store i64 %50, i64* %tmp.sroa.0.0..idx.4, align 1
<   %tmp.sroa.1.8..idx8.4 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 21, i64 %59, i32 1
<   %60 = bitcast [8 x i8]* %tmp.sroa.1.8..idx8.4 to i16*
<   store i16 %53, i16* %60, align 1
<   %61 = add i32 %2, 50
<   %62 = tail call fastcc i64 @ldq_data(i32 %61) nounwind
<   %63 = add i32 %2, 58
<   %64 = tail call fastcc i32 @lduw_data(i32 %63) nounwind
<   %65 = trunc i32 %64 to i16
<   %66 = load %struct.CPUX86State** @env, align 8
<   %67 = getelementptr inbounds %struct.CPUX86State* %66, i64 0, i32 17
<   %68 = load i32* %67, align 4
<   %69 = add i32 %68, 5
<   %70 = and i32 %69, 7
<   %71 = zext i32 %70 to i64
<   %tmp.sroa.0.0..idx.5 = getelementptr inbounds %struct.CPUX86State* %66, i64 0, i32 21, i64 %71, i32 0, i32 0
<   store i64 %62, i64* %tmp.sroa.0.0..idx.5, align 1
<   %tmp.sroa.1.8..idx8.5 = getelementptr inbounds %struct.CPUX86State* %66, i64 0, i32 21, i64 %71, i32 1
<   %72 = bitcast [8 x i8]* %tmp.sroa.1.8..idx8.5 to i16*
<   store i16 %65, i16* %72, align 1
<   %73 = add i32 %2, 60
<   %74 = tail call fastcc i64 @ldq_data(i32 %73) nounwind
<   %75 = add i32 %2, 68
<   %76 = tail call fastcc i32 @lduw_data(i32 %75) nounwind
<   %77 = trunc i32 %76 to i16
<   %78 = load %struct.CPUX86State** @env, align 8
<   %79 = getelementptr inbounds %struct.CPUX86State* %78, i64 0, i32 17
<   %80 = load i32* %79, align 4
<   %81 = add i32 %80, 6
<   %82 = and i32 %81, 7
<   %83 = zext i32 %82 to i64
<   %tmp.sroa.0.0..idx.6 = getelementptr inbounds %struct.CPUX86State* %78, i64 0, i32 21, i64 %83, i32 0, i32 0
<   store i64 %74, i64* %tmp.sroa.0.0..idx.6, align 1
<   %tmp.sroa.1.8..idx8.6 = getelementptr inbounds %struct.CPUX86State* %78, i64 0, i32 21, i64 %83, i32 1
<   %84 = bitcast [8 x i8]* %tmp.sroa.1.8..idx8.6 to i16*
<   store i16 %77, i16* %84, align 1
<   %85 = add i32 %2, 70
<   %86 = tail call fastcc i64 @ldq_data(i32 %85) nounwind
<   %87 = add i32 %2, 78
<   %88 = tail call fastcc i32 @lduw_data(i32 %87) nounwind
<   %89 = trunc i32 %88 to i16
<   %90 = load %struct.CPUX86State** @env, align 8
<   %91 = getelementptr inbounds %struct.CPUX86State* %90, i64 0, i32 17
<   %92 = load i32* %91, align 4
<   %93 = add i32 %92, 7
<   %94 = and i32 %93, 7
<   %95 = zext i32 %94 to i64
<   %tmp.sroa.0.0..idx.7 = getelementptr inbounds %struct.CPUX86State* %90, i64 0, i32 21, i64 %95, i32 0, i32 0
<   store i64 %86, i64* %tmp.sroa.0.0..idx.7, align 1
<   %tmp.sroa.1.8..idx8.7 = getelementptr inbounds %struct.CPUX86State* %90, i64 0, i32 21, i64 %95, i32 1
<   %96 = bitcast [8 x i8]* %tmp.sroa.1.8..idx8.7 to i16*
<   store i16 %89, i16* %96, align 1
<   ret void
---
> ; <label>:27                                      ; preds = %26, %15, %11
>   %28 = load i16* %1
>   ret i16 %28
15709,15712c12378,12396
< define void @helper_fxsave(i32 %ptr, i32 %data64) nounwind uwtable {
<   %1 = and i32 %ptr, 15
<   %2 = icmp eq i32 %1, 0
<   br i1 %2, label %4, label %3
---
> define internal zeroext i16 @packFloat16(i8 zeroext %zSign, i32 %zExp, i16 zeroext %zSig) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = alloca i16, align 2
>   store i8 %zSign, i8* %1, align 1
>   store i32 %zExp, i32* %2, align 4
>   store i16 %zSig, i16* %3, align 2
>   %4 = load i8* %1, align 1
>   %5 = zext i8 %4 to i32
>   %6 = shl i32 %5, 15
>   %7 = load i32* %2, align 4
>   %8 = shl i32 %7, 10
>   %9 = add i32 %6, %8
>   %10 = load i16* %3, align 2
>   %11 = zext i16 %10 to i32
>   %12 = add i32 %9, %11
>   %13 = trunc i32 %12 to i16
>   ret i16 %13
> }
15714,15716c12398,12422
< ; <label>:3                                       ; preds = %0
<   tail call fastcc void @raise_exception(i32 13) noreturn
<   unreachable
---
> define internal void @float64_to_floatx80(%struct.floatx80* noalias sret %agg.result, i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %3 = alloca %struct.commonNaNT, align 4
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %4 = load i64* %1, align 8
>   %5 = load %struct.float_status** %2, align 4
>   %6 = call i64 @float64_squash_input_denormal(i64 %4, %struct.float_status* %5)
>   store i64 %6, i64* %1, align 8
>   %7 = load i64* %1, align 8
>   %8 = call i64 @extractFloat64Frac(i64 %7)
>   store i64 %8, i64* %aSig, align 8
>   %9 = load i64* %1, align 8
>   %10 = call i32 @extractFloat64Exp(i64 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i64* %1, align 8
>   %12 = call zeroext i8 @extractFloat64Sign(i64 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 2047
>   br i1 %14, label %15, label %24
15718,15786c12424,12435
< ; <label>:4                                       ; preds = %0
<   %5 = load %struct.CPUX86State** @env, align 8
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 18
<   %7 = load i16* %6, align 2
<   %8 = zext i16 %7 to i32
<   %9 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 17
<   %10 = load i32* %9, align 4
<   %11 = shl i32 %10, 11
<   %12 = and i32 %11, 14336
<   %13 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 20, i64 0
<   %14 = load i8* %13, align 1
<   %15 = zext i8 %14 to i32
<   %16 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 20, i64 1
<   %17 = load i8* %16, align 1
<   %18 = zext i8 %17 to i32
<   %19 = shl nuw nsw i32 %18, 1
<   %20 = or i32 %19, %15
<   %21 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 20, i64 2
<   %22 = load i8* %21, align 1
<   %23 = zext i8 %22 to i32
<   %24 = shl nuw nsw i32 %23, 2
<   %25 = or i32 %20, %24
<   %26 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 20, i64 3
<   %27 = load i8* %26, align 1
<   %28 = zext i8 %27 to i32
<   %29 = shl nuw nsw i32 %28, 3
<   %30 = or i32 %25, %29
<   %31 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 20, i64 4
<   %32 = load i8* %31, align 1
<   %33 = zext i8 %32 to i32
<   %34 = shl nuw nsw i32 %33, 4
<   %35 = or i32 %30, %34
<   %36 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 20, i64 5
<   %37 = load i8* %36, align 1
<   %38 = zext i8 %37 to i32
<   %39 = shl nuw nsw i32 %38, 5
<   %40 = or i32 %35, %39
<   %41 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 20, i64 6
<   %42 = load i8* %41, align 1
<   %43 = zext i8 %42 to i32
<   %44 = shl nuw nsw i32 %43, 6
<   %45 = or i32 %40, %44
<   %46 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 20, i64 7
<   %47 = load i8* %46, align 1
<   %48 = zext i8 %47 to i32
<   %49 = shl nuw nsw i32 %48, 7
<   %50 = or i32 %45, %49
<   %51 = and i32 %8, 51199
<   %52 = or i32 %12, %51
<   %53 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 19
<   %54 = load i16* %53, align 2
<   %55 = zext i16 %54 to i32
<   tail call fastcc void @stw_data(i32 %ptr, i32 %55)
<   %56 = add i32 %ptr, 2
<   tail call fastcc void @stw_data(i32 %56, i32 %52)
<   %57 = add i32 %ptr, 4
<   %58 = xor i32 %50, 255
<   tail call fastcc void @stw_data(i32 %57, i32 %58)
<   %59 = add i32 %ptr, 8
<   tail call fastcc void @stl_data(i32 %59, i32 0)
<   %60 = add i32 %ptr, 12
<   tail call fastcc void @stl_data(i32 %60, i32 0)
<   %61 = add i32 %ptr, 16
<   tail call fastcc void @stl_data(i32 %61, i32 0)
<   %62 = add i32 %ptr, 20
<   tail call fastcc void @stl_data(i32 %62, i32 0)
<   %63 = add i32 %ptr, 32
<   %64 = load %struct.CPUX86State** @env, align 8
<   br label %65
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i64* %aSig, align 8
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %18, label %22
> 
> ; <label>:18                                      ; preds = %15
>   %19 = load i64* %1, align 8
>   %20 = load %struct.float_status** %2, align 4
>   call void @float64ToCommonNaN(%struct.commonNaNT* sret %3, i64 %19, %struct.float_status* %20)
>   %21 = load %struct.float_status** %2, align 4
>   call void @commonNaNToFloatx80(%struct.floatx80* sret %agg.result, %struct.commonNaNT* byval align 4 %3, %struct.float_status* %21)
>   br label %41
15788,15864c12437,12440
< ; <label>:65                                      ; preds = %65, %4
<   %66 = phi %struct.CPUX86State* [ %64, %4 ], [ %77, %65 ]
<   %i.133 = phi i32 [ 0, %4 ], [ %76, %65 ]
<   %addr.032 = phi i32 [ %63, %4 ], [ %75, %65 ]
<   %67 = getelementptr inbounds %struct.CPUX86State* %66, i64 0, i32 17
<   %68 = load i32* %67, align 4
<   %69 = add i32 %68, %i.133
<   %70 = and i32 %69, 7
<   %71 = zext i32 %70 to i64
<   %tmp.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %66, i64 0, i32 21, i64 %71, i32 0, i32 0
<   %tmp.sroa.0.0.copyload = load i64* %tmp.sroa.0.0..idx, align 1
<   %tmp.sroa.1.8..idx6 = getelementptr inbounds %struct.CPUX86State* %66, i64 0, i32 21, i64 %71, i32 1
<   %72 = bitcast [8 x i8]* %tmp.sroa.1.8..idx6 to i16*
<   %tmp.sroa.1.8.copyload = load i16* %72, align 1
<   tail call fastcc void @stq_data(i32 %addr.032, i64 %tmp.sroa.0.0.copyload) nounwind
<   %73 = add i32 %addr.032, 8
<   %74 = zext i16 %tmp.sroa.1.8.copyload to i32
<   tail call fastcc void @stw_data(i32 %73, i32 %74) nounwind
<   %75 = add i32 %addr.032, 16
<   %76 = add nsw i32 %i.133, 1
<   %77 = load %struct.CPUX86State** @env, align 8
<   %exitcond = icmp eq i32 %76, 8
<   br i1 %exitcond, label %78, label %65
< 
< ; <label>:78                                      ; preds = %65
<   %79 = getelementptr inbounds %struct.CPUX86State* %77, i64 0, i32 15, i64 4
<   %80 = load i32* %79, align 4
<   %81 = and i32 %80, 512
<   %82 = icmp eq i32 %81, 0
<   br i1 %82, label %.loopexit, label %83
< 
< ; <label>:83                                      ; preds = %78
<   %84 = add i32 %ptr, 24
<   %85 = getelementptr inbounds %struct.CPUX86State* %77, i64 0, i32 29
<   %86 = load i32* %85, align 4
<   tail call fastcc void @stl_data(i32 %84, i32 %86)
<   %87 = add i32 %ptr, 28
<   tail call fastcc void @stl_data(i32 %87, i32 65535)
<   %88 = load %struct.CPUX86State** @env, align 8
<   %89 = getelementptr inbounds %struct.CPUX86State* %88, i64 0, i32 8
<   %90 = load i32* %89, align 4
<   %91 = lshr i32 %90, 12
<   %92 = and i32 %91, 8
<   %93 = add i32 %92, 8
<   %94 = add i32 %ptr, 160
<   %95 = getelementptr inbounds %struct.CPUX86State* %88, i64 0, i32 36
<   %96 = load i64* %95, align 8
<   %97 = and i64 %96, 16384
<   %98 = icmp eq i64 %97, 0
<   br i1 %98, label %.lr.ph, label %99
< 
< ; <label>:99                                      ; preds = %83
<   %100 = and i32 %90, 16387
<   %101 = icmp eq i32 %100, 16384
<   br i1 %101, label %.loopexit, label %.lr.ph
< 
< .lr.ph:                                           ; preds = %._crit_edge, %99, %83
<   %102 = phi %struct.CPUX86State* [ %.pre, %._crit_edge ], [ %88, %99 ], [ %88, %83 ]
<   %indvars.iv = phi i64 [ %indvars.iv.next, %._crit_edge ], [ 0, %99 ], [ 0, %83 ]
<   %addr.130 = phi i32 [ %111, %._crit_edge ], [ %94, %99 ], [ %94, %83 ]
<   %103 = getelementptr inbounds %struct.CPUX86State* %102, i64 0, i32 30, i64 %indvars.iv, i32 0, i64 0
<   %104 = load i64* %103, align 8
<   tail call fastcc void @stq_data(i32 %addr.130, i64 %104)
<   %105 = add i32 %addr.130, 8
<   %106 = load %struct.CPUX86State** @env, align 8
<   %107 = getelementptr inbounds %struct.CPUX86State* %106, i64 0, i32 30, i64 %indvars.iv, i32 0, i64 1
<   %108 = load i64* %107, align 8
<   tail call fastcc void @stq_data(i32 %105, i64 %108)
<   %indvars.iv.next = add i64 %indvars.iv, 1
<   %109 = trunc i64 %indvars.iv.next to i32
<   %110 = icmp slt i32 %109, %93
<   br i1 %110, label %._crit_edge, label %.loopexit
< 
< ._crit_edge:                                      ; preds = %.lr.ph
<   %111 = add i32 %addr.130, 16
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %.lr.ph
---
> ; <label>:22                                      ; preds = %15
>   %23 = load i8* %aSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %23, i32 32767, i64 -9223372036854775808)
>   br label %41
15866,15868c12442,12445
< .loopexit:                                        ; preds = %.lr.ph, %99, %78
<   ret void
< }
---
> ; <label>:24                                      ; preds = %0
>   %25 = load i32* %aExp, align 4
>   %26 = icmp eq i32 %25, 0
>   br i1 %26, label %27, label %34
15870,15873c12447,12455
< define void @helper_fxrstor(i32 %ptr, i32 %data64) nounwind uwtable {
<   %1 = and i32 %ptr, 15
<   %2 = icmp eq i32 %1, 0
<   br i1 %2, label %4, label %3
---
> ; <label>:27                                      ; preds = %24
>   %28 = load i64* %aSig, align 8
>   %29 = icmp eq i64 %28, 0
>   br i1 %29, label %30, label %32
> 
> ; <label>:30                                      ; preds = %27
>   %31 = load i8* %aSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %31, i32 0, i64 0)
>   br label %41
15875,15877c12457,12460
< ; <label>:3                                       ; preds = %0
<   tail call fastcc void @raise_exception(i32 13) noreturn
<   unreachable
---
> ; <label>:32                                      ; preds = %27
>   %33 = load i64* %aSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %33, i32* %aExp, i64* %aSig)
>   br label %34
15879,16121c12462,12470
< ; <label>:4                                       ; preds = %0
<   %5 = tail call fastcc i32 @lduw_data(i32 %ptr)
<   %6 = trunc i32 %5 to i16
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 19
<   store i16 %6, i16* %8, align 2
<   %9 = add i32 %ptr, 2
<   %10 = tail call fastcc i32 @lduw_data(i32 %9)
<   %11 = add i32 %ptr, 4
<   %12 = tail call fastcc i32 @lduw_data(i32 %11)
<   %13 = lshr i32 %10, 11
<   %14 = and i32 %13, 7
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 17
<   store i32 %14, i32* %16, align 4
<   %.tr = trunc i32 %10 to i16
<   %17 = and i16 %.tr, -14337
<   %18 = load %struct.CPUX86State** @env, align 8
<   %19 = getelementptr inbounds %struct.CPUX86State* %18, i64 0, i32 18
<   store i16 %17, i16* %19, align 2
<   %20 = xor i32 %12, 255
<   %.tr29 = trunc i32 %20 to i8
<   %21 = and i8 %.tr29, 1
<   %22 = load %struct.CPUX86State** @env, align 8
<   %23 = getelementptr inbounds %struct.CPUX86State* %22, i64 0, i32 20, i64 0
<   store i8 %21, i8* %23, align 1
<   %24 = lshr i32 %20, 1
<   %.tr29.1 = trunc i32 %24 to i8
<   %25 = and i8 %.tr29.1, 1
<   %26 = load %struct.CPUX86State** @env, align 8
<   %27 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 20, i64 1
<   store i8 %25, i8* %27, align 1
<   %28 = lshr i32 %20, 2
<   %.tr29.2 = trunc i32 %28 to i8
<   %29 = and i8 %.tr29.2, 1
<   %30 = load %struct.CPUX86State** @env, align 8
<   %31 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 20, i64 2
<   store i8 %29, i8* %31, align 1
<   %32 = lshr i32 %20, 3
<   %.tr29.3 = trunc i32 %32 to i8
<   %33 = and i8 %.tr29.3, 1
<   %34 = load %struct.CPUX86State** @env, align 8
<   %35 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 20, i64 3
<   store i8 %33, i8* %35, align 1
<   %36 = lshr i32 %20, 4
<   %.tr29.4 = trunc i32 %36 to i8
<   %37 = and i8 %.tr29.4, 1
<   %38 = load %struct.CPUX86State** @env, align 8
<   %39 = getelementptr inbounds %struct.CPUX86State* %38, i64 0, i32 20, i64 4
<   store i8 %37, i8* %39, align 1
<   %40 = lshr i32 %20, 5
<   %.tr29.5 = trunc i32 %40 to i8
<   %41 = and i8 %.tr29.5, 1
<   %42 = load %struct.CPUX86State** @env, align 8
<   %43 = getelementptr inbounds %struct.CPUX86State* %42, i64 0, i32 20, i64 5
<   store i8 %41, i8* %43, align 1
<   %44 = lshr i32 %20, 6
<   %.tr29.6 = trunc i32 %44 to i8
<   %45 = and i8 %.tr29.6, 1
<   %46 = load %struct.CPUX86State** @env, align 8
<   %47 = getelementptr inbounds %struct.CPUX86State* %46, i64 0, i32 20, i64 6
<   store i8 %45, i8* %47, align 1
<   %48 = lshr i32 %20, 7
<   %.tr29.7 = trunc i32 %48 to i8
<   %49 = and i8 %.tr29.7, 1
<   %50 = load %struct.CPUX86State** @env, align 8
<   %51 = getelementptr inbounds %struct.CPUX86State* %50, i64 0, i32 20, i64 7
<   store i8 %49, i8* %51, align 1
<   %52 = add i32 %ptr, 32
<   %53 = tail call fastcc i64 @ldq_data(i32 %52) nounwind
<   %54 = add i32 %ptr, 40
<   %55 = tail call fastcc i32 @lduw_data(i32 %54) nounwind
<   %56 = trunc i32 %55 to i16
<   %57 = load %struct.CPUX86State** @env, align 8
<   %58 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 17
<   %59 = load i32* %58, align 4
<   %60 = and i32 %59, 7
<   %61 = zext i32 %60 to i64
<   %tmp.sroa.0.0..idx = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 21, i64 %61, i32 0, i32 0
<   store i64 %53, i64* %tmp.sroa.0.0..idx, align 1
<   %tmp.sroa.1.8..idx10 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 21, i64 %61, i32 1
<   %62 = bitcast [8 x i8]* %tmp.sroa.1.8..idx10 to i16*
<   store i16 %56, i16* %62, align 1
<   %63 = add i32 %ptr, 48
<   %64 = tail call fastcc i64 @ldq_data(i32 %63) nounwind
<   %65 = add i32 %ptr, 56
<   %66 = tail call fastcc i32 @lduw_data(i32 %65) nounwind
<   %67 = trunc i32 %66 to i16
<   %68 = load %struct.CPUX86State** @env, align 8
<   %69 = getelementptr inbounds %struct.CPUX86State* %68, i64 0, i32 17
<   %70 = load i32* %69, align 4
<   %71 = add i32 %70, 1
<   %72 = and i32 %71, 7
<   %73 = zext i32 %72 to i64
<   %tmp.sroa.0.0..idx.1 = getelementptr inbounds %struct.CPUX86State* %68, i64 0, i32 21, i64 %73, i32 0, i32 0
<   store i64 %64, i64* %tmp.sroa.0.0..idx.1, align 1
<   %tmp.sroa.1.8..idx10.1 = getelementptr inbounds %struct.CPUX86State* %68, i64 0, i32 21, i64 %73, i32 1
<   %74 = bitcast [8 x i8]* %tmp.sroa.1.8..idx10.1 to i16*
<   store i16 %67, i16* %74, align 1
<   %75 = add i32 %ptr, 64
<   %76 = tail call fastcc i64 @ldq_data(i32 %75) nounwind
<   %77 = add i32 %ptr, 72
<   %78 = tail call fastcc i32 @lduw_data(i32 %77) nounwind
<   %79 = trunc i32 %78 to i16
<   %80 = load %struct.CPUX86State** @env, align 8
<   %81 = getelementptr inbounds %struct.CPUX86State* %80, i64 0, i32 17
<   %82 = load i32* %81, align 4
<   %83 = add i32 %82, 2
<   %84 = and i32 %83, 7
<   %85 = zext i32 %84 to i64
<   %tmp.sroa.0.0..idx.2 = getelementptr inbounds %struct.CPUX86State* %80, i64 0, i32 21, i64 %85, i32 0, i32 0
<   store i64 %76, i64* %tmp.sroa.0.0..idx.2, align 1
<   %tmp.sroa.1.8..idx10.2 = getelementptr inbounds %struct.CPUX86State* %80, i64 0, i32 21, i64 %85, i32 1
<   %86 = bitcast [8 x i8]* %tmp.sroa.1.8..idx10.2 to i16*
<   store i16 %79, i16* %86, align 1
<   %87 = add i32 %ptr, 80
<   %88 = tail call fastcc i64 @ldq_data(i32 %87) nounwind
<   %89 = add i32 %ptr, 88
<   %90 = tail call fastcc i32 @lduw_data(i32 %89) nounwind
<   %91 = trunc i32 %90 to i16
<   %92 = load %struct.CPUX86State** @env, align 8
<   %93 = getelementptr inbounds %struct.CPUX86State* %92, i64 0, i32 17
<   %94 = load i32* %93, align 4
<   %95 = add i32 %94, 3
<   %96 = and i32 %95, 7
<   %97 = zext i32 %96 to i64
<   %tmp.sroa.0.0..idx.3 = getelementptr inbounds %struct.CPUX86State* %92, i64 0, i32 21, i64 %97, i32 0, i32 0
<   store i64 %88, i64* %tmp.sroa.0.0..idx.3, align 1
<   %tmp.sroa.1.8..idx10.3 = getelementptr inbounds %struct.CPUX86State* %92, i64 0, i32 21, i64 %97, i32 1
<   %98 = bitcast [8 x i8]* %tmp.sroa.1.8..idx10.3 to i16*
<   store i16 %91, i16* %98, align 1
<   %99 = add i32 %ptr, 96
<   %100 = tail call fastcc i64 @ldq_data(i32 %99) nounwind
<   %101 = add i32 %ptr, 104
<   %102 = tail call fastcc i32 @lduw_data(i32 %101) nounwind
<   %103 = trunc i32 %102 to i16
<   %104 = load %struct.CPUX86State** @env, align 8
<   %105 = getelementptr inbounds %struct.CPUX86State* %104, i64 0, i32 17
<   %106 = load i32* %105, align 4
<   %107 = add i32 %106, 4
<   %108 = and i32 %107, 7
<   %109 = zext i32 %108 to i64
<   %tmp.sroa.0.0..idx.4 = getelementptr inbounds %struct.CPUX86State* %104, i64 0, i32 21, i64 %109, i32 0, i32 0
<   store i64 %100, i64* %tmp.sroa.0.0..idx.4, align 1
<   %tmp.sroa.1.8..idx10.4 = getelementptr inbounds %struct.CPUX86State* %104, i64 0, i32 21, i64 %109, i32 1
<   %110 = bitcast [8 x i8]* %tmp.sroa.1.8..idx10.4 to i16*
<   store i16 %103, i16* %110, align 1
<   %111 = add i32 %ptr, 112
<   %112 = tail call fastcc i64 @ldq_data(i32 %111) nounwind
<   %113 = add i32 %ptr, 120
<   %114 = tail call fastcc i32 @lduw_data(i32 %113) nounwind
<   %115 = trunc i32 %114 to i16
<   %116 = load %struct.CPUX86State** @env, align 8
<   %117 = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 17
<   %118 = load i32* %117, align 4
<   %119 = add i32 %118, 5
<   %120 = and i32 %119, 7
<   %121 = zext i32 %120 to i64
<   %tmp.sroa.0.0..idx.5 = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 21, i64 %121, i32 0, i32 0
<   store i64 %112, i64* %tmp.sroa.0.0..idx.5, align 1
<   %tmp.sroa.1.8..idx10.5 = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 21, i64 %121, i32 1
<   %122 = bitcast [8 x i8]* %tmp.sroa.1.8..idx10.5 to i16*
<   store i16 %115, i16* %122, align 1
<   %123 = add i32 %ptr, 128
<   %124 = tail call fastcc i64 @ldq_data(i32 %123) nounwind
<   %125 = add i32 %ptr, 136
<   %126 = tail call fastcc i32 @lduw_data(i32 %125) nounwind
<   %127 = trunc i32 %126 to i16
<   %128 = load %struct.CPUX86State** @env, align 8
<   %129 = getelementptr inbounds %struct.CPUX86State* %128, i64 0, i32 17
<   %130 = load i32* %129, align 4
<   %131 = add i32 %130, 6
<   %132 = and i32 %131, 7
<   %133 = zext i32 %132 to i64
<   %tmp.sroa.0.0..idx.6 = getelementptr inbounds %struct.CPUX86State* %128, i64 0, i32 21, i64 %133, i32 0, i32 0
<   store i64 %124, i64* %tmp.sroa.0.0..idx.6, align 1
<   %tmp.sroa.1.8..idx10.6 = getelementptr inbounds %struct.CPUX86State* %128, i64 0, i32 21, i64 %133, i32 1
<   %134 = bitcast [8 x i8]* %tmp.sroa.1.8..idx10.6 to i16*
<   store i16 %127, i16* %134, align 1
<   %135 = add i32 %ptr, 144
<   %136 = tail call fastcc i64 @ldq_data(i32 %135) nounwind
<   %137 = add i32 %ptr, 152
<   %138 = tail call fastcc i32 @lduw_data(i32 %137) nounwind
<   %139 = trunc i32 %138 to i16
<   %140 = load %struct.CPUX86State** @env, align 8
<   %141 = getelementptr inbounds %struct.CPUX86State* %140, i64 0, i32 17
<   %142 = load i32* %141, align 4
<   %143 = add i32 %142, 7
<   %144 = and i32 %143, 7
<   %145 = zext i32 %144 to i64
<   %tmp.sroa.0.0..idx.7 = getelementptr inbounds %struct.CPUX86State* %140, i64 0, i32 21, i64 %145, i32 0, i32 0
<   store i64 %136, i64* %tmp.sroa.0.0..idx.7, align 1
<   %tmp.sroa.1.8..idx10.7 = getelementptr inbounds %struct.CPUX86State* %140, i64 0, i32 21, i64 %145, i32 1
<   %146 = bitcast [8 x i8]* %tmp.sroa.1.8..idx10.7 to i16*
<   store i16 %139, i16* %146, align 1
<   %147 = load %struct.CPUX86State** @env, align 8
<   %148 = getelementptr inbounds %struct.CPUX86State* %147, i64 0, i32 15, i64 4
<   %149 = load i32* %148, align 4
<   %150 = and i32 %149, 512
<   %151 = icmp eq i32 %150, 0
<   br i1 %151, label %.loopexit, label %152
< 
< ; <label>:152                                     ; preds = %4
<   %153 = add i32 %ptr, 24
<   %154 = tail call fastcc i32 @ldl_data(i32 %153)
<   %155 = load %struct.CPUX86State** @env, align 8
<   %156 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 29
<   store i32 %154, i32* %156, align 4
<   %157 = load %struct.CPUX86State** @env, align 8
<   %158 = getelementptr inbounds %struct.CPUX86State* %157, i64 0, i32 8
<   %159 = load i32* %158, align 4
<   %160 = lshr i32 %159, 12
<   %161 = and i32 %160, 8
<   %162 = add i32 %161, 8
<   %163 = add i32 %ptr, 160
<   %164 = getelementptr inbounds %struct.CPUX86State* %157, i64 0, i32 36
<   %165 = load i64* %164, align 8
<   %166 = and i64 %165, 16384
<   %167 = icmp eq i64 %166, 0
<   br i1 %167, label %.lr.ph, label %168
< 
< ; <label>:168                                     ; preds = %152
<   %169 = and i32 %159, 16387
<   %170 = icmp eq i32 %169, 16384
<   br i1 %170, label %.loopexit, label %.lr.ph
< 
< .lr.ph:                                           ; preds = %.lr.ph, %168, %152
<   %indvars.iv = phi i64 [ %indvars.iv.next, %.lr.ph ], [ 0, %168 ], [ 0, %152 ]
<   %addr.131 = phi i32 [ %178, %.lr.ph ], [ %163, %168 ], [ %163, %152 ]
<   %171 = tail call fastcc i64 @ldq_data(i32 %addr.131)
<   %172 = load %struct.CPUX86State** @env, align 8
<   %173 = getelementptr inbounds %struct.CPUX86State* %172, i64 0, i32 30, i64 %indvars.iv, i32 0, i64 0
<   store i64 %171, i64* %173, align 8
<   %174 = add i32 %addr.131, 8
<   %175 = tail call fastcc i64 @ldq_data(i32 %174)
<   %176 = load %struct.CPUX86State** @env, align 8
<   %177 = getelementptr inbounds %struct.CPUX86State* %176, i64 0, i32 30, i64 %indvars.iv, i32 0, i64 1
<   store i64 %175, i64* %177, align 8
<   %178 = add i32 %addr.131, 16
<   %indvars.iv.next = add i64 %indvars.iv, 1
<   %179 = trunc i64 %indvars.iv.next to i32
<   %180 = icmp slt i32 %179, %162
<   br i1 %180, label %.lr.ph, label %.loopexit
---
> ; <label>:34                                      ; preds = %32, %24
>   %35 = load i8* %aSign, align 1
>   %36 = load i32* %aExp, align 4
>   %37 = add nsw i32 %36, 15360
>   %38 = load i64* %aSig, align 8
>   %39 = or i64 %38, 4503599627370496
>   %40 = shl i64 %39, 11
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %35, i32 %37, i64 %40)
>   br label %41
16123c12472
< .loopexit:                                        ; preds = %.lr.ph, %168, %4
---
> ; <label>:41                                      ; preds = %34, %30, %22, %18
16127,16129c12476,12501
< define void @cpu_get_fp80(i64* nocapture %pmant, i16* nocapture %pexp, i64 %f.coerce0, i16 %f.coerce1) nounwind uwtable {
<   store i64 %f.coerce0, i64* %pmant, align 8
<   store i16 %f.coerce1, i16* %pexp, align 2
---
> define internal void @normalizeFloat64Subnormal(i64 %aSig, i32* %zExpPtr, i64* %zSigPtr) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca i32*, align 4
>   %3 = alloca i64*, align 4
>   %shiftCount = alloca i8, align 1
>   store i64 %aSig, i64* %1, align 8
>   store i32* %zExpPtr, i32** %2, align 4
>   store i64* %zSigPtr, i64** %3, align 4
>   %4 = load i64* %1, align 8
>   %5 = call signext i8 @countLeadingZeros64(i64 %4)
>   %6 = sext i8 %5 to i32
>   %7 = sub nsw i32 %6, 11
>   %8 = trunc i32 %7 to i8
>   store i8 %8, i8* %shiftCount, align 1
>   %9 = load i64* %1, align 8
>   %10 = load i8* %shiftCount, align 1
>   %11 = sext i8 %10 to i32
>   %12 = zext i32 %11 to i64
>   %13 = shl i64 %9, %12
>   %14 = load i64** %3, align 4
>   store i64 %13, i64* %14, align 4
>   %15 = load i8* %shiftCount, align 1
>   %16 = sext i8 %15 to i32
>   %17 = sub nsw i32 1, %16
>   %18 = load i32** %2, align 4
>   store i32 %17, i32* %18, align 4
16133,16156c12505,12531
< define { i64, i16 } @cpu_set_fp80(i64 %mant, i16 zeroext %upper) nounwind uwtable readnone {
<   %.fca.0.insert = insertvalue { i64, i16 } undef, i64 %mant, 0
<   %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %upper, 1
<   ret { i64, i16 } %.fca.1.insert
< }
< 
< define void @helper_hlt(i32 %next_eip_addend) noreturn nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
< 
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 16777216
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
< 
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 120, i64 0) nounwind
<   unreachable
---
> define internal void @float64_to_float128(%struct.float128* noalias sret %agg.result, i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %3 = alloca %struct.commonNaNT, align 4
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %4 = load i64* %1, align 8
>   %5 = load %struct.float_status** %2, align 4
>   %6 = call i64 @float64_squash_input_denormal(i64 %4, %struct.float_status* %5)
>   store i64 %6, i64* %1, align 8
>   %7 = load i64* %1, align 8
>   %8 = call i64 @extractFloat64Frac(i64 %7)
>   store i64 %8, i64* %aSig, align 8
>   %9 = load i64* %1, align 8
>   %10 = call i32 @extractFloat64Exp(i64 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i64* %1, align 8
>   %12 = call zeroext i8 @extractFloat64Sign(i64 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 2047
>   br i1 %14, label %15, label %24
16158,16165c12533,12544
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 5
<   %12 = load i32* %11, align 4
<   %13 = add i32 %12, %next_eip_addend
<   store i32 %13, i32* %11, align 4
<   tail call fastcc void @do_hlt()
<   unreachable
< }
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i64* %aSig, align 8
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %18, label %22
> 
> ; <label>:18                                      ; preds = %15
>   %19 = load i64* %1, align 8
>   %20 = load %struct.float_status** %2, align 4
>   call void @float64ToCommonNaN(%struct.commonNaNT* sret %3, i64 %19, %struct.float_status* %20)
>   %21 = load %struct.float_status** %2, align 4
>   call void @commonNaNToFloat128(%struct.float128* sret %agg.result, %struct.commonNaNT* byval align 4 %3, %struct.float_status* %21)
>   br label %43
16167,16182c12546,12549
< define internal fastcc void @do_hlt() noreturn nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, -9
<   store i32 %4, i32* %2, align 4
<   %5 = load %struct.CPUX86State** @env, align 8
<   %6 = getelementptr inbounds %struct.CPUX86State* %5, i64 0, i32 70
<   store i32 1, i32* %6, align 4
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 92
<   store i32 65537, i32* %8, align 4
<   %9 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_loop_exit(%struct.CPUX86State* %9) noreturn nounwind
<   unreachable
< }
---
> ; <label>:22                                      ; preds = %15
>   %23 = load i8* %aSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %23, i32 32767, i64 0, i64 0)
>   br label %43
16184,16189c12551,12554
< define void @helper_monitor(i32 %ptr) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 1
<   %3 = load i32* %2, align 4
<   %4 = icmp eq i32 %3, 0
<   br i1 %4, label %6, label %5
---
> ; <label>:24                                      ; preds = %0
>   %25 = load i32* %aExp, align 4
>   %26 = icmp eq i32 %25, 0
>   br i1 %26, label %27, label %36
16191,16193c12556,12564
< ; <label>:5                                       ; preds = %0
<   tail call fastcc void @raise_exception(i32 13) noreturn
<   unreachable
---
> ; <label>:27                                      ; preds = %24
>   %28 = load i64* %aSig, align 8
>   %29 = icmp eq i64 %28, 0
>   br i1 %29, label %30, label %32
> 
> ; <label>:30                                      ; preds = %27
>   %31 = load i8* %aSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %31, i32 0, i64 0, i64 0)
>   br label %43
16195,16207c12566,12572
< ; <label>:6                                       ; preds = %0
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %8 = load i32* %7, align 4
<   %.lobit.i = and i32 %8, 2097152
<   %9 = icmp eq i32 %.lobit.i, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10, !prof !0
< 
< ; <label>:10                                      ; preds = %6
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %12 = load i64* %11, align 8
<   %13 = and i64 %12, 4398046511104
<   %14 = icmp eq i64 %13, 0
<   br i1 %14, label %helper_svm_check_intercept_param.exit, label %15
---
> ; <label>:32                                      ; preds = %27
>   %33 = load i64* %aSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %33, i32* %aExp, i64* %aSig)
>   %34 = load i32* %aExp, align 4
>   %35 = add nsw i32 %34, -1
>   store i32 %35, i32* %aExp, align 4
>   br label %36
16209,16211c12574,12583
< ; <label>:15                                      ; preds = %10
<   tail call void @helper_vmexit(i32 138, i64 0) nounwind
<   unreachable
---
> ; <label>:36                                      ; preds = %32, %24
>   %37 = load i64* %aSig, align 8
>   call void @shift128Right(i64 %37, i64 0, i32 4, i64* %zSig0, i64* %zSig1)
>   %38 = load i8* %aSign, align 1
>   %39 = load i32* %aExp, align 4
>   %40 = add nsw i32 %39, 15360
>   %41 = load i64* %zSig0, align 8
>   %42 = load i64* %zSig1, align 8
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %38, i32 %40, i64 %41, i64 %42)
>   br label %43
16213c12585
< helper_svm_check_intercept_param.exit:            ; preds = %10, %6
---
> ; <label>:43                                      ; preds = %36, %30, %22, %18
16217,16222c12589,12610
< define void @helper_mwait(i32 %next_eip_addend) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 1
<   %3 = load i32* %2, align 4
<   %4 = icmp eq i32 %3, 0
<   br i1 %4, label %6, label %5
---
> define internal void @shift128Right(i64 %a0, i64 %a1, i32 %count, i64* %z0Ptr, i64* %z1Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i32, align 4
>   %4 = alloca i64*, align 4
>   %5 = alloca i64*, align 4
>   %z0 = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   %negCount = alloca i8, align 1
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i32 %count, i32* %3, align 4
>   store i64* %z0Ptr, i64** %4, align 4
>   store i64* %z1Ptr, i64** %5, align 4
>   %6 = load i32* %3, align 4
>   %7 = sub nsw i32 0, %6
>   %8 = and i32 %7, 63
>   %9 = trunc i32 %8 to i8
>   store i8 %9, i8* %negCount, align 1
>   %10 = load i32* %3, align 4
>   %11 = icmp eq i32 %10, 0
>   br i1 %11, label %12, label %15
16224,16226c12612,12617
< ; <label>:5                                       ; preds = %0
<   tail call fastcc void @raise_exception(i32 13) noreturn
<   unreachable
---
> ; <label>:12                                      ; preds = %0
>   %13 = load i64* %2, align 8
>   store i64 %13, i64* %z1, align 8
>   %14 = load i64* %1, align 8
>   store i64 %14, i64* %z0, align 8
>   br label %46
16228,16240c12619,12641
< ; <label>:6                                       ; preds = %0
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %8 = load i32* %7, align 4
<   %.lobit.i = and i32 %8, 2097152
<   %9 = icmp eq i32 %.lobit.i, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10, !prof !0
< 
< ; <label>:10                                      ; preds = %6
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %12 = load i64* %11, align 8
<   %13 = and i64 %12, 8796093022208
<   %14 = icmp eq i64 %13, 0
<   br i1 %14, label %helper_svm_check_intercept_param.exit, label %15
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %3, align 4
>   %17 = icmp slt i32 %16, 64
>   br i1 %17, label %18, label %33
> 
> ; <label>:18                                      ; preds = %15
>   %19 = load i64* %1, align 8
>   %20 = load i8* %negCount, align 1
>   %21 = sext i8 %20 to i32
>   %22 = zext i32 %21 to i64
>   %23 = shl i64 %19, %22
>   %24 = load i64* %2, align 8
>   %25 = load i32* %3, align 4
>   %26 = zext i32 %25 to i64
>   %27 = lshr i64 %24, %26
>   %28 = or i64 %23, %27
>   store i64 %28, i64* %z1, align 8
>   %29 = load i64* %1, align 8
>   %30 = load i32* %3, align 4
>   %31 = zext i32 %30 to i64
>   %32 = lshr i64 %29, %31
>   store i64 %32, i64* %z0, align 8
>   br label %45
16242,16244c12643,12646
< ; <label>:15                                      ; preds = %10
<   tail call void @helper_vmexit(i32 139, i64 0) nounwind
<   unreachable
---
> ; <label>:33                                      ; preds = %15
>   %34 = load i32* %3, align 4
>   %35 = icmp slt i32 %34, 64
>   br i1 %35, label %36, label %42
16246,16255c12648,12654
< helper_svm_check_intercept_param.exit:            ; preds = %10, %6
<   %16 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 5
<   %17 = load i32* %16, align 4
<   %18 = add i32 %17, %next_eip_addend
<   store i32 %18, i32* %16, align 4
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 94
<   %21 = load i32* %20, align 4
<   %22 = icmp eq i32 %21, 0
<   br i1 %22, label %23, label %28
---
> ; <label>:36                                      ; preds = %33
>   %37 = load i64* %1, align 8
>   %38 = load i32* %3, align 4
>   %39 = and i32 %38, 63
>   %40 = zext i32 %39 to i64
>   %41 = lshr i64 %37, %40
>   br label %43
16257,16261c12656,12657
< ; <label>:23                                      ; preds = %helper_svm_check_intercept_param.exit
<   %24 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 93
<   %25 = load %struct.CPUX86State** %24, align 8
<   %26 = icmp eq %struct.CPUX86State* %25, null
<   br i1 %26, label %27, label %28
---
> ; <label>:42                                      ; preds = %33
>   br label %43
16263,16265c12659,12663
< ; <label>:27                                      ; preds = %23
<   tail call fastcc void @do_hlt()
<   unreachable
---
> ; <label>:43                                      ; preds = %42, %36
>   %44 = phi i64 [ %41, %36 ], [ 0, %42 ]
>   store i64 %44, i64* %z1, align 8
>   store i64 0, i64* %z0, align 8
>   br label %45
16267,16269c12665,12666
< ; <label>:28                                      ; preds = %23, %helper_svm_check_intercept_param.exit
<   ret void
< }
---
> ; <label>:45                                      ; preds = %43, %18
>   br label %46
16271,16277c12668,12675
< define void @helper_debug() noreturn nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 92
<   store i32 65538, i32* %2, align 4
<   %3 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_loop_exit(%struct.CPUX86State* %3) noreturn nounwind
<   unreachable
---
> ; <label>:46                                      ; preds = %45, %12
>   %47 = load i64* %z1, align 8
>   %48 = load i64** %5, align 4
>   store i64 %47, i64* %48, align 4
>   %49 = load i64* %z0, align 8
>   %50 = load i64** %4, align 4
>   store i64 %49, i64* %50, align 4
>   ret void
16280c12678,12699
< declare void @cpu_loop_exit(%struct.CPUX86State*) noreturn
---
> define internal i64 @float64_round_to_int(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %lastBitMask = alloca i64, align 8
>   %roundBitsMask = alloca i64, align 8
>   %roundingMode = alloca i8, align 1
>   %z = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i64 @float64_squash_input_denormal(i64 %4, %struct.float_status* %5)
>   store i64 %6, i64* %2, align 8
>   %7 = load i64* %2, align 8
>   %8 = call i32 @extractFloat64Exp(i64 %7)
>   store i32 %8, i32* %aExp, align 4
>   %9 = load i32* %aExp, align 4
>   %10 = icmp sle i32 1075, %9
>   br i1 %10, label %11, label %25
16282,16289c12701,12704
< define void @helper_reset_rf() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 7
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, -65537
<   store i32 %4, i32* %2, align 4
<   ret void
< }
---
> ; <label>:11                                      ; preds = %0
>   %12 = load i32* %aExp, align 4
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %23
16291,16294c12706,12718
< define void @helper_raise_interrupt(i32 %intno, i32 %next_eip_addend) noreturn nounwind uwtable {
<   tail call fastcc void @raise_interrupt(i32 %intno, i32 1, i32 0, i32 %next_eip_addend) noreturn
<   unreachable
< }
---
> ; <label>:14                                      ; preds = %11
>   %15 = load i64* %2, align 8
>   %16 = call i64 @extractFloat64Frac(i64 %15)
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %18, label %23
> 
> ; <label>:18                                      ; preds = %14
>   %19 = load i64* %2, align 8
>   %20 = load i64* %2, align 8
>   %21 = load %struct.float_status** %3, align 4
>   %22 = call i64 @propagateFloat64NaN(i64 %19, i64 %20, %struct.float_status* %21)
>   store i64 %22, i64* %1
>   br label %138
16296,16299c12720,12723
< define void @helper_raise_exception(i32 %exception_index) noreturn nounwind uwtable {
<   tail call fastcc void @raise_exception(i32 %exception_index) noreturn
<   unreachable
< }
---
> ; <label>:23                                      ; preds = %14, %11
>   %24 = load i64* %2, align 8
>   store i64 %24, i64* %1
>   br label %138
16301,16308c12725,12728
< define void @helper_cli() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 7
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, -513
<   store i32 %4, i32* %2, align 4
<   ret void
< }
---
> ; <label>:25                                      ; preds = %0
>   %26 = load i32* %aExp, align 4
>   %27 = icmp slt i32 %26, 1023
>   br i1 %27, label %28, label %71
16310,16317c12730,12739
< define void @helper_sti() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 7
<   %3 = load i32* %2, align 4
<   %4 = or i32 %3, 512
<   store i32 %4, i32* %2, align 4
<   ret void
< }
---
> ; <label>:28                                      ; preds = %25
>   %29 = load i64* %2, align 8
>   %30 = shl i64 %29, 1
>   %31 = icmp eq i64 %30, 0
>   br i1 %31, label %32, label %34
> 
> ; <label>:32                                      ; preds = %28
>   %33 = load i64* %2, align 8
>   store i64 %33, i64* %1
>   br label %138
16319,16326c12741,12760
< define void @helper_set_inhibit_irq() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %4 = or i32 %3, 8
<   store i32 %4, i32* %2, align 4
<   ret void
< }
---
> ; <label>:34                                      ; preds = %28
>   %35 = load %struct.float_status** %3, align 4
>   %36 = getelementptr inbounds %struct.float_status* %35, i32 0, i32 2
>   %37 = load i8* %36, align 1
>   %38 = sext i8 %37 to i32
>   %39 = or i32 %38, 32
>   %40 = trunc i32 %39 to i8
>   store i8 %40, i8* %36, align 1
>   %41 = load i64* %2, align 8
>   %42 = call zeroext i8 @extractFloat64Sign(i64 %41)
>   store i8 %42, i8* %aSign, align 1
>   %43 = load %struct.float_status** %3, align 4
>   %44 = getelementptr inbounds %struct.float_status* %43, i32 0, i32 1
>   %45 = load i8* %44, align 1
>   %46 = sext i8 %45 to i32
>   switch i32 %46, label %68 [
>     i32 0, label %47
>     i32 1, label %58
>     i32 2, label %63
>   ]
16328,16335c12762,12765
< define void @helper_reset_inhibit_irq() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %4 = and i32 %3, -9
<   store i32 %4, i32* %2, align 4
<   ret void
< }
---
> ; <label>:47                                      ; preds = %34
>   %48 = load i32* %aExp, align 4
>   %49 = icmp eq i32 %48, 1022
>   br i1 %49, label %50, label %57
16337,16346c12767,12777
< define void @helper_boundw(i32 %a0, i32 %v) nounwind uwtable {
<   %1 = tail call fastcc i32 @ldsw_data(i32 %a0)
<   %2 = add i32 %a0, 2
<   %3 = tail call fastcc i32 @ldsw_data(i32 %2)
<   %sext = shl i32 %v, 16
<   %4 = ashr exact i32 %sext, 16
<   %5 = icmp slt i32 %4, %1
<   %6 = icmp sgt i32 %4, %3
<   %or.cond = or i1 %5, %6
<   br i1 %or.cond, label %7, label %8
---
> ; <label>:50                                      ; preds = %47
>   %51 = load i64* %2, align 8
>   %52 = call i64 @extractFloat64Frac(i64 %51)
>   %53 = icmp ne i64 %52, 0
>   br i1 %53, label %54, label %57
> 
> ; <label>:54                                      ; preds = %50
>   %55 = load i8* %aSign, align 1
>   %56 = call i64 @packFloat64(i8 zeroext %55, i32 1023, i64 0)
>   store i64 %56, i64* %1
>   br label %138
16348,16350c12779,12780
< ; <label>:7                                       ; preds = %0
<   tail call fastcc void @raise_exception(i32 5) noreturn
<   unreachable
---
> ; <label>:57                                      ; preds = %50, %47
>   br label %68
16352,16354c12782,12788
< ; <label>:8                                       ; preds = %0
<   ret void
< }
---
> ; <label>:58                                      ; preds = %34
>   %59 = load i8* %aSign, align 1
>   %60 = zext i8 %59 to i32
>   %61 = icmp ne i32 %60, 0
>   %62 = select i1 %61, i64 -4616189618054758400, i64 0
>   store i64 %62, i64* %1
>   br label %138
16356,16360c12790,12796
< define internal fastcc i32 @ldsw_data(i32 %ptr) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:63                                      ; preds = %34
>   %64 = load i8* %aSign, align 1
>   %65 = zext i8 %64 to i32
>   %66 = icmp ne i32 %65, 0
>   %67 = select i1 %66, i64 -9223372036854775808, i64 4607182418800017408
>   store i64 %67, i64* %1
>   br label %138
16362,16364c12798,12802
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:68                                      ; preds = %57, %34
>   %69 = load i8* %aSign, align 1
>   %70 = call i64 @packFloat64(i8 zeroext %69, i32 0, i64 0)
>   store i64 %70, i64* %1
>   br label %138
16366,16389c12804,12844
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 8
<   %16 = load i32* %15, align 4
<   %17 = and i32 %16, 3
<   %18 = icmp eq i32 %17, 3
<   %19 = zext i1 %18 to i64
<   %20 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 0
<   %21 = load i32* %20, align 4
<   %22 = and i32 %8, -4095
<   %23 = icmp eq i32 %21, %22
<   br i1 %23, label %27, label %24, !prof !0
< 
< ; <label>:24                                      ; preds = %6
<   %25 = zext i1 %18 to i32
<   %26 = tail call zeroext i16 @__ldw_mmu(i32 %8, i32 %25)
<   br label %35
---
> ; <label>:71                                      ; preds = %25
>   store i64 1, i64* %lastBitMask, align 8
>   %72 = load i32* %aExp, align 4
>   %73 = sub nsw i32 1075, %72
>   %74 = load i64* %lastBitMask, align 8
>   %75 = zext i32 %73 to i64
>   %76 = shl i64 %74, %75
>   store i64 %76, i64* %lastBitMask, align 8
>   %77 = load i64* %lastBitMask, align 8
>   %78 = sub i64 %77, 1
>   store i64 %78, i64* %roundBitsMask, align 8
>   %79 = load i64* %2, align 8
>   store i64 %79, i64* %z, align 8
>   %80 = load %struct.float_status** %3, align 4
>   %81 = getelementptr inbounds %struct.float_status* %80, i32 0, i32 1
>   %82 = load i8* %81, align 1
>   store i8 %82, i8* %roundingMode, align 1
>   %83 = load i8* %roundingMode, align 1
>   %84 = sext i8 %83 to i32
>   %85 = icmp eq i32 %84, 0
>   br i1 %85, label %86, label %101
> 
> ; <label>:86                                      ; preds = %71
>   %87 = load i64* %lastBitMask, align 8
>   %88 = lshr i64 %87, 1
>   %89 = load i64* %z, align 8
>   %90 = add i64 %89, %88
>   store i64 %90, i64* %z, align 8
>   %91 = load i64* %z, align 8
>   %92 = load i64* %roundBitsMask, align 8
>   %93 = and i64 %91, %92
>   %94 = icmp eq i64 %93, 0
>   br i1 %94, label %95, label %100
> 
> ; <label>:95                                      ; preds = %86
>   %96 = load i64* %lastBitMask, align 8
>   %97 = xor i64 %96, -1
>   %98 = load i64* %z, align 8
>   %99 = and i64 %98, %97
>   store i64 %99, i64* %z, align 8
>   br label %100
16391,16400c12846,12847
< ; <label>:27                                      ; preds = %6
<   %28 = and i64 %7, 4294967295
<   %29 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 %19, i64 %13, i32 3
<   %30 = load i64* %29, align 8
<   %31 = add i64 %30, %28
<   %32 = inttoptr i64 %31 to i16*
<   %33 = load i16* %32, align 2
<   %34 = sext i16 %33 to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %28, i64 %31, i64 %34, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %35
---
> ; <label>:100                                     ; preds = %95, %86
>   br label %121
16402,16406c12849,12865
< ; <label>:35                                      ; preds = %27, %24
<   %res.0.in = phi i16 [ %26, %24 ], [ %33, %27 ]
<   %res.0 = sext i16 %res.0.in to i32
<   ret i32 %res.0
< }
---
> ; <label>:101                                     ; preds = %71
>   %102 = load i8* %roundingMode, align 1
>   %103 = sext i8 %102 to i32
>   %104 = icmp ne i32 %103, 3
>   br i1 %104, label %105, label %120
> 
> ; <label>:105                                     ; preds = %101
>   %106 = load i64* %z, align 8
>   %107 = call zeroext i8 @extractFloat64Sign(i64 %106)
>   %108 = zext i8 %107 to i32
>   %109 = load i8* %roundingMode, align 1
>   %110 = sext i8 %109 to i32
>   %111 = icmp eq i32 %110, 2
>   %112 = zext i1 %111 to i32
>   %113 = xor i32 %108, %112
>   %114 = icmp ne i32 %113, 0
>   br i1 %114, label %115, label %119
16408,16415c12867,12872
< define void @helper_boundl(i32 %a0, i32 %v) nounwind uwtable {
<   %1 = tail call fastcc i32 @ldl_data(i32 %a0)
<   %2 = add i32 %a0, 4
<   %3 = tail call fastcc i32 @ldl_data(i32 %2)
<   %4 = icmp sgt i32 %1, %v
<   %5 = icmp slt i32 %3, %v
<   %or.cond = or i1 %4, %5
<   br i1 %or.cond, label %6, label %7
---
> ; <label>:115                                     ; preds = %105
>   %116 = load i64* %roundBitsMask, align 8
>   %117 = load i64* %z, align 8
>   %118 = add i64 %117, %116
>   store i64 %118, i64* %z, align 8
>   br label %119
16417,16419c12874,12875
< ; <label>:6                                       ; preds = %0
<   tail call fastcc void @raise_exception(i32 5) noreturn
<   unreachable
---
> ; <label>:119                                     ; preds = %115, %105
>   br label %120
16421,16422c12877,12908
< ; <label>:7                                       ; preds = %0
<   ret void
---
> ; <label>:120                                     ; preds = %119, %101
>   br label %121
> 
> ; <label>:121                                     ; preds = %120, %100
>   %122 = load i64* %roundBitsMask, align 8
>   %123 = xor i64 %122, -1
>   %124 = load i64* %z, align 8
>   %125 = and i64 %124, %123
>   store i64 %125, i64* %z, align 8
>   %126 = load i64* %z, align 8
>   %127 = load i64* %2, align 8
>   %128 = icmp ne i64 %126, %127
>   br i1 %128, label %129, label %136
> 
> ; <label>:129                                     ; preds = %121
>   %130 = load %struct.float_status** %3, align 4
>   %131 = getelementptr inbounds %struct.float_status* %130, i32 0, i32 2
>   %132 = load i8* %131, align 1
>   %133 = sext i8 %132 to i32
>   %134 = or i32 %133, 32
>   %135 = trunc i32 %134 to i8
>   store i8 %135, i8* %131, align 1
>   br label %136
> 
> ; <label>:136                                     ; preds = %129, %121
>   %137 = load i64* %z, align 8
>   store i64 %137, i64* %1
>   br label %138
> 
> ; <label>:138                                     ; preds = %136, %68, %63, %58, %54, %32, %23, %18
>   %139 = load i64* %1
>   ret i64 %139
16425,16435c12911,12957
< define zeroext i8 @io_read_chkb_mmu(i64 %physaddr, i32 %addr, i8* %retaddr) nounwind uwtable inlinehint alwaysinline {
<   %ret.i.i = alloca i8, align 1
<   %label = alloca [64 x i8], align 16
<   %1 = call %struct.MemoryRegion* @iotlb_to_region(i64 %physaddr) nounwind
<   %2 = and i64 %physaddr, 4294963200
<   %3 = zext i32 %addr to i64
<   %4 = add i64 %3, %2
<   %5 = trunc i64 %4 to i32
<   %6 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %7 = icmp eq i32 %6, 0
<   br i1 %7, label %17, label %8
---
> define internal i64 @propagateFloat64NaN(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aIsQuietNaN = alloca i8, align 1
>   %aIsSignalingNaN = alloca i8, align 1
>   %bIsQuietNaN = alloca i8, align 1
>   %bIsSignalingNaN = alloca i8, align 1
>   %aIsLargerSignificand = alloca i8, align 1
>   %av = alloca i64, align 8
>   %bv = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = call i32 @float64_is_quiet_nan(i64 %5)
>   %7 = trunc i32 %6 to i8
>   store i8 %7, i8* %aIsQuietNaN, align 1
>   %8 = load i64* %2, align 8
>   %9 = call i32 @float64_is_signaling_nan(i64 %8)
>   %10 = trunc i32 %9 to i8
>   store i8 %10, i8* %aIsSignalingNaN, align 1
>   %11 = load i64* %3, align 8
>   %12 = call i32 @float64_is_quiet_nan(i64 %11)
>   %13 = trunc i32 %12 to i8
>   store i8 %13, i8* %bIsQuietNaN, align 1
>   %14 = load i64* %3, align 8
>   %15 = call i32 @float64_is_signaling_nan(i64 %14)
>   %16 = trunc i32 %15 to i8
>   store i8 %16, i8* %bIsSignalingNaN, align 1
>   %17 = load i64* %2, align 8
>   store i64 %17, i64* %av, align 8
>   %18 = load i64* %3, align 8
>   store i64 %18, i64* %bv, align 8
>   %19 = load i8* %aIsSignalingNaN, align 1
>   %20 = zext i8 %19 to i32
>   %21 = load i8* %bIsSignalingNaN, align 1
>   %22 = zext i8 %21 to i32
>   %23 = or i32 %20, %22
>   %24 = icmp ne i32 %23, 0
>   br i1 %24, label %25, label %27
> 
> ; <label>:25                                      ; preds = %0
>   %26 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %26)
>   br label %27
16437,16441c12959,12964
< ; <label>:8                                       ; preds = %0
<   %9 = and i64 %4, 4294967295
<   %10 = call i32 @s2e_is_mmio_symbolic_b(i64 %9) nounwind
<   %11 = icmp eq i32 %10, 0
<   br i1 %11, label %17, label %12
---
> ; <label>:27                                      ; preds = %25, %0
>   %28 = load %struct.float_status** %4, align 4
>   %29 = getelementptr inbounds %struct.float_status* %28, i32 0, i32 6
>   %30 = load i8* %29, align 1
>   %31 = icmp ne i8 %30, 0
>   br i1 %31, label %32, label %33
16443,16449c12966,12968
< ; <label>:12                                      ; preds = %8
<   %13 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 5
<   %16 = load i32* %15, align 4
<   call void @trace_port(i8* %13, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %5, i32 %16)
<   br label %17
---
> ; <label>:32                                      ; preds = %27
>   store i64 -2251799813685248, i64* %1
>   br label %68
16451,16469c12970,12976
< ; <label>:17                                      ; preds = %12, %8, %0
<   %isSymb.0 = phi i32 [ %10, %12 ], [ 0, %8 ], [ 0, %0 ]
<   %18 = ptrtoint i8* %retaddr to i64
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 68
<   store i64 %18, i64* %20, align 8
<   %21 = icmp ne %struct.MemoryRegion* %1, @io_mem_ram
<   %22 = icmp ne %struct.MemoryRegion* %1, @io_mem_rom
<   %or.cond = and i1 %21, %22
<   %23 = icmp ne %struct.MemoryRegion* %1, @io_mem_unassigned
<   %or.cond3 = and i1 %or.cond, %23
<   %24 = icmp ne %struct.MemoryRegion* %1, @io_mem_notdirty
<   %or.cond5 = and i1 %or.cond3, %24
<   %25 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not = xor i1 %or.cond5, true
<   %26 = load i32* @use_icount, align 4
<   %27 = icmp eq i32 %26, 0
<   %or.cond24 = or i1 %27, %or.cond5.not
<   br i1 %or.cond24, label %can_do_io.exit.thread, label %28
---
> ; <label>:33                                      ; preds = %27
>   %34 = load i64* %av, align 8
>   %35 = shl i64 %34, 1
>   %36 = load i64* %bv, align 8
>   %37 = shl i64 %36, 1
>   %38 = icmp ult i64 %35, %37
>   br i1 %38, label %39, label %40
16471,16475c12978,12980
< ; <label>:28                                      ; preds = %17
<   %29 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 66
<   %30 = load %struct.TranslationBlock** %29, align 8
<   %31 = icmp eq %struct.TranslationBlock* %30, null
<   br i1 %31, label %can_do_io.exit.thread, label %can_do_io.exit
---
> ; <label>:39                                      ; preds = %33
>   store i8 0, i8* %aIsLargerSignificand, align 1
>   br label %54
16477,16481c12982,12988
< can_do_io.exit:                                   ; preds = %28
<   %32 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 85
<   %33 = load i32* %32, align 4
<   %34 = icmp eq i32 %33, 0
<   br i1 %34, label %35, label %can_do_io.exit.thread
---
> ; <label>:40                                      ; preds = %33
>   %41 = load i64* %bv, align 8
>   %42 = shl i64 %41, 1
>   %43 = load i64* %av, align 8
>   %44 = shl i64 %43, 1
>   %45 = icmp ult i64 %42, %44
>   br i1 %45, label %46, label %47
16483,16485c12990,12992
< ; <label>:35                                      ; preds = %can_do_io.exit
<   call void @cpu_io_recompile(%struct.CPUX86State* %25, i8* %retaddr) noreturn nounwind
<   unreachable
---
> ; <label>:46                                      ; preds = %40
>   store i8 1, i8* %aIsLargerSignificand, align 1
>   br label %53
16487,16492c12994,13001
< can_do_io.exit.thread:                            ; preds = %can_do_io.exit, %28, %17
<   %36 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 69
<   store i32 %addr, i32* %36, align 4
<   %37 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %1, i32 0) nounwind
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %57, label %39
---
> ; <label>:47                                      ; preds = %40
>   %48 = load i64* %av, align 8
>   %49 = load i64* %bv, align 8
>   %50 = icmp ult i64 %48, %49
>   %51 = select i1 %50, i32 1, i32 0
>   %52 = trunc i32 %51 to i8
>   store i8 %52, i8* %aIsLargerSignificand, align 1
>   br label %53
16494,16497c13003,13004
< ; <label>:39                                      ; preds = %can_do_io.exit.thread
<   %40 = call i64 @s2e_notdirty_mem_write(i64 %physaddr) nounwind
<   %41 = icmp eq i32 %isSymb.0, 0
<   br i1 %41, label %54, label %42
---
> ; <label>:53                                      ; preds = %47, %46
>   br label %54
16499,16505c13006,13014
< ; <label>:42                                      ; preds = %39
<   %43 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %44 = inttoptr i64 %40 to i8*
<   %45 = load i8* %44, align 1
<   %46 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %47 = icmp eq i32 %46, 0
<   br i1 %47, label %io_read_chk_symb_b.exit, label %48
---
> ; <label>:54                                      ; preds = %53, %39
>   %55 = load i8* %aIsQuietNaN, align 1
>   %56 = load i8* %aIsSignalingNaN, align 1
>   %57 = load i8* %bIsQuietNaN, align 1
>   %58 = load i8* %bIsSignalingNaN, align 1
>   %59 = load i8* %aIsLargerSignificand, align 1
>   %60 = call i32 @pickNaN(i8 zeroext %55, i8 zeroext %56, i8 zeroext %57, i8 zeroext %58, i8 zeroext %59)
>   %61 = icmp ne i32 %60, 0
>   br i1 %61, label %62, label %65
16507,16516c13016,13020
< ; <label>:48                                      ; preds = %42
<   %49 = and i64 %4, 4294967295
<   %50 = call i32 @s2e_is_mmio_symbolic_b(i64 %49) nounwind
<   %51 = icmp eq i32 %50, 0
<   br i1 %51, label %io_read_chk_symb_b.exit, label %52
< 
< ; <label>:52                                      ; preds = %48
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i, i32 1, i8* %43) nounwind
<   %53 = load i8* %ret.i.i, align 1
<   br label %io_read_chk_symb_b.exit
---
> ; <label>:62                                      ; preds = %54
>   %63 = load i64* %3, align 8
>   %64 = call i64 @float64_maybe_silence_nan(i64 %63)
>   store i64 %64, i64* %1
>   br label %68
16518,16521c13022,13026
< ; <label>:54                                      ; preds = %39
<   %55 = inttoptr i64 %40 to i8*
<   %56 = load i8* %55, align 1
<   br label %io_read_chk_symb_b.exit
---
> ; <label>:65                                      ; preds = %54
>   %66 = load i64* %2, align 8
>   %67 = call i64 @float64_maybe_silence_nan(i64 %66)
>   store i64 %67, i64* %1
>   br label %68
16523,16529c13028,13030
< ; <label>:57                                      ; preds = %can_do_io.exit.thread
<   %58 = call zeroext i8 @io_readb_mmu(i64 %physaddr, i32 %addr, i8* %retaddr) nounwind
<   br label %io_read_chk_symb_b.exit
< 
< io_read_chk_symb_b.exit:                          ; preds = %57, %54, %52, %48, %42
<   %.0 = phi i8 [ %56, %54 ], [ %58, %57 ], [ %45, %48 ], [ %45, %42 ], [ %53, %52 ]
<   ret i8 %.0
---
> ; <label>:68                                      ; preds = %65, %62, %32
>   %69 = load i64* %1
>   ret i64 %69
16532c13033,13102
< declare %struct.MemoryRegion* @iotlb_to_region(i64)
---
> define internal i64 @float64_trunc_to_int(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %oldmode = alloca i32, align 4
>   %res = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load %struct.float_status** %2, align 4
>   %4 = getelementptr inbounds %struct.float_status* %3, i32 0, i32 1
>   %5 = load i8* %4, align 1
>   %6 = sext i8 %5 to i32
>   store i32 %6, i32* %oldmode, align 4
>   %7 = load %struct.float_status** %2, align 4
>   %8 = getelementptr inbounds %struct.float_status* %7, i32 0, i32 1
>   store i8 3, i8* %8, align 1
>   %9 = load i64* %1, align 8
>   %10 = load %struct.float_status** %2, align 4
>   %11 = call i64 @float64_round_to_int(i64 %9, %struct.float_status* %10)
>   store i64 %11, i64* %res, align 8
>   %12 = load i32* %oldmode, align 4
>   %13 = trunc i32 %12 to i8
>   %14 = load %struct.float_status** %2, align 4
>   %15 = getelementptr inbounds %struct.float_status* %14, i32 0, i32 1
>   store i8 %13, i8* %15, align 1
>   %16 = load i64* %res, align 8
>   ret i64 %16
> }
> 
> define internal i64 @addFloat64Sigs(i64 %a, i64 %b, i8 zeroext %zSign, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i8, align 1
>   %5 = alloca %struct.float_status*, align 4
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %zSig = alloca i64, align 8
>   %expDiff = alloca i32, align 4
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store i8 %zSign, i8* %4, align 1
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load i64* %2, align 8
>   %7 = call i64 @extractFloat64Frac(i64 %6)
>   store i64 %7, i64* %aSig, align 8
>   %8 = load i64* %2, align 8
>   %9 = call i32 @extractFloat64Exp(i64 %8)
>   store i32 %9, i32* %aExp, align 4
>   %10 = load i64* %3, align 8
>   %11 = call i64 @extractFloat64Frac(i64 %10)
>   store i64 %11, i64* %bSig, align 8
>   %12 = load i64* %3, align 8
>   %13 = call i32 @extractFloat64Exp(i64 %12)
>   store i32 %13, i32* %bExp, align 4
>   %14 = load i32* %aExp, align 4
>   %15 = load i32* %bExp, align 4
>   %16 = sub nsw i32 %14, %15
>   store i32 %16, i32* %expDiff, align 4
>   %17 = load i64* %aSig, align 8
>   %18 = shl i64 %17, 9
>   store i64 %18, i64* %aSig, align 8
>   %19 = load i64* %bSig, align 8
>   %20 = shl i64 %19, 9
>   store i64 %20, i64* %bSig, align 8
>   %21 = load i32* %expDiff, align 4
>   %22 = icmp slt i32 0, %21
>   br i1 %22, label %23, label %49
16534c13104,13120
< declare i32 @s2e_is_mmio_symbolic_b(i64)
---
> ; <label>:23                                      ; preds = %0
>   %24 = load i32* %aExp, align 4
>   %25 = icmp eq i32 %24, 2047
>   br i1 %25, label %26, label %36
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load i64* %aSig, align 8
>   %28 = icmp ne i64 %27, 0
>   br i1 %28, label %29, label %34
> 
> ; <label>:29                                      ; preds = %26
>   %30 = load i64* %2, align 8
>   %31 = load i64* %3, align 8
>   %32 = load %struct.float_status** %5, align 4
>   %33 = call i64 @propagateFloat64NaN(i64 %30, i64 %31, %struct.float_status* %32)
>   store i64 %33, i64* %1
>   br label %151
16536c13122,13125
< declare void @cpu_io_recompile(%struct.CPUX86State*, i8*) noreturn
---
> ; <label>:34                                      ; preds = %26
>   %35 = load i64* %2, align 8
>   store i64 %35, i64* %1
>   br label %151
16538c13127,13130
< declare i32 @s2e_ismemfunc(%struct.MemoryRegion*, i32)
---
> ; <label>:36                                      ; preds = %23
>   %37 = load i32* %bExp, align 4
>   %38 = icmp eq i32 %37, 0
>   br i1 %38, label %39, label %42
16540c13132,13136
< declare i64 @s2e_notdirty_mem_write(i64)
---
> ; <label>:39                                      ; preds = %36
>   %40 = load i32* %expDiff, align 4
>   %41 = add nsw i32 %40, -1
>   store i32 %41, i32* %expDiff, align 4
>   br label %45
16542c13138,13142
< declare zeroext i8 @io_readb_mmu(i64, i32, i8*)
---
> ; <label>:42                                      ; preds = %36
>   %43 = load i64* %bSig, align 8
>   %44 = or i64 %43, 2305843009213693952
>   store i64 %44, i64* %bSig, align 8
>   br label %45
16544,16550c13144,13173
< define zeroext i8 @__ldb_mmu(i32 %addr, i32 %mmu_idx) nounwind uwtable {
<   %ret.i.i.i = alloca i8, align 1
<   %label.i = alloca [64 x i8], align 16
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %addr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:45                                      ; preds = %42, %39
>   %46 = load i64* %bSig, align 8
>   %47 = load i32* %expDiff, align 4
>   call void @shift64RightJamming(i64 %46, i32 %47, i64* %bSig)
>   %48 = load i32* %aExp, align 4
>   store i32 %48, i32* %zExp, align 4
>   br label %127
> 
> ; <label>:49                                      ; preds = %0
>   %50 = load i32* %expDiff, align 4
>   %51 = icmp slt i32 %50, 0
>   br i1 %51, label %52, label %80
> 
> ; <label>:52                                      ; preds = %49
>   %53 = load i32* %bExp, align 4
>   %54 = icmp eq i32 %53, 2047
>   br i1 %54, label %55, label %66
> 
> ; <label>:55                                      ; preds = %52
>   %56 = load i64* %bSig, align 8
>   %57 = icmp ne i64 %56, 0
>   br i1 %57, label %58, label %63
> 
> ; <label>:58                                      ; preds = %55
>   %59 = load i64* %2, align 8
>   %60 = load i64* %3, align 8
>   %61 = load %struct.float_status** %5, align 4
>   %62 = call i64 @propagateFloat64NaN(i64 %59, i64 %60, %struct.float_status* %61)
>   store i64 %62, i64* %1
>   br label %151
16552,16554c13175,13179
< ; <label>:4                                       ; preds = %0
<   %5 = call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:63                                      ; preds = %55
>   %64 = load i8* %4, align 1
>   %65 = call i64 @packFloat64(i8 zeroext %64, i32 2047, i64 0)
>   store i64 %65, i64* %1
>   br label %151
16556,16571c13181,13184
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = sext i32 %mmu_idx to i64
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %17 = load i32* %16, align 4
<   %18 = and i32 %8, -4096
<   %19 = and i32 %17, -4088
<   %20 = icmp eq i32 %18, %19
<   br i1 %20, label %._crit_edge, label %.lr.ph, !prof !0
---
> ; <label>:66                                      ; preds = %52
>   %67 = load i32* %aExp, align 4
>   %68 = icmp eq i32 %67, 0
>   br i1 %68, label %69, label %72
16573,16576c13186,13190
< .lr.ph:                                           ; preds = %6
<   %21 = trunc i64 %11 to i32
<   %22 = shl i32 %21, 7
<   br label %90
---
> ; <label>:69                                      ; preds = %66
>   %70 = load i32* %expDiff, align 4
>   %71 = add nsw i32 %70, 1
>   store i32 %71, i32* %expDiff, align 4
>   br label %75
16578,16583c13192,13196
< ._crit_edge:                                      ; preds = %90, %6
<   %.lcssa29 = phi i32 [ %17, %6 ], [ %94, %90 ]
<   %.lcssa28 = phi %struct.CPUX86State* [ %15, %6 ], [ %92, %90 ]
<   %23 = and i32 %.lcssa29, 4095
<   %24 = icmp eq i32 %23, 0
<   br i1 %24, label %82, label %25, !prof !0
---
> ; <label>:72                                      ; preds = %66
>   %73 = load i64* %aSig, align 8
>   %74 = or i64 %73, 2305843009213693952
>   store i64 %74, i64* %aSig, align 8
>   br label %75
16585,16601c13198,13210
< ; <label>:25                                      ; preds = %._crit_edge
<   %26 = getelementptr inbounds %struct.CPUX86State* %.lcssa28, i64 0, i32 75, i64 %14, i64 %13
<   %27 = load i64* %26, align 8
<   %28 = getelementptr inbounds [64 x i8]* %label.i, i64 0, i64 0
<   %29 = call %struct.MemoryRegion* @iotlb_to_region(i64 %27) nounwind
<   %30 = and i64 %27, 4294963200
<   %31 = add i64 %30, %7
<   %32 = trunc i64 %31 to i32
<   %33 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %34 = icmp eq i32 %33, 0
<   br i1 %34, label %43, label %35
< 
< ; <label>:35                                      ; preds = %25
<   %36 = and i64 %31, 4294967295
<   %37 = call i32 @s2e_is_mmio_symbolic_b(i64 %36) nounwind
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %43, label %39
---
> ; <label>:75                                      ; preds = %72, %69
>   %76 = load i64* %aSig, align 8
>   %77 = load i32* %expDiff, align 4
>   %78 = sub nsw i32 0, %77
>   call void @shift64RightJamming(i64 %76, i32 %78, i64* %aSig)
>   %79 = load i32* %bExp, align 4
>   store i32 %79, i32* %zExp, align 4
>   br label %126
> 
> ; <label>:80                                      ; preds = %49
>   %81 = load i32* %aExp, align 4
>   %82 = icmp eq i32 %81, 2047
>   br i1 %82, label %83, label %95
16603,16608c13212,13217
< ; <label>:39                                      ; preds = %35
<   %40 = load %struct.CPUX86State** @env, align 8
<   %41 = getelementptr inbounds %struct.CPUX86State* %40, i64 0, i32 5
<   %42 = load i32* %41, align 4
<   call void @trace_port(i8* %28, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %32, i32 %42) nounwind
<   br label %43
---
> ; <label>:83                                      ; preds = %80
>   %84 = load i64* %aSig, align 8
>   %85 = load i64* %bSig, align 8
>   %86 = or i64 %84, %85
>   %87 = icmp ne i64 %86, 0
>   br i1 %87, label %88, label %93
16610,16627c13219,13225
< ; <label>:43                                      ; preds = %39, %35, %25
<   %isSymb.0.i = phi i32 [ %37, %39 ], [ 0, %35 ], [ 0, %25 ]
<   %44 = load %struct.CPUX86State** @env, align 8
<   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 68
<   store i64 0, i64* %45, align 8
<   %46 = icmp ne %struct.MemoryRegion* %29, @io_mem_ram
<   %47 = icmp ne %struct.MemoryRegion* %29, @io_mem_rom
<   %or.cond.i = and i1 %46, %47
<   %48 = icmp ne %struct.MemoryRegion* %29, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %48
<   %49 = icmp ne %struct.MemoryRegion* %29, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %49
<   %50 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %51 = load i32* @use_icount, align 4
<   %52 = icmp eq i32 %51, 0
<   %or.cond24.i = or i1 %52, %or.cond5.not.i
<   br i1 %or.cond24.i, label %can_do_io.exit.thread.i, label %53
---
> ; <label>:88                                      ; preds = %83
>   %89 = load i64* %2, align 8
>   %90 = load i64* %3, align 8
>   %91 = load %struct.float_status** %5, align 4
>   %92 = call i64 @propagateFloat64NaN(i64 %89, i64 %90, %struct.float_status* %91)
>   store i64 %92, i64* %1
>   br label %151
16629,16639c13227,13230
< ; <label>:53                                      ; preds = %43
<   %54 = getelementptr inbounds %struct.CPUX86State* %50, i64 0, i32 66
<   %55 = load %struct.TranslationBlock** %54, align 8
<   %56 = icmp eq %struct.TranslationBlock* %55, null
<   br i1 %56, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
< 
< can_do_io.exit.i:                                 ; preds = %53
<   %57 = getelementptr inbounds %struct.CPUX86State* %50, i64 0, i32 85
<   %58 = load i32* %57, align 4
<   %59 = icmp eq i32 %58, 0
<   br i1 %59, label %60, label %can_do_io.exit.thread.i
---
> ; <label>:93                                      ; preds = %83
>   %94 = load i64* %2, align 8
>   store i64 %94, i64* %1
>   br label %151
16641,16643c13232,13260
< ; <label>:60                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %50, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:95                                      ; preds = %80
>   %96 = load i32* %aExp, align 4
>   %97 = icmp eq i32 %96, 0
>   br i1 %97, label %98, label %120
> 
> ; <label>:98                                      ; preds = %95
>   %99 = load %struct.float_status** %5, align 4
>   %100 = getelementptr inbounds %struct.float_status* %99, i32 0, i32 4
>   %101 = load i8* %100, align 1
>   %102 = icmp ne i8 %101, 0
>   br i1 %102, label %103, label %113
> 
> ; <label>:103                                     ; preds = %98
>   %104 = load i64* %aSig, align 8
>   %105 = load i64* %bSig, align 8
>   %106 = or i64 %104, %105
>   %107 = icmp ne i64 %106, 0
>   br i1 %107, label %108, label %110
> 
> ; <label>:108                                     ; preds = %103
>   %109 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext -128, %struct.float_status* %109)
>   br label %110
> 
> ; <label>:110                                     ; preds = %108, %103
>   %111 = load i8* %4, align 1
>   %112 = call i64 @packFloat64(i8 zeroext %111, i32 0, i64 0)
>   store i64 %112, i64* %1
>   br label %151
16645,16650c13262,13270
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %53, %43
<   %61 = getelementptr inbounds %struct.CPUX86State* %50, i64 0, i32 69
<   store i32 %8, i32* %61, align 4
<   %62 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %29, i32 0) nounwind
<   %63 = icmp eq i32 %62, 0
<   br i1 %63, label %77, label %64
---
> ; <label>:113                                     ; preds = %98
>   %114 = load i8* %4, align 1
>   %115 = load i64* %aSig, align 8
>   %116 = load i64* %bSig, align 8
>   %117 = add i64 %115, %116
>   %118 = lshr i64 %117, 9
>   %119 = call i64 @packFloat64(i8 zeroext %114, i32 0, i64 %118)
>   store i64 %119, i64* %1
>   br label %151
16652,16660c13272,13280
< ; <label>:64                                      ; preds = %can_do_io.exit.thread.i
<   %65 = call i64 @s2e_notdirty_mem_write(i64 %27) nounwind
<   %66 = icmp eq i32 %isSymb.0.i, 0
<   %67 = inttoptr i64 %65 to i8*
<   %68 = load i8* %67, align 1
<   %69 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %70 = icmp eq i32 %69, 0
<   %or.cond = or i1 %66, %70
<   br i1 %or.cond, label %io_read_chkb_mmu.exit, label %71
---
> ; <label>:120                                     ; preds = %95
>   %121 = load i64* %aSig, align 8
>   %122 = add i64 4611686018427387904, %121
>   %123 = load i64* %bSig, align 8
>   %124 = add i64 %122, %123
>   store i64 %124, i64* %zSig, align 8
>   %125 = load i32* %aExp, align 4
>   store i32 %125, i32* %zExp, align 4
>   br label %145
16662,16666c13282,13283
< ; <label>:71                                      ; preds = %64
<   %72 = and i64 %31, 4294967295
<   %73 = call i32 @s2e_is_mmio_symbolic_b(i64 %72) nounwind
<   %74 = icmp eq i32 %73, 0
<   br i1 %74, label %io_read_chkb_mmu.exit, label %75
---
> ; <label>:126                                     ; preds = %75
>   br label %127
16668,16683c13285,13309
< ; <label>:75                                      ; preds = %71
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %28) nounwind
<   %76 = load i8* %ret.i.i.i, align 1
<   br label %io_read_chkb_mmu.exit
< 
< ; <label>:77                                      ; preds = %can_do_io.exit.thread.i
<   %78 = call zeroext i8 @io_readb_mmu(i64 %27, i32 %8, i8* null) nounwind
<   br label %io_read_chkb_mmu.exit
< 
< io_read_chkb_mmu.exit:                            ; preds = %77, %75, %71, %64
<   %.0.i = phi i8 [ %78, %77 ], [ %68, %71 ], [ %76, %75 ], [ %68, %64 ]
<   %79 = and i64 %7, 4294967295
<   %80 = add i64 %27, %79
<   %81 = zext i8 %.0.i to i64
<   call void @tcg_llvm_trace_memory_access(i64 %79, i64 %80, i64 %81, i32 8, i8 zeroext 0, i8 zeroext 1) nounwind
<   br label %97
---
> ; <label>:127                                     ; preds = %126, %45
>   %128 = load i64* %aSig, align 8
>   %129 = or i64 %128, 2305843009213693952
>   store i64 %129, i64* %aSig, align 8
>   %130 = load i64* %aSig, align 8
>   %131 = load i64* %bSig, align 8
>   %132 = add i64 %130, %131
>   %133 = shl i64 %132, 1
>   store i64 %133, i64* %zSig, align 8
>   %134 = load i32* %zExp, align 4
>   %135 = add nsw i32 %134, -1
>   store i32 %135, i32* %zExp, align 4
>   %136 = load i64* %zSig, align 8
>   %137 = icmp slt i64 %136, 0
>   br i1 %137, label %138, label %144
> 
> ; <label>:138                                     ; preds = %127
>   %139 = load i64* %aSig, align 8
>   %140 = load i64* %bSig, align 8
>   %141 = add i64 %139, %140
>   store i64 %141, i64* %zSig, align 8
>   %142 = load i32* %zExp, align 4
>   %143 = add nsw i32 %142, 1
>   store i32 %143, i32* %zExp, align 4
>   br label %144
16685,16694c13311,13321
< ; <label>:82                                      ; preds = %._crit_edge
<   %83 = getelementptr inbounds %struct.CPUX86State* %.lcssa28, i64 0, i32 73, i64 %14, i64 %13, i32 3
<   %84 = load i64* %83, align 8
<   %85 = and i64 %7, 4294967295
<   %86 = add i64 %84, %85
<   %87 = inttoptr i64 %86 to i8*
<   %88 = load i8* %87, align 1
<   %89 = zext i8 %88 to i64
<   call void @tcg_llvm_trace_memory_access(i64 %85, i64 %86, i64 %89, i32 8, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %97
---
> ; <label>:144                                     ; preds = %138, %127
>   br label %145
> 
> ; <label>:145                                     ; preds = %144, %120
>   %146 = load i8* %4, align 1
>   %147 = load i32* %zExp, align 4
>   %148 = load i64* %zSig, align 8
>   %149 = load %struct.float_status** %5, align 4
>   %150 = call i64 @roundAndPackFloat64(i8 zeroext %146, i32 %147, i64 %148, %struct.float_status* %149)
>   store i64 %150, i64* %1
>   br label %151
16696,16708c13323,13325
< ; <label>:90                                      ; preds = %90, %.lr.ph
<   %91 = phi %struct.CPUX86State* [ %15, %.lr.ph ], [ %92, %90 ]
<   call void @tlb_fill(%struct.CPUX86State* %91, i32 %8, i32 %22, i32 0, i32 %mmu_idx, i8* null)
<   %92 = load %struct.CPUX86State** @env, align 8
<   %93 = getelementptr inbounds %struct.CPUX86State* %92, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %94 = load i32* %93, align 4
<   %95 = and i32 %94, -4088
<   %96 = icmp eq i32 %18, %95
<   br i1 %96, label %._crit_edge, label %90, !prof !0
< 
< ; <label>:97                                      ; preds = %82, %io_read_chkb_mmu.exit
<   %res.0 = phi i8 [ %.0.i, %io_read_chkb_mmu.exit ], [ %88, %82 ]
<   ret i8 %res.0
---
> ; <label>:151                                     ; preds = %145, %113, %110, %93, %88, %63, %58, %34, %29
>   %152 = load i64* %1
>   ret i64 %152
16711c13328,13369
< declare i64 @tcg_llvm_fork_and_concretize(i64, i64, i64)
---
> define internal i64 @subFloat64Sigs(i64 %a, i64 %b, i8 zeroext %zSign, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i8, align 1
>   %5 = alloca %struct.float_status*, align 4
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %zSig = alloca i64, align 8
>   %expDiff = alloca i32, align 4
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store i8 %zSign, i8* %4, align 1
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load i64* %2, align 8
>   %7 = call i64 @extractFloat64Frac(i64 %6)
>   store i64 %7, i64* %aSig, align 8
>   %8 = load i64* %2, align 8
>   %9 = call i32 @extractFloat64Exp(i64 %8)
>   store i32 %9, i32* %aExp, align 4
>   %10 = load i64* %3, align 8
>   %11 = call i64 @extractFloat64Frac(i64 %10)
>   store i64 %11, i64* %bSig, align 8
>   %12 = load i64* %3, align 8
>   %13 = call i32 @extractFloat64Exp(i64 %12)
>   store i32 %13, i32* %bExp, align 4
>   %14 = load i32* %aExp, align 4
>   %15 = load i32* %bExp, align 4
>   %16 = sub nsw i32 %14, %15
>   store i32 %16, i32* %expDiff, align 4
>   %17 = load i64* %aSig, align 8
>   %18 = shl i64 %17, 10
>   store i64 %18, i64* %aSig, align 8
>   %19 = load i64* %bSig, align 8
>   %20 = shl i64 %19, 10
>   store i64 %20, i64* %bSig, align 8
>   %21 = load i32* %expDiff, align 4
>   %22 = icmp slt i32 0, %21
>   br i1 %22, label %23, label %24
16713c13371,13372
< declare void @tcg_llvm_trace_memory_access(i64, i64, i64, i32, i8 zeroext, i8 zeroext)
---
> ; <label>:23                                      ; preds = %0
>   br label %107
16715,16723c13374,13377
< define void @tlb_fill(%struct.CPUX86State* %env1, i32 %addr, i32 %page_addr, i32 %is_write, i32 %mmu_idx, i8* %retaddr) nounwind uwtable {
<   %1 = load %struct.S2E** @g_s2e, align 8
<   %2 = load %struct.S2EExecutionState** @g_s2e_state, align 8
<   %3 = zext i32 %addr to i64
<   tail call void @s2e_on_tlb_miss(%struct.S2E* %1, %struct.S2EExecutionState* %2, i64 %3, i32 %is_write) nounwind
<   %4 = load %struct.CPUX86State** @env, align 8
<   %5 = tail call i32 @cpu_x86_handle_mmu_fault(%struct.CPUX86State* %4, i32 %page_addr, i32 %is_write, i32 %mmu_idx) nounwind
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %39, label %7
---
> ; <label>:24                                      ; preds = %0
>   %25 = load i32* %expDiff, align 4
>   %26 = icmp slt i32 %25, 0
>   br i1 %26, label %27, label %28
16725,16730c13379,13380
< ; <label>:7                                       ; preds = %0
<   %8 = load %struct.CPUX86State** @env, align 8
<   %9 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 92
<   %10 = load i32* %9, align 4
<   %11 = icmp eq i32 %10, 14
<   br i1 %11, label %12, label %23
---
> ; <label>:27                                      ; preds = %24
>   br label %66
16732,16737c13382,13400
< ; <label>:12                                      ; preds = %7
<   %13 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 46
<   %14 = load i32* %13, align 4
<   %15 = and i32 %14, 16384
<   %16 = icmp eq i32 %15, 0
<   br i1 %16, label %21, label %17
---
> ; <label>:28                                      ; preds = %24
>   %29 = load i32* %aExp, align 4
>   %30 = icmp eq i32 %29, 2047
>   br i1 %30, label %31, label %43
> 
> ; <label>:31                                      ; preds = %28
>   %32 = load i64* %aSig, align 8
>   %33 = load i64* %bSig, align 8
>   %34 = or i64 %32, %33
>   %35 = icmp ne i64 %34, 0
>   br i1 %35, label %36, label %41
> 
> ; <label>:36                                      ; preds = %31
>   %37 = load i64* %2, align 8
>   %38 = load i64* %3, align 8
>   %39 = load %struct.float_status** %5, align 4
>   %40 = call i64 @propagateFloat64NaN(i64 %37, i64 %38, %struct.float_status* %39)
>   store i64 %40, i64* %1
>   br label %147
16739,16744c13402,13406
< ; <label>:17                                      ; preds = %12
<   %18 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 39
<   %19 = load i64* %18, align 8
<   %20 = add i64 %19, 128
<   tail call void @stq_phys(i64 %20, i64 %3) nounwind
<   br label %23
---
> ; <label>:41                                      ; preds = %31
>   %42 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %42)
>   store i64 -2251799813685248, i64* %1
>   br label %147
16746,16749c13408,13411
< ; <label>:21                                      ; preds = %12
<   %22 = getelementptr inbounds %struct.CPUX86State* %8, i64 0, i32 15, i64 2
<   store i32 %addr, i32* %22, align 4
<   br label %23
---
> ; <label>:43                                      ; preds = %28
>   %44 = load i32* %aExp, align 4
>   %45 = icmp eq i32 %44, 0
>   br i1 %45, label %46, label %47
16751,16753c13413,13416
< ; <label>:23                                      ; preds = %21, %17, %7
<   %24 = icmp eq i8* %retaddr, null
<   br i1 %24, label %31, label %25
---
> ; <label>:46                                      ; preds = %43
>   store i32 1, i32* %aExp, align 4
>   store i32 1, i32* %bExp, align 4
>   br label %47
16755,16759c13418,13422
< ; <label>:25                                      ; preds = %23
<   %26 = ptrtoint i8* %retaddr to i64
<   %27 = tail call %struct.TranslationBlock* @tb_find_pc(i64 %26) nounwind
<   %28 = icmp eq %struct.TranslationBlock* %27, null
<   br i1 %28, label %31, label %29
---
> ; <label>:47                                      ; preds = %46, %43
>   %48 = load i64* %bSig, align 8
>   %49 = load i64* %aSig, align 8
>   %50 = icmp ult i64 %48, %49
>   br i1 %50, label %51, label %52
16761,16763c13424,13425
< ; <label>:29                                      ; preds = %25
<   %30 = tail call i32 @cpu_restore_state(%struct.TranslationBlock* %27, %struct.CPUX86State* %env1, i64 %26) nounwind
<   br label %31
---
> ; <label>:51                                      ; preds = %47
>   br label %134
16765,16775c13427,13446
< ; <label>:31                                      ; preds = %29, %25, %23
<   %32 = load %struct.S2E** @g_s2e, align 8
<   %33 = load %struct.S2EExecutionState** @g_s2e_state, align 8
<   tail call void @s2e_on_page_fault(%struct.S2E* %32, %struct.S2EExecutionState* %33, i64 %3, i32 %is_write) nounwind
<   %34 = load %struct.CPUX86State** @env, align 8
<   %35 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 92
<   %36 = load i32* %35, align 4
<   %37 = getelementptr inbounds %struct.CPUX86State* %34, i64 0, i32 55
<   %38 = load i32* %37, align 4
<   tail call fastcc void @raise_exception_err(i32 %36, i32 %38) noreturn
<   unreachable
---
> ; <label>:52                                      ; preds = %47
>   %53 = load i64* %aSig, align 8
>   %54 = load i64* %bSig, align 8
>   %55 = icmp ult i64 %53, %54
>   br i1 %55, label %56, label %57
> 
> ; <label>:56                                      ; preds = %52
>   br label %98
> 
> ; <label>:57                                      ; preds = %52
>   %58 = load %struct.float_status** %5, align 4
>   %59 = getelementptr inbounds %struct.float_status* %58, i32 0, i32 1
>   %60 = load i8* %59, align 1
>   %61 = sext i8 %60 to i32
>   %62 = icmp eq i32 %61, 1
>   %63 = zext i1 %62 to i32
>   %64 = trunc i32 %63 to i8
>   %65 = call i64 @packFloat64(i8 zeroext %64, i32 0, i64 0)
>   store i64 %65, i64* %1
>   br label %147
16777,16779c13448,13456
< ; <label>:39                                      ; preds = %0
<   ret void
< }
---
> ; <label>:66                                      ; preds = %27
>   %67 = load i32* %bExp, align 4
>   %68 = icmp eq i32 %67, 2047
>   br i1 %68, label %69, label %83
> 
> ; <label>:69                                      ; preds = %66
>   %70 = load i64* %bSig, align 8
>   %71 = icmp ne i64 %70, 0
>   br i1 %71, label %72, label %77
16781,16802c13458,13464
< define void @io_write_chkb_mmu(i64 %physaddr, i8 zeroext %val, i32 %addr, i8* %retaddr) nounwind uwtable inlinehint alwaysinline {
<   %1 = alloca i8, align 1
<   %2 = alloca i32, align 4
<   store i8 %val, i8* %1, align 1
<   store i32 %addr, i32* %2, align 4
<   %3 = call %struct.MemoryRegion* @iotlb_to_region(i64 %physaddr) nounwind
<   %4 = and i64 %physaddr, -4096
<   %5 = zext i32 %addr to i64
<   %6 = add i64 %5, %4
<   %7 = icmp ne %struct.MemoryRegion* %3, @io_mem_ram
<   %8 = icmp ne %struct.MemoryRegion* %3, @io_mem_rom
<   %or.cond = and i1 %7, %8
<   %9 = icmp ne %struct.MemoryRegion* %3, @io_mem_unassigned
<   %or.cond3 = and i1 %or.cond, %9
<   %10 = icmp ne %struct.MemoryRegion* %3, @io_mem_notdirty
<   %or.cond5 = and i1 %or.cond3, %10
<   %11 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not = xor i1 %or.cond5, true
<   %12 = load i32* @use_icount, align 4
<   %13 = icmp eq i32 %12, 0
<   %or.cond17 = or i1 %13, %or.cond5.not
<   br i1 %or.cond17, label %can_do_io.exit.thread, label %14
---
> ; <label>:72                                      ; preds = %69
>   %73 = load i64* %2, align 8
>   %74 = load i64* %3, align 8
>   %75 = load %struct.float_status** %5, align 4
>   %76 = call i64 @propagateFloat64NaN(i64 %73, i64 %74, %struct.float_status* %75)
>   store i64 %76, i64* %1
>   br label %147
16804,16808c13466,13473
< ; <label>:14                                      ; preds = %0
<   %15 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 66
<   %16 = load %struct.TranslationBlock** %15, align 8
<   %17 = icmp eq %struct.TranslationBlock* %16, null
<   br i1 %17, label %can_do_io.exit.thread, label %can_do_io.exit
---
> ; <label>:77                                      ; preds = %69
>   %78 = load i8* %4, align 1
>   %79 = zext i8 %78 to i32
>   %80 = xor i32 %79, 1
>   %81 = trunc i32 %80 to i8
>   %82 = call i64 @packFloat64(i8 zeroext %81, i32 2047, i64 0)
>   store i64 %82, i64* %1
>   br label %147
16810,16814c13475,13532
< can_do_io.exit:                                   ; preds = %14
<   %18 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 85
<   %19 = load i32* %18, align 4
<   %20 = icmp eq i32 %19, 0
<   br i1 %20, label %21, label %can_do_io.exit.thread
---
> ; <label>:83                                      ; preds = %66
>   %84 = load i32* %aExp, align 4
>   %85 = icmp eq i32 %84, 0
>   br i1 %85, label %86, label %89
> 
> ; <label>:86                                      ; preds = %83
>   %87 = load i32* %expDiff, align 4
>   %88 = add nsw i32 %87, 1
>   store i32 %88, i32* %expDiff, align 4
>   br label %92
> 
> ; <label>:89                                      ; preds = %83
>   %90 = load i64* %aSig, align 8
>   %91 = or i64 %90, 4611686018427387904
>   store i64 %91, i64* %aSig, align 8
>   br label %92
> 
> ; <label>:92                                      ; preds = %89, %86
>   %93 = load i64* %aSig, align 8
>   %94 = load i32* %expDiff, align 4
>   %95 = sub nsw i32 0, %94
>   call void @shift64RightJamming(i64 %93, i32 %95, i64* %aSig)
>   %96 = load i64* %bSig, align 8
>   %97 = or i64 %96, 4611686018427387904
>   store i64 %97, i64* %bSig, align 8
>   br label %98
> 
> ; <label>:98                                      ; preds = %92, %56
>   %99 = load i64* %bSig, align 8
>   %100 = load i64* %aSig, align 8
>   %101 = sub i64 %99, %100
>   store i64 %101, i64* %zSig, align 8
>   %102 = load i32* %bExp, align 4
>   store i32 %102, i32* %zExp, align 4
>   %103 = load i8* %4, align 1
>   %104 = zext i8 %103 to i32
>   %105 = xor i32 %104, 1
>   %106 = trunc i32 %105 to i8
>   store i8 %106, i8* %4, align 1
>   br label %139
> 
> ; <label>:107                                     ; preds = %23
>   %108 = load i32* %aExp, align 4
>   %109 = icmp eq i32 %108, 2047
>   br i1 %109, label %110, label %120
> 
> ; <label>:110                                     ; preds = %107
>   %111 = load i64* %aSig, align 8
>   %112 = icmp ne i64 %111, 0
>   br i1 %112, label %113, label %118
> 
> ; <label>:113                                     ; preds = %110
>   %114 = load i64* %2, align 8
>   %115 = load i64* %3, align 8
>   %116 = load %struct.float_status** %5, align 4
>   %117 = call i64 @propagateFloat64NaN(i64 %114, i64 %115, %struct.float_status* %116)
>   store i64 %117, i64* %1
>   br label %147
16816,16818c13534,13537
< ; <label>:21                                      ; preds = %can_do_io.exit
<   call void @cpu_io_recompile(%struct.CPUX86State* %11, i8* %retaddr) noreturn nounwind
<   unreachable
---
> ; <label>:118                                     ; preds = %110
>   %119 = load i64* %2, align 8
>   store i64 %119, i64* %1
>   br label %147
16820,16829c13539,13548
< can_do_io.exit.thread:                            ; preds = %can_do_io.exit, %14, %0
<   %22 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 69
<   store i32 %addr, i32* %22, align 4
<   %23 = ptrtoint i8* %retaddr to i64
<   %24 = load %struct.CPUX86State** @env, align 8
<   %25 = getelementptr inbounds %struct.CPUX86State* %24, i64 0, i32 68
<   store i64 %23, i64* %25, align 8
<   %26 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %3, i32 1) nounwind
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %32, label %28
---
> ; <label>:120                                     ; preds = %107
>   %121 = load i32* %bExp, align 4
>   %122 = icmp eq i32 %121, 0
>   br i1 %122, label %123, label %126
> 
> ; <label>:123                                     ; preds = %120
>   %124 = load i32* %expDiff, align 4
>   %125 = add nsw i32 %124, -1
>   store i32 %125, i32* %expDiff, align 4
>   br label %129
16831,16836c13550,13554
< ; <label>:28                                      ; preds = %can_do_io.exit.thread
<   %29 = call i64 @s2e_notdirty_mem_write(i64 %6) nounwind
<   %30 = inttoptr i64 %29 to i8*
<   %31 = load i8* %1, align 1
<   store i8 %31, i8* %30, align 1
<   br label %43
---
> ; <label>:126                                     ; preds = %120
>   %127 = load i64* %bSig, align 8
>   %128 = or i64 %127, 4611686018427387904
>   store i64 %128, i64* %bSig, align 8
>   br label %129
16838,16841c13556,13563
< ; <label>:32                                      ; preds = %can_do_io.exit.thread
<   %33 = load i32* @g_s2e_concretize_io_writes, align 4
<   %34 = icmp eq i32 %33, 0
<   br i1 %34, label %36, label %35
---
> ; <label>:129                                     ; preds = %126, %123
>   %130 = load i64* %bSig, align 8
>   %131 = load i32* %expDiff, align 4
>   call void @shift64RightJamming(i64 %130, i32 %131, i64* %bSig)
>   %132 = load i64* %aSig, align 8
>   %133 = or i64 %132, 4611686018427387904
>   store i64 %133, i64* %aSig, align 8
>   br label %134
16843,16845c13565,13584
< ; <label>:35                                      ; preds = %32
<   call void @tcg_llvm_get_value(i8* %1, i32 1, i1 zeroext true) nounwind
<   br label %36
---
> ; <label>:134                                     ; preds = %129, %51
>   %135 = load i64* %aSig, align 8
>   %136 = load i64* %bSig, align 8
>   %137 = sub i64 %135, %136
>   store i64 %137, i64* %zSig, align 8
>   %138 = load i32* %aExp, align 4
>   store i32 %138, i32* %zExp, align 4
>   br label %139
> 
> ; <label>:139                                     ; preds = %134, %98
>   %140 = load i32* %zExp, align 4
>   %141 = add nsw i32 %140, -1
>   store i32 %141, i32* %zExp, align 4
>   %142 = load i8* %4, align 1
>   %143 = load i32* %zExp, align 4
>   %144 = load i64* %zSig, align 8
>   %145 = load %struct.float_status** %5, align 4
>   %146 = call i64 @normalizeRoundAndPackFloat64(i8 zeroext %142, i32 %143, i64 %144, %struct.float_status* %145)
>   store i64 %146, i64* %1
>   br label %147
16847,16850c13586,13589
< ; <label>:36                                      ; preds = %35, %32
<   %37 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %._crit_edge, label %39
---
> ; <label>:147                                     ; preds = %139, %118, %113, %77, %72, %57, %41, %36
>   %148 = load i64* %1
>   ret i64 %148
> }
16852,16855c13591,13620
< ; <label>:39                                      ; preds = %36
<   %40 = bitcast i32* %2 to i8*
<   call void @tcg_llvm_get_value(i8* %40, i32 4, i1 zeroext true) nounwind
<   br label %._crit_edge
---
> define internal i64 @float64_sub(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call zeroext i8 @extractFloat64Sign(i64 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i64* %3, align 8
>   %14 = call zeroext i8 @extractFloat64Sign(i64 %13)
>   store i8 %14, i8* %bSign, align 1
>   %15 = load i8* %aSign, align 1
>   %16 = zext i8 %15 to i32
>   %17 = load i8* %bSign, align 1
>   %18 = zext i8 %17 to i32
>   %19 = icmp eq i32 %16, %18
>   br i1 %19, label %20, label %26
16857,16861c13622,13629
< ._crit_edge:                                      ; preds = %39, %36
<   %41 = load i8* %1, align 1
<   %42 = load i32* %2, align 4
<   call void @io_writeb_mmu(i64 %physaddr, i8 zeroext %41, i32 %42, i8* %retaddr) nounwind
<   br label %43
---
> ; <label>:20                                      ; preds = %0
>   %21 = load i64* %2, align 8
>   %22 = load i64* %3, align 8
>   %23 = load i8* %aSign, align 1
>   %24 = load %struct.float_status** %4, align 4
>   %25 = call i64 @subFloat64Sigs(i64 %21, i64 %22, i8 zeroext %23, %struct.float_status* %24)
>   store i64 %25, i64* %1
>   br label %32
16863,16864c13631,13642
< ; <label>:43                                      ; preds = %._crit_edge, %28
<   ret void
---
> ; <label>:26                                      ; preds = %0
>   %27 = load i64* %2, align 8
>   %28 = load i64* %3, align 8
>   %29 = load i8* %aSign, align 1
>   %30 = load %struct.float_status** %4, align 4
>   %31 = call i64 @addFloat64Sigs(i64 %27, i64 %28, i8 zeroext %29, %struct.float_status* %30)
>   store i64 %31, i64* %1
>   br label %32
> 
> ; <label>:32                                      ; preds = %26, %20
>   %33 = load i64* %1
>   ret i64 %33
16867c13645,13738
< declare void @io_writeb_mmu(i64, i8 zeroext, i32, i8*)
---
> define internal void @mul64To128(i64 %a, i64 %b, i64* %z0Ptr, i64* %z1Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64*, align 4
>   %4 = alloca i64*, align 4
>   %aHigh = alloca i32, align 4
>   %aLow = alloca i32, align 4
>   %bHigh = alloca i32, align 4
>   %bLow = alloca i32, align 4
>   %z0 = alloca i64, align 8
>   %zMiddleA = alloca i64, align 8
>   %zMiddleB = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   store i64 %b, i64* %2, align 8
>   store i64* %z0Ptr, i64** %3, align 4
>   store i64* %z1Ptr, i64** %4, align 4
>   %5 = load i64* %1, align 8
>   %6 = trunc i64 %5 to i32
>   store i32 %6, i32* %aLow, align 4
>   %7 = load i64* %1, align 8
>   %8 = lshr i64 %7, 32
>   %9 = trunc i64 %8 to i32
>   store i32 %9, i32* %aHigh, align 4
>   %10 = load i64* %2, align 8
>   %11 = trunc i64 %10 to i32
>   store i32 %11, i32* %bLow, align 4
>   %12 = load i64* %2, align 8
>   %13 = lshr i64 %12, 32
>   %14 = trunc i64 %13 to i32
>   store i32 %14, i32* %bHigh, align 4
>   %15 = load i32* %aLow, align 4
>   %16 = zext i32 %15 to i64
>   %17 = load i32* %bLow, align 4
>   %18 = zext i32 %17 to i64
>   %19 = mul i64 %16, %18
>   store i64 %19, i64* %z1, align 8
>   %20 = load i32* %aLow, align 4
>   %21 = zext i32 %20 to i64
>   %22 = load i32* %bHigh, align 4
>   %23 = zext i32 %22 to i64
>   %24 = mul i64 %21, %23
>   store i64 %24, i64* %zMiddleA, align 8
>   %25 = load i32* %aHigh, align 4
>   %26 = zext i32 %25 to i64
>   %27 = load i32* %bLow, align 4
>   %28 = zext i32 %27 to i64
>   %29 = mul i64 %26, %28
>   store i64 %29, i64* %zMiddleB, align 8
>   %30 = load i32* %aHigh, align 4
>   %31 = zext i32 %30 to i64
>   %32 = load i32* %bHigh, align 4
>   %33 = zext i32 %32 to i64
>   %34 = mul i64 %31, %33
>   store i64 %34, i64* %z0, align 8
>   %35 = load i64* %zMiddleB, align 8
>   %36 = load i64* %zMiddleA, align 8
>   %37 = add i64 %36, %35
>   store i64 %37, i64* %zMiddleA, align 8
>   %38 = load i64* %zMiddleA, align 8
>   %39 = load i64* %zMiddleB, align 8
>   %40 = icmp ult i64 %38, %39
>   %41 = zext i1 %40 to i32
>   %42 = sext i32 %41 to i64
>   %43 = shl i64 %42, 32
>   %44 = load i64* %zMiddleA, align 8
>   %45 = lshr i64 %44, 32
>   %46 = add i64 %43, %45
>   %47 = load i64* %z0, align 8
>   %48 = add i64 %47, %46
>   store i64 %48, i64* %z0, align 8
>   %49 = load i64* %zMiddleA, align 8
>   %50 = shl i64 %49, 32
>   store i64 %50, i64* %zMiddleA, align 8
>   %51 = load i64* %zMiddleA, align 8
>   %52 = load i64* %z1, align 8
>   %53 = add i64 %52, %51
>   store i64 %53, i64* %z1, align 8
>   %54 = load i64* %z1, align 8
>   %55 = load i64* %zMiddleA, align 8
>   %56 = icmp ult i64 %54, %55
>   %57 = zext i1 %56 to i32
>   %58 = sext i32 %57 to i64
>   %59 = load i64* %z0, align 8
>   %60 = add i64 %59, %58
>   store i64 %60, i64* %z0, align 8
>   %61 = load i64* %z1, align 8
>   %62 = load i64** %4, align 4
>   store i64 %61, i64* %62, align 4
>   %63 = load i64* %z0, align 8
>   %64 = load i64** %3, align 4
>   store i64 %63, i64* %64, align 4
>   ret void
> }
16869,16875c13740,13768
< define void @__stb_mmu(i32 %addr, i8 zeroext %val, i32 %mmu_idx) nounwind uwtable {
<   %1 = alloca i8, align 1
<   %2 = alloca i32, align 4
<   %3 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %4 = icmp eq i32 %3, 0
<   %5 = zext i32 %addr to i64
<   br i1 %4, label %8, label %6
---
> define internal i64 @roundAndPackFloat64(i8 zeroext %zSign, i32 %zExp, i64 %zSig, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i8, align 1
>   %3 = alloca i32, align 4
>   %4 = alloca i64, align 8
>   %5 = alloca %struct.float_status*, align 4
>   %roundingMode = alloca i8, align 1
>   %roundNearestEven = alloca i8, align 1
>   %roundIncrement = alloca i32, align 4
>   %roundBits = alloca i32, align 4
>   %isTiny = alloca i8, align 1
>   store i8 %zSign, i8* %2, align 1
>   store i32 %zExp, i32* %3, align 4
>   store i64 %zSig, i64* %4, align 8
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load %struct.float_status** %5, align 4
>   %7 = getelementptr inbounds %struct.float_status* %6, i32 0, i32 1
>   %8 = load i8* %7, align 1
>   store i8 %8, i8* %roundingMode, align 1
>   %9 = load i8* %roundingMode, align 1
>   %10 = sext i8 %9 to i32
>   %11 = icmp eq i32 %10, 0
>   %12 = zext i1 %11 to i32
>   %13 = trunc i32 %12 to i8
>   store i8 %13, i8* %roundNearestEven, align 1
>   store i32 512, i32* %roundIncrement, align 4
>   %14 = load i8* %roundNearestEven, align 1
>   %15 = icmp ne i8 %14, 0
>   br i1 %15, label %38, label %16
16877,16879c13770,13774
< ; <label>:6                                       ; preds = %0
<   %7 = call i64 @tcg_llvm_fork_and_concretize(i64 %5, i64 0, i64 4294967295) nounwind
<   br label %8
---
> ; <label>:16                                      ; preds = %0
>   %17 = load i8* %roundingMode, align 1
>   %18 = sext i8 %17 to i32
>   %19 = icmp eq i32 %18, 3
>   br i1 %19, label %20, label %21
16881,16896c13776,13778
< ; <label>:8                                       ; preds = %6, %0
<   %9 = phi i64 [ %7, %6 ], [ %5, %0 ]
<   %10 = trunc i64 %9 to i32
<   %11 = lshr i64 %9, 7
<   %12 = and i64 %11, 33554431
<   %13 = call i64 @tcg_llvm_fork_and_concretize(i64 %12, i64 0, i64 33554431) nounwind
<   %14 = lshr i64 %13, 5
<   %15 = and i64 %14, 255
<   %16 = sext i32 %mmu_idx to i64
<   %17 = load %struct.CPUX86State** @env, align 8
<   %18 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 73, i64 %16, i64 %15, i32 1
<   %19 = load i32* %18, align 4
<   %20 = and i32 %10, -4096
<   %21 = and i32 %19, -4088
<   %22 = icmp eq i32 %20, %21
<   br i1 %22, label %._crit_edge, label %.lr.ph, !prof !0
---
> ; <label>:20                                      ; preds = %16
>   store i32 0, i32* %roundIncrement, align 4
>   br label %37
16898,16901c13780,13784
< .lr.ph:                                           ; preds = %8
<   %23 = trunc i64 %13 to i32
<   %24 = shl i32 %23, 7
<   br label %78
---
> ; <label>:21                                      ; preds = %16
>   store i32 1023, i32* %roundIncrement, align 4
>   %22 = load i8* %2, align 1
>   %23 = icmp ne i8 %22, 0
>   br i1 %23, label %24, label %30
16903,16908c13786,13790
< ._crit_edge:                                      ; preds = %78, %8
<   %.lcssa31 = phi i32 [ %19, %8 ], [ %82, %78 ]
<   %.lcssa30 = phi %struct.CPUX86State* [ %17, %8 ], [ %80, %78 ]
<   %25 = and i32 %.lcssa31, 4095
<   %26 = icmp eq i32 %25, 0
<   br i1 %26, label %71, label %27, !prof !0
---
> ; <label>:24                                      ; preds = %21
>   %25 = load i8* %roundingMode, align 1
>   %26 = sext i8 %25 to i32
>   %27 = icmp eq i32 %26, 2
>   br i1 %27, label %28, label %29
16910,16932c13792,13794
< ; <label>:27                                      ; preds = %._crit_edge
<   %28 = getelementptr inbounds %struct.CPUX86State* %.lcssa30, i64 0, i32 75, i64 %16, i64 %15
<   %29 = load i64* %28, align 8
<   %30 = bitcast i32* %2 to i8*
<   store i8 %val, i8* %1, align 1
<   store i32 %10, i32* %2, align 4
<   %31 = call %struct.MemoryRegion* @iotlb_to_region(i64 %29) nounwind
<   %32 = and i64 %29, -4096
<   %33 = and i64 %9, 4294967295
<   %34 = add i64 %32, %33
<   %35 = icmp ne %struct.MemoryRegion* %31, @io_mem_ram
<   %36 = icmp ne %struct.MemoryRegion* %31, @io_mem_rom
<   %or.cond.i = and i1 %35, %36
<   %37 = icmp ne %struct.MemoryRegion* %31, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %37
<   %38 = icmp ne %struct.MemoryRegion* %31, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %38
<   %39 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %40 = load i32* @use_icount, align 4
<   %41 = icmp eq i32 %40, 0
<   %or.cond17.i = or i1 %41, %or.cond5.not.i
<   br i1 %or.cond17.i, label %can_do_io.exit.thread.i, label %42
---
> ; <label>:28                                      ; preds = %24
>   store i32 0, i32* %roundIncrement, align 4
>   br label %29
16934,16938c13796,13797
< ; <label>:42                                      ; preds = %27
<   %43 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 66
<   %44 = load %struct.TranslationBlock** %43, align 8
<   %45 = icmp eq %struct.TranslationBlock* %44, null
<   br i1 %45, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:29                                      ; preds = %28, %24
>   br label %36
16940,16944c13799,13803
< can_do_io.exit.i:                                 ; preds = %42
<   %46 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 85
<   %47 = load i32* %46, align 4
<   %48 = icmp eq i32 %47, 0
<   br i1 %48, label %49, label %can_do_io.exit.thread.i
---
> ; <label>:30                                      ; preds = %21
>   %31 = load i8* %roundingMode, align 1
>   %32 = sext i8 %31 to i32
>   %33 = icmp eq i32 %32, 1
>   br i1 %33, label %34, label %35
16946,16948c13805,13807
< ; <label>:49                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %39, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:34                                      ; preds = %30
>   store i32 0, i32* %roundIncrement, align 4
>   br label %35
16950,16958c13809,13810
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %42, %27
<   %50 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 69
<   store i32 %10, i32* %50, align 4
<   %51 = load %struct.CPUX86State** @env, align 8
<   %52 = getelementptr inbounds %struct.CPUX86State* %51, i64 0, i32 68
<   store i64 0, i64* %52, align 8
<   %53 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %31, i32 1) nounwind
<   %54 = icmp eq i32 %53, 0
<   br i1 %54, label %59, label %55
---
> ; <label>:35                                      ; preds = %34, %30
>   br label %36
16960,16965c13812,13813
< ; <label>:55                                      ; preds = %can_do_io.exit.thread.i
<   %56 = call i64 @s2e_notdirty_mem_write(i64 %34) nounwind
<   %57 = inttoptr i64 %56 to i8*
<   %58 = load i8* %1, align 1
<   store i8 %58, i8* %57, align 1
<   br label %io_write_chkb_mmu.exit
---
> ; <label>:36                                      ; preds = %35, %29
>   br label %37
16967,16970c13815,13816
< ; <label>:59                                      ; preds = %can_do_io.exit.thread.i
<   %60 = load i32* @g_s2e_concretize_io_writes, align 4
<   %61 = icmp eq i32 %60, 0
<   br i1 %61, label %63, label %62
---
> ; <label>:37                                      ; preds = %36, %20
>   br label %38
16972,16974c13818,13832
< ; <label>:62                                      ; preds = %59
<   call void @tcg_llvm_get_value(i8* %1, i32 1, i1 zeroext true) nounwind
<   br label %63
---
> ; <label>:38                                      ; preds = %37, %0
>   %39 = load i64* %4, align 8
>   %40 = and i64 %39, 1023
>   %41 = trunc i64 %40 to i32
>   store i32 %41, i32* %roundBits, align 4
>   %42 = load i32* %3, align 4
>   %43 = trunc i32 %42 to i16
>   %44 = zext i16 %43 to i32
>   %45 = icmp sle i32 2045, %44
>   br i1 %45, label %46, label %114
> 
> ; <label>:46                                      ; preds = %38
>   %47 = load i32* %3, align 4
>   %48 = icmp slt i32 2045, %47
>   br i1 %48, label %58, label %49
16976,16979c13834,13858
< ; <label>:63                                      ; preds = %62, %59
<   %64 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %65 = icmp eq i32 %64, 0
<   br i1 %65, label %._crit_edge.i, label %66
---
> ; <label>:49                                      ; preds = %46
>   %50 = load i32* %3, align 4
>   %51 = icmp eq i32 %50, 2045
>   br i1 %51, label %52, label %67
> 
> ; <label>:52                                      ; preds = %49
>   %53 = load i64* %4, align 8
>   %54 = load i32* %roundIncrement, align 4
>   %55 = sext i32 %54 to i64
>   %56 = add i64 %53, %55
>   %57 = icmp slt i64 %56, 0
>   br i1 %57, label %58, label %67
> 
> ; <label>:58                                      ; preds = %52, %46
>   %59 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext 40, %struct.float_status* %59)
>   %60 = load i8* %2, align 1
>   %61 = load i32* %roundIncrement, align 4
>   %62 = icmp eq i32 %61, 0
>   %63 = zext i1 %62 to i32
>   %64 = sub nsw i32 0, %63
>   %65 = sext i32 %64 to i64
>   %66 = call i64 @packFloat64(i8 zeroext %60, i32 2047, i64 %65)
>   store i64 %66, i64* %1
>   br label %149
16981,16983c13860,13870
< ; <label>:66                                      ; preds = %63
<   call void @tcg_llvm_get_value(i8* %30, i32 4, i1 zeroext true) nounwind
<   br label %._crit_edge.i
---
> ; <label>:67                                      ; preds = %52, %49
>   %68 = load i32* %3, align 4
>   %69 = icmp slt i32 %68, 0
>   br i1 %69, label %70, label %113
> 
> ; <label>:70                                      ; preds = %67
>   %71 = load %struct.float_status** %5, align 4
>   %72 = getelementptr inbounds %struct.float_status* %71, i32 0, i32 4
>   %73 = load i8* %72, align 1
>   %74 = icmp ne i8 %73, 0
>   br i1 %74, label %75, label %79
16985,16989c13872,13878
< ._crit_edge.i:                                    ; preds = %66, %63
<   %67 = load i8* %1, align 1
<   %68 = load i32* %2, align 4
<   call void @io_writeb_mmu(i64 %29, i8 zeroext %67, i32 %68, i8* null) nounwind
<   br label %io_write_chkb_mmu.exit
---
> ; <label>:75                                      ; preds = %70
>   %76 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext -128, %struct.float_status* %76)
>   %77 = load i8* %2, align 1
>   %78 = call i64 @packFloat64(i8 zeroext %77, i32 0, i64 0)
>   store i64 %78, i64* %1
>   br label %149
16991,16995c13880,13939
< io_write_chkb_mmu.exit:                           ; preds = %._crit_edge.i, %55
<   %69 = add i64 %29, %33
<   %70 = zext i8 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %33, i64 %69, i64 %70, i32 8, i8 zeroext 1, i8 zeroext 1) nounwind
<   br label %85
---
> ; <label>:79                                      ; preds = %70
>   %80 = load %struct.float_status** %5, align 4
>   %81 = getelementptr inbounds %struct.float_status* %80, i32 0, i32 0
>   %82 = load i8* %81, align 1
>   %83 = sext i8 %82 to i32
>   %84 = icmp eq i32 %83, 1
>   br i1 %84, label %94, label %85
> 
> ; <label>:85                                      ; preds = %79
>   %86 = load i32* %3, align 4
>   %87 = icmp slt i32 %86, -1
>   br i1 %87, label %94, label %88
> 
> ; <label>:88                                      ; preds = %85
>   %89 = load i64* %4, align 8
>   %90 = load i32* %roundIncrement, align 4
>   %91 = sext i32 %90 to i64
>   %92 = add i64 %89, %91
>   %93 = icmp ult i64 %92, -9223372036854775808
>   br label %94
> 
> ; <label>:94                                      ; preds = %88, %85, %79
>   %95 = phi i1 [ true, %85 ], [ true, %79 ], [ %93, %88 ]
>   %96 = zext i1 %95 to i32
>   %97 = trunc i32 %96 to i8
>   store i8 %97, i8* %isTiny, align 1
>   %98 = load i64* %4, align 8
>   %99 = load i32* %3, align 4
>   %100 = sub nsw i32 0, %99
>   call void @shift64RightJamming(i64 %98, i32 %100, i64* %4)
>   store i32 0, i32* %3, align 4
>   %101 = load i64* %4, align 8
>   %102 = and i64 %101, 1023
>   %103 = trunc i64 %102 to i32
>   store i32 %103, i32* %roundBits, align 4
>   %104 = load i8* %isTiny, align 1
>   %105 = zext i8 %104 to i32
>   %106 = icmp ne i32 %105, 0
>   br i1 %106, label %107, label %112
> 
> ; <label>:107                                     ; preds = %94
>   %108 = load i32* %roundBits, align 4
>   %109 = icmp ne i32 %108, 0
>   br i1 %109, label %110, label %112
> 
> ; <label>:110                                     ; preds = %107
>   %111 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext 16, %struct.float_status* %111)
>   br label %112
> 
> ; <label>:112                                     ; preds = %110, %107, %94
>   br label %113
> 
> ; <label>:113                                     ; preds = %112, %67
>   br label %114
> 
> ; <label>:114                                     ; preds = %113, %38
>   %115 = load i32* %roundBits, align 4
>   %116 = icmp ne i32 %115, 0
>   br i1 %116, label %117, label %124
16997,17006c13941,13949
< ; <label>:71                                      ; preds = %._crit_edge
<   %72 = getelementptr inbounds %struct.CPUX86State* %.lcssa30, i64 0, i32 73, i64 %16, i64 %15, i32 3
<   %73 = load i64* %72, align 8
<   %74 = and i64 %9, 4294967295
<   %75 = add i64 %73, %74
<   %76 = inttoptr i64 %75 to i8*
<   store i8 %val, i8* %76, align 1
<   %77 = zext i8 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %74, i64 %75, i64 %77, i32 8, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %85
---
> ; <label>:117                                     ; preds = %114
>   %118 = load %struct.float_status** %5, align 4
>   %119 = getelementptr inbounds %struct.float_status* %118, i32 0, i32 2
>   %120 = load i8* %119, align 1
>   %121 = sext i8 %120 to i32
>   %122 = or i32 %121, 32
>   %123 = trunc i32 %122 to i8
>   store i8 %123, i8* %119, align 1
>   br label %124
17008,17016c13951,13984
< ; <label>:78                                      ; preds = %78, %.lr.ph
<   %79 = phi %struct.CPUX86State* [ %17, %.lr.ph ], [ %80, %78 ]
<   call void @tlb_fill(%struct.CPUX86State* %79, i32 %10, i32 %24, i32 1, i32 %mmu_idx, i8* null)
<   %80 = load %struct.CPUX86State** @env, align 8
<   %81 = getelementptr inbounds %struct.CPUX86State* %80, i64 0, i32 73, i64 %16, i64 %15, i32 1
<   %82 = load i32* %81, align 4
<   %83 = and i32 %82, -4088
<   %84 = icmp eq i32 %20, %83
<   br i1 %84, label %._crit_edge, label %78, !prof !0
---
> ; <label>:124                                     ; preds = %117, %114
>   %125 = load i64* %4, align 8
>   %126 = load i32* %roundIncrement, align 4
>   %127 = sext i32 %126 to i64
>   %128 = add i64 %125, %127
>   %129 = lshr i64 %128, 10
>   store i64 %129, i64* %4, align 8
>   %130 = load i32* %roundBits, align 4
>   %131 = xor i32 %130, 512
>   %132 = icmp eq i32 %131, 0
>   %133 = zext i1 %132 to i32
>   %134 = load i8* %roundNearestEven, align 1
>   %135 = zext i8 %134 to i32
>   %136 = and i32 %133, %135
>   %137 = xor i32 %136, -1
>   %138 = sext i32 %137 to i64
>   %139 = load i64* %4, align 8
>   %140 = and i64 %139, %138
>   store i64 %140, i64* %4, align 8
>   %141 = load i64* %4, align 8
>   %142 = icmp eq i64 %141, 0
>   br i1 %142, label %143, label %144
> 
> ; <label>:143                                     ; preds = %124
>   store i32 0, i32* %3, align 4
>   br label %144
> 
> ; <label>:144                                     ; preds = %143, %124
>   %145 = load i8* %2, align 1
>   %146 = load i32* %3, align 4
>   %147 = load i64* %4, align 8
>   %148 = call i64 @packFloat64(i8 zeroext %145, i32 %146, i64 %147)
>   store i64 %148, i64* %1
>   br label %149
17018,17019c13986,13988
< ; <label>:85                                      ; preds = %71, %io_write_chkb_mmu.exit
<   ret void
---
> ; <label>:149                                     ; preds = %144, %75, %58
>   %150 = load i64* %1
>   ret i64 %150
17022,17028c13991,14052
< define internal fastcc void @slow_stb_mmu(i32 %addr, i8 zeroext %val, i32 %mmu_idx) nounwind uwtable {
<   %1 = alloca i8, align 1
<   %2 = alloca i32, align 4
<   %3 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %4 = icmp eq i32 %3, 0
<   %5 = zext i32 %addr to i64
<   br i1 %4, label %8, label %6
---
> define internal i64 @float64_div(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %zSig = alloca i64, align 8
>   %rem0 = alloca i64, align 8
>   %rem1 = alloca i64, align 8
>   %term0 = alloca i64, align 8
>   %term1 = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i64 @extractFloat64Frac(i64 %11)
>   store i64 %12, i64* %aSig, align 8
>   %13 = load i64* %2, align 8
>   %14 = call i32 @extractFloat64Exp(i64 %13)
>   store i32 %14, i32* %aExp, align 4
>   %15 = load i64* %2, align 8
>   %16 = call zeroext i8 @extractFloat64Sign(i64 %15)
>   store i8 %16, i8* %aSign, align 1
>   %17 = load i64* %3, align 8
>   %18 = call i64 @extractFloat64Frac(i64 %17)
>   store i64 %18, i64* %bSig, align 8
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   store i32 %20, i32* %bExp, align 4
>   %21 = load i64* %3, align 8
>   %22 = call zeroext i8 @extractFloat64Sign(i64 %21)
>   store i8 %22, i8* %bSign, align 1
>   %23 = load i8* %aSign, align 1
>   %24 = zext i8 %23 to i32
>   %25 = load i8* %bSign, align 1
>   %26 = zext i8 %25 to i32
>   %27 = xor i32 %24, %26
>   %28 = trunc i32 %27 to i8
>   store i8 %28, i8* %zSign, align 1
>   %29 = load i32* %aExp, align 4
>   %30 = icmp eq i32 %29, 2047
>   br i1 %30, label %31, label %55
> 
> ; <label>:31                                      ; preds = %0
>   %32 = load i64* %aSig, align 8
>   %33 = icmp ne i64 %32, 0
>   br i1 %33, label %34, label %39
17030,17032c14054,14065
< ; <label>:6                                       ; preds = %0
<   %7 = call i64 @tcg_llvm_fork_and_concretize(i64 %5, i64 0, i64 4294967295) nounwind
<   br label %8
---
> ; <label>:34                                      ; preds = %31
>   %35 = load i64* %2, align 8
>   %36 = load i64* %3, align 8
>   %37 = load %struct.float_status** %4, align 4
>   %38 = call i64 @propagateFloat64NaN(i64 %35, i64 %36, %struct.float_status* %37)
>   store i64 %38, i64* %1
>   br label %156
> 
> ; <label>:39                                      ; preds = %31
>   %40 = load i32* %bExp, align 4
>   %41 = icmp eq i32 %40, 2047
>   br i1 %41, label %42, label %52
17034,17049c14067,14070
< ; <label>:8                                       ; preds = %6, %0
<   %9 = phi i64 [ %7, %6 ], [ %5, %0 ]
<   %10 = trunc i64 %9 to i32
<   %11 = lshr i64 %9, 7
<   %12 = and i64 %11, 33554431
<   %13 = call i64 @tcg_llvm_fork_and_concretize(i64 %12, i64 0, i64 33554431) nounwind
<   %14 = lshr i64 %13, 5
<   %15 = and i64 %14, 255
<   %16 = sext i32 %mmu_idx to i64
<   %17 = load %struct.CPUX86State** @env, align 8
<   %18 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 73, i64 %16, i64 %15, i32 1
<   %19 = load i32* %18, align 4
<   %20 = and i32 %10, -4096
<   %21 = and i32 %19, -4088
<   %22 = icmp eq i32 %20, %21
<   br i1 %22, label %._crit_edge, label %.lr.ph
---
> ; <label>:42                                      ; preds = %39
>   %43 = load i64* %bSig, align 8
>   %44 = icmp ne i64 %43, 0
>   br i1 %44, label %45, label %50
17051,17054c14072,14100
< .lr.ph:                                           ; preds = %8
<   %23 = trunc i64 %13 to i32
<   %24 = shl i32 %23, 7
<   br label %78
---
> ; <label>:45                                      ; preds = %42
>   %46 = load i64* %2, align 8
>   %47 = load i64* %3, align 8
>   %48 = load %struct.float_status** %4, align 4
>   %49 = call i64 @propagateFloat64NaN(i64 %46, i64 %47, %struct.float_status* %48)
>   store i64 %49, i64* %1
>   br label %156
> 
> ; <label>:50                                      ; preds = %42
>   %51 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %51)
>   store i64 -2251799813685248, i64* %1
>   br label %156
> 
> ; <label>:52                                      ; preds = %39
>   %53 = load i8* %zSign, align 1
>   %54 = call i64 @packFloat64(i8 zeroext %53, i32 2047, i64 0)
>   store i64 %54, i64* %1
>   br label %156
> 
> ; <label>:55                                      ; preds = %0
>   %56 = load i32* %bExp, align 4
>   %57 = icmp eq i32 %56, 2047
>   br i1 %57, label %58, label %69
> 
> ; <label>:58                                      ; preds = %55
>   %59 = load i64* %bSig, align 8
>   %60 = icmp ne i64 %59, 0
>   br i1 %60, label %61, label %66
17056,17061c14102,14114
< ._crit_edge:                                      ; preds = %78, %8
<   %.lcssa2 = phi i32 [ %19, %8 ], [ %82, %78 ]
<   %.lcssa1 = phi %struct.CPUX86State* [ %17, %8 ], [ %80, %78 ]
<   %25 = and i32 %.lcssa2, 4095
<   %26 = icmp eq i32 %25, 0
<   br i1 %26, label %71, label %27
---
> ; <label>:61                                      ; preds = %58
>   %62 = load i64* %2, align 8
>   %63 = load i64* %3, align 8
>   %64 = load %struct.float_status** %4, align 4
>   %65 = call i64 @propagateFloat64NaN(i64 %62, i64 %63, %struct.float_status* %64)
>   store i64 %65, i64* %1
>   br label %156
> 
> ; <label>:66                                      ; preds = %58
>   %67 = load i8* %zSign, align 1
>   %68 = call i64 @packFloat64(i8 zeroext %67, i32 0, i64 0)
>   store i64 %68, i64* %1
>   br label %156
17063,17085c14116,14119
< ; <label>:27                                      ; preds = %._crit_edge
<   %28 = getelementptr inbounds %struct.CPUX86State* %.lcssa1, i64 0, i32 75, i64 %16, i64 %15
<   %29 = load i64* %28, align 8
<   %30 = bitcast i32* %2 to i8*
<   store i8 %val, i8* %1, align 1
<   store i32 %10, i32* %2, align 4
<   %31 = call %struct.MemoryRegion* @iotlb_to_region(i64 %29) nounwind
<   %32 = and i64 %29, -4096
<   %33 = and i64 %9, 4294967295
<   %34 = add i64 %32, %33
<   %35 = icmp ne %struct.MemoryRegion* %31, @io_mem_ram
<   %36 = icmp ne %struct.MemoryRegion* %31, @io_mem_rom
<   %or.cond.i = and i1 %35, %36
<   %37 = icmp ne %struct.MemoryRegion* %31, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %37
<   %38 = icmp ne %struct.MemoryRegion* %31, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %38
<   %39 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %40 = load i32* @use_icount, align 4
<   %41 = icmp eq i32 %40, 0
<   %or.cond17.i = or i1 %41, %or.cond5.not.i
<   br i1 %or.cond17.i, label %can_do_io.exit.thread.i, label %42
---
> ; <label>:69                                      ; preds = %55
>   %70 = load i32* %bExp, align 4
>   %71 = icmp eq i32 %70, 0
>   br i1 %71, label %72, label %89
17087,17091c14121,14151
< ; <label>:42                                      ; preds = %27
<   %43 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 66
<   %44 = load %struct.TranslationBlock** %43, align 8
<   %45 = icmp eq %struct.TranslationBlock* %44, null
<   br i1 %45, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:72                                      ; preds = %69
>   %73 = load i64* %bSig, align 8
>   %74 = icmp eq i64 %73, 0
>   br i1 %74, label %75, label %87
> 
> ; <label>:75                                      ; preds = %72
>   %76 = load i32* %aExp, align 4
>   %77 = sext i32 %76 to i64
>   %78 = load i64* %aSig, align 8
>   %79 = or i64 %77, %78
>   %80 = icmp eq i64 %79, 0
>   br i1 %80, label %81, label %83
> 
> ; <label>:81                                      ; preds = %75
>   %82 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %82)
>   store i64 -2251799813685248, i64* %1
>   br label %156
> 
> ; <label>:83                                      ; preds = %75
>   %84 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 4, %struct.float_status* %84)
>   %85 = load i8* %zSign, align 1
>   %86 = call i64 @packFloat64(i8 zeroext %85, i32 2047, i64 0)
>   store i64 %86, i64* %1
>   br label %156
> 
> ; <label>:87                                      ; preds = %72
>   %88 = load i64* %bSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %88, i32* %bExp, i64* %bSig)
>   br label %89
17093,17097c14153,14156
< can_do_io.exit.i:                                 ; preds = %42
<   %46 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 85
<   %47 = load i32* %46, align 4
<   %48 = icmp eq i32 %47, 0
<   br i1 %48, label %49, label %can_do_io.exit.thread.i
---
> ; <label>:89                                      ; preds = %87, %69
>   %90 = load i32* %aExp, align 4
>   %91 = icmp eq i32 %90, 0
>   br i1 %91, label %92, label %100
17099,17101c14158,14202
< ; <label>:49                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %39, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:92                                      ; preds = %89
>   %93 = load i64* %aSig, align 8
>   %94 = icmp eq i64 %93, 0
>   br i1 %94, label %95, label %98
> 
> ; <label>:95                                      ; preds = %92
>   %96 = load i8* %zSign, align 1
>   %97 = call i64 @packFloat64(i8 zeroext %96, i32 0, i64 0)
>   store i64 %97, i64* %1
>   br label %156
> 
> ; <label>:98                                      ; preds = %92
>   %99 = load i64* %aSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %99, i32* %aExp, i64* %aSig)
>   br label %100
> 
> ; <label>:100                                     ; preds = %98, %89
>   %101 = load i32* %aExp, align 4
>   %102 = load i32* %bExp, align 4
>   %103 = sub nsw i32 %101, %102
>   %104 = add nsw i32 %103, 1021
>   store i32 %104, i32* %zExp, align 4
>   %105 = load i64* %aSig, align 8
>   %106 = or i64 %105, 4503599627370496
>   %107 = shl i64 %106, 10
>   store i64 %107, i64* %aSig, align 8
>   %108 = load i64* %bSig, align 8
>   %109 = or i64 %108, 4503599627370496
>   %110 = shl i64 %109, 11
>   store i64 %110, i64* %bSig, align 8
>   %111 = load i64* %bSig, align 8
>   %112 = load i64* %aSig, align 8
>   %113 = load i64* %aSig, align 8
>   %114 = add i64 %112, %113
>   %115 = icmp ule i64 %111, %114
>   br i1 %115, label %116, label %121
> 
> ; <label>:116                                     ; preds = %100
>   %117 = load i64* %aSig, align 8
>   %118 = lshr i64 %117, 1
>   store i64 %118, i64* %aSig, align 8
>   %119 = load i32* %zExp, align 4
>   %120 = add nsw i32 %119, 1
>   store i32 %120, i32* %zExp, align 4
>   br label %121
17103,17111c14204,14222
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %42, %27
<   %50 = getelementptr inbounds %struct.CPUX86State* %39, i64 0, i32 69
<   store i32 %10, i32* %50, align 4
<   %51 = load %struct.CPUX86State** @env, align 8
<   %52 = getelementptr inbounds %struct.CPUX86State* %51, i64 0, i32 68
<   store i64 0, i64* %52, align 8
<   %53 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %31, i32 1) nounwind
<   %54 = icmp eq i32 %53, 0
<   br i1 %54, label %59, label %55
---
> ; <label>:121                                     ; preds = %116, %100
>   %122 = load i64* %aSig, align 8
>   %123 = load i64* %bSig, align 8
>   %124 = call i64 @estimateDiv128To64(i64 %122, i64 0, i64 %123)
>   store i64 %124, i64* %zSig, align 8
>   %125 = load i64* %zSig, align 8
>   %126 = and i64 %125, 511
>   %127 = icmp ule i64 %126, 2
>   br i1 %127, label %128, label %150
> 
> ; <label>:128                                     ; preds = %121
>   %129 = load i64* %bSig, align 8
>   %130 = load i64* %zSig, align 8
>   call void @mul64To128(i64 %129, i64 %130, i64* %term0, i64* %term1)
>   %131 = load i64* %aSig, align 8
>   %132 = load i64* %term0, align 8
>   %133 = load i64* %term1, align 8
>   call void @sub128(i64 %131, i64 0, i64 %132, i64 %133, i64* %rem0, i64* %rem1)
>   br label %134
17113,17118c14224,14227
< ; <label>:55                                      ; preds = %can_do_io.exit.thread.i
<   %56 = call i64 @s2e_notdirty_mem_write(i64 %34) nounwind
<   %57 = inttoptr i64 %56 to i8*
<   %58 = load i8* %1, align 1
<   store i8 %58, i8* %57, align 1
<   br label %io_write_chkb_mmu.exit
---
> ; <label>:134                                     ; preds = %137, %128
>   %135 = load i64* %rem0, align 8
>   %136 = icmp slt i64 %135, 0
>   br i1 %136, label %137, label %143
17120,17123c14229,14237
< ; <label>:59                                      ; preds = %can_do_io.exit.thread.i
<   %60 = load i32* @g_s2e_concretize_io_writes, align 4
<   %61 = icmp eq i32 %60, 0
<   br i1 %61, label %63, label %62
---
> ; <label>:137                                     ; preds = %134
>   %138 = load i64* %zSig, align 8
>   %139 = add i64 %138, -1
>   store i64 %139, i64* %zSig, align 8
>   %140 = load i64* %rem0, align 8
>   %141 = load i64* %rem1, align 8
>   %142 = load i64* %bSig, align 8
>   call void @add128(i64 %140, i64 %141, i64 0, i64 %142, i64* %rem0, i64* %rem1)
>   br label %134
17125,17127c14239,14247
< ; <label>:62                                      ; preds = %59
<   call void @tcg_llvm_get_value(i8* %1, i32 1, i1 zeroext true) nounwind
<   br label %63
---
> ; <label>:143                                     ; preds = %134
>   %144 = load i64* %rem1, align 8
>   %145 = icmp ne i64 %144, 0
>   %146 = zext i1 %145 to i32
>   %147 = sext i32 %146 to i64
>   %148 = load i64* %zSig, align 8
>   %149 = or i64 %148, %147
>   store i64 %149, i64* %zSig, align 8
>   br label %150
17129,17132c14249,14261
< ; <label>:63                                      ; preds = %62, %59
<   %64 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %65 = icmp eq i32 %64, 0
<   br i1 %65, label %._crit_edge.i, label %66
---
> ; <label>:150                                     ; preds = %143, %121
>   %151 = load i8* %zSign, align 1
>   %152 = load i32* %zExp, align 4
>   %153 = load i64* %zSig, align 8
>   %154 = load %struct.float_status** %4, align 4
>   %155 = call i64 @roundAndPackFloat64(i8 zeroext %151, i32 %152, i64 %153, %struct.float_status* %154)
>   store i64 %155, i64* %1
>   br label %156
> 
> ; <label>:156                                     ; preds = %150, %95, %83, %81, %66, %61, %52, %50, %45, %34
>   %157 = load i64* %1
>   ret i64 %157
> }
17134,17136c14263,14293
< ; <label>:66                                      ; preds = %63
<   call void @tcg_llvm_get_value(i8* %30, i32 4, i1 zeroext true) nounwind
<   br label %._crit_edge.i
---
> define internal void @sub128(i64 %a0, i64 %a1, i64 %b0, i64 %b1, i64* %z0Ptr, i64* %z1Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca i64*, align 4
>   %6 = alloca i64*, align 4
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %b0, i64* %3, align 8
>   store i64 %b1, i64* %4, align 8
>   store i64* %z0Ptr, i64** %5, align 4
>   store i64* %z1Ptr, i64** %6, align 4
>   %7 = load i64* %2, align 8
>   %8 = load i64* %4, align 8
>   %9 = sub i64 %7, %8
>   %10 = load i64** %6, align 4
>   store i64 %9, i64* %10, align 4
>   %11 = load i64* %1, align 8
>   %12 = load i64* %3, align 8
>   %13 = sub i64 %11, %12
>   %14 = load i64* %2, align 8
>   %15 = load i64* %4, align 8
>   %16 = icmp ult i64 %14, %15
>   %17 = zext i1 %16 to i32
>   %18 = sext i32 %17 to i64
>   %19 = sub i64 %13, %18
>   %20 = load i64** %5, align 4
>   store i64 %19, i64* %20, align 4
>   ret void
> }
17138,17142c14295,14328
< ._crit_edge.i:                                    ; preds = %66, %63
<   %67 = load i8* %1, align 1
<   %68 = load i32* %2, align 4
<   call void @io_writeb_mmu(i64 %29, i8 zeroext %67, i32 %68, i8* null) nounwind
<   br label %io_write_chkb_mmu.exit
---
> define internal void @add128(i64 %a0, i64 %a1, i64 %b0, i64 %b1, i64* %z0Ptr, i64* %z1Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca i64*, align 4
>   %6 = alloca i64*, align 4
>   %z1 = alloca i64, align 8
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %b0, i64* %3, align 8
>   store i64 %b1, i64* %4, align 8
>   store i64* %z0Ptr, i64** %5, align 4
>   store i64* %z1Ptr, i64** %6, align 4
>   %7 = load i64* %2, align 8
>   %8 = load i64* %4, align 8
>   %9 = add i64 %7, %8
>   store i64 %9, i64* %z1, align 8
>   %10 = load i64* %z1, align 8
>   %11 = load i64** %6, align 4
>   store i64 %10, i64* %11, align 4
>   %12 = load i64* %1, align 8
>   %13 = load i64* %3, align 8
>   %14 = add i64 %12, %13
>   %15 = load i64* %z1, align 8
>   %16 = load i64* %2, align 8
>   %17 = icmp ult i64 %15, %16
>   %18 = zext i1 %17 to i32
>   %19 = sext i32 %18 to i64
>   %20 = add i64 %14, %19
>   %21 = load i64** %5, align 4
>   store i64 %20, i64* %21, align 4
>   ret void
> }
17144,17148c14330,14373
< io_write_chkb_mmu.exit:                           ; preds = %._crit_edge.i, %55
<   %69 = add i64 %29, %33
<   %70 = zext i8 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %33, i64 %69, i64 %70, i32 8, i8 zeroext 1, i8 zeroext 1) nounwind
<   br label %85
---
> define internal i64 @float64_rem(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %expDiff = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %q = alloca i64, align 8
>   %alternateASig = alloca i64, align 8
>   %sigMean = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i64 @extractFloat64Frac(i64 %11)
>   store i64 %12, i64* %aSig, align 8
>   %13 = load i64* %2, align 8
>   %14 = call i32 @extractFloat64Exp(i64 %13)
>   store i32 %14, i32* %aExp, align 4
>   %15 = load i64* %2, align 8
>   %16 = call zeroext i8 @extractFloat64Sign(i64 %15)
>   store i8 %16, i8* %aSign, align 1
>   %17 = load i64* %3, align 8
>   %18 = call i64 @extractFloat64Frac(i64 %17)
>   store i64 %18, i64* %bSig, align 8
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   store i32 %20, i32* %bExp, align 4
>   %21 = load i32* %aExp, align 4
>   %22 = icmp eq i32 %21, 2047
>   br i1 %22, label %23, label %39
17150,17159c14375,14388
< ; <label>:71                                      ; preds = %._crit_edge
<   %72 = getelementptr inbounds %struct.CPUX86State* %.lcssa1, i64 0, i32 73, i64 %16, i64 %15, i32 3
<   %73 = load i64* %72, align 8
<   %74 = and i64 %9, 4294967295
<   %75 = add i64 %73, %74
<   %76 = inttoptr i64 %75 to i8*
<   store i8 %val, i8* %76, align 1
<   %77 = zext i8 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %74, i64 %75, i64 %77, i32 8, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %85
---
> ; <label>:23                                      ; preds = %0
>   %24 = load i64* %aSig, align 8
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %32, label %26
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load i32* %bExp, align 4
>   %28 = icmp eq i32 %27, 2047
>   br i1 %28, label %29, label %37
> 
> ; <label>:29                                      ; preds = %26
>   %30 = load i64* %bSig, align 8
>   %31 = icmp ne i64 %30, 0
>   br i1 %31, label %32, label %37
17161,17169c14390,14402
< ; <label>:78                                      ; preds = %78, %.lr.ph
<   %79 = phi %struct.CPUX86State* [ %17, %.lr.ph ], [ %80, %78 ]
<   call void @tlb_fill(%struct.CPUX86State* %79, i32 %10, i32 %24, i32 1, i32 %mmu_idx, i8* null)
<   %80 = load %struct.CPUX86State** @env, align 8
<   %81 = getelementptr inbounds %struct.CPUX86State* %80, i64 0, i32 73, i64 %16, i64 %15, i32 1
<   %82 = load i32* %81, align 4
<   %83 = and i32 %82, -4088
<   %84 = icmp eq i32 %20, %83
<   br i1 %84, label %._crit_edge, label %78
---
> ; <label>:32                                      ; preds = %29, %23
>   %33 = load i64* %2, align 8
>   %34 = load i64* %3, align 8
>   %35 = load %struct.float_status** %4, align 4
>   %36 = call i64 @propagateFloat64NaN(i64 %33, i64 %34, %struct.float_status* %35)
>   store i64 %36, i64* %1
>   br label %215
> 
> ; <label>:37                                      ; preds = %29, %26
>   %38 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %38)
>   store i64 -2251799813685248, i64* %1
>   br label %215
17171,17173c14404,14407
< ; <label>:85                                      ; preds = %71, %io_write_chkb_mmu.exit
<   ret void
< }
---
> ; <label>:39                                      ; preds = %0
>   %40 = load i32* %bExp, align 4
>   %41 = icmp eq i32 %40, 2047
>   br i1 %41, label %42, label %52
17175,17185c14409,14412
< define zeroext i16 @io_read_chkw_mmu(i64 %physaddr, i32 %addr, i8* %retaddr) nounwind uwtable inlinehint alwaysinline {
<   %ret.i.i = alloca i8, align 1
<   %label = alloca [64 x i8], align 16
<   %1 = call %struct.MemoryRegion* @iotlb_to_region(i64 %physaddr) nounwind
<   %2 = and i64 %physaddr, 4294963200
<   %3 = zext i32 %addr to i64
<   %4 = add i64 %3, %2
<   %5 = trunc i64 %4 to i32
<   %6 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %7 = icmp eq i32 %6, 0
<   br i1 %7, label %17, label %8
---
> ; <label>:42                                      ; preds = %39
>   %43 = load i64* %bSig, align 8
>   %44 = icmp ne i64 %43, 0
>   br i1 %44, label %45, label %50
17187,17191c14414,14425
< ; <label>:8                                       ; preds = %0
<   %9 = and i64 %4, 4294967295
<   %10 = call i32 @s2e_is_mmio_symbolic_w(i64 %9) nounwind
<   %11 = icmp eq i32 %10, 0
<   br i1 %11, label %17, label %12
---
> ; <label>:45                                      ; preds = %42
>   %46 = load i64* %2, align 8
>   %47 = load i64* %3, align 8
>   %48 = load %struct.float_status** %4, align 4
>   %49 = call i64 @propagateFloat64NaN(i64 %46, i64 %47, %struct.float_status* %48)
>   store i64 %49, i64* %1
>   br label %215
> 
> ; <label>:50                                      ; preds = %42
>   %51 = load i64* %2, align 8
>   store i64 %51, i64* %1
>   br label %215
17193,17199c14427,14430
< ; <label>:12                                      ; preds = %8
<   %13 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 5
<   %16 = load i32* %15, align 4
<   call void @trace_port(i8* %13, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %5, i32 %16)
<   br label %17
---
> ; <label>:52                                      ; preds = %39
>   %53 = load i32* %bExp, align 4
>   %54 = icmp eq i32 %53, 0
>   br i1 %54, label %55, label %62
17201,17219c14432,14441
< ; <label>:17                                      ; preds = %12, %8, %0
<   %isSymb.0 = phi i32 [ %10, %12 ], [ 0, %8 ], [ 0, %0 ]
<   %18 = ptrtoint i8* %retaddr to i64
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 68
<   store i64 %18, i64* %20, align 8
<   %21 = icmp ne %struct.MemoryRegion* %1, @io_mem_ram
<   %22 = icmp ne %struct.MemoryRegion* %1, @io_mem_rom
<   %or.cond = and i1 %21, %22
<   %23 = icmp ne %struct.MemoryRegion* %1, @io_mem_unassigned
<   %or.cond3 = and i1 %or.cond, %23
<   %24 = icmp ne %struct.MemoryRegion* %1, @io_mem_notdirty
<   %or.cond5 = and i1 %or.cond3, %24
<   %25 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not = xor i1 %or.cond5, true
<   %26 = load i32* @use_icount, align 4
<   %27 = icmp eq i32 %26, 0
<   %or.cond26 = or i1 %27, %or.cond5.not
<   br i1 %or.cond26, label %can_do_io.exit.thread, label %28
---
> ; <label>:55                                      ; preds = %52
>   %56 = load i64* %bSig, align 8
>   %57 = icmp eq i64 %56, 0
>   br i1 %57, label %58, label %60
> 
> ; <label>:58                                      ; preds = %55
>   %59 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %59)
>   store i64 -2251799813685248, i64* %1
>   br label %215
17221,17225c14443,14446
< ; <label>:28                                      ; preds = %17
<   %29 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 66
<   %30 = load %struct.TranslationBlock** %29, align 8
<   %31 = icmp eq %struct.TranslationBlock* %30, null
<   br i1 %31, label %can_do_io.exit.thread, label %can_do_io.exit
---
> ; <label>:60                                      ; preds = %55
>   %61 = load i64* %bSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %61, i32* %bExp, i64* %bSig)
>   br label %62
17227,17231c14448,14451
< can_do_io.exit:                                   ; preds = %28
<   %32 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 85
<   %33 = load i32* %32, align 4
<   %34 = icmp eq i32 %33, 0
<   br i1 %34, label %35, label %can_do_io.exit.thread
---
> ; <label>:62                                      ; preds = %60, %52
>   %63 = load i32* %aExp, align 4
>   %64 = icmp eq i32 %63, 0
>   br i1 %64, label %65, label %72
17233,17235c14453,14456
< ; <label>:35                                      ; preds = %can_do_io.exit
<   call void @cpu_io_recompile(%struct.CPUX86State* %25, i8* %retaddr) noreturn nounwind
<   unreachable
---
> ; <label>:65                                      ; preds = %62
>   %66 = load i64* %aSig, align 8
>   %67 = icmp eq i64 %66, 0
>   br i1 %67, label %68, label %70
17237,17242c14458,14510
< can_do_io.exit.thread:                            ; preds = %can_do_io.exit, %28, %17
<   %36 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 69
<   store i32 %addr, i32* %36, align 4
<   %37 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %1, i32 0) nounwind
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %66, label %39
---
> ; <label>:68                                      ; preds = %65
>   %69 = load i64* %2, align 8
>   store i64 %69, i64* %1
>   br label %215
> 
> ; <label>:70                                      ; preds = %65
>   %71 = load i64* %aSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %71, i32* %aExp, i64* %aSig)
>   br label %72
> 
> ; <label>:72                                      ; preds = %70, %62
>   %73 = load i32* %aExp, align 4
>   %74 = load i32* %bExp, align 4
>   %75 = sub nsw i32 %73, %74
>   store i32 %75, i32* %expDiff, align 4
>   %76 = load i64* %aSig, align 8
>   %77 = or i64 %76, 4503599627370496
>   %78 = shl i64 %77, 11
>   store i64 %78, i64* %aSig, align 8
>   %79 = load i64* %bSig, align 8
>   %80 = or i64 %79, 4503599627370496
>   %81 = shl i64 %80, 11
>   store i64 %81, i64* %bSig, align 8
>   %82 = load i32* %expDiff, align 4
>   %83 = icmp slt i32 %82, 0
>   br i1 %83, label %84, label %92
> 
> ; <label>:84                                      ; preds = %72
>   %85 = load i32* %expDiff, align 4
>   %86 = icmp slt i32 %85, -1
>   br i1 %86, label %87, label %89
> 
> ; <label>:87                                      ; preds = %84
>   %88 = load i64* %2, align 8
>   store i64 %88, i64* %1
>   br label %215
> 
> ; <label>:89                                      ; preds = %84
>   %90 = load i64* %aSig, align 8
>   %91 = lshr i64 %90, 1
>   store i64 %91, i64* %aSig, align 8
>   br label %92
> 
> ; <label>:92                                      ; preds = %89, %72
>   %93 = load i64* %bSig, align 8
>   %94 = load i64* %aSig, align 8
>   %95 = icmp ule i64 %93, %94
>   %96 = zext i1 %95 to i32
>   %97 = sext i32 %96 to i64
>   store i64 %97, i64* %q, align 8
>   %98 = load i64* %q, align 8
>   %99 = icmp ne i64 %98, 0
>   br i1 %99, label %100, label %104
17244,17247c14512,14609
< ; <label>:39                                      ; preds = %can_do_io.exit.thread
<   %40 = call i64 @s2e_notdirty_mem_write(i64 %physaddr) nounwind
<   %41 = icmp eq i32 %isSymb.0, 0
<   br i1 %41, label %63, label %42
---
> ; <label>:100                                     ; preds = %92
>   %101 = load i64* %bSig, align 8
>   %102 = load i64* %aSig, align 8
>   %103 = sub i64 %102, %101
>   store i64 %103, i64* %aSig, align 8
>   br label %104
> 
> ; <label>:104                                     ; preds = %100, %92
>   %105 = load i32* %expDiff, align 4
>   %106 = sub nsw i32 %105, 64
>   store i32 %106, i32* %expDiff, align 4
>   br label %107
> 
> ; <label>:107                                     ; preds = %120, %104
>   %108 = load i32* %expDiff, align 4
>   %109 = icmp slt i32 0, %108
>   br i1 %109, label %110, label %129
> 
> ; <label>:110                                     ; preds = %107
>   %111 = load i64* %aSig, align 8
>   %112 = load i64* %bSig, align 8
>   %113 = call i64 @estimateDiv128To64(i64 %111, i64 0, i64 %112)
>   store i64 %113, i64* %q, align 8
>   %114 = load i64* %q, align 8
>   %115 = icmp ult i64 2, %114
>   br i1 %115, label %116, label %119
> 
> ; <label>:116                                     ; preds = %110
>   %117 = load i64* %q, align 8
>   %118 = sub i64 %117, 2
>   br label %120
> 
> ; <label>:119                                     ; preds = %110
>   br label %120
> 
> ; <label>:120                                     ; preds = %119, %116
>   %121 = phi i64 [ %118, %116 ], [ 0, %119 ]
>   store i64 %121, i64* %q, align 8
>   %122 = load i64* %bSig, align 8
>   %123 = lshr i64 %122, 2
>   %124 = load i64* %q, align 8
>   %125 = mul i64 %123, %124
>   %126 = sub i64 0, %125
>   store i64 %126, i64* %aSig, align 8
>   %127 = load i32* %expDiff, align 4
>   %128 = sub nsw i32 %127, 62
>   store i32 %128, i32* %expDiff, align 4
>   br label %107
> 
> ; <label>:129                                     ; preds = %107
>   %130 = load i32* %expDiff, align 4
>   %131 = add nsw i32 %130, 64
>   store i32 %131, i32* %expDiff, align 4
>   %132 = load i32* %expDiff, align 4
>   %133 = icmp slt i32 0, %132
>   br i1 %133, label %134, label %163
> 
> ; <label>:134                                     ; preds = %129
>   %135 = load i64* %aSig, align 8
>   %136 = load i64* %bSig, align 8
>   %137 = call i64 @estimateDiv128To64(i64 %135, i64 0, i64 %136)
>   store i64 %137, i64* %q, align 8
>   %138 = load i64* %q, align 8
>   %139 = icmp ult i64 2, %138
>   br i1 %139, label %140, label %143
> 
> ; <label>:140                                     ; preds = %134
>   %141 = load i64* %q, align 8
>   %142 = sub i64 %141, 2
>   br label %144
> 
> ; <label>:143                                     ; preds = %134
>   br label %144
> 
> ; <label>:144                                     ; preds = %143, %140
>   %145 = phi i64 [ %142, %140 ], [ 0, %143 ]
>   store i64 %145, i64* %q, align 8
>   %146 = load i32* %expDiff, align 4
>   %147 = sub nsw i32 64, %146
>   %148 = load i64* %q, align 8
>   %149 = zext i32 %147 to i64
>   %150 = lshr i64 %148, %149
>   store i64 %150, i64* %q, align 8
>   %151 = load i64* %bSig, align 8
>   %152 = lshr i64 %151, 2
>   store i64 %152, i64* %bSig, align 8
>   %153 = load i64* %aSig, align 8
>   %154 = lshr i64 %153, 1
>   %155 = load i32* %expDiff, align 4
>   %156 = sub nsw i32 %155, 1
>   %157 = zext i32 %156 to i64
>   %158 = shl i64 %154, %157
>   %159 = load i64* %bSig, align 8
>   %160 = load i64* %q, align 8
>   %161 = mul i64 %159, %160
>   %162 = sub i64 %158, %161
>   store i64 %162, i64* %aSig, align 8
>   br label %168
17249,17258c14611,14618
< ; <label>:42                                      ; preds = %39
<   %43 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %44 = inttoptr i64 %40 to i16*
<   %45 = load i16* %44, align 2
<   %data.i.sroa.0.0.extract.trunc = trunc i16 %45 to i8
<   %data.i.sroa.1.1.extract.shift = lshr i16 %45, 8
<   %data.i.sroa.1.1.extract.trunc = trunc i16 %data.i.sroa.1.1.extract.shift to i8
<   %46 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %47 = icmp eq i32 %46, 0
<   br i1 %47, label %io_read_chk_symb_w.exit, label %48
---
> ; <label>:163                                     ; preds = %129
>   %164 = load i64* %aSig, align 8
>   %165 = lshr i64 %164, 2
>   store i64 %165, i64* %aSig, align 8
>   %166 = load i64* %bSig, align 8
>   %167 = lshr i64 %166, 2
>   store i64 %167, i64* %bSig, align 8
>   br label %168
17260,17282c14620,14621
< ; <label>:48                                      ; preds = %42
<   %49 = and i64 %4, 4294967295
<   %50 = call i32 @s2e_is_mmio_symbolic_b(i64 %49) nounwind
<   %51 = icmp eq i32 %50, 0
<   br i1 %51, label %._crit_edge8.i, label %52
< 
< ; <label>:52                                      ; preds = %48
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i, i32 1, i8* %43) nounwind
<   %53 = load i8* %ret.i.i, align 1
<   br label %._crit_edge8.i
< 
< ._crit_edge8.i:                                   ; preds = %52, %48
<   %data.i.sroa.0.0.extract.trunc23 = phi i8 [ %53, %52 ], [ %data.i.sroa.0.0.extract.trunc, %48 ]
<   %.pr.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %54 = icmp eq i32 %.pr.i, 0
<   br i1 %54, label %io_read_chk_symb_w.exit, label %55
< 
< ; <label>:55                                      ; preds = %._crit_edge8.i
<   %56 = add i64 %4, 1
<   %57 = and i64 %56, 4294967295
<   %58 = call i32 @s2e_is_mmio_symbolic_b(i64 %57) nounwind
<   %59 = icmp eq i32 %58, 0
<   br i1 %59, label %io_read_chk_symb_w.exit, label %60
---
> ; <label>:168                                     ; preds = %163, %144
>   br label %169
17284,17296c14623,14633
< ; <label>:60                                      ; preds = %55
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i, i32 1, i8* %43) nounwind
<   %61 = load i8* %ret.i.i, align 1
<   br label %io_read_chk_symb_w.exit
< 
< io_read_chk_symb_w.exit:                          ; preds = %60, %55, %._crit_edge8.i, %42
<   %62 = phi i8 [ %data.i.sroa.1.1.extract.trunc, %42 ], [ %data.i.sroa.1.1.extract.trunc, %._crit_edge8.i ], [ %data.i.sroa.1.1.extract.trunc, %55 ], [ %61, %60 ]
<   %data.i.sroa.0.0.extract.trunc24 = phi i8 [ %data.i.sroa.0.0.extract.trunc, %42 ], [ %data.i.sroa.0.0.extract.trunc23, %._crit_edge8.i ], [ %data.i.sroa.0.0.extract.trunc23, %55 ], [ %data.i.sroa.0.0.extract.trunc23, %60 ]
<   %data.i.sroa.1.1.insert.ext = zext i8 %62 to i16
<   %data.i.sroa.1.1.insert.shift = shl nuw i16 %data.i.sroa.1.1.insert.ext, 8
<   %data.i.sroa.0.0.insert.ext = zext i8 %data.i.sroa.0.0.extract.trunc24 to i16
<   %data.i.sroa.0.0.insert.insert = or i16 %data.i.sroa.1.1.insert.shift, %data.i.sroa.0.0.insert.ext
<   br label %68
---
> ; <label>:169                                     ; preds = %176, %168
>   %170 = load i64* %aSig, align 8
>   store i64 %170, i64* %alternateASig, align 8
>   %171 = load i64* %q, align 8
>   %172 = add i64 %171, 1
>   store i64 %172, i64* %q, align 8
>   %173 = load i64* %bSig, align 8
>   %174 = load i64* %aSig, align 8
>   %175 = sub i64 %174, %173
>   store i64 %175, i64* %aSig, align 8
>   br label %176
17298,17301c14635,14778
< ; <label>:63                                      ; preds = %39
<   %64 = inttoptr i64 %40 to i16*
<   %65 = load i16* %64, align 2
<   br label %68
---
> ; <label>:176                                     ; preds = %169
>   %177 = load i64* %aSig, align 8
>   %178 = icmp sle i64 0, %177
>   br i1 %178, label %169, label %179
> 
> ; <label>:179                                     ; preds = %176
>   %180 = load i64* %aSig, align 8
>   %181 = load i64* %alternateASig, align 8
>   %182 = add i64 %180, %181
>   store i64 %182, i64* %sigMean, align 8
>   %183 = load i64* %sigMean, align 8
>   %184 = icmp slt i64 %183, 0
>   br i1 %184, label %192, label %185
> 
> ; <label>:185                                     ; preds = %179
>   %186 = load i64* %sigMean, align 8
>   %187 = icmp eq i64 %186, 0
>   br i1 %187, label %188, label %194
> 
> ; <label>:188                                     ; preds = %185
>   %189 = load i64* %q, align 8
>   %190 = and i64 %189, 1
>   %191 = icmp ne i64 %190, 0
>   br i1 %191, label %192, label %194
> 
> ; <label>:192                                     ; preds = %188, %179
>   %193 = load i64* %alternateASig, align 8
>   store i64 %193, i64* %aSig, align 8
>   br label %194
> 
> ; <label>:194                                     ; preds = %192, %188, %185
>   %195 = load i64* %aSig, align 8
>   %196 = icmp slt i64 %195, 0
>   %197 = zext i1 %196 to i32
>   %198 = trunc i32 %197 to i8
>   store i8 %198, i8* %zSign, align 1
>   %199 = load i8* %zSign, align 1
>   %200 = icmp ne i8 %199, 0
>   br i1 %200, label %201, label %204
> 
> ; <label>:201                                     ; preds = %194
>   %202 = load i64* %aSig, align 8
>   %203 = sub i64 0, %202
>   store i64 %203, i64* %aSig, align 8
>   br label %204
> 
> ; <label>:204                                     ; preds = %201, %194
>   %205 = load i8* %aSign, align 1
>   %206 = zext i8 %205 to i32
>   %207 = load i8* %zSign, align 1
>   %208 = zext i8 %207 to i32
>   %209 = xor i32 %206, %208
>   %210 = trunc i32 %209 to i8
>   %211 = load i32* %bExp, align 4
>   %212 = load i64* %aSig, align 8
>   %213 = load %struct.float_status** %4, align 4
>   %214 = call i64 @normalizeRoundAndPackFloat64(i8 zeroext %210, i32 %211, i64 %212, %struct.float_status* %213)
>   store i64 %214, i64* %1
>   br label %215
> 
> ; <label>:215                                     ; preds = %204, %87, %68, %58, %50, %45, %37, %32
>   %216 = load i64* %1
>   ret i64 %216
> }
> 
> define internal i64 @float64_muladd(i64 %a, i64 %b, i64 %c, i32 %flags, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca i32, align 4
>   %6 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %cSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %cExp = alloca i32, align 4
>   %pExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %expDiff = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %cSig = alloca i64, align 8
>   %pInf = alloca i8, align 1
>   %pZero = alloca i8, align 1
>   %pSign = alloca i8, align 1
>   %pSig0 = alloca i64, align 8
>   %pSig1 = alloca i64, align 8
>   %cSig0 = alloca i64, align 8
>   %cSig1 = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %shiftcount = alloca i32, align 4
>   %signflip = alloca i8, align 1
>   %infzero = alloca i8, align 1
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store i64 %c, i64* %4, align 8
>   store i32 %flags, i32* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %6, align 4
>   %7 = load i64* %2, align 8
>   %8 = load %struct.float_status** %6, align 4
>   %9 = call i64 @float64_squash_input_denormal(i64 %7, %struct.float_status* %8)
>   store i64 %9, i64* %2, align 8
>   %10 = load i64* %3, align 8
>   %11 = load %struct.float_status** %6, align 4
>   %12 = call i64 @float64_squash_input_denormal(i64 %10, %struct.float_status* %11)
>   store i64 %12, i64* %3, align 8
>   %13 = load i64* %4, align 8
>   %14 = load %struct.float_status** %6, align 4
>   %15 = call i64 @float64_squash_input_denormal(i64 %13, %struct.float_status* %14)
>   store i64 %15, i64* %4, align 8
>   %16 = load i64* %2, align 8
>   %17 = call i64 @extractFloat64Frac(i64 %16)
>   store i64 %17, i64* %aSig, align 8
>   %18 = load i64* %2, align 8
>   %19 = call i32 @extractFloat64Exp(i64 %18)
>   store i32 %19, i32* %aExp, align 4
>   %20 = load i64* %2, align 8
>   %21 = call zeroext i8 @extractFloat64Sign(i64 %20)
>   store i8 %21, i8* %aSign, align 1
>   %22 = load i64* %3, align 8
>   %23 = call i64 @extractFloat64Frac(i64 %22)
>   store i64 %23, i64* %bSig, align 8
>   %24 = load i64* %3, align 8
>   %25 = call i32 @extractFloat64Exp(i64 %24)
>   store i32 %25, i32* %bExp, align 4
>   %26 = load i64* %3, align 8
>   %27 = call zeroext i8 @extractFloat64Sign(i64 %26)
>   store i8 %27, i8* %bSign, align 1
>   %28 = load i64* %4, align 8
>   %29 = call i64 @extractFloat64Frac(i64 %28)
>   store i64 %29, i64* %cSig, align 8
>   %30 = load i64* %4, align 8
>   %31 = call i32 @extractFloat64Exp(i64 %30)
>   store i32 %31, i32* %cExp, align 4
>   %32 = load i64* %4, align 8
>   %33 = call zeroext i8 @extractFloat64Sign(i64 %32)
>   store i8 %33, i8* %cSign, align 1
>   %34 = load i32* %aExp, align 4
>   %35 = icmp eq i32 %34, 0
>   br i1 %35, label %36, label %45
17303,17305c14780,14783
< ; <label>:66                                      ; preds = %can_do_io.exit.thread
<   %67 = call zeroext i16 @io_readw_mmu(i64 %physaddr, i32 %addr, i8* %retaddr) nounwind
<   br label %68
---
> ; <label>:36                                      ; preds = %0
>   %37 = load i64* %aSig, align 8
>   %38 = icmp eq i64 %37, 0
>   br i1 %38, label %39, label %45
17307,17310c14785,14788
< ; <label>:68                                      ; preds = %66, %63, %io_read_chk_symb_w.exit
<   %.0 = phi i16 [ %data.i.sroa.0.0.insert.insert, %io_read_chk_symb_w.exit ], [ %65, %63 ], [ %67, %66 ]
<   ret i16 %.0
< }
---
> ; <label>:39                                      ; preds = %36
>   %40 = load i32* %bExp, align 4
>   %41 = icmp eq i32 %40, 2047
>   br i1 %41, label %42, label %45
17312c14790,14803
< declare i32 @s2e_is_mmio_symbolic_w(i64)
---
> ; <label>:42                                      ; preds = %39
>   %43 = load i64* %bSig, align 8
>   %44 = icmp eq i64 %43, 0
>   br i1 %44, label %59, label %45
> 
> ; <label>:45                                      ; preds = %42, %39, %36, %0
>   %46 = load i32* %aExp, align 4
>   %47 = icmp eq i32 %46, 2047
>   br i1 %47, label %48, label %57
> 
> ; <label>:48                                      ; preds = %45
>   %49 = load i64* %aSig, align 8
>   %50 = icmp eq i64 %49, 0
>   br i1 %50, label %51, label %57
17314c14805,14808
< declare zeroext i16 @io_readw_mmu(i64, i32, i8*)
---
> ; <label>:51                                      ; preds = %48
>   %52 = load i32* %bExp, align 4
>   %53 = icmp eq i32 %52, 0
>   br i1 %53, label %54, label %57
17316,17322c14810,14813
< define zeroext i16 @__ldw_mmu(i32 %addr, i32 %mmu_idx) nounwind uwtable {
<   %ret.i.i.i = alloca i8, align 1
<   %label.i = alloca [64 x i8], align 16
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %addr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:54                                      ; preds = %51
>   %55 = load i64* %bSig, align 8
>   %56 = icmp eq i64 %55, 0
>   br label %57
17324,17326c14815,14817
< ; <label>:4                                       ; preds = %0
<   %5 = call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:57                                      ; preds = %54, %51, %48, %45
>   %58 = phi i1 [ false, %51 ], [ false, %48 ], [ false, %45 ], [ %56, %54 ]
>   br label %59
17328,17343c14819,14846
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = sext i32 %mmu_idx to i64
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %17 = load i32* %16, align 4
<   %18 = and i32 %8, -4096
<   %19 = and i32 %17, -4088
<   %20 = icmp eq i32 %18, %19
<   br i1 %20, label %._crit_edge, label %.lr.ph, !prof !0
---
> ; <label>:59                                      ; preds = %57, %42
>   %60 = phi i1 [ true, %42 ], [ %58, %57 ]
>   %61 = zext i1 %60 to i32
>   %62 = trunc i32 %61 to i8
>   store i8 %62, i8* %infzero, align 1
>   %63 = load i32* %aExp, align 4
>   %64 = icmp eq i32 %63, 2047
>   br i1 %64, label %65, label %68
> 
> ; <label>:65                                      ; preds = %59
>   %66 = load i64* %aSig, align 8
>   %67 = icmp ne i64 %66, 0
>   br i1 %67, label %80, label %68
> 
> ; <label>:68                                      ; preds = %65, %59
>   %69 = load i32* %bExp, align 4
>   %70 = icmp eq i32 %69, 2047
>   br i1 %70, label %71, label %74
> 
> ; <label>:71                                      ; preds = %68
>   %72 = load i64* %bSig, align 8
>   %73 = icmp ne i64 %72, 0
>   br i1 %73, label %80, label %74
> 
> ; <label>:74                                      ; preds = %71, %68
>   %75 = load i32* %cExp, align 4
>   %76 = icmp eq i32 %75, 2047
>   br i1 %76, label %77, label %87
17345,17348c14848,14913
< .lr.ph:                                           ; preds = %6
<   %21 = trunc i64 %11 to i32
<   %22 = shl i32 %21, 7
<   br label %109
---
> ; <label>:77                                      ; preds = %74
>   %78 = load i64* %cSig, align 8
>   %79 = icmp ne i64 %78, 0
>   br i1 %79, label %80, label %87
> 
> ; <label>:80                                      ; preds = %77, %71, %65
>   %81 = load i64* %2, align 8
>   %82 = load i64* %3, align 8
>   %83 = load i64* %4, align 8
>   %84 = load i8* %infzero, align 1
>   %85 = load %struct.float_status** %6, align 4
>   %86 = call i64 @propagateFloat64MulAddNaN(i64 %81, i64 %82, i64 %83, i8 zeroext %84, %struct.float_status* %85)
>   store i64 %86, i64* %1
>   br label %460
> 
> ; <label>:87                                      ; preds = %77, %74
>   %88 = load i8* %infzero, align 1
>   %89 = icmp ne i8 %88, 0
>   br i1 %89, label %90, label %92
> 
> ; <label>:90                                      ; preds = %87
>   %91 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %91)
>   store i64 -2251799813685248, i64* %1
>   br label %460
> 
> ; <label>:92                                      ; preds = %87
>   %93 = load i32* %5, align 4
>   %94 = and i32 %93, 1
>   %95 = icmp ne i32 %94, 0
>   br i1 %95, label %96, label %101
> 
> ; <label>:96                                      ; preds = %92
>   %97 = load i8* %cSign, align 1
>   %98 = zext i8 %97 to i32
>   %99 = xor i32 %98, 1
>   %100 = trunc i32 %99 to i8
>   store i8 %100, i8* %cSign, align 1
>   br label %101
> 
> ; <label>:101                                     ; preds = %96, %92
>   %102 = load i32* %5, align 4
>   %103 = and i32 %102, 3
>   %104 = icmp ne i32 %103, 0
>   %105 = select i1 %104, i32 1, i32 0
>   %106 = trunc i32 %105 to i8
>   store i8 %106, i8* %signflip, align 1
>   %107 = load i8* %aSign, align 1
>   %108 = zext i8 %107 to i32
>   %109 = load i8* %bSign, align 1
>   %110 = zext i8 %109 to i32
>   %111 = xor i32 %108, %110
>   %112 = trunc i32 %111 to i8
>   store i8 %112, i8* %pSign, align 1
>   %113 = load i32* %5, align 4
>   %114 = and i32 %113, 2
>   %115 = icmp ne i32 %114, 0
>   br i1 %115, label %116, label %121
> 
> ; <label>:116                                     ; preds = %101
>   %117 = load i8* %pSign, align 1
>   %118 = zext i8 %117 to i32
>   %119 = xor i32 %118, 1
>   %120 = trunc i32 %119 to i8
>   store i8 %120, i8* %pSign, align 1
>   br label %121
17350,17355c14915,14943
< ._crit_edge:                                      ; preds = %109, %6
<   %.lcssa29 = phi i32 [ %17, %6 ], [ %113, %109 ]
<   %.lcssa28 = phi %struct.CPUX86State* [ %15, %6 ], [ %111, %109 ]
<   %23 = and i32 %.lcssa29, 4095
<   %24 = icmp eq i32 %23, 0
<   br i1 %24, label %95, label %25, !prof !0
---
> ; <label>:121                                     ; preds = %116, %101
>   %122 = load i32* %aExp, align 4
>   %123 = icmp eq i32 %122, 2047
>   br i1 %123, label %127, label %124
> 
> ; <label>:124                                     ; preds = %121
>   %125 = load i32* %bExp, align 4
>   %126 = icmp eq i32 %125, 2047
>   br label %127
> 
> ; <label>:127                                     ; preds = %124, %121
>   %128 = phi i1 [ true, %121 ], [ %126, %124 ]
>   %129 = zext i1 %128 to i32
>   %130 = trunc i32 %129 to i8
>   store i8 %130, i8* %pInf, align 1
>   %131 = load i32* %aExp, align 4
>   %132 = sext i32 %131 to i64
>   %133 = load i64* %aSig, align 8
>   %134 = or i64 %132, %133
>   %135 = icmp eq i64 %134, 0
>   br i1 %135, label %142, label %136
> 
> ; <label>:136                                     ; preds = %127
>   %137 = load i32* %bExp, align 4
>   %138 = sext i32 %137 to i64
>   %139 = load i64* %bSig, align 8
>   %140 = or i64 %138, %139
>   %141 = icmp eq i64 %140, 0
>   br label %142
17357,17360c14945,14967
< ; <label>:25                                      ; preds = %._crit_edge
<   %26 = and i32 %8, 1
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %28, label %99
---
> ; <label>:142                                     ; preds = %136, %127
>   %143 = phi i1 [ true, %127 ], [ %141, %136 ]
>   %144 = zext i1 %143 to i32
>   %145 = trunc i32 %144 to i8
>   store i8 %145, i8* %pZero, align 1
>   %146 = load i32* %cExp, align 4
>   %147 = icmp eq i32 %146, 2047
>   br i1 %147, label %148, label %169
> 
> ; <label>:148                                     ; preds = %142
>   %149 = load i8* %pInf, align 1
>   %150 = zext i8 %149 to i32
>   %151 = icmp ne i32 %150, 0
>   br i1 %151, label %152, label %161
> 
> ; <label>:152                                     ; preds = %148
>   %153 = load i8* %pSign, align 1
>   %154 = zext i8 %153 to i32
>   %155 = load i8* %cSign, align 1
>   %156 = zext i8 %155 to i32
>   %157 = xor i32 %154, %156
>   %158 = icmp ne i32 %157, 0
>   br i1 %158, label %159, label %161
17362,17373c14969,15036
< ; <label>:28                                      ; preds = %25
<   %29 = getelementptr inbounds %struct.CPUX86State* %.lcssa28, i64 0, i32 75, i64 %14, i64 %13
<   %30 = load i64* %29, align 8
<   %31 = getelementptr inbounds [64 x i8]* %label.i, i64 0, i64 0
<   %32 = call %struct.MemoryRegion* @iotlb_to_region(i64 %30) nounwind
<   %33 = and i64 %30, 4294963200
<   %34 = and i64 %7, 4294967295
<   %35 = add i64 %33, %34
<   %36 = trunc i64 %35 to i32
<   %37 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %47, label %39
---
> ; <label>:159                                     ; preds = %152
>   %160 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %160)
>   store i64 -2251799813685248, i64* %1
>   br label %460
> 
> ; <label>:161                                     ; preds = %152, %148
>   %162 = load i8* %cSign, align 1
>   %163 = zext i8 %162 to i32
>   %164 = load i8* %signflip, align 1
>   %165 = zext i8 %164 to i32
>   %166 = xor i32 %163, %165
>   %167 = trunc i32 %166 to i8
>   %168 = call i64 @packFloat64(i8 zeroext %167, i32 2047, i64 0)
>   store i64 %168, i64* %1
>   br label %460
> 
> ; <label>:169                                     ; preds = %142
>   %170 = load i8* %pInf, align 1
>   %171 = icmp ne i8 %170, 0
>   br i1 %171, label %172, label %180
> 
> ; <label>:172                                     ; preds = %169
>   %173 = load i8* %pSign, align 1
>   %174 = zext i8 %173 to i32
>   %175 = load i8* %signflip, align 1
>   %176 = zext i8 %175 to i32
>   %177 = xor i32 %174, %176
>   %178 = trunc i32 %177 to i8
>   %179 = call i64 @packFloat64(i8 zeroext %178, i32 2047, i64 0)
>   store i64 %179, i64* %1
>   br label %460
> 
> ; <label>:180                                     ; preds = %169
>   %181 = load i8* %pZero, align 1
>   %182 = icmp ne i8 %181, 0
>   br i1 %182, label %183, label %235
> 
> ; <label>:183                                     ; preds = %180
>   %184 = load i32* %cExp, align 4
>   %185 = icmp eq i32 %184, 0
>   br i1 %185, label %186, label %229
> 
> ; <label>:186                                     ; preds = %183
>   %187 = load i64* %cSig, align 8
>   %188 = icmp eq i64 %187, 0
>   br i1 %188, label %189, label %214
> 
> ; <label>:189                                     ; preds = %186
>   %190 = load i8* %pSign, align 1
>   %191 = zext i8 %190 to i32
>   %192 = load i8* %cSign, align 1
>   %193 = zext i8 %192 to i32
>   %194 = icmp eq i32 %191, %193
>   br i1 %194, label %195, label %197
> 
> ; <label>:195                                     ; preds = %189
>   %196 = load i8* %pSign, align 1
>   store i8 %196, i8* %zSign, align 1
>   br label %206
> 
> ; <label>:197                                     ; preds = %189
>   %198 = load %struct.float_status** %6, align 4
>   %199 = getelementptr inbounds %struct.float_status* %198, i32 0, i32 1
>   %200 = load i8* %199, align 1
>   %201 = sext i8 %200 to i32
>   %202 = icmp eq i32 %201, 1
>   br i1 %202, label %203, label %204
17375,17380c15038,15090
< ; <label>:39                                      ; preds = %28
<   %fold = add i64 %33, %7
<   %40 = and i64 %fold, 4294967295
<   %41 = call i32 @s2e_is_mmio_symbolic_w(i64 %40) nounwind
<   %42 = icmp eq i32 %41, 0
<   br i1 %42, label %47, label %43
---
> ; <label>:203                                     ; preds = %197
>   store i8 1, i8* %zSign, align 1
>   br label %205
> 
> ; <label>:204                                     ; preds = %197
>   store i8 0, i8* %zSign, align 1
>   br label %205
> 
> ; <label>:205                                     ; preds = %204, %203
>   br label %206
> 
> ; <label>:206                                     ; preds = %205, %195
>   %207 = load i8* %zSign, align 1
>   %208 = zext i8 %207 to i32
>   %209 = load i8* %signflip, align 1
>   %210 = zext i8 %209 to i32
>   %211 = xor i32 %208, %210
>   %212 = trunc i32 %211 to i8
>   %213 = call i64 @packFloat64(i8 zeroext %212, i32 0, i64 0)
>   store i64 %213, i64* %1
>   br label %460
> 
> ; <label>:214                                     ; preds = %186
>   %215 = load %struct.float_status** %6, align 4
>   %216 = getelementptr inbounds %struct.float_status* %215, i32 0, i32 4
>   %217 = load i8* %216, align 1
>   %218 = icmp ne i8 %217, 0
>   br i1 %218, label %219, label %228
> 
> ; <label>:219                                     ; preds = %214
>   %220 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext -128, %struct.float_status* %220)
>   %221 = load i8* %cSign, align 1
>   %222 = zext i8 %221 to i32
>   %223 = load i8* %signflip, align 1
>   %224 = zext i8 %223 to i32
>   %225 = xor i32 %222, %224
>   %226 = trunc i32 %225 to i8
>   %227 = call i64 @packFloat64(i8 zeroext %226, i32 0, i64 0)
>   store i64 %227, i64* %1
>   br label %460
> 
> ; <label>:228                                     ; preds = %214
>   br label %229
> 
> ; <label>:229                                     ; preds = %228, %183
>   %230 = load i64* %4, align 8
>   %231 = load i8* %signflip, align 1
>   %232 = zext i8 %231 to i64
>   %233 = shl i64 %232, 63
>   %234 = xor i64 %230, %233
>   store i64 %234, i64* %1
>   br label %460
17382,17387c15092,15095
< ; <label>:43                                      ; preds = %39
<   %44 = load %struct.CPUX86State** @env, align 8
<   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 5
<   %46 = load i32* %45, align 4
<   call void @trace_port(i8* %31, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %36, i32 %46) nounwind
<   br label %47
---
> ; <label>:235                                     ; preds = %180
>   %236 = load i32* %aExp, align 4
>   %237 = icmp eq i32 %236, 0
>   br i1 %237, label %238, label %240
17389,17406c15097,15100
< ; <label>:47                                      ; preds = %43, %39, %28
<   %isSymb.0.i = phi i32 [ %41, %43 ], [ 0, %39 ], [ 0, %28 ]
<   %48 = load %struct.CPUX86State** @env, align 8
<   %49 = getelementptr inbounds %struct.CPUX86State* %48, i64 0, i32 68
<   store i64 0, i64* %49, align 8
<   %50 = icmp ne %struct.MemoryRegion* %32, @io_mem_ram
<   %51 = icmp ne %struct.MemoryRegion* %32, @io_mem_rom
<   %or.cond.i = and i1 %50, %51
<   %52 = icmp ne %struct.MemoryRegion* %32, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %52
<   %53 = icmp ne %struct.MemoryRegion* %32, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %53
<   %54 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %55 = load i32* @use_icount, align 4
<   %56 = icmp eq i32 %55, 0
<   %or.cond26.i = or i1 %56, %or.cond5.not.i
<   br i1 %or.cond26.i, label %can_do_io.exit.thread.i, label %57
---
> ; <label>:238                                     ; preds = %235
>   %239 = load i64* %aSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %239, i32* %aExp, i64* %aSig)
>   br label %240
17408,17412c15102,15105
< ; <label>:57                                      ; preds = %47
<   %58 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 66
<   %59 = load %struct.TranslationBlock** %58, align 8
<   %60 = icmp eq %struct.TranslationBlock* %59, null
<   br i1 %60, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:240                                     ; preds = %238, %235
>   %241 = load i32* %bExp, align 4
>   %242 = icmp eq i32 %241, 0
>   br i1 %242, label %243, label %245
17414,17418c15107,15110
< can_do_io.exit.i:                                 ; preds = %57
<   %61 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 85
<   %62 = load i32* %61, align 4
<   %63 = icmp eq i32 %62, 0
<   br i1 %63, label %64, label %can_do_io.exit.thread.i
---
> ; <label>:243                                     ; preds = %240
>   %244 = load i64* %bSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %244, i32* %bExp, i64* %bSig)
>   br label %245
17420,17422c15112,15505
< ; <label>:64                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %54, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:245                                     ; preds = %243, %240
>   %246 = load i32* %aExp, align 4
>   %247 = load i32* %bExp, align 4
>   %248 = add nsw i32 %246, %247
>   %249 = sub nsw i32 %248, 1022
>   store i32 %249, i32* %pExp, align 4
>   %250 = load i64* %aSig, align 8
>   %251 = or i64 %250, 4503599627370496
>   %252 = shl i64 %251, 10
>   store i64 %252, i64* %aSig, align 8
>   %253 = load i64* %bSig, align 8
>   %254 = or i64 %253, 4503599627370496
>   %255 = shl i64 %254, 11
>   store i64 %255, i64* %bSig, align 8
>   %256 = load i64* %aSig, align 8
>   %257 = load i64* %bSig, align 8
>   call void @mul64To128(i64 %256, i64 %257, i64* %pSig0, i64* %pSig1)
>   %258 = load i64* %pSig0, align 8
>   %259 = shl i64 %258, 1
>   %260 = icmp sge i64 %259, 0
>   br i1 %260, label %261, label %266
> 
> ; <label>:261                                     ; preds = %245
>   %262 = load i64* %pSig0, align 8
>   %263 = load i64* %pSig1, align 8
>   call void @shortShift128Left(i64 %262, i64 %263, i32 1, i64* %pSig0, i64* %pSig1)
>   %264 = load i32* %pExp, align 4
>   %265 = add nsw i32 %264, -1
>   store i32 %265, i32* %pExp, align 4
>   br label %266
> 
> ; <label>:266                                     ; preds = %261, %245
>   %267 = load i8* %pSign, align 1
>   %268 = zext i8 %267 to i32
>   %269 = load i8* %signflip, align 1
>   %270 = zext i8 %269 to i32
>   %271 = xor i32 %268, %270
>   %272 = trunc i32 %271 to i8
>   store i8 %272, i8* %zSign, align 1
>   %273 = load i32* %cExp, align 4
>   %274 = icmp eq i32 %273, 0
>   br i1 %274, label %275, label %289
> 
> ; <label>:275                                     ; preds = %266
>   %276 = load i64* %cSig, align 8
>   %277 = icmp ne i64 %276, 0
>   br i1 %277, label %287, label %278
> 
> ; <label>:278                                     ; preds = %275
>   %279 = load i64* %pSig0, align 8
>   %280 = load i64* %pSig1, align 8
>   call void @shift128RightJamming(i64 %279, i64 %280, i32 64, i64* %pSig0, i64* %pSig1)
>   %281 = load i8* %zSign, align 1
>   %282 = load i32* %pExp, align 4
>   %283 = sub nsw i32 %282, 1
>   %284 = load i64* %pSig1, align 8
>   %285 = load %struct.float_status** %6, align 4
>   %286 = call i64 @roundAndPackFloat64(i8 zeroext %281, i32 %283, i64 %284, %struct.float_status* %285)
>   store i64 %286, i64* %1
>   br label %460
> 
> ; <label>:287                                     ; preds = %275
>   %288 = load i64* %cSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %288, i32* %cExp, i64* %cSig)
>   br label %289
> 
> ; <label>:289                                     ; preds = %287, %266
>   %290 = load i64* %cSig, align 8
>   %291 = shl i64 %290, 10
>   store i64 %291, i64* %cSig0, align 8
>   store i64 0, i64* %cSig1, align 8
>   %292 = load i64* %cSig0, align 8
>   %293 = or i64 %292, 4611686018427387904
>   store i64 %293, i64* %cSig0, align 8
>   %294 = load i32* %pExp, align 4
>   %295 = load i32* %cExp, align 4
>   %296 = sub nsw i32 %294, %295
>   store i32 %296, i32* %expDiff, align 4
>   %297 = load i8* %pSign, align 1
>   %298 = zext i8 %297 to i32
>   %299 = load i8* %cSign, align 1
>   %300 = zext i8 %299 to i32
>   %301 = icmp eq i32 %298, %300
>   br i1 %301, label %302, label %343
> 
> ; <label>:302                                     ; preds = %289
>   %303 = load i32* %expDiff, align 4
>   %304 = icmp sgt i32 %303, 0
>   br i1 %304, label %305, label %310
> 
> ; <label>:305                                     ; preds = %302
>   %306 = load i64* %cSig0, align 8
>   %307 = load i64* %cSig1, align 8
>   %308 = load i32* %expDiff, align 4
>   call void @shift128RightJamming(i64 %306, i64 %307, i32 %308, i64* %cSig0, i64* %cSig1)
>   %309 = load i32* %pExp, align 4
>   store i32 %309, i32* %zExp, align 4
>   br label %322
> 
> ; <label>:310                                     ; preds = %302
>   %311 = load i32* %expDiff, align 4
>   %312 = icmp slt i32 %311, 0
>   br i1 %312, label %313, label %319
> 
> ; <label>:313                                     ; preds = %310
>   %314 = load i64* %pSig0, align 8
>   %315 = load i64* %pSig1, align 8
>   %316 = load i32* %expDiff, align 4
>   %317 = sub nsw i32 0, %316
>   call void @shift128RightJamming(i64 %314, i64 %315, i32 %317, i64* %pSig0, i64* %pSig1)
>   %318 = load i32* %cExp, align 4
>   store i32 %318, i32* %zExp, align 4
>   br label %321
> 
> ; <label>:319                                     ; preds = %310
>   %320 = load i32* %cExp, align 4
>   store i32 %320, i32* %zExp, align 4
>   br label %321
> 
> ; <label>:321                                     ; preds = %319, %313
>   br label %322
> 
> ; <label>:322                                     ; preds = %321, %305
>   %323 = load i64* %pSig0, align 8
>   %324 = load i64* %pSig1, align 8
>   %325 = load i64* %cSig0, align 8
>   %326 = load i64* %cSig1, align 8
>   call void @add128(i64 %323, i64 %324, i64 %325, i64 %326, i64* %zSig0, i64* %zSig1)
>   %327 = load i64* %zSig0, align 8
>   %328 = icmp slt i64 %327, 0
>   br i1 %328, label %329, label %332
> 
> ; <label>:329                                     ; preds = %322
>   %330 = load i64* %zSig0, align 8
>   %331 = load i64* %zSig1, align 8
>   call void @shift128RightJamming(i64 %330, i64 %331, i32 1, i64* %zSig0, i64* %zSig1)
>   br label %335
> 
> ; <label>:332                                     ; preds = %322
>   %333 = load i32* %zExp, align 4
>   %334 = add nsw i32 %333, -1
>   store i32 %334, i32* %zExp, align 4
>   br label %335
> 
> ; <label>:335                                     ; preds = %332, %329
>   %336 = load i64* %zSig0, align 8
>   %337 = load i64* %zSig1, align 8
>   call void @shift128RightJamming(i64 %336, i64 %337, i32 64, i64* %zSig0, i64* %zSig1)
>   %338 = load i8* %zSign, align 1
>   %339 = load i32* %zExp, align 4
>   %340 = load i64* %zSig1, align 8
>   %341 = load %struct.float_status** %6, align 4
>   %342 = call i64 @roundAndPackFloat64(i8 zeroext %338, i32 %339, i64 %340, %struct.float_status* %341)
>   store i64 %342, i64* %1
>   br label %460
> 
> ; <label>:343                                     ; preds = %289
>   %344 = load i32* %expDiff, align 4
>   %345 = icmp sgt i32 %344, 0
>   br i1 %345, label %346, label %355
> 
> ; <label>:346                                     ; preds = %343
>   %347 = load i64* %cSig0, align 8
>   %348 = load i64* %cSig1, align 8
>   %349 = load i32* %expDiff, align 4
>   call void @shift128RightJamming(i64 %347, i64 %348, i32 %349, i64* %cSig0, i64* %cSig1)
>   %350 = load i64* %pSig0, align 8
>   %351 = load i64* %pSig1, align 8
>   %352 = load i64* %cSig0, align 8
>   %353 = load i64* %cSig1, align 8
>   call void @sub128(i64 %350, i64 %351, i64 %352, i64 %353, i64* %zSig0, i64* %zSig1)
>   %354 = load i32* %pExp, align 4
>   store i32 %354, i32* %zExp, align 4
>   br label %419
> 
> ; <label>:355                                     ; preds = %343
>   %356 = load i32* %expDiff, align 4
>   %357 = icmp slt i32 %356, 0
>   br i1 %357, label %358, label %372
> 
> ; <label>:358                                     ; preds = %355
>   %359 = load i64* %pSig0, align 8
>   %360 = load i64* %pSig1, align 8
>   %361 = load i32* %expDiff, align 4
>   %362 = sub nsw i32 0, %361
>   call void @shift128RightJamming(i64 %359, i64 %360, i32 %362, i64* %pSig0, i64* %pSig1)
>   %363 = load i64* %cSig0, align 8
>   %364 = load i64* %cSig1, align 8
>   %365 = load i64* %pSig0, align 8
>   %366 = load i64* %pSig1, align 8
>   call void @sub128(i64 %363, i64 %364, i64 %365, i64 %366, i64* %zSig0, i64* %zSig1)
>   %367 = load i32* %cExp, align 4
>   store i32 %367, i32* %zExp, align 4
>   %368 = load i8* %zSign, align 1
>   %369 = zext i8 %368 to i32
>   %370 = xor i32 %369, 1
>   %371 = trunc i32 %370 to i8
>   store i8 %371, i8* %zSign, align 1
>   br label %418
> 
> ; <label>:372                                     ; preds = %355
>   %373 = load i32* %pExp, align 4
>   store i32 %373, i32* %zExp, align 4
>   %374 = load i64* %cSig0, align 8
>   %375 = load i64* %cSig1, align 8
>   %376 = load i64* %pSig0, align 8
>   %377 = load i64* %pSig1, align 8
>   %378 = call zeroext i8 @lt128(i64 %374, i64 %375, i64 %376, i64 %377)
>   %379 = icmp ne i8 %378, 0
>   br i1 %379, label %380, label %385
> 
> ; <label>:380                                     ; preds = %372
>   %381 = load i64* %pSig0, align 8
>   %382 = load i64* %pSig1, align 8
>   %383 = load i64* %cSig0, align 8
>   %384 = load i64* %cSig1, align 8
>   call void @sub128(i64 %381, i64 %382, i64 %383, i64 %384, i64* %zSig0, i64* %zSig1)
>   br label %417
> 
> ; <label>:385                                     ; preds = %372
>   %386 = load i64* %pSig0, align 8
>   %387 = load i64* %pSig1, align 8
>   %388 = load i64* %cSig0, align 8
>   %389 = load i64* %cSig1, align 8
>   %390 = call zeroext i8 @lt128(i64 %386, i64 %387, i64 %388, i64 %389)
>   %391 = icmp ne i8 %390, 0
>   br i1 %391, label %392, label %401
> 
> ; <label>:392                                     ; preds = %385
>   %393 = load i64* %cSig0, align 8
>   %394 = load i64* %cSig1, align 8
>   %395 = load i64* %pSig0, align 8
>   %396 = load i64* %pSig1, align 8
>   call void @sub128(i64 %393, i64 %394, i64 %395, i64 %396, i64* %zSig0, i64* %zSig1)
>   %397 = load i8* %zSign, align 1
>   %398 = zext i8 %397 to i32
>   %399 = xor i32 %398, 1
>   %400 = trunc i32 %399 to i8
>   store i8 %400, i8* %zSign, align 1
>   br label %416
> 
> ; <label>:401                                     ; preds = %385
>   %402 = load i8* %signflip, align 1
>   store i8 %402, i8* %zSign, align 1
>   %403 = load %struct.float_status** %6, align 4
>   %404 = getelementptr inbounds %struct.float_status* %403, i32 0, i32 1
>   %405 = load i8* %404, align 1
>   %406 = sext i8 %405 to i32
>   %407 = icmp eq i32 %406, 1
>   br i1 %407, label %408, label %413
> 
> ; <label>:408                                     ; preds = %401
>   %409 = load i8* %zSign, align 1
>   %410 = zext i8 %409 to i32
>   %411 = xor i32 %410, 1
>   %412 = trunc i32 %411 to i8
>   store i8 %412, i8* %zSign, align 1
>   br label %413
> 
> ; <label>:413                                     ; preds = %408, %401
>   %414 = load i8* %zSign, align 1
>   %415 = call i64 @packFloat64(i8 zeroext %414, i32 0, i64 0)
>   store i64 %415, i64* %1
>   br label %460
> 
> ; <label>:416                                     ; preds = %392
>   br label %417
> 
> ; <label>:417                                     ; preds = %416, %380
>   br label %418
> 
> ; <label>:418                                     ; preds = %417, %358
>   br label %419
> 
> ; <label>:419                                     ; preds = %418, %346
>   %420 = load i32* %zExp, align 4
>   %421 = add nsw i32 %420, -1
>   store i32 %421, i32* %zExp, align 4
>   %422 = load i64* %zSig0, align 8
>   %423 = icmp ne i64 %422, 0
>   br i1 %423, label %424, label %441
> 
> ; <label>:424                                     ; preds = %419
>   %425 = load i64* %zSig0, align 8
>   %426 = call signext i8 @countLeadingZeros64(i64 %425)
>   %427 = sext i8 %426 to i32
>   %428 = sub nsw i32 %427, 1
>   store i32 %428, i32* %shiftcount, align 4
>   %429 = load i64* %zSig0, align 8
>   %430 = load i64* %zSig1, align 8
>   %431 = load i32* %shiftcount, align 4
>   call void @shortShift128Left(i64 %429, i64 %430, i32 %431, i64* %zSig0, i64* %zSig1)
>   %432 = load i64* %zSig1, align 8
>   %433 = icmp ne i64 %432, 0
>   br i1 %433, label %434, label %437
> 
> ; <label>:434                                     ; preds = %424
>   %435 = load i64* %zSig0, align 8
>   %436 = or i64 %435, 1
>   store i64 %436, i64* %zSig0, align 8
>   br label %437
> 
> ; <label>:437                                     ; preds = %434, %424
>   %438 = load i32* %shiftcount, align 4
>   %439 = load i32* %zExp, align 4
>   %440 = sub nsw i32 %439, %438
>   store i32 %440, i32* %zExp, align 4
>   br label %454
> 
> ; <label>:441                                     ; preds = %419
>   %442 = load i64* %zSig1, align 8
>   %443 = call signext i8 @countLeadingZeros64(i64 %442)
>   %444 = sext i8 %443 to i32
>   %445 = sub nsw i32 %444, 1
>   store i32 %445, i32* %shiftcount, align 4
>   %446 = load i64* %zSig1, align 8
>   %447 = load i32* %shiftcount, align 4
>   %448 = zext i32 %447 to i64
>   %449 = shl i64 %446, %448
>   store i64 %449, i64* %zSig0, align 8
>   %450 = load i32* %shiftcount, align 4
>   %451 = add nsw i32 %450, 64
>   %452 = load i32* %zExp, align 4
>   %453 = sub nsw i32 %452, %451
>   store i32 %453, i32* %zExp, align 4
>   br label %454
> 
> ; <label>:454                                     ; preds = %441, %437
>   %455 = load i8* %zSign, align 1
>   %456 = load i32* %zExp, align 4
>   %457 = load i64* %zSig0, align 8
>   %458 = load %struct.float_status** %6, align 4
>   %459 = call i64 @roundAndPackFloat64(i8 zeroext %455, i32 %456, i64 %457, %struct.float_status* %458)
>   store i64 %459, i64* %1
>   br label %460
> 
> ; <label>:460                                     ; preds = %454, %413, %335, %278, %229, %219, %206, %172, %161, %159, %90, %80
>   %461 = load i64* %1
>   ret i64 %461
> }
> 
> define internal i64 @propagateFloat64MulAddNaN(i64 %a, i64 %b, i64 %c, i8 zeroext %infzero, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca i8, align 1
>   %6 = alloca %struct.float_status*, align 4
>   %aIsQuietNaN = alloca i8, align 1
>   %aIsSignalingNaN = alloca i8, align 1
>   %bIsQuietNaN = alloca i8, align 1
>   %bIsSignalingNaN = alloca i8, align 1
>   %cIsQuietNaN = alloca i8, align 1
>   %cIsSignalingNaN = alloca i8, align 1
>   %which = alloca i32, align 4
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store i64 %c, i64* %4, align 8
>   store i8 %infzero, i8* %5, align 1
>   store %struct.float_status* %status, %struct.float_status** %6, align 4
>   %7 = load i64* %2, align 8
>   %8 = call i32 @float64_is_quiet_nan(i64 %7)
>   %9 = trunc i32 %8 to i8
>   store i8 %9, i8* %aIsQuietNaN, align 1
>   %10 = load i64* %2, align 8
>   %11 = call i32 @float64_is_signaling_nan(i64 %10)
>   %12 = trunc i32 %11 to i8
>   store i8 %12, i8* %aIsSignalingNaN, align 1
>   %13 = load i64* %3, align 8
>   %14 = call i32 @float64_is_quiet_nan(i64 %13)
>   %15 = trunc i32 %14 to i8
>   store i8 %15, i8* %bIsQuietNaN, align 1
>   %16 = load i64* %3, align 8
>   %17 = call i32 @float64_is_signaling_nan(i64 %16)
>   %18 = trunc i32 %17 to i8
>   store i8 %18, i8* %bIsSignalingNaN, align 1
>   %19 = load i64* %4, align 8
>   %20 = call i32 @float64_is_quiet_nan(i64 %19)
>   %21 = trunc i32 %20 to i8
>   store i8 %21, i8* %cIsQuietNaN, align 1
>   %22 = load i64* %4, align 8
>   %23 = call i32 @float64_is_signaling_nan(i64 %22)
>   %24 = trunc i32 %23 to i8
>   store i8 %24, i8* %cIsSignalingNaN, align 1
>   %25 = load i8* %aIsSignalingNaN, align 1
>   %26 = zext i8 %25 to i32
>   %27 = load i8* %bIsSignalingNaN, align 1
>   %28 = zext i8 %27 to i32
>   %29 = or i32 %26, %28
>   %30 = load i8* %cIsSignalingNaN, align 1
>   %31 = zext i8 %30 to i32
>   %32 = or i32 %29, %31
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
17424,17429c15507,15510
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %57, %47
<   %65 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 69
<   store i32 %8, i32* %65, align 4
<   %66 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %32, i32 0) nounwind
<   %67 = icmp eq i32 %66, 0
<   br i1 %67, label %91, label %68
---
> ; <label>:34                                      ; preds = %0
>   %35 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
17431,17436c15512,15540
< ; <label>:68                                      ; preds = %can_do_io.exit.thread.i
<   %69 = call i64 @s2e_notdirty_mem_write(i64 %30) nounwind
<   %70 = icmp eq i32 %isSymb.0.i, 0
<   %71 = inttoptr i64 %69 to i16*
<   %72 = load i16* %71, align 2
<   br i1 %70, label %io_read_chkw_mmu.exit, label %73
---
> ; <label>:36                                      ; preds = %34, %0
>   %37 = load i8* %aIsQuietNaN, align 1
>   %38 = load i8* %aIsSignalingNaN, align 1
>   %39 = load i8* %bIsQuietNaN, align 1
>   %40 = load i8* %bIsSignalingNaN, align 1
>   %41 = load i8* %cIsQuietNaN, align 1
>   %42 = load i8* %cIsSignalingNaN, align 1
>   %43 = load i8* %5, align 1
>   %44 = load %struct.float_status** %6, align 4
>   %45 = call i32 @pickNaNMulAdd(i8 zeroext %37, i8 zeroext %38, i8 zeroext %39, i8 zeroext %40, i8 zeroext %41, i8 zeroext %42, i8 zeroext %43, %struct.float_status* %44)
>   store i32 %45, i32* %which, align 4
>   %46 = load %struct.float_status** %6, align 4
>   %47 = getelementptr inbounds %struct.float_status* %46, i32 0, i32 6
>   %48 = load i8* %47, align 1
>   %49 = icmp ne i8 %48, 0
>   br i1 %49, label %50, label %51
> 
> ; <label>:50                                      ; preds = %36
>   store i64 -2251799813685248, i64* %1
>   br label %64
> 
> ; <label>:51                                      ; preds = %36
>   %52 = load i32* %which, align 4
>   switch i32 %52, label %63 [
>     i32 0, label %53
>     i32 1, label %56
>     i32 2, label %59
>     i32 3, label %62
>   ]
17438,17451c15542,15558
< ; <label>:73                                      ; preds = %68
<   %data.i.sroa.0.0.extract.trunc.i = trunc i16 %72 to i8
<   %data.i.sroa.1.1.extract.shift.i = lshr i16 %72, 8
<   %data.i.sroa.1.1.extract.trunc.i = trunc i16 %data.i.sroa.1.1.extract.shift.i to i8
<   %74 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %75 = icmp eq i32 %74, 0
<   br i1 %75, label %io_read_chk_symb_w.exit.i, label %76
< 
< ; <label>:76                                      ; preds = %73
<   %fold27 = add i64 %33, %7
<   %77 = and i64 %fold27, 4294967295
<   %78 = call i32 @s2e_is_mmio_symbolic_b(i64 %77) nounwind
<   %79 = icmp eq i32 %78, 0
<   br i1 %79, label %._crit_edge8.i.i, label %80
---
> ; <label>:53                                      ; preds = %51
>   %54 = load i64* %2, align 8
>   %55 = call i64 @float64_maybe_silence_nan(i64 %54)
>   store i64 %55, i64* %1
>   br label %64
> 
> ; <label>:56                                      ; preds = %51
>   %57 = load i64* %3, align 8
>   %58 = call i64 @float64_maybe_silence_nan(i64 %57)
>   store i64 %58, i64* %1
>   br label %64
> 
> ; <label>:59                                      ; preds = %51
>   %60 = load i64* %4, align 8
>   %61 = call i64 @float64_maybe_silence_nan(i64 %60)
>   store i64 %61, i64* %1
>   br label %64
17453,17456c15560,15561
< ; <label>:80                                      ; preds = %76
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %81 = load i8* %ret.i.i.i, align 1
<   br label %._crit_edge8.i.i
---
> ; <label>:62                                      ; preds = %51
>   br label %63
17458,17462c15563,15565
< ._crit_edge8.i.i:                                 ; preds = %80, %76
<   %data.i.sroa.0.0.extract.trunc23.i = phi i8 [ %81, %80 ], [ %data.i.sroa.0.0.extract.trunc.i, %76 ]
<   %.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %82 = icmp eq i32 %.pr.i.i, 0
<   br i1 %82, label %io_read_chk_symb_w.exit.i, label %83
---
> ; <label>:63                                      ; preds = %62, %51
>   store i64 -2251799813685248, i64* %1
>   br label %64
17464,17469c15567,15570
< ; <label>:83                                      ; preds = %._crit_edge8.i.i
<   %84 = add i64 %35, 1
<   %85 = and i64 %84, 4294967295
<   %86 = call i32 @s2e_is_mmio_symbolic_b(i64 %85) nounwind
<   %87 = icmp eq i32 %86, 0
<   br i1 %87, label %io_read_chk_symb_w.exit.i, label %88
---
> ; <label>:64                                      ; preds = %63, %59, %56, %53, %50
>   %65 = load i64* %1
>   ret i64 %65
> }
17471,17474c15572,15593
< ; <label>:88                                      ; preds = %83
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %89 = load i8* %ret.i.i.i, align 1
<   br label %io_read_chk_symb_w.exit.i
---
> define internal void @shift128RightJamming(i64 %a0, i64 %a1, i32 %count, i64* %z0Ptr, i64* %z1Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i32, align 4
>   %4 = alloca i64*, align 4
>   %5 = alloca i64*, align 4
>   %z0 = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   %negCount = alloca i8, align 1
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i32 %count, i32* %3, align 4
>   store i64* %z0Ptr, i64** %4, align 4
>   store i64* %z1Ptr, i64** %5, align 4
>   %6 = load i32* %3, align 4
>   %7 = sub nsw i32 0, %6
>   %8 = and i32 %7, 63
>   %9 = trunc i32 %8 to i8
>   store i8 %9, i8* %negCount, align 1
>   %10 = load i32* %3, align 4
>   %11 = icmp eq i32 %10, 0
>   br i1 %11, label %12, label %15
17476,17494c15595,15600
< io_read_chk_symb_w.exit.i:                        ; preds = %88, %83, %._crit_edge8.i.i, %73
<   %90 = phi i8 [ %data.i.sroa.1.1.extract.trunc.i, %73 ], [ %data.i.sroa.1.1.extract.trunc.i, %._crit_edge8.i.i ], [ %data.i.sroa.1.1.extract.trunc.i, %83 ], [ %89, %88 ]
<   %data.i.sroa.0.0.extract.trunc24.i = phi i8 [ %data.i.sroa.0.0.extract.trunc.i, %73 ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge8.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %83 ], [ %data.i.sroa.0.0.extract.trunc23.i, %88 ]
<   %data.i.sroa.1.1.insert.ext.i = zext i8 %90 to i16
<   %data.i.sroa.1.1.insert.shift.i = shl nuw i16 %data.i.sroa.1.1.insert.ext.i, 8
<   %data.i.sroa.0.0.insert.ext.i = zext i8 %data.i.sroa.0.0.extract.trunc24.i to i16
<   %data.i.sroa.0.0.insert.insert.i = or i16 %data.i.sroa.1.1.insert.shift.i, %data.i.sroa.0.0.insert.ext.i
<   br label %io_read_chkw_mmu.exit
< 
< ; <label>:91                                      ; preds = %can_do_io.exit.thread.i
<   %92 = call zeroext i16 @io_readw_mmu(i64 %30, i32 %8, i8* null) nounwind
<   br label %io_read_chkw_mmu.exit
< 
< io_read_chkw_mmu.exit:                            ; preds = %91, %io_read_chk_symb_w.exit.i, %68
<   %.0.i = phi i16 [ %data.i.sroa.0.0.insert.insert.i, %io_read_chk_symb_w.exit.i ], [ %92, %91 ], [ %72, %68 ]
<   %93 = add i64 %30, %34
<   %94 = zext i16 %.0.i to i64
<   call void @tcg_llvm_trace_memory_access(i64 %34, i64 %93, i64 %94, i32 16, i8 zeroext 0, i8 zeroext 1) nounwind
<   br label %116
---
> ; <label>:12                                      ; preds = %0
>   %13 = load i64* %2, align 8
>   store i64 %13, i64* %z1, align 8
>   %14 = load i64* %1, align 8
>   store i64 %14, i64* %z0, align 8
>   br label %82
17496,17500c15602,15638
< ; <label>:95                                      ; preds = %._crit_edge
<   %96 = and i32 %8, 127
<   %97 = add i32 %96, 1
<   %98 = icmp ugt i32 %97, 127
<   br i1 %98, label %99, label %101, !prof !1
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %3, align 4
>   %17 = icmp slt i32 %16, 64
>   br i1 %17, label %18, label %42
> 
> ; <label>:18                                      ; preds = %15
>   %19 = load i64* %1, align 8
>   %20 = load i8* %negCount, align 1
>   %21 = sext i8 %20 to i32
>   %22 = zext i32 %21 to i64
>   %23 = shl i64 %19, %22
>   %24 = load i64* %2, align 8
>   %25 = load i32* %3, align 4
>   %26 = zext i32 %25 to i64
>   %27 = lshr i64 %24, %26
>   %28 = or i64 %23, %27
>   %29 = load i64* %2, align 8
>   %30 = load i8* %negCount, align 1
>   %31 = sext i8 %30 to i32
>   %32 = zext i32 %31 to i64
>   %33 = shl i64 %29, %32
>   %34 = icmp ne i64 %33, 0
>   %35 = zext i1 %34 to i32
>   %36 = sext i32 %35 to i64
>   %37 = or i64 %28, %36
>   store i64 %37, i64* %z1, align 8
>   %38 = load i64* %1, align 8
>   %39 = load i32* %3, align 4
>   %40 = zext i32 %39 to i64
>   %41 = lshr i64 %38, %40
>   store i64 %41, i64* %z0, align 8
>   br label %81
> 
> ; <label>:42                                      ; preds = %15
>   %43 = load i32* %3, align 4
>   %44 = icmp eq i32 %43, 64
>   br i1 %44, label %45, label %52
17502,17504c15640,15673
< ; <label>:99                                      ; preds = %95, %25
<   %100 = call fastcc zeroext i16 @slow_ldw_mmu(i32 %8, i32 %mmu_idx)
<   br label %116
---
> ; <label>:45                                      ; preds = %42
>   %46 = load i64* %1, align 8
>   %47 = load i64* %2, align 8
>   %48 = icmp ne i64 %47, 0
>   %49 = zext i1 %48 to i32
>   %50 = sext i32 %49 to i64
>   %51 = or i64 %46, %50
>   store i64 %51, i64* %z1, align 8
>   br label %80
> 
> ; <label>:52                                      ; preds = %42
>   %53 = load i32* %3, align 4
>   %54 = icmp slt i32 %53, 128
>   br i1 %54, label %55, label %72
> 
> ; <label>:55                                      ; preds = %52
>   %56 = load i64* %1, align 8
>   %57 = load i32* %3, align 4
>   %58 = and i32 %57, 63
>   %59 = zext i32 %58 to i64
>   %60 = lshr i64 %56, %59
>   %61 = load i64* %1, align 8
>   %62 = load i8* %negCount, align 1
>   %63 = sext i8 %62 to i32
>   %64 = zext i32 %63 to i64
>   %65 = shl i64 %61, %64
>   %66 = load i64* %2, align 8
>   %67 = or i64 %65, %66
>   %68 = icmp ne i64 %67, 0
>   %69 = zext i1 %68 to i32
>   %70 = sext i32 %69 to i64
>   %71 = or i64 %60, %70
>   store i64 %71, i64* %z1, align 8
>   br label %79
17506,17515c15675,15683
< ; <label>:101                                     ; preds = %95
<   %102 = getelementptr inbounds %struct.CPUX86State* %.lcssa28, i64 0, i32 73, i64 %14, i64 %13, i32 3
<   %103 = load i64* %102, align 8
<   %104 = and i64 %7, 4294967295
<   %105 = add i64 %103, %104
<   %106 = inttoptr i64 %105 to i16*
<   %107 = load i16* %106, align 2
<   %108 = zext i16 %107 to i64
<   call void @tcg_llvm_trace_memory_access(i64 %104, i64 %105, i64 %108, i32 16, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %116
---
> ; <label>:72                                      ; preds = %52
>   %73 = load i64* %1, align 8
>   %74 = load i64* %2, align 8
>   %75 = or i64 %73, %74
>   %76 = icmp ne i64 %75, 0
>   %77 = zext i1 %76 to i32
>   %78 = sext i32 %77 to i64
>   store i64 %78, i64* %z1, align 8
>   br label %79
17517,17530c15685,15686
< ; <label>:109                                     ; preds = %109, %.lr.ph
<   %110 = phi %struct.CPUX86State* [ %15, %.lr.ph ], [ %111, %109 ]
<   call void @tlb_fill(%struct.CPUX86State* %110, i32 %8, i32 %22, i32 0, i32 %mmu_idx, i8* null)
<   %111 = load %struct.CPUX86State** @env, align 8
<   %112 = getelementptr inbounds %struct.CPUX86State* %111, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %113 = load i32* %112, align 4
<   %114 = and i32 %113, -4088
<   %115 = icmp eq i32 %18, %114
<   br i1 %115, label %._crit_edge, label %109, !prof !0
< 
< ; <label>:116                                     ; preds = %101, %99, %io_read_chkw_mmu.exit
<   %res.0 = phi i16 [ %100, %99 ], [ %.0.i, %io_read_chkw_mmu.exit ], [ %107, %101 ]
<   ret i16 %res.0
< }
---
> ; <label>:79                                      ; preds = %72, %55
>   br label %80
17532,17538c15688,15690
< define internal fastcc zeroext i16 @slow_ldw_mmu(i32 %addr, i32 %mmu_idx) nounwind uwtable {
<   %ret.i.i.i = alloca i8, align 1
<   %label.i = alloca [64 x i8], align 16
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %addr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:80                                      ; preds = %79, %45
>   store i64 0, i64* %z0, align 8
>   br label %81
17540,17542c15692,15693
< ; <label>:4                                       ; preds = %0
<   %5 = call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:81                                      ; preds = %80, %18
>   br label %82
17544,17559c15695,15703
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = sext i32 %mmu_idx to i64
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %17 = load i32* %16, align 4
<   %18 = and i32 %8, -4096
<   %19 = and i32 %17, -4088
<   %20 = icmp eq i32 %18, %19
<   br i1 %20, label %._crit_edge, label %.lr.ph
---
> ; <label>:82                                      ; preds = %81, %12
>   %83 = load i64* %z1, align 8
>   %84 = load i64** %5, align 4
>   store i64 %83, i64* %84, align 4
>   %85 = load i64* %z0, align 8
>   %86 = load i64** %4, align 4
>   store i64 %85, i64* %86, align 4
>   ret void
> }
17561,17564c15705,15717
< .lr.ph:                                           ; preds = %6
<   %21 = trunc i64 %11 to i32
<   %22 = shl i32 %21, 7
<   br label %121
---
> define internal zeroext i8 @lt128(i64 %a0, i64 %a1, i64 %b0, i64 %b1) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %b0, i64* %3, align 8
>   store i64 %b1, i64* %4, align 8
>   %5 = load i64* %1, align 8
>   %6 = load i64* %3, align 8
>   %7 = icmp ult i64 %5, %6
>   br i1 %7, label %18, label %8
17566,17571c15719,15723
< ._crit_edge:                                      ; preds = %121, %6
<   %.lcssa3 = phi i32 [ %17, %6 ], [ %125, %121 ]
<   %.lcssa2 = phi %struct.CPUX86State* [ %15, %6 ], [ %123, %121 ]
<   %23 = and i32 %.lcssa3, 4095
<   %24 = icmp eq i32 %23, 0
<   br i1 %24, label %95, label %25
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i64* %1, align 8
>   %10 = load i64* %3, align 8
>   %11 = icmp eq i64 %9, %10
>   br i1 %11, label %12, label %16
17573,17576c15725,15729
< ; <label>:25                                      ; preds = %._crit_edge
<   %26 = and i32 %8, 1
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %28, label %99
---
> ; <label>:12                                      ; preds = %8
>   %13 = load i64* %2, align 8
>   %14 = load i64* %4, align 8
>   %15 = icmp ult i64 %13, %14
>   br label %16
17578,17589c15731,15733
< ; <label>:28                                      ; preds = %25
<   %29 = getelementptr inbounds %struct.CPUX86State* %.lcssa2, i64 0, i32 75, i64 %14, i64 %13
<   %30 = load i64* %29, align 8
<   %31 = getelementptr inbounds [64 x i8]* %label.i, i64 0, i64 0
<   %32 = call %struct.MemoryRegion* @iotlb_to_region(i64 %30) nounwind
<   %33 = and i64 %30, 4294963200
<   %34 = and i64 %7, 4294967295
<   %35 = add i64 %33, %34
<   %36 = trunc i64 %35 to i32
<   %37 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %47, label %39
---
> ; <label>:16                                      ; preds = %12, %8
>   %17 = phi i1 [ false, %8 ], [ %15, %12 ]
>   br label %18
17591,17596c15735,15773
< ; <label>:39                                      ; preds = %28
<   %fold = add i64 %33, %7
<   %40 = and i64 %fold, 4294967295
<   %41 = call i32 @s2e_is_mmio_symbolic_w(i64 %40) nounwind
<   %42 = icmp eq i32 %41, 0
<   br i1 %42, label %47, label %43
---
> ; <label>:18                                      ; preds = %16, %0
>   %19 = phi i1 [ true, %0 ], [ %17, %16 ]
>   %20 = zext i1 %19 to i32
>   %21 = trunc i32 %20 to i8
>   ret i8 %21
> }
> 
> define internal i64 @float64_sqrt(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %zSig = alloca i64, align 8
>   %doubleZSig = alloca i64, align 8
>   %rem0 = alloca i64, align 8
>   %rem1 = alloca i64, align 8
>   %term0 = alloca i64, align 8
>   %term1 = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i64 @float64_squash_input_denormal(i64 %4, %struct.float_status* %5)
>   store i64 %6, i64* %2, align 8
>   %7 = load i64* %2, align 8
>   %8 = call i64 @extractFloat64Frac(i64 %7)
>   store i64 %8, i64* %aSig, align 8
>   %9 = load i64* %2, align 8
>   %10 = call i32 @extractFloat64Exp(i64 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i64* %2, align 8
>   %12 = call zeroext i8 @extractFloat64Sign(i64 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 2047
>   br i1 %14, label %15, label %30
17598,17603c15775,15786
< ; <label>:43                                      ; preds = %39
<   %44 = load %struct.CPUX86State** @env, align 8
<   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 5
<   %46 = load i32* %45, align 4
<   call void @trace_port(i8* %31, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %36, i32 %46) nounwind
<   br label %47
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i64* %aSig, align 8
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %18, label %23
> 
> ; <label>:18                                      ; preds = %15
>   %19 = load i64* %2, align 8
>   %20 = load i64* %2, align 8
>   %21 = load %struct.float_status** %3, align 4
>   %22 = call i64 @propagateFloat64NaN(i64 %19, i64 %20, %struct.float_status* %21)
>   store i64 %22, i64* %1
>   br label %117
17605,17622c15788,15807
< ; <label>:47                                      ; preds = %43, %39, %28
<   %isSymb.0.i = phi i32 [ %41, %43 ], [ 0, %39 ], [ 0, %28 ]
<   %48 = load %struct.CPUX86State** @env, align 8
<   %49 = getelementptr inbounds %struct.CPUX86State* %48, i64 0, i32 68
<   store i64 0, i64* %49, align 8
<   %50 = icmp ne %struct.MemoryRegion* %32, @io_mem_ram
<   %51 = icmp ne %struct.MemoryRegion* %32, @io_mem_rom
<   %or.cond.i = and i1 %50, %51
<   %52 = icmp ne %struct.MemoryRegion* %32, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %52
<   %53 = icmp ne %struct.MemoryRegion* %32, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %53
<   %54 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %55 = load i32* @use_icount, align 4
<   %56 = icmp eq i32 %55, 0
<   %or.cond26.i = or i1 %56, %or.cond5.not.i
<   br i1 %or.cond26.i, label %can_do_io.exit.thread.i, label %57
---
> ; <label>:23                                      ; preds = %15
>   %24 = load i8* %aSign, align 1
>   %25 = icmp ne i8 %24, 0
>   br i1 %25, label %28, label %26
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load i64* %2, align 8
>   store i64 %27, i64* %1
>   br label %117
> 
> ; <label>:28                                      ; preds = %23
>   %29 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %29)
>   store i64 -2251799813685248, i64* %1
>   br label %117
> 
> ; <label>:30                                      ; preds = %0
>   %31 = load i8* %aSign, align 1
>   %32 = icmp ne i8 %31, 0
>   br i1 %32, label %33, label %43
17624,17628c15809,15820
< ; <label>:57                                      ; preds = %47
<   %58 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 66
<   %59 = load %struct.TranslationBlock** %58, align 8
<   %60 = icmp eq %struct.TranslationBlock* %59, null
<   br i1 %60, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:33                                      ; preds = %30
>   %34 = load i32* %aExp, align 4
>   %35 = sext i32 %34 to i64
>   %36 = load i64* %aSig, align 8
>   %37 = or i64 %35, %36
>   %38 = icmp eq i64 %37, 0
>   br i1 %38, label %39, label %41
> 
> ; <label>:39                                      ; preds = %33
>   %40 = load i64* %2, align 8
>   store i64 %40, i64* %1
>   br label %117
17630,17634c15822,15826
< can_do_io.exit.i:                                 ; preds = %57
<   %61 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 85
<   %62 = load i32* %61, align 4
<   %63 = icmp eq i32 %62, 0
<   br i1 %63, label %64, label %can_do_io.exit.thread.i
---
> ; <label>:41                                      ; preds = %33
>   %42 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %42)
>   store i64 -2251799813685248, i64* %1
>   br label %117
17636,17638c15828,15831
< ; <label>:64                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %54, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:43                                      ; preds = %30
>   %44 = load i32* %aExp, align 4
>   %45 = icmp eq i32 %44, 0
>   br i1 %45, label %46, label %52
17640,17645c15833,15836
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %57, %47
<   %65 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 69
<   store i32 %8, i32* %65, align 4
<   %66 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %32, i32 0) nounwind
<   %67 = icmp eq i32 %66, 0
<   br i1 %67, label %91, label %68
---
> ; <label>:46                                      ; preds = %43
>   %47 = load i64* %aSig, align 8
>   %48 = icmp eq i64 %47, 0
>   br i1 %48, label %49, label %50
17647,17652c15838,15840
< ; <label>:68                                      ; preds = %can_do_io.exit.thread.i
<   %69 = call i64 @s2e_notdirty_mem_write(i64 %30) nounwind
<   %70 = icmp eq i32 %isSymb.0.i, 0
<   %71 = inttoptr i64 %69 to i16*
<   %72 = load i16* %71, align 2
<   br i1 %70, label %io_read_chkw_mmu.exit, label %73
---
> ; <label>:49                                      ; preds = %46
>   store i64 0, i64* %1
>   br label %117
17654,17660c15842,15845
< ; <label>:73                                      ; preds = %68
<   %data.i.sroa.0.0.extract.trunc.i = trunc i16 %72 to i8
<   %data.i.sroa.1.1.extract.shift.i = lshr i16 %72, 8
<   %data.i.sroa.1.1.extract.trunc.i = trunc i16 %data.i.sroa.1.1.extract.shift.i to i8
<   %74 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %75 = icmp eq i32 %74, 0
<   br i1 %75, label %io_read_chk_symb_w.exit.i, label %76
---
> ; <label>:50                                      ; preds = %46
>   %51 = load i64* %aSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %51, i32* %aExp, i64* %aSig)
>   br label %52
17662,17667c15847,15894
< ; <label>:76                                      ; preds = %73
<   %fold1 = add i64 %33, %7
<   %77 = and i64 %fold1, 4294967295
<   %78 = call i32 @s2e_is_mmio_symbolic_b(i64 %77) nounwind
<   %79 = icmp eq i32 %78, 0
<   br i1 %79, label %._crit_edge8.i.i, label %80
---
> ; <label>:52                                      ; preds = %50, %43
>   %53 = load i32* %aExp, align 4
>   %54 = sub nsw i32 %53, 1023
>   %55 = ashr i32 %54, 1
>   %56 = add nsw i32 %55, 1022
>   store i32 %56, i32* %zExp, align 4
>   %57 = load i64* %aSig, align 8
>   %58 = or i64 %57, 4503599627370496
>   store i64 %58, i64* %aSig, align 8
>   %59 = load i32* %aExp, align 4
>   %60 = load i64* %aSig, align 8
>   %61 = lshr i64 %60, 21
>   %62 = trunc i64 %61 to i32
>   %63 = call i32 @estimateSqrt32(i32 %59, i32 %62)
>   %64 = zext i32 %63 to i64
>   store i64 %64, i64* %zSig, align 8
>   %65 = load i32* %aExp, align 4
>   %66 = and i32 %65, 1
>   %67 = sub nsw i32 9, %66
>   %68 = load i64* %aSig, align 8
>   %69 = zext i32 %67 to i64
>   %70 = shl i64 %68, %69
>   store i64 %70, i64* %aSig, align 8
>   %71 = load i64* %aSig, align 8
>   %72 = load i64* %zSig, align 8
>   %73 = shl i64 %72, 32
>   %74 = call i64 @estimateDiv128To64(i64 %71, i64 0, i64 %73)
>   %75 = load i64* %zSig, align 8
>   %76 = shl i64 %75, 30
>   %77 = add i64 %74, %76
>   store i64 %77, i64* %zSig, align 8
>   %78 = load i64* %zSig, align 8
>   %79 = and i64 %78, 511
>   %80 = icmp ule i64 %79, 5
>   br i1 %80, label %81, label %112
> 
> ; <label>:81                                      ; preds = %52
>   %82 = load i64* %zSig, align 8
>   %83 = shl i64 %82, 1
>   store i64 %83, i64* %doubleZSig, align 8
>   %84 = load i64* %zSig, align 8
>   %85 = load i64* %zSig, align 8
>   call void @mul64To128(i64 %84, i64 %85, i64* %term0, i64* %term1)
>   %86 = load i64* %aSig, align 8
>   %87 = load i64* %term0, align 8
>   %88 = load i64* %term1, align 8
>   call void @sub128(i64 %86, i64 0, i64 %87, i64 %88, i64* %rem0, i64* %rem1)
>   br label %89
17669,17672c15896,15915
< ; <label>:80                                      ; preds = %76
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %81 = load i8* %ret.i.i.i, align 1
<   br label %._crit_edge8.i.i
---
> ; <label>:89                                      ; preds = %92, %81
>   %90 = load i64* %rem0, align 8
>   %91 = icmp slt i64 %90, 0
>   br i1 %91, label %92, label %103
> 
> ; <label>:92                                      ; preds = %89
>   %93 = load i64* %zSig, align 8
>   %94 = add i64 %93, -1
>   store i64 %94, i64* %zSig, align 8
>   %95 = load i64* %doubleZSig, align 8
>   %96 = sub i64 %95, 2
>   store i64 %96, i64* %doubleZSig, align 8
>   %97 = load i64* %rem0, align 8
>   %98 = load i64* %rem1, align 8
>   %99 = load i64* %zSig, align 8
>   %100 = lshr i64 %99, 63
>   %101 = load i64* %doubleZSig, align 8
>   %102 = or i64 %101, 1
>   call void @add128(i64 %97, i64 %98, i64 %100, i64 %102, i64* %rem0, i64* %rem1)
>   br label %89
17674,17678c15917,15971
< ._crit_edge8.i.i:                                 ; preds = %80, %76
<   %data.i.sroa.0.0.extract.trunc23.i = phi i8 [ %81, %80 ], [ %data.i.sroa.0.0.extract.trunc.i, %76 ]
<   %.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %82 = icmp eq i32 %.pr.i.i, 0
<   br i1 %82, label %io_read_chk_symb_w.exit.i, label %83
---
> ; <label>:103                                     ; preds = %89
>   %104 = load i64* %rem0, align 8
>   %105 = load i64* %rem1, align 8
>   %106 = or i64 %104, %105
>   %107 = icmp ne i64 %106, 0
>   %108 = zext i1 %107 to i32
>   %109 = sext i32 %108 to i64
>   %110 = load i64* %zSig, align 8
>   %111 = or i64 %110, %109
>   store i64 %111, i64* %zSig, align 8
>   br label %112
> 
> ; <label>:112                                     ; preds = %103, %52
>   %113 = load i32* %zExp, align 4
>   %114 = load i64* %zSig, align 8
>   %115 = load %struct.float_status** %3, align 4
>   %116 = call i64 @roundAndPackFloat64(i8 zeroext 0, i32 %113, i64 %114, %struct.float_status* %115)
>   store i64 %116, i64* %1
>   br label %117
> 
> ; <label>:117                                     ; preds = %112, %49, %41, %39, %28, %26, %18
>   %118 = load i64* %1
>   ret i64 %118
> }
> 
> define internal i64 @float64_log2(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %zSig = alloca i64, align 8
>   %i = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %2, align 8
>   %5 = load %struct.float_status** %3, align 4
>   %6 = call i64 @float64_squash_input_denormal(i64 %4, %struct.float_status* %5)
>   store i64 %6, i64* %2, align 8
>   %7 = load i64* %2, align 8
>   %8 = call i64 @extractFloat64Frac(i64 %7)
>   store i64 %8, i64* %aSig, align 8
>   %9 = load i64* %2, align 8
>   %10 = call i32 @extractFloat64Exp(i64 %9)
>   store i32 %10, i32* %aExp, align 4
>   %11 = load i64* %2, align 8
>   %12 = call zeroext i8 @extractFloat64Sign(i64 %11)
>   store i8 %12, i8* %aSign, align 1
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 0
>   br i1 %14, label %15, label %22
17680,17685c15973,15981
< ; <label>:83                                      ; preds = %._crit_edge8.i.i
<   %84 = add i64 %35, 1
<   %85 = and i64 %84, 4294967295
<   %86 = call i32 @s2e_is_mmio_symbolic_b(i64 %85) nounwind
<   %87 = icmp eq i32 %86, 0
<   br i1 %87, label %io_read_chk_symb_w.exit.i, label %88
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i64* %aSig, align 8
>   %17 = icmp eq i64 %16, 0
>   br i1 %17, label %18, label %20
> 
> ; <label>:18                                      ; preds = %15
>   %19 = call i64 @packFloat64(i8 zeroext 1, i32 2047, i64 0)
>   store i64 %19, i64* %1
>   br label %86
17687,17690c15983,15997
< ; <label>:88                                      ; preds = %83
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %89 = load i8* %ret.i.i.i, align 1
<   br label %io_read_chk_symb_w.exit.i
---
> ; <label>:20                                      ; preds = %15
>   %21 = load i64* %aSig, align 8
>   call void @normalizeFloat64Subnormal(i64 %21, i32* %aExp, i64* %aSig)
>   br label %22
> 
> ; <label>:22                                      ; preds = %20, %0
>   %23 = load i8* %aSign, align 1
>   %24 = icmp ne i8 %23, 0
>   br i1 %24, label %25, label %27
> 
> ; <label>:25                                      ; preds = %22
>   %26 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %26)
>   store i64 -2251799813685248, i64* %1
>   br label %86
17692,17710c15999,16007
< io_read_chk_symb_w.exit.i:                        ; preds = %88, %83, %._crit_edge8.i.i, %73
<   %90 = phi i8 [ %data.i.sroa.1.1.extract.trunc.i, %73 ], [ %data.i.sroa.1.1.extract.trunc.i, %._crit_edge8.i.i ], [ %data.i.sroa.1.1.extract.trunc.i, %83 ], [ %89, %88 ]
<   %data.i.sroa.0.0.extract.trunc24.i = phi i8 [ %data.i.sroa.0.0.extract.trunc.i, %73 ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge8.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %83 ], [ %data.i.sroa.0.0.extract.trunc23.i, %88 ]
<   %data.i.sroa.1.1.insert.ext.i = zext i8 %90 to i16
<   %data.i.sroa.1.1.insert.shift.i = shl nuw i16 %data.i.sroa.1.1.insert.ext.i, 8
<   %data.i.sroa.0.0.insert.ext.i = zext i8 %data.i.sroa.0.0.extract.trunc24.i to i16
<   %data.i.sroa.0.0.insert.insert.i = or i16 %data.i.sroa.1.1.insert.shift.i, %data.i.sroa.0.0.insert.ext.i
<   br label %io_read_chkw_mmu.exit
< 
< ; <label>:91                                      ; preds = %can_do_io.exit.thread.i
<   %92 = call zeroext i16 @io_readw_mmu(i64 %30, i32 %8, i8* null) nounwind
<   br label %io_read_chkw_mmu.exit
< 
< io_read_chkw_mmu.exit:                            ; preds = %91, %io_read_chk_symb_w.exit.i, %68
<   %.0.i = phi i16 [ %data.i.sroa.0.0.insert.insert.i, %io_read_chk_symb_w.exit.i ], [ %92, %91 ], [ %72, %68 ]
<   %93 = add i64 %30, %34
<   %94 = zext i16 %.0.i to i64
<   call void @tcg_llvm_trace_memory_access(i64 %34, i64 %93, i64 %94, i32 16, i8 zeroext 0, i8 zeroext 1) nounwind
<   br label %128
---
> ; <label>:27                                      ; preds = %22
>   %28 = load i32* %aExp, align 4
>   %29 = icmp eq i32 %28, 2047
>   br i1 %29, label %30, label %39
> 
> ; <label>:30                                      ; preds = %27
>   %31 = load i64* %aSig, align 8
>   %32 = icmp ne i64 %31, 0
>   br i1 %32, label %33, label %37
17712,17732c16009,16014
< ; <label>:95                                      ; preds = %._crit_edge
<   %96 = and i32 %8, 127
<   %97 = add i32 %96, 1
<   %98 = icmp ugt i32 %97, 127
<   br i1 %98, label %99, label %113
< 
< ; <label>:99                                      ; preds = %95, %25
<   %100 = and i32 %8, -2
<   %101 = add i32 %100, 2
<   %102 = call fastcc zeroext i16 @slow_ldw_mmu(i32 %100, i32 %mmu_idx)
<   %103 = call fastcc zeroext i16 @slow_ldw_mmu(i32 %101, i32 %mmu_idx)
<   %104 = shl i32 %8, 3
<   %105 = and i32 %104, 8
<   %106 = zext i16 %102 to i32
<   %107 = lshr i32 %106, %105
<   %108 = zext i16 %103 to i32
<   %109 = sub i32 16, %105
<   %110 = shl i32 %108, %109
<   %111 = or i32 %110, %107
<   %112 = trunc i32 %111 to i16
<   br label %128
---
> ; <label>:33                                      ; preds = %30
>   %34 = load i64* %2, align 8
>   %35 = load %struct.float_status** %3, align 4
>   %36 = call i64 @propagateFloat64NaN(i64 %34, i64 0, %struct.float_status* %35)
>   store i64 %36, i64* %1
>   br label %86
17734,17743c16016,16019
< ; <label>:113                                     ; preds = %95
<   %114 = getelementptr inbounds %struct.CPUX86State* %.lcssa2, i64 0, i32 73, i64 %14, i64 %13, i32 3
<   %115 = load i64* %114, align 8
<   %116 = and i64 %7, 4294967295
<   %117 = add i64 %115, %116
<   %118 = inttoptr i64 %117 to i16*
<   %119 = load i16* %118, align 2
<   %120 = zext i16 %119 to i64
<   call void @tcg_llvm_trace_memory_access(i64 %116, i64 %117, i64 %120, i32 16, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %128
---
> ; <label>:37                                      ; preds = %30
>   %38 = load i64* %2, align 8
>   store i64 %38, i64* %1
>   br label %86
17745,17758c16021,16038
< ; <label>:121                                     ; preds = %121, %.lr.ph
<   %122 = phi %struct.CPUX86State* [ %15, %.lr.ph ], [ %123, %121 ]
<   call void @tlb_fill(%struct.CPUX86State* %122, i32 %8, i32 %22, i32 0, i32 %mmu_idx, i8* null)
<   %123 = load %struct.CPUX86State** @env, align 8
<   %124 = getelementptr inbounds %struct.CPUX86State* %123, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %125 = load i32* %124, align 4
<   %126 = and i32 %125, -4088
<   %127 = icmp eq i32 %18, %126
<   br i1 %127, label %._crit_edge, label %121
< 
< ; <label>:128                                     ; preds = %113, %99, %io_read_chkw_mmu.exit
<   %res.0 = phi i16 [ %112, %99 ], [ %.0.i, %io_read_chkw_mmu.exit ], [ %119, %113 ]
<   ret i16 %res.0
< }
---
> ; <label>:39                                      ; preds = %27
>   %40 = load i32* %aExp, align 4
>   %41 = sub nsw i32 %40, 1023
>   store i32 %41, i32* %aExp, align 4
>   %42 = load i64* %aSig, align 8
>   %43 = or i64 %42, 4503599627370496
>   store i64 %43, i64* %aSig, align 8
>   %44 = load i32* %aExp, align 4
>   %45 = icmp slt i32 %44, 0
>   %46 = zext i1 %45 to i32
>   %47 = trunc i32 %46 to i8
>   store i8 %47, i8* %zSign, align 1
>   %48 = load i32* %aExp, align 4
>   %49 = sext i32 %48 to i64
>   %50 = shl i64 %49, 52
>   store i64 %50, i64* %zSig, align 8
>   store i64 2251799813685248, i64* %i, align 8
>   br label %51
17760,17781c16040,16043
< define void @io_write_chkw_mmu(i64 %physaddr, i16 zeroext %val, i32 %addr, i8* %retaddr) nounwind uwtable inlinehint alwaysinline {
<   %1 = alloca i16, align 2
<   %2 = alloca i32, align 4
<   store i16 %val, i16* %1, align 2
<   store i32 %addr, i32* %2, align 4
<   %3 = call %struct.MemoryRegion* @iotlb_to_region(i64 %physaddr) nounwind
<   %4 = and i64 %physaddr, -4096
<   %5 = zext i32 %addr to i64
<   %6 = add i64 %5, %4
<   %7 = icmp ne %struct.MemoryRegion* %3, @io_mem_ram
<   %8 = icmp ne %struct.MemoryRegion* %3, @io_mem_rom
<   %or.cond = and i1 %7, %8
<   %9 = icmp ne %struct.MemoryRegion* %3, @io_mem_unassigned
<   %or.cond3 = and i1 %or.cond, %9
<   %10 = icmp ne %struct.MemoryRegion* %3, @io_mem_notdirty
<   %or.cond5 = and i1 %or.cond3, %10
<   %11 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not = xor i1 %or.cond5, true
<   %12 = load i32* @use_icount, align 4
<   %13 = icmp eq i32 %12, 0
<   %or.cond17 = or i1 %13, %or.cond5.not
<   br i1 %or.cond17, label %can_do_io.exit.thread, label %14
---
> ; <label>:51                                      ; preds = %72, %39
>   %52 = load i64* %i, align 8
>   %53 = icmp ugt i64 %52, 0
>   br i1 %53, label %54, label %75
17783,17787c16045,16077
< ; <label>:14                                      ; preds = %0
<   %15 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 66
<   %16 = load %struct.TranslationBlock** %15, align 8
<   %17 = icmp eq %struct.TranslationBlock* %16, null
<   br i1 %17, label %can_do_io.exit.thread, label %can_do_io.exit
---
> ; <label>:54                                      ; preds = %51
>   %55 = load i64* %aSig, align 8
>   %56 = load i64* %aSig, align 8
>   call void @mul64To128(i64 %55, i64 %56, i64* %aSig0, i64* %aSig1)
>   %57 = load i64* %aSig0, align 8
>   %58 = shl i64 %57, 12
>   %59 = load i64* %aSig1, align 8
>   %60 = lshr i64 %59, 52
>   %61 = or i64 %58, %60
>   store i64 %61, i64* %aSig, align 8
>   %62 = load i64* %aSig, align 8
>   %63 = and i64 %62, 9007199254740992
>   %64 = icmp ne i64 %63, 0
>   br i1 %64, label %65, label %71
> 
> ; <label>:65                                      ; preds = %54
>   %66 = load i64* %aSig, align 8
>   %67 = lshr i64 %66, 1
>   store i64 %67, i64* %aSig, align 8
>   %68 = load i64* %i, align 8
>   %69 = load i64* %zSig, align 8
>   %70 = or i64 %69, %68
>   store i64 %70, i64* %zSig, align 8
>   br label %71
> 
> ; <label>:71                                      ; preds = %65, %54
>   br label %72
> 
> ; <label>:72                                      ; preds = %71
>   %73 = load i64* %i, align 8
>   %74 = lshr i64 %73, 1
>   store i64 %74, i64* %i, align 8
>   br label %51
17789,17793c16079,16082
< can_do_io.exit:                                   ; preds = %14
<   %18 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 85
<   %19 = load i32* %18, align 4
<   %20 = icmp eq i32 %19, 0
<   br i1 %20, label %21, label %can_do_io.exit.thread
---
> ; <label>:75                                      ; preds = %51
>   %76 = load i8* %zSign, align 1
>   %77 = icmp ne i8 %76, 0
>   br i1 %77, label %78, label %81
17795,17797c16084,16096
< ; <label>:21                                      ; preds = %can_do_io.exit
<   call void @cpu_io_recompile(%struct.CPUX86State* %11, i8* %retaddr) noreturn nounwind
<   unreachable
---
> ; <label>:78                                      ; preds = %75
>   %79 = load i64* %zSig, align 8
>   %80 = sub i64 0, %79
>   store i64 %80, i64* %zSig, align 8
>   br label %81
> 
> ; <label>:81                                      ; preds = %78, %75
>   %82 = load i8* %zSign, align 1
>   %83 = load i64* %zSig, align 8
>   %84 = load %struct.float_status** %3, align 4
>   %85 = call i64 @normalizeRoundAndPackFloat64(i8 zeroext %82, i32 1032, i64 %83, %struct.float_status* %84)
>   store i64 %85, i64* %1
>   br label %86
17799,17808c16098,16101
< can_do_io.exit.thread:                            ; preds = %can_do_io.exit, %14, %0
<   %22 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 69
<   store i32 %addr, i32* %22, align 4
<   %23 = ptrtoint i8* %retaddr to i64
<   %24 = load %struct.CPUX86State** @env, align 8
<   %25 = getelementptr inbounds %struct.CPUX86State* %24, i64 0, i32 68
<   store i64 %23, i64* %25, align 8
<   %26 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %3, i32 1) nounwind
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %32, label %28
---
> ; <label>:86                                      ; preds = %81, %37, %33, %25, %18
>   %87 = load i64* %1
>   ret i64 %87
> }
17810,17820c16103,16124
< ; <label>:28                                      ; preds = %can_do_io.exit.thread
<   %29 = call i64 @s2e_notdirty_mem_write(i64 %6) nounwind
<   %30 = load i16* %1, align 2
<   %31 = inttoptr i64 %29 to i16*
<   store i16 %30, i16* %31, align 2
<   br label %44
< 
< ; <label>:32                                      ; preds = %can_do_io.exit.thread
<   %33 = load i32* @g_s2e_concretize_io_writes, align 4
<   %34 = icmp eq i32 %33, 0
<   br i1 %34, label %37, label %35
---
> define internal i32 @float64_eq(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %av = alloca i64, align 8
>   %bv = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i32 @extractFloat64Exp(i64 %11)
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %18
17822,17825c16126,16148
< ; <label>:35                                      ; preds = %32
<   %36 = bitcast i16* %1 to i8*
<   call void @tcg_llvm_get_value(i8* %36, i32 2, i1 zeroext true) nounwind
<   br label %37
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %2, align 8
>   %16 = call i64 @extractFloat64Frac(i64 %15)
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   %21 = icmp eq i32 %20, 2047
>   br i1 %21, label %22, label %28
> 
> ; <label>:22                                      ; preds = %18
>   %23 = load i64* %3, align 8
>   %24 = call i64 @extractFloat64Frac(i64 %23)
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   store i32 0, i32* %1
>   br label %43
17827,17830c16150,16166
< ; <label>:37                                      ; preds = %35, %32
<   %38 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %39 = icmp eq i32 %38, 0
<   br i1 %39, label %._crit_edge, label %40
---
> ; <label>:28                                      ; preds = %22, %18
>   %29 = load i64* %2, align 8
>   store i64 %29, i64* %av, align 8
>   %30 = load i64* %3, align 8
>   store i64 %30, i64* %bv, align 8
>   %31 = load i64* %av, align 8
>   %32 = load i64* %bv, align 8
>   %33 = icmp eq i64 %31, %32
>   br i1 %33, label %40, label %34
> 
> ; <label>:34                                      ; preds = %28
>   %35 = load i64* %av, align 8
>   %36 = load i64* %bv, align 8
>   %37 = or i64 %35, %36
>   %38 = shl i64 %37, 1
>   %39 = icmp eq i64 %38, 0
>   br label %40
17832,17841c16168,16172
< ; <label>:40                                      ; preds = %37
<   %41 = bitcast i32* %2 to i8*
<   call void @tcg_llvm_get_value(i8* %41, i32 4, i1 zeroext true) nounwind
<   br label %._crit_edge
< 
< ._crit_edge:                                      ; preds = %40, %37
<   %42 = load i16* %1, align 2
<   %43 = load i32* %2, align 4
<   call void @io_writew_mmu(i64 %physaddr, i16 zeroext %42, i32 %43, i8* %retaddr) nounwind
<   br label %44
---
> ; <label>:40                                      ; preds = %34, %28
>   %41 = phi i1 [ true, %28 ], [ %39, %34 ]
>   %42 = zext i1 %41 to i32
>   store i32 %42, i32* %1
>   br label %43
17843,17844c16174,16176
< ; <label>:44                                      ; preds = %._crit_edge, %28
<   ret void
---
> ; <label>:43                                      ; preds = %40, %26
>   %44 = load i32* %1
>   ret i32 %44
17847c16179,16226
< declare void @io_writew_mmu(i64, i16 zeroext, i32, i8*)
---
> define internal i32 @float64_le(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i64, align 8
>   %bv = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i32 @extractFloat64Exp(i64 %11)
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %18
> 
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %2, align 8
>   %16 = call i64 @extractFloat64Frac(i64 %15)
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   %21 = icmp eq i32 %20, 2047
>   br i1 %21, label %22, label %28
> 
> ; <label>:22                                      ; preds = %18
>   %23 = load i64* %3, align 8
>   %24 = call i64 @extractFloat64Frac(i64 %23)
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   store i32 0, i32* %1
>   br label %69
17849,17857c16228,16244
< define void @__stw_mmu(i32 %addr, i16 zeroext %val, i32 %mmu_idx) nounwind uwtable {
<   %1 = alloca i16, align 2
<   %2 = alloca i32, align 4
<   %3 = alloca i16, align 2
<   %4 = alloca i32, align 4
<   %5 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %6 = icmp eq i32 %5, 0
<   %7 = zext i32 %addr to i64
<   br i1 %6, label %10, label %8
---
> ; <label>:28                                      ; preds = %22, %18
>   %29 = load i64* %2, align 8
>   %30 = call zeroext i8 @extractFloat64Sign(i64 %29)
>   store i8 %30, i8* %aSign, align 1
>   %31 = load i64* %3, align 8
>   %32 = call zeroext i8 @extractFloat64Sign(i64 %31)
>   store i8 %32, i8* %bSign, align 1
>   %33 = load i64* %2, align 8
>   store i64 %33, i64* %av, align 8
>   %34 = load i64* %3, align 8
>   store i64 %34, i64* %bv, align 8
>   %35 = load i8* %aSign, align 1
>   %36 = zext i8 %35 to i32
>   %37 = load i8* %bSign, align 1
>   %38 = zext i8 %37 to i32
>   %39 = icmp ne i32 %36, %38
>   br i1 %39, label %40, label %53
17859,17861c16246,16258
< ; <label>:8                                       ; preds = %0
<   %9 = call i64 @tcg_llvm_fork_and_concretize(i64 %7, i64 0, i64 4294967295) nounwind
<   br label %10
---
> ; <label>:40                                      ; preds = %28
>   %41 = load i8* %aSign, align 1
>   %42 = zext i8 %41 to i32
>   %43 = icmp ne i32 %42, 0
>   br i1 %43, label %50, label %44
> 
> ; <label>:44                                      ; preds = %40
>   %45 = load i64* %av, align 8
>   %46 = load i64* %bv, align 8
>   %47 = or i64 %45, %46
>   %48 = shl i64 %47, 1
>   %49 = icmp eq i64 %48, 0
>   br label %50
17863,17890c16260,16264
< ; <label>:10                                      ; preds = %8, %0
<   %11 = phi i64 [ %9, %8 ], [ %7, %0 ]
<   %12 = trunc i64 %11 to i32
<   %13 = lshr i64 %11, 7
<   %14 = and i64 %13, 33554431
<   %15 = call i64 @tcg_llvm_fork_and_concretize(i64 %14, i64 0, i64 33554431) nounwind
<   %16 = lshr i64 %15, 5
<   %17 = and i64 %16, 255
<   %18 = sext i32 %mmu_idx to i64
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 73, i64 %18, i64 %17, i32 1
<   %21 = load i32* %20, align 4
<   %22 = and i32 %12, -4096
<   %23 = and i32 %21, -4088
<   %24 = icmp eq i32 %22, %23
<   br i1 %24, label %._crit_edge, label %.lr.ph, !prof !0
< 
< .lr.ph:                                           ; preds = %10
<   %25 = trunc i64 %15 to i32
<   %26 = shl i32 %25, 7
<   br label %182
< 
< ._crit_edge:                                      ; preds = %182, %10
<   %.lcssa34 = phi i32 [ %21, %10 ], [ %186, %182 ]
<   %.lcssa33 = phi %struct.CPUX86State* [ %19, %10 ], [ %184, %182 ]
<   %27 = and i32 %.lcssa34, 4095
<   %28 = icmp eq i32 %27, 0
<   br i1 %28, label %77, label %29, !prof !0
---
> ; <label>:50                                      ; preds = %44, %40
>   %51 = phi i1 [ true, %40 ], [ %49, %44 ]
>   %52 = zext i1 %51 to i32
>   store i32 %52, i32* %1
>   br label %69
17892,17895c16266,16281
< ; <label>:29                                      ; preds = %._crit_edge
<   %30 = and i32 %12, 1
<   %31 = icmp eq i32 %30, 0
<   br i1 %31, label %32, label %81
---
> ; <label>:53                                      ; preds = %28
>   %54 = load i64* %av, align 8
>   %55 = load i64* %bv, align 8
>   %56 = icmp eq i64 %54, %55
>   br i1 %56, label %66, label %57
> 
> ; <label>:57                                      ; preds = %53
>   %58 = load i8* %aSign, align 1
>   %59 = zext i8 %58 to i32
>   %60 = load i64* %av, align 8
>   %61 = load i64* %bv, align 8
>   %62 = icmp ult i64 %60, %61
>   %63 = zext i1 %62 to i32
>   %64 = xor i32 %59, %63
>   %65 = icmp ne i32 %64, 0
>   br label %66
17897,17920c16283,16287
< ; <label>:32                                      ; preds = %29
<   %33 = getelementptr inbounds %struct.CPUX86State* %.lcssa33, i64 0, i32 75, i64 %18, i64 %17
<   %34 = load i64* %33, align 8
<   %35 = bitcast i16* %3 to i8*
<   %36 = bitcast i32* %4 to i8*
<   store i16 %val, i16* %3, align 2
<   store i32 %12, i32* %4, align 4
<   %37 = call %struct.MemoryRegion* @iotlb_to_region(i64 %34) nounwind
<   %38 = and i64 %34, -4096
<   %39 = and i64 %11, 4294967295
<   %40 = add i64 %38, %39
<   %41 = icmp ne %struct.MemoryRegion* %37, @io_mem_ram
<   %42 = icmp ne %struct.MemoryRegion* %37, @io_mem_rom
<   %or.cond.i = and i1 %41, %42
<   %43 = icmp ne %struct.MemoryRegion* %37, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %43
<   %44 = icmp ne %struct.MemoryRegion* %37, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %44
<   %45 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %46 = load i32* @use_icount, align 4
<   %47 = icmp eq i32 %46, 0
<   %or.cond17.i = or i1 %47, %or.cond5.not.i
<   br i1 %or.cond17.i, label %can_do_io.exit.thread.i, label %48
---
> ; <label>:66                                      ; preds = %57, %53
>   %67 = phi i1 [ true, %53 ], [ %65, %57 ]
>   %68 = zext i1 %67 to i32
>   store i32 %68, i32* %1
>   br label %69
17922,17926c16289,16292
< ; <label>:48                                      ; preds = %32
<   %49 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 66
<   %50 = load %struct.TranslationBlock** %49, align 8
<   %51 = icmp eq %struct.TranslationBlock* %50, null
<   br i1 %51, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:69                                      ; preds = %66, %50, %26
>   %70 = load i32* %1
>   ret i32 %70
> }
17928,17932c16294,16317
< can_do_io.exit.i:                                 ; preds = %48
<   %52 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 85
<   %53 = load i32* %52, align 4
<   %54 = icmp eq i32 %53, 0
<   br i1 %54, label %55, label %can_do_io.exit.thread.i
---
> define internal i32 @float64_lt(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i64, align 8
>   %bv = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i32 @extractFloat64Exp(i64 %11)
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %18
17934,17936c16319,16341
< ; <label>:55                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %45, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %2, align 8
>   %16 = call i64 @extractFloat64Frac(i64 %15)
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   %21 = icmp eq i32 %20, 2047
>   br i1 %21, label %22, label %28
> 
> ; <label>:22                                      ; preds = %18
>   %23 = load i64* %3, align 8
>   %24 = call i64 @extractFloat64Frac(i64 %23)
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   store i32 0, i32* %1
>   br label %69
17938,17953c16343,16359
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %48, %32
<   %56 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 69
<   store i32 %12, i32* %56, align 4
<   %57 = load %struct.CPUX86State** @env, align 8
<   %58 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 68
<   store i64 0, i64* %58, align 8
<   %59 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %37, i32 1) nounwind
<   %60 = icmp eq i32 %59, 0
<   br i1 %60, label %65, label %61
< 
< ; <label>:61                                      ; preds = %can_do_io.exit.thread.i
<   %62 = call i64 @s2e_notdirty_mem_write(i64 %40) nounwind
<   %63 = load i16* %3, align 2
<   %64 = inttoptr i64 %62 to i16*
<   store i16 %63, i16* %64, align 2
<   br label %io_write_chkw_mmu.exit
---
> ; <label>:28                                      ; preds = %22, %18
>   %29 = load i64* %2, align 8
>   %30 = call zeroext i8 @extractFloat64Sign(i64 %29)
>   store i8 %30, i8* %aSign, align 1
>   %31 = load i64* %3, align 8
>   %32 = call zeroext i8 @extractFloat64Sign(i64 %31)
>   store i8 %32, i8* %bSign, align 1
>   %33 = load i64* %2, align 8
>   store i64 %33, i64* %av, align 8
>   %34 = load i64* %3, align 8
>   store i64 %34, i64* %bv, align 8
>   %35 = load i8* %aSign, align 1
>   %36 = zext i8 %35 to i32
>   %37 = load i8* %bSign, align 1
>   %38 = zext i8 %37 to i32
>   %39 = icmp ne i32 %36, %38
>   br i1 %39, label %40, label %53
17955,17958c16361,16373
< ; <label>:65                                      ; preds = %can_do_io.exit.thread.i
<   %66 = load i32* @g_s2e_concretize_io_writes, align 4
<   %67 = icmp eq i32 %66, 0
<   br i1 %67, label %69, label %68
---
> ; <label>:40                                      ; preds = %28
>   %41 = load i8* %aSign, align 1
>   %42 = zext i8 %41 to i32
>   %43 = icmp ne i32 %42, 0
>   br i1 %43, label %44, label %50
> 
> ; <label>:44                                      ; preds = %40
>   %45 = load i64* %av, align 8
>   %46 = load i64* %bv, align 8
>   %47 = or i64 %45, %46
>   %48 = shl i64 %47, 1
>   %49 = icmp ne i64 %48, 0
>   br label %50
17960,17961c16375,16378
< ; <label>:68                                      ; preds = %65
<   call void @tcg_llvm_get_value(i8* %35, i32 2, i1 zeroext true) nounwind
---
> ; <label>:50                                      ; preds = %44, %40
>   %51 = phi i1 [ false, %40 ], [ %49, %44 ]
>   %52 = zext i1 %51 to i32
>   store i32 %52, i32* %1
17964,17971c16381,16396
< ; <label>:69                                      ; preds = %68, %65
<   %70 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %71 = icmp eq i32 %70, 0
<   br i1 %71, label %._crit_edge.i, label %72
< 
< ; <label>:72                                      ; preds = %69
<   call void @tcg_llvm_get_value(i8* %36, i32 4, i1 zeroext true) nounwind
<   br label %._crit_edge.i
---
> ; <label>:53                                      ; preds = %28
>   %54 = load i64* %av, align 8
>   %55 = load i64* %bv, align 8
>   %56 = icmp ne i64 %54, %55
>   br i1 %56, label %57, label %66
> 
> ; <label>:57                                      ; preds = %53
>   %58 = load i8* %aSign, align 1
>   %59 = zext i8 %58 to i32
>   %60 = load i64* %av, align 8
>   %61 = load i64* %bv, align 8
>   %62 = icmp ult i64 %60, %61
>   %63 = zext i1 %62 to i32
>   %64 = xor i32 %59, %63
>   %65 = icmp ne i32 %64, 0
>   br label %66
17973,17989c16398,16402
< ._crit_edge.i:                                    ; preds = %72, %69
<   %73 = load i16* %3, align 2
<   %74 = load i32* %4, align 4
<   call void @io_writew_mmu(i64 %34, i16 zeroext %73, i32 %74, i8* null) nounwind
<   br label %io_write_chkw_mmu.exit
< 
< io_write_chkw_mmu.exit:                           ; preds = %._crit_edge.i, %61
<   %75 = add i64 %34, %39
<   %76 = zext i16 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %39, i64 %75, i64 %76, i32 16, i8 zeroext 1, i8 zeroext 1) nounwind
<   br label %slow_stw_mmu.exit
< 
< ; <label>:77                                      ; preds = %._crit_edge
<   %78 = and i32 %12, 127
<   %79 = add i32 %78, 1
<   %80 = icmp ugt i32 %79, 127
<   br i1 %80, label %81, label %175, !prof !1
---
> ; <label>:66                                      ; preds = %57, %53
>   %67 = phi i1 [ false, %53 ], [ %65, %57 ]
>   %68 = zext i1 %67 to i32
>   store i32 %68, i32* %1
>   br label %69
17991,17995c16404,16407
< ; <label>:81                                      ; preds = %77, %29
<   %82 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %83 = icmp eq i32 %82, 0
<   %84 = and i64 %11, 4294967295
<   br i1 %83, label %87, label %85
---
> ; <label>:69                                      ; preds = %66, %50, %26
>   %70 = load i32* %1
>   ret i32 %70
> }
17997,17999c16409,16428
< ; <label>:85                                      ; preds = %81
<   %86 = call i64 @tcg_llvm_fork_and_concretize(i64 %84, i64 0, i64 4294967295) nounwind
<   br label %87
---
> define internal i32 @float64_unordered(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i32 @extractFloat64Exp(i64 %11)
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %18
18001,18020c16430,16452
< ; <label>:87                                      ; preds = %85, %81
<   %88 = phi i64 [ %86, %85 ], [ %84, %81 ]
<   %89 = trunc i64 %88 to i32
<   %90 = lshr i64 %88, 7
<   %91 = and i64 %90, 33554431
<   %92 = call i64 @tcg_llvm_fork_and_concretize(i64 %91, i64 0, i64 33554431) nounwind
<   %93 = lshr i64 %92, 5
<   %94 = and i64 %93, 255
<   %95 = load %struct.CPUX86State** @env, align 8
<   %96 = getelementptr inbounds %struct.CPUX86State* %95, i64 0, i32 73, i64 %18, i64 %94, i32 1
<   %97 = load i32* %96, align 4
<   %98 = and i32 %89, -4096
<   %99 = and i32 %97, -4088
<   %100 = icmp eq i32 %98, %99
<   br i1 %100, label %._crit_edge.i30, label %.lr.ph.i
< 
< .lr.ph.i:                                         ; preds = %87
<   %101 = trunc i64 %92 to i32
<   %102 = shl i32 %101, 7
<   br label %168
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %2, align 8
>   %16 = call i64 @extractFloat64Frac(i64 %15)
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   %21 = icmp eq i32 %20, 2047
>   br i1 %21, label %22, label %28
> 
> ; <label>:22                                      ; preds = %18
>   %23 = load i64* %3, align 8
>   %24 = call i64 @extractFloat64Frac(i64 %23)
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   store i32 1, i32* %1
>   br label %29
18022,18069c16454,16456
< ._crit_edge.i30:                                  ; preds = %168, %87
<   %.lcssa3.i = phi i32 [ %97, %87 ], [ %172, %168 ]
<   %.lcssa2.i = phi %struct.CPUX86State* [ %95, %87 ], [ %170, %168 ]
<   %103 = and i32 %.lcssa3.i, 4095
<   %104 = icmp eq i32 %103, 0
<   br i1 %104, label %153, label %105
< 
< ; <label>:105                                     ; preds = %._crit_edge.i30
<   %106 = and i32 %89, 1
<   %107 = icmp eq i32 %106, 0
<   br i1 %107, label %108, label %.preheader.i
< 
< ; <label>:108                                     ; preds = %105
<   %109 = getelementptr inbounds %struct.CPUX86State* %.lcssa2.i, i64 0, i32 75, i64 %18, i64 %94
<   %110 = load i64* %109, align 8
<   %111 = bitcast i16* %1 to i8*
<   %112 = bitcast i32* %2 to i8*
<   store i16 %val, i16* %1, align 2
<   store i32 %89, i32* %2, align 4
<   %113 = call %struct.MemoryRegion* @iotlb_to_region(i64 %110) nounwind
<   %114 = and i64 %110, -4096
<   %115 = and i64 %88, 4294967295
<   %116 = add i64 %114, %115
<   %117 = icmp ne %struct.MemoryRegion* %113, @io_mem_ram
<   %118 = icmp ne %struct.MemoryRegion* %113, @io_mem_rom
<   %or.cond.i.i = and i1 %117, %118
<   %119 = icmp ne %struct.MemoryRegion* %113, @io_mem_unassigned
<   %or.cond3.i.i = and i1 %or.cond.i.i, %119
<   %120 = icmp ne %struct.MemoryRegion* %113, @io_mem_notdirty
<   %or.cond5.i.i = and i1 %or.cond3.i.i, %120
<   %121 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i.i = xor i1 %or.cond5.i.i, true
<   %122 = load i32* @use_icount, align 4
<   %123 = icmp eq i32 %122, 0
<   %or.cond17.i.i = or i1 %123, %or.cond5.not.i.i
<   br i1 %or.cond17.i.i, label %can_do_io.exit.thread.i.i, label %124
< 
< ; <label>:124                                     ; preds = %108
<   %125 = getelementptr inbounds %struct.CPUX86State* %121, i64 0, i32 66
<   %126 = load %struct.TranslationBlock** %125, align 8
<   %127 = icmp eq %struct.TranslationBlock* %126, null
<   br i1 %127, label %can_do_io.exit.thread.i.i, label %can_do_io.exit.i.i
< 
< can_do_io.exit.i.i:                               ; preds = %124
<   %128 = getelementptr inbounds %struct.CPUX86State* %121, i64 0, i32 85
<   %129 = load i32* %128, align 4
<   %130 = icmp eq i32 %129, 0
<   br i1 %130, label %131, label %can_do_io.exit.thread.i.i
---
> ; <label>:28                                      ; preds = %22, %18
>   store i32 0, i32* %1
>   br label %29
18071,18073c16458,16461
< ; <label>:131                                     ; preds = %can_do_io.exit.i.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %121, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:29                                      ; preds = %28, %26
>   %30 = load i32* %1
>   ret i32 %30
> }
18075,18083c16463,16484
< can_do_io.exit.thread.i.i:                        ; preds = %can_do_io.exit.i.i, %124, %108
<   %132 = getelementptr inbounds %struct.CPUX86State* %121, i64 0, i32 69
<   store i32 %89, i32* %132, align 4
<   %133 = load %struct.CPUX86State** @env, align 8
<   %134 = getelementptr inbounds %struct.CPUX86State* %133, i64 0, i32 68
<   store i64 0, i64* %134, align 8
<   %135 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %113, i32 1) nounwind
<   %136 = icmp eq i32 %135, 0
<   br i1 %136, label %141, label %137
---
> define internal i32 @float64_eq_quiet(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %av = alloca i64, align 8
>   %bv = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i32 @extractFloat64Exp(i64 %11)
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %18
18085,18090c16486,16519
< ; <label>:137                                     ; preds = %can_do_io.exit.thread.i.i
<   %138 = call i64 @s2e_notdirty_mem_write(i64 %116) nounwind
<   %139 = load i16* %1, align 2
<   %140 = inttoptr i64 %138 to i16*
<   store i16 %139, i16* %140, align 2
<   br label %io_write_chkw_mmu.exit.i
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %2, align 8
>   %16 = call i64 @extractFloat64Frac(i64 %15)
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   %21 = icmp eq i32 %20, 2047
>   br i1 %21, label %22, label %37
> 
> ; <label>:22                                      ; preds = %18
>   %23 = load i64* %3, align 8
>   %24 = call i64 @extractFloat64Frac(i64 %23)
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %37
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load i64* %2, align 8
>   %28 = call i32 @float64_is_signaling_nan(i64 %27)
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %34, label %30
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load i64* %3, align 8
>   %32 = call i32 @float64_is_signaling_nan(i64 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
> 
> ; <label>:34                                      ; preds = %30, %26
>   %35 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
18092,18095c16521,16523
< ; <label>:141                                     ; preds = %can_do_io.exit.thread.i.i
<   %142 = load i32* @g_s2e_concretize_io_writes, align 4
<   %143 = icmp eq i32 %142, 0
<   br i1 %143, label %145, label %144
---
> ; <label>:36                                      ; preds = %34, %30
>   store i32 0, i32* %1
>   br label %52
18097,18099c16525,16541
< ; <label>:144                                     ; preds = %141
<   call void @tcg_llvm_get_value(i8* %111, i32 2, i1 zeroext true) nounwind
<   br label %145
---
> ; <label>:37                                      ; preds = %22, %18
>   %38 = load i64* %2, align 8
>   store i64 %38, i64* %av, align 8
>   %39 = load i64* %3, align 8
>   store i64 %39, i64* %bv, align 8
>   %40 = load i64* %av, align 8
>   %41 = load i64* %bv, align 8
>   %42 = icmp eq i64 %40, %41
>   br i1 %42, label %49, label %43
> 
> ; <label>:43                                      ; preds = %37
>   %44 = load i64* %av, align 8
>   %45 = load i64* %bv, align 8
>   %46 = or i64 %44, %45
>   %47 = shl i64 %46, 1
>   %48 = icmp eq i64 %47, 0
>   br label %49
18101,18135c16543,16547
< ; <label>:145                                     ; preds = %144, %141
<   %146 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %147 = icmp eq i32 %146, 0
<   br i1 %147, label %._crit_edge.i.i, label %148
< 
< ; <label>:148                                     ; preds = %145
<   call void @tcg_llvm_get_value(i8* %112, i32 4, i1 zeroext true) nounwind
<   br label %._crit_edge.i.i
< 
< ._crit_edge.i.i:                                  ; preds = %148, %145
<   %149 = load i16* %1, align 2
<   %150 = load i32* %2, align 4
<   call void @io_writew_mmu(i64 %110, i16 zeroext %149, i32 %150, i8* null) nounwind
<   br label %io_write_chkw_mmu.exit.i
< 
< io_write_chkw_mmu.exit.i:                         ; preds = %._crit_edge.i.i, %137
<   %151 = add i64 %110, %115
<   %152 = zext i16 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %115, i64 %151, i64 %152, i32 16, i8 zeroext 1, i8 zeroext 1) nounwind
<   br label %slow_stw_mmu.exit
< 
< ; <label>:153                                     ; preds = %._crit_edge.i30
<   %154 = and i32 %89, 127
<   %155 = add i32 %154, 1
<   %156 = icmp ugt i32 %155, 127
<   br i1 %156, label %.preheader.i, label %161
< 
< .preheader.i:                                     ; preds = %153, %105
<   %157 = add i32 %89, 1
<   %158 = lshr i16 %val, 8
<   %159 = trunc i16 %158 to i8
<   call fastcc void @slow_stb_mmu(i32 %157, i8 zeroext %159, i32 %mmu_idx) nounwind
<   %160 = trunc i16 %val to i8
<   call fastcc void @slow_stb_mmu(i32 %89, i8 zeroext %160, i32 %mmu_idx) nounwind
<   br label %slow_stw_mmu.exit
---
> ; <label>:49                                      ; preds = %43, %37
>   %50 = phi i1 [ true, %37 ], [ %48, %43 ]
>   %51 = zext i1 %50 to i32
>   store i32 %51, i32* %1
>   br label %52
18137,18156c16549,16552
< ; <label>:161                                     ; preds = %153
<   %162 = getelementptr inbounds %struct.CPUX86State* %.lcssa2.i, i64 0, i32 73, i64 %18, i64 %94, i32 3
<   %163 = load i64* %162, align 8
<   %164 = and i64 %88, 4294967295
<   %165 = add i64 %163, %164
<   %166 = inttoptr i64 %165 to i16*
<   store i16 %val, i16* %166, align 2
<   %167 = zext i16 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %164, i64 %165, i64 %167, i32 16, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %slow_stw_mmu.exit
< 
< ; <label>:168                                     ; preds = %168, %.lr.ph.i
<   %169 = phi %struct.CPUX86State* [ %95, %.lr.ph.i ], [ %170, %168 ]
<   call void @tlb_fill(%struct.CPUX86State* %169, i32 %89, i32 %102, i32 1, i32 %mmu_idx, i8* null) nounwind
<   %170 = load %struct.CPUX86State** @env, align 8
<   %171 = getelementptr inbounds %struct.CPUX86State* %170, i64 0, i32 73, i64 %18, i64 %94, i32 1
<   %172 = load i32* %171, align 4
<   %173 = and i32 %172, -4088
<   %174 = icmp eq i32 %98, %173
<   br i1 %174, label %._crit_edge.i30, label %168
---
> ; <label>:52                                      ; preds = %49, %36
>   %53 = load i32* %1
>   ret i32 %53
> }
18158,18177c16554,16577
< ; <label>:175                                     ; preds = %77
<   %176 = getelementptr inbounds %struct.CPUX86State* %.lcssa33, i64 0, i32 73, i64 %18, i64 %17, i32 3
<   %177 = load i64* %176, align 8
<   %178 = and i64 %11, 4294967295
<   %179 = add i64 %177, %178
<   %180 = inttoptr i64 %179 to i16*
<   store i16 %val, i16* %180, align 2
<   %181 = zext i16 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %178, i64 %179, i64 %181, i32 16, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %slow_stw_mmu.exit
< 
< ; <label>:182                                     ; preds = %182, %.lr.ph
<   %183 = phi %struct.CPUX86State* [ %19, %.lr.ph ], [ %184, %182 ]
<   call void @tlb_fill(%struct.CPUX86State* %183, i32 %12, i32 %26, i32 1, i32 %mmu_idx, i8* null)
<   %184 = load %struct.CPUX86State** @env, align 8
<   %185 = getelementptr inbounds %struct.CPUX86State* %184, i64 0, i32 73, i64 %18, i64 %17, i32 1
<   %186 = load i32* %185, align 4
<   %187 = and i32 %186, -4088
<   %188 = icmp eq i32 %22, %187
<   br i1 %188, label %._crit_edge, label %182, !prof !0
---
> define internal i32 @float64_le_quiet(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i64, align 8
>   %bv = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i32 @extractFloat64Exp(i64 %11)
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %18
18179,18181c16579,16612
< slow_stw_mmu.exit:                                ; preds = %175, %161, %.preheader.i, %io_write_chkw_mmu.exit.i, %io_write_chkw_mmu.exit
<   ret void
< }
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %2, align 8
>   %16 = call i64 @extractFloat64Frac(i64 %15)
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   %21 = icmp eq i32 %20, 2047
>   br i1 %21, label %22, label %37
> 
> ; <label>:22                                      ; preds = %18
>   %23 = load i64* %3, align 8
>   %24 = call i64 @extractFloat64Frac(i64 %23)
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %37
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load i64* %2, align 8
>   %28 = call i32 @float64_is_signaling_nan(i64 %27)
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %34, label %30
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load i64* %3, align 8
>   %32 = call i32 @float64_is_signaling_nan(i64 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
> 
> ; <label>:34                                      ; preds = %30, %26
>   %35 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
18183,18193c16614,16616
< define i32 @io_read_chkl_mmu(i64 %physaddr, i32 %addr, i8* %retaddr) nounwind uwtable inlinehint alwaysinline {
<   %ret.i.i = alloca i8, align 1
<   %label = alloca [64 x i8], align 16
<   %1 = call %struct.MemoryRegion* @iotlb_to_region(i64 %physaddr) nounwind
<   %2 = and i64 %physaddr, 4294963200
<   %3 = zext i32 %addr to i64
<   %4 = add i64 %3, %2
<   %5 = trunc i64 %4 to i32
<   %6 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %7 = icmp eq i32 %6, 0
<   br i1 %7, label %17, label %8
---
> ; <label>:36                                      ; preds = %34, %30
>   store i32 0, i32* %1
>   br label %78
18195,18199c16618,16640
< ; <label>:8                                       ; preds = %0
<   %9 = and i64 %4, 4294967295
<   %10 = call i32 @s2e_is_mmio_symbolic_l(i64 %9) nounwind
<   %11 = icmp eq i32 %10, 0
<   br i1 %11, label %17, label %12
---
> ; <label>:37                                      ; preds = %22, %18
>   %38 = load i64* %2, align 8
>   %39 = call zeroext i8 @extractFloat64Sign(i64 %38)
>   store i8 %39, i8* %aSign, align 1
>   %40 = load i64* %3, align 8
>   %41 = call zeroext i8 @extractFloat64Sign(i64 %40)
>   store i8 %41, i8* %bSign, align 1
>   %42 = load i64* %2, align 8
>   store i64 %42, i64* %av, align 8
>   %43 = load i64* %3, align 8
>   store i64 %43, i64* %bv, align 8
>   %44 = load i8* %aSign, align 1
>   %45 = zext i8 %44 to i32
>   %46 = load i8* %bSign, align 1
>   %47 = zext i8 %46 to i32
>   %48 = icmp ne i32 %45, %47
>   br i1 %48, label %49, label %62
> 
> ; <label>:49                                      ; preds = %37
>   %50 = load i8* %aSign, align 1
>   %51 = zext i8 %50 to i32
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %59, label %53
18201,18207c16642,16648
< ; <label>:12                                      ; preds = %8
<   %13 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 5
<   %16 = load i32* %15, align 4
<   call void @trace_port(i8* %13, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %5, i32 %16)
<   br label %17
---
> ; <label>:53                                      ; preds = %49
>   %54 = load i64* %av, align 8
>   %55 = load i64* %bv, align 8
>   %56 = or i64 %54, %55
>   %57 = shl i64 %56, 1
>   %58 = icmp eq i64 %57, 0
>   br label %59
18209,18227c16650,16654
< ; <label>:17                                      ; preds = %12, %8, %0
<   %isSymb.0 = phi i32 [ %10, %12 ], [ 0, %8 ], [ 0, %0 ]
<   %18 = ptrtoint i8* %retaddr to i64
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 68
<   store i64 %18, i64* %20, align 8
<   %21 = icmp ne %struct.MemoryRegion* %1, @io_mem_ram
<   %22 = icmp ne %struct.MemoryRegion* %1, @io_mem_rom
<   %or.cond = and i1 %21, %22
<   %23 = icmp ne %struct.MemoryRegion* %1, @io_mem_unassigned
<   %or.cond3 = and i1 %or.cond, %23
<   %24 = icmp ne %struct.MemoryRegion* %1, @io_mem_notdirty
<   %or.cond5 = and i1 %or.cond3, %24
<   %25 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not = xor i1 %or.cond5, true
<   %26 = load i32* @use_icount, align 4
<   %27 = icmp eq i32 %26, 0
<   %or.cond26 = or i1 %27, %or.cond5.not
<   br i1 %or.cond26, label %can_do_io.exit.thread, label %28
---
> ; <label>:59                                      ; preds = %53, %49
>   %60 = phi i1 [ true, %49 ], [ %58, %53 ]
>   %61 = zext i1 %60 to i32
>   store i32 %61, i32* %1
>   br label %78
18229,18233c16656,16671
< ; <label>:28                                      ; preds = %17
<   %29 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 66
<   %30 = load %struct.TranslationBlock** %29, align 8
<   %31 = icmp eq %struct.TranslationBlock* %30, null
<   br i1 %31, label %can_do_io.exit.thread, label %can_do_io.exit
---
> ; <label>:62                                      ; preds = %37
>   %63 = load i64* %av, align 8
>   %64 = load i64* %bv, align 8
>   %65 = icmp eq i64 %63, %64
>   br i1 %65, label %75, label %66
> 
> ; <label>:66                                      ; preds = %62
>   %67 = load i8* %aSign, align 1
>   %68 = zext i8 %67 to i32
>   %69 = load i64* %av, align 8
>   %70 = load i64* %bv, align 8
>   %71 = icmp ult i64 %69, %70
>   %72 = zext i1 %71 to i32
>   %73 = xor i32 %68, %72
>   %74 = icmp ne i32 %73, 0
>   br label %75
18235,18239c16673,16677
< can_do_io.exit:                                   ; preds = %28
<   %32 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 85
<   %33 = load i32* %32, align 4
<   %34 = icmp eq i32 %33, 0
<   br i1 %34, label %35, label %can_do_io.exit.thread
---
> ; <label>:75                                      ; preds = %66, %62
>   %76 = phi i1 [ true, %62 ], [ %74, %66 ]
>   %77 = zext i1 %76 to i32
>   store i32 %77, i32* %1
>   br label %78
18241,18243c16679,16682
< ; <label>:35                                      ; preds = %can_do_io.exit
<   call void @cpu_io_recompile(%struct.CPUX86State* %25, i8* %retaddr) noreturn nounwind
<   unreachable
---
> ; <label>:78                                      ; preds = %75, %59, %36
>   %79 = load i32* %1
>   ret i32 %79
> }
18245,18250c16684,16707
< can_do_io.exit.thread:                            ; preds = %can_do_io.exit, %28, %17
<   %36 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 69
<   store i32 %addr, i32* %36, align 4
<   %37 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %1, i32 0) nounwind
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %86, label %39
---
> define internal i32 @float64_lt_quiet(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i64, align 8
>   %bv = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i32 @extractFloat64Exp(i64 %11)
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %18
18252,18255c16709,16742
< ; <label>:39                                      ; preds = %can_do_io.exit.thread
<   %40 = call i64 @s2e_notdirty_mem_write(i64 %physaddr) nounwind
<   %41 = icmp eq i32 %isSymb.0, 0
<   br i1 %41, label %83, label %42
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %2, align 8
>   %16 = call i64 @extractFloat64Frac(i64 %15)
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   %21 = icmp eq i32 %20, 2047
>   br i1 %21, label %22, label %37
> 
> ; <label>:22                                      ; preds = %18
>   %23 = load i64* %3, align 8
>   %24 = call i64 @extractFloat64Frac(i64 %23)
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %37
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load i64* %2, align 8
>   %28 = call i32 @float64_is_signaling_nan(i64 %27)
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %34, label %30
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load i64* %3, align 8
>   %32 = call i32 @float64_is_signaling_nan(i64 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
> 
> ; <label>:34                                      ; preds = %30, %26
>   %35 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
18257,18270c16744,16746
< ; <label>:42                                      ; preds = %39
<   %43 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %44 = inttoptr i64 %40 to i32*
<   %45 = load i32* %44, align 4
<   %data.i.sroa.0.0.extract.trunc = trunc i32 %45 to i8
<   %data.i.sroa.1.1.extract.shift = lshr i32 %45, 8
<   %data.i.sroa.1.1.extract.trunc = trunc i32 %data.i.sroa.1.1.extract.shift to i8
<   %data.i.sroa.2.2.extract.shift = lshr i32 %45, 16
<   %data.i.sroa.2.2.extract.trunc = trunc i32 %data.i.sroa.2.2.extract.shift to i8
<   %data.i.sroa.3.3.extract.shift = lshr i32 %45, 24
<   %data.i.sroa.3.3.extract.trunc = trunc i32 %data.i.sroa.3.3.extract.shift to i8
<   %46 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %47 = icmp eq i32 %46, 0
<   br i1 %47, label %io_read_chk_symb_l.exit, label %48
---
> ; <label>:36                                      ; preds = %34, %30
>   store i32 0, i32* %1
>   br label %78
18272,18294c16748,16770
< ; <label>:48                                      ; preds = %42
<   %49 = and i64 %4, 4294967295
<   %50 = call i32 @s2e_is_mmio_symbolic_b(i64 %49) nounwind
<   %51 = icmp eq i32 %50, 0
<   br i1 %51, label %._crit_edge10.i, label %52
< 
< ; <label>:52                                      ; preds = %48
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i, i32 1, i8* %43) nounwind
<   %53 = load i8* %ret.i.i, align 1
<   br label %._crit_edge10.i
< 
< ._crit_edge10.i:                                  ; preds = %52, %48
<   %data.i.sroa.0.0.extract.trunc23 = phi i8 [ %53, %52 ], [ %data.i.sroa.0.0.extract.trunc, %48 ]
<   %.pr.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %54 = icmp eq i32 %.pr.i, 0
<   br i1 %54, label %io_read_chk_symb_l.exit, label %55
< 
< ; <label>:55                                      ; preds = %._crit_edge10.i
<   %56 = add i64 %4, 1
<   %57 = and i64 %56, 4294967295
<   %58 = call i32 @s2e_is_mmio_symbolic_b(i64 %57) nounwind
<   %59 = icmp eq i32 %58, 0
<   br i1 %59, label %._crit_edge9.i, label %60
---
> ; <label>:37                                      ; preds = %22, %18
>   %38 = load i64* %2, align 8
>   %39 = call zeroext i8 @extractFloat64Sign(i64 %38)
>   store i8 %39, i8* %aSign, align 1
>   %40 = load i64* %3, align 8
>   %41 = call zeroext i8 @extractFloat64Sign(i64 %40)
>   store i8 %41, i8* %bSign, align 1
>   %42 = load i64* %2, align 8
>   store i64 %42, i64* %av, align 8
>   %43 = load i64* %3, align 8
>   store i64 %43, i64* %bv, align 8
>   %44 = load i8* %aSign, align 1
>   %45 = zext i8 %44 to i32
>   %46 = load i8* %bSign, align 1
>   %47 = zext i8 %46 to i32
>   %48 = icmp ne i32 %45, %47
>   br i1 %48, label %49, label %62
> 
> ; <label>:49                                      ; preds = %37
>   %50 = load i8* %aSign, align 1
>   %51 = zext i8 %50 to i32
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %53, label %59
18296,18312c16772,16778
< ; <label>:60                                      ; preds = %55
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i, i32 1, i8* %43) nounwind
<   %61 = load i8* %ret.i.i, align 1
<   br label %._crit_edge9.i
< 
< ._crit_edge9.i:                                   ; preds = %60, %55
<   %62 = phi i8 [ %61, %60 ], [ %data.i.sroa.1.1.extract.trunc, %55 ]
<   %.pr11.pr.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %63 = icmp eq i32 %.pr11.pr.i, 0
<   br i1 %63, label %io_read_chk_symb_l.exit, label %64
< 
< ; <label>:64                                      ; preds = %._crit_edge9.i
<   %65 = add i64 %4, 2
<   %66 = and i64 %65, 4294967295
<   %67 = call i32 @s2e_is_mmio_symbolic_b(i64 %66) nounwind
<   %68 = icmp eq i32 %67, 0
<   br i1 %68, label %._crit_edge8.i, label %69
---
> ; <label>:53                                      ; preds = %49
>   %54 = load i64* %av, align 8
>   %55 = load i64* %bv, align 8
>   %56 = or i64 %54, %55
>   %57 = shl i64 %56, 1
>   %58 = icmp ne i64 %57, 0
>   br label %59
18314,18352c16780,16784
< ; <label>:69                                      ; preds = %64
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i, i32 1, i8* %43) nounwind
<   %70 = load i8* %ret.i.i, align 1
<   br label %._crit_edge8.i
< 
< ._crit_edge8.i:                                   ; preds = %69, %64
<   %71 = phi i8 [ %70, %69 ], [ %data.i.sroa.2.2.extract.trunc, %64 ]
<   %.pr12.pr.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %72 = icmp eq i32 %.pr12.pr.i, 0
<   br i1 %72, label %io_read_chk_symb_l.exit, label %73
< 
< ; <label>:73                                      ; preds = %._crit_edge8.i
<   %74 = add i64 %4, 3
<   %75 = and i64 %74, 4294967295
<   %76 = call i32 @s2e_is_mmio_symbolic_b(i64 %75) nounwind
<   %77 = icmp eq i32 %76, 0
<   br i1 %77, label %io_read_chk_symb_l.exit, label %78
< 
< ; <label>:78                                      ; preds = %73
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i, i32 1, i8* %43) nounwind
<   %79 = load i8* %ret.i.i, align 1
<   br label %io_read_chk_symb_l.exit
< 
< io_read_chk_symb_l.exit:                          ; preds = %78, %73, %._crit_edge8.i, %._crit_edge9.i, %._crit_edge10.i, %42
<   %80 = phi i8 [ %data.i.sroa.3.3.extract.trunc, %42 ], [ %data.i.sroa.3.3.extract.trunc, %._crit_edge10.i ], [ %data.i.sroa.3.3.extract.trunc, %._crit_edge9.i ], [ %data.i.sroa.3.3.extract.trunc, %._crit_edge8.i ], [ %data.i.sroa.3.3.extract.trunc, %73 ], [ %79, %78 ]
<   %81 = phi i8 [ %data.i.sroa.2.2.extract.trunc, %42 ], [ %data.i.sroa.2.2.extract.trunc, %._crit_edge10.i ], [ %data.i.sroa.2.2.extract.trunc, %._crit_edge9.i ], [ %71, %._crit_edge8.i ], [ %71, %73 ], [ %71, %78 ]
<   %82 = phi i8 [ %data.i.sroa.1.1.extract.trunc, %42 ], [ %data.i.sroa.1.1.extract.trunc, %._crit_edge10.i ], [ %62, %._crit_edge9.i ], [ %62, %._crit_edge8.i ], [ %62, %73 ], [ %62, %78 ]
<   %data.i.sroa.0.0.extract.trunc24 = phi i8 [ %data.i.sroa.0.0.extract.trunc, %42 ], [ %data.i.sroa.0.0.extract.trunc23, %._crit_edge10.i ], [ %data.i.sroa.0.0.extract.trunc23, %._crit_edge9.i ], [ %data.i.sroa.0.0.extract.trunc23, %._crit_edge8.i ], [ %data.i.sroa.0.0.extract.trunc23, %73 ], [ %data.i.sroa.0.0.extract.trunc23, %78 ]
<   %data.i.sroa.3.3.insert.ext = zext i8 %80 to i32
<   %data.i.sroa.3.3.insert.shift = shl nuw i32 %data.i.sroa.3.3.insert.ext, 24
<   %data.i.sroa.2.2.insert.ext = zext i8 %81 to i32
<   %data.i.sroa.2.2.insert.shift = shl nuw nsw i32 %data.i.sroa.2.2.insert.ext, 16
<   %data.i.sroa.2.2.insert.insert = or i32 %data.i.sroa.2.2.insert.shift, %data.i.sroa.3.3.insert.shift
<   %data.i.sroa.1.1.insert.ext = zext i8 %82 to i32
<   %data.i.sroa.1.1.insert.shift = shl nuw nsw i32 %data.i.sroa.1.1.insert.ext, 8
<   %data.i.sroa.1.1.insert.insert = or i32 %data.i.sroa.2.2.insert.insert, %data.i.sroa.1.1.insert.shift
<   %data.i.sroa.0.0.insert.ext = zext i8 %data.i.sroa.0.0.extract.trunc24 to i32
<   %data.i.sroa.0.0.insert.insert = or i32 %data.i.sroa.1.1.insert.insert, %data.i.sroa.0.0.insert.ext
<   br label %88
---
> ; <label>:59                                      ; preds = %53, %49
>   %60 = phi i1 [ false, %49 ], [ %58, %53 ]
>   %61 = zext i1 %60 to i32
>   store i32 %61, i32* %1
>   br label %78
18354,18357c16786,16801
< ; <label>:83                                      ; preds = %39
<   %84 = inttoptr i64 %40 to i32*
<   %85 = load i32* %84, align 4
<   br label %88
---
> ; <label>:62                                      ; preds = %37
>   %63 = load i64* %av, align 8
>   %64 = load i64* %bv, align 8
>   %65 = icmp ne i64 %63, %64
>   br i1 %65, label %66, label %75
> 
> ; <label>:66                                      ; preds = %62
>   %67 = load i8* %aSign, align 1
>   %68 = zext i8 %67 to i32
>   %69 = load i64* %av, align 8
>   %70 = load i64* %bv, align 8
>   %71 = icmp ult i64 %69, %70
>   %72 = zext i1 %71 to i32
>   %73 = xor i32 %68, %72
>   %74 = icmp ne i32 %73, 0
>   br label %75
18359,18361c16803,16807
< ; <label>:86                                      ; preds = %can_do_io.exit.thread
<   %87 = call i32 @io_readl_mmu(i64 %physaddr, i32 %addr, i8* %retaddr) nounwind
<   br label %88
---
> ; <label>:75                                      ; preds = %66, %62
>   %76 = phi i1 [ false, %62 ], [ %74, %66 ]
>   %77 = zext i1 %76 to i32
>   store i32 %77, i32* %1
>   br label %78
18363,18365c16809,16811
< ; <label>:88                                      ; preds = %86, %83, %io_read_chk_symb_l.exit
<   %.0 = phi i32 [ %data.i.sroa.0.0.insert.insert, %io_read_chk_symb_l.exit ], [ %85, %83 ], [ %87, %86 ]
<   ret i32 %.0
---
> ; <label>:78                                      ; preds = %75, %59, %36
>   %79 = load i32* %1
>   ret i32 %79
18368,18370c16814,16833
< declare i32 @s2e_is_mmio_symbolic_l(i64)
< 
< declare i32 @io_readl_mmu(i64, i32, i8*)
---
> define internal i32 @float64_unordered_quiet(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca %struct.float_status*, align 4
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %3, align 8
>   %9 = load %struct.float_status** %4, align 4
>   %10 = call i64 @float64_squash_input_denormal(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %3, align 8
>   %11 = load i64* %2, align 8
>   %12 = call i32 @extractFloat64Exp(i64 %11)
>   %13 = icmp eq i32 %12, 2047
>   br i1 %13, label %14, label %18
18372,18378c16835,16868
< define i32 @__ldl_mmu(i32 %addr, i32 %mmu_idx) nounwind uwtable {
<   %ret.i.i.i = alloca i8, align 1
<   %label.i = alloca [64 x i8], align 16
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %addr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %2, align 8
>   %16 = call i64 @extractFloat64Frac(i64 %15)
>   %17 = icmp ne i64 %16, 0
>   br i1 %17, label %26, label %18
> 
> ; <label>:18                                      ; preds = %14, %0
>   %19 = load i64* %3, align 8
>   %20 = call i32 @extractFloat64Exp(i64 %19)
>   %21 = icmp eq i32 %20, 2047
>   br i1 %21, label %22, label %37
> 
> ; <label>:22                                      ; preds = %18
>   %23 = load i64* %3, align 8
>   %24 = call i64 @extractFloat64Frac(i64 %23)
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %37
> 
> ; <label>:26                                      ; preds = %22, %14
>   %27 = load i64* %2, align 8
>   %28 = call i32 @float64_is_signaling_nan(i64 %27)
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %34, label %30
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load i64* %3, align 8
>   %32 = call i32 @float64_is_signaling_nan(i64 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %34, label %36
> 
> ; <label>:34                                      ; preds = %30, %26
>   %35 = load %struct.float_status** %4, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %35)
>   br label %36
18380,18382c16870,16898
< ; <label>:4                                       ; preds = %0
<   %5 = call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:36                                      ; preds = %34, %30
>   store i32 1, i32* %1
>   br label %38
> 
> ; <label>:37                                      ; preds = %22, %18
>   store i32 0, i32* %1
>   br label %38
> 
> ; <label>:38                                      ; preds = %37, %36
>   %39 = load i32* %1
>   ret i32 %39
> }
> 
> define internal i32 @floatx80_to_int32(%struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %2, i64* %aSig, align 8
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %3, i32* %aExp, align 4
>   %4 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %4, i8* %aSign, align 1
>   %5 = load i32* %aExp, align 4
>   %6 = icmp eq i32 %5, 32767
>   br i1 %6, label %7, label %12
18384,18399c16900,16904
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = sext i32 %mmu_idx to i64
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %17 = load i32* %16, align 4
<   %18 = and i32 %8, -4096
<   %19 = and i32 %17, -4088
<   %20 = icmp eq i32 %18, %19
<   br i1 %20, label %._crit_edge, label %.lr.ph, !prof !0
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i64* %aSig, align 8
>   %9 = shl i64 %8, 1
>   %10 = icmp ne i64 %9, 0
>   br i1 %10, label %11, label %12
18401,18404c16906,16908
< .lr.ph:                                           ; preds = %6
<   %21 = trunc i64 %11 to i32
<   %22 = shl i32 %21, 7
<   br label %129
---
> ; <label>:11                                      ; preds = %7
>   store i8 0, i8* %aSign, align 1
>   br label %12
18406,18411c16910,16916
< ._crit_edge:                                      ; preds = %129, %6
<   %.lcssa29 = phi i32 [ %17, %6 ], [ %133, %129 ]
<   %.lcssa28 = phi %struct.CPUX86State* [ %15, %6 ], [ %131, %129 ]
<   %23 = and i32 %.lcssa29, 4095
<   %24 = icmp eq i32 %23, 0
<   br i1 %24, label %115, label %25, !prof !0
---
> ; <label>:12                                      ; preds = %11, %7, %0
>   %13 = load i32* %aExp, align 4
>   %14 = sub nsw i32 16439, %13
>   store i32 %14, i32* %shiftCount, align 4
>   %15 = load i32* %shiftCount, align 4
>   %16 = icmp sle i32 %15, 0
>   br i1 %16, label %17, label %18
18413,18416c16918,16920
< ; <label>:25                                      ; preds = %._crit_edge
<   %26 = and i32 %8, 3
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %28, label %119
---
> ; <label>:17                                      ; preds = %12
>   store i32 1, i32* %shiftCount, align 4
>   br label %18
18418,18429c16922,16945
< ; <label>:28                                      ; preds = %25
<   %29 = getelementptr inbounds %struct.CPUX86State* %.lcssa28, i64 0, i32 75, i64 %14, i64 %13
<   %30 = load i64* %29, align 8
<   %31 = getelementptr inbounds [64 x i8]* %label.i, i64 0, i64 0
<   %32 = call %struct.MemoryRegion* @iotlb_to_region(i64 %30) nounwind
<   %33 = and i64 %30, 4294963200
<   %34 = and i64 %7, 4294967295
<   %35 = add i64 %33, %34
<   %36 = trunc i64 %35 to i32
<   %37 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %47, label %39
---
> ; <label>:18                                      ; preds = %17, %12
>   %19 = load i64* %aSig, align 8
>   %20 = load i32* %shiftCount, align 4
>   call void @shift64RightJamming(i64 %19, i32 %20, i64* %aSig)
>   %21 = load i8* %aSign, align 1
>   %22 = load i64* %aSig, align 8
>   %23 = load %struct.float_status** %1, align 4
>   %24 = call i32 @roundAndPackInt32(i8 zeroext %21, i64 %22, %struct.float_status* %23)
>   ret i32 %24
> }
> 
> define internal i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a) nounwind inlinehint {
>   %1 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %2 = load i64* %1, align 1
>   ret i64 %2
> }
> 
> define internal i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a) nounwind inlinehint {
>   %1 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %2 = load i16* %1, align 1
>   %3 = zext i16 %2 to i32
>   %4 = and i32 %3, 32767
>   ret i32 %4
> }
18431,18436c16947,16954
< ; <label>:39                                      ; preds = %28
<   %fold = add i64 %33, %7
<   %40 = and i64 %fold, 4294967295
<   %41 = call i32 @s2e_is_mmio_symbolic_l(i64 %40) nounwind
<   %42 = icmp eq i32 %41, 0
<   br i1 %42, label %47, label %43
---
> define internal zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a) nounwind inlinehint {
>   %1 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %2 = load i16* %1, align 1
>   %3 = zext i16 %2 to i32
>   %4 = ashr i32 %3, 15
>   %5 = trunc i32 %4 to i8
>   ret i8 %5
> }
18438,18443c16956,16974
< ; <label>:43                                      ; preds = %39
<   %44 = load %struct.CPUX86State** @env, align 8
<   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 5
<   %46 = load i32* %45, align 4
<   call void @trace_port(i8* %31, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %36, i32 %46) nounwind
<   br label %47
---
> define internal i32 @floatx80_to_int32_round_to_zero(%struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %savedASig = alloca i64, align 8
>   %z = alloca i32, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %3, i64* %aSig, align 8
>   %4 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %4, i32* %aExp, align 4
>   %5 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %5, i8* %aSign, align 1
>   %6 = load i32* %aExp, align 4
>   %7 = icmp slt i32 16414, %6
>   br i1 %7, label %8, label %17
18445,18462c16976,16979
< ; <label>:47                                      ; preds = %43, %39, %28
<   %isSymb.0.i = phi i32 [ %41, %43 ], [ 0, %39 ], [ 0, %28 ]
<   %48 = load %struct.CPUX86State** @env, align 8
<   %49 = getelementptr inbounds %struct.CPUX86State* %48, i64 0, i32 68
<   store i64 0, i64* %49, align 8
<   %50 = icmp ne %struct.MemoryRegion* %32, @io_mem_ram
<   %51 = icmp ne %struct.MemoryRegion* %32, @io_mem_rom
<   %or.cond.i = and i1 %50, %51
<   %52 = icmp ne %struct.MemoryRegion* %32, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %52
<   %53 = icmp ne %struct.MemoryRegion* %32, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %53
<   %54 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %55 = load i32* @use_icount, align 4
<   %56 = icmp eq i32 %55, 0
<   %or.cond26.i = or i1 %56, %or.cond5.not.i
<   br i1 %or.cond26.i, label %can_do_io.exit.thread.i, label %57
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i32* %aExp, align 4
>   %10 = icmp eq i32 %9, 32767
>   br i1 %10, label %11, label %16
18464,18468c16981,16985
< ; <label>:57                                      ; preds = %47
<   %58 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 66
<   %59 = load %struct.TranslationBlock** %58, align 8
<   %60 = icmp eq %struct.TranslationBlock* %59, null
<   br i1 %60, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:11                                      ; preds = %8
>   %12 = load i64* %aSig, align 8
>   %13 = shl i64 %12, 1
>   %14 = icmp ne i64 %13, 0
>   br i1 %14, label %15, label %16
18470,18474c16987,16989
< can_do_io.exit.i:                                 ; preds = %57
<   %61 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 85
<   %62 = load i32* %61, align 4
<   %63 = icmp eq i32 %62, 0
<   br i1 %63, label %64, label %can_do_io.exit.thread.i
---
> ; <label>:15                                      ; preds = %11
>   store i8 0, i8* %aSign, align 1
>   br label %16
18476,18478c16991,16992
< ; <label>:64                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %54, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:16                                      ; preds = %15, %11, %8
>   br label %59
18480,18485c16994,16997
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %57, %47
<   %65 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 69
<   store i32 %8, i32* %65, align 4
<   %66 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %32, i32 0) nounwind
<   %67 = icmp eq i32 %66, 0
<   br i1 %67, label %111, label %68
---
> ; <label>:17                                      ; preds = %0
>   %18 = load i32* %aExp, align 4
>   %19 = icmp slt i32 %18, 16383
>   br i1 %19, label %20, label %34
18487,18492c16999,17002
< ; <label>:68                                      ; preds = %can_do_io.exit.thread.i
<   %69 = call i64 @s2e_notdirty_mem_write(i64 %30) nounwind
<   %70 = icmp eq i32 %isSymb.0.i, 0
<   %71 = inttoptr i64 %69 to i32*
<   %72 = load i32* %71, align 4
<   br i1 %70, label %io_read_chkl_mmu.exit, label %73
---
> ; <label>:20                                      ; preds = %17
>   %21 = load i32* %aExp, align 4
>   %22 = icmp ne i32 %21, 0
>   br i1 %22, label %26, label %23
18494,18504c17004,17017
< ; <label>:73                                      ; preds = %68
<   %data.i.sroa.0.0.extract.trunc.i = trunc i32 %72 to i8
<   %data.i.sroa.1.1.extract.shift.i = lshr i32 %72, 8
<   %data.i.sroa.1.1.extract.trunc.i = trunc i32 %data.i.sroa.1.1.extract.shift.i to i8
<   %data.i.sroa.2.2.extract.shift.i = lshr i32 %72, 16
<   %data.i.sroa.2.2.extract.trunc.i = trunc i32 %data.i.sroa.2.2.extract.shift.i to i8
<   %data.i.sroa.3.3.extract.shift.i = lshr i32 %72, 24
<   %data.i.sroa.3.3.extract.trunc.i = trunc i32 %data.i.sroa.3.3.extract.shift.i to i8
<   %74 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %75 = icmp eq i32 %74, 0
<   br i1 %75, label %io_read_chk_symb_l.exit.i, label %76
---
> ; <label>:23                                      ; preds = %20
>   %24 = load i64* %aSig, align 8
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %33
> 
> ; <label>:26                                      ; preds = %23, %20
>   %27 = load %struct.float_status** %2, align 4
>   %28 = getelementptr inbounds %struct.float_status* %27, i32 0, i32 2
>   %29 = load i8* %28, align 1
>   %30 = sext i8 %29 to i32
>   %31 = or i32 %30, 32
>   %32 = trunc i32 %31 to i8
>   store i8 %32, i8* %28, align 1
>   br label %33
18506,18511c17019,17021
< ; <label>:76                                      ; preds = %73
<   %fold27 = add i64 %33, %7
<   %77 = and i64 %fold27, 4294967295
<   %78 = call i32 @s2e_is_mmio_symbolic_b(i64 %77) nounwind
<   %79 = icmp eq i32 %78, 0
<   br i1 %79, label %._crit_edge10.i.i, label %80
---
> ; <label>:33                                      ; preds = %26, %23
>   store i32 0, i32* %1
>   br label %81
18513,18516c17023,17024
< ; <label>:80                                      ; preds = %76
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %81 = load i8* %ret.i.i.i, align 1
<   br label %._crit_edge10.i.i
---
> ; <label>:34                                      ; preds = %17
>   br label %35
18518,18522c17026,17048
< ._crit_edge10.i.i:                                ; preds = %80, %76
<   %data.i.sroa.0.0.extract.trunc23.i = phi i8 [ %81, %80 ], [ %data.i.sroa.0.0.extract.trunc.i, %76 ]
<   %.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %82 = icmp eq i32 %.pr.i.i, 0
<   br i1 %82, label %io_read_chk_symb_l.exit.i, label %83
---
> ; <label>:35                                      ; preds = %34
>   %36 = load i32* %aExp, align 4
>   %37 = sub nsw i32 16446, %36
>   store i32 %37, i32* %shiftCount, align 4
>   %38 = load i64* %aSig, align 8
>   store i64 %38, i64* %savedASig, align 8
>   %39 = load i32* %shiftCount, align 4
>   %40 = load i64* %aSig, align 8
>   %41 = zext i32 %39 to i64
>   %42 = lshr i64 %40, %41
>   store i64 %42, i64* %aSig, align 8
>   %43 = load i64* %aSig, align 8
>   %44 = trunc i64 %43 to i32
>   store i32 %44, i32* %z, align 4
>   %45 = load i8* %aSign, align 1
>   %46 = icmp ne i8 %45, 0
>   br i1 %46, label %47, label %50
> 
> ; <label>:47                                      ; preds = %35
>   %48 = load i32* %z, align 4
>   %49 = sub nsw i32 0, %48
>   store i32 %49, i32* %z, align 4
>   br label %50
18524,18529c17050,17058
< ; <label>:83                                      ; preds = %._crit_edge10.i.i
<   %84 = add i64 %35, 1
<   %85 = and i64 %84, 4294967295
<   %86 = call i32 @s2e_is_mmio_symbolic_b(i64 %85) nounwind
<   %87 = icmp eq i32 %86, 0
<   br i1 %87, label %._crit_edge9.i.i, label %88
---
> ; <label>:50                                      ; preds = %47, %35
>   %51 = load i32* %z, align 4
>   %52 = icmp slt i32 %51, 0
>   %53 = zext i1 %52 to i32
>   %54 = load i8* %aSign, align 1
>   %55 = zext i8 %54 to i32
>   %56 = xor i32 %53, %55
>   %57 = icmp ne i32 %56, 0
>   br i1 %57, label %58, label %65
18531,18534c17060,17061
< ; <label>:88                                      ; preds = %83
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %89 = load i8* %ret.i.i.i, align 1
<   br label %._crit_edge9.i.i
---
> ; <label>:58                                      ; preds = %50
>   br label %59
18536,18540c17063,17090
< ._crit_edge9.i.i:                                 ; preds = %88, %83
<   %90 = phi i8 [ %89, %88 ], [ %data.i.sroa.1.1.extract.trunc.i, %83 ]
<   %.pr11.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %91 = icmp eq i32 %.pr11.pr.i.i, 0
<   br i1 %91, label %io_read_chk_symb_l.exit.i, label %92
---
> ; <label>:59                                      ; preds = %58, %16
>   %60 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %60)
>   %61 = load i8* %aSign, align 1
>   %62 = zext i8 %61 to i32
>   %63 = icmp ne i32 %62, 0
>   %64 = select i1 %63, i32 -2147483648, i32 2147483647
>   store i32 %64, i32* %1
>   br label %81
> 
> ; <label>:65                                      ; preds = %50
>   %66 = load i64* %aSig, align 8
>   %67 = load i32* %shiftCount, align 4
>   %68 = zext i32 %67 to i64
>   %69 = shl i64 %66, %68
>   %70 = load i64* %savedASig, align 8
>   %71 = icmp ne i64 %69, %70
>   br i1 %71, label %72, label %79
> 
> ; <label>:72                                      ; preds = %65
>   %73 = load %struct.float_status** %2, align 4
>   %74 = getelementptr inbounds %struct.float_status* %73, i32 0, i32 2
>   %75 = load i8* %74, align 1
>   %76 = sext i8 %75 to i32
>   %77 = or i32 %76, 32
>   %78 = trunc i32 %77 to i8
>   store i8 %78, i8* %74, align 1
>   br label %79
18542,18547c17092,17122
< ; <label>:92                                      ; preds = %._crit_edge9.i.i
<   %93 = add i64 %35, 2
<   %94 = and i64 %93, 4294967295
<   %95 = call i32 @s2e_is_mmio_symbolic_b(i64 %94) nounwind
<   %96 = icmp eq i32 %95, 0
<   br i1 %96, label %._crit_edge8.i.i, label %97
---
> ; <label>:79                                      ; preds = %72, %65
>   %80 = load i32* %z, align 4
>   store i32 %80, i32* %1
>   br label %81
> 
> ; <label>:81                                      ; preds = %79, %59, %33
>   %82 = load i32* %1
>   ret i32 %82
> }
> 
> define internal i64 @floatx80_to_int64(%struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %aSigExtra = alloca i64, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %3, i64* %aSig, align 8
>   %4 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %4, i32* %aExp, align 4
>   %5 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %5, i8* %aSign, align 1
>   %6 = load i32* %aExp, align 4
>   %7 = sub nsw i32 16446, %6
>   store i32 %7, i32* %shiftCount, align 4
>   %8 = load i32* %shiftCount, align 4
>   %9 = icmp sle i32 %8, 0
>   br i1 %9, label %10, label %26
18549,18552c17124,17127
< ; <label>:97                                      ; preds = %92
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %98 = load i8* %ret.i.i.i, align 1
<   br label %._crit_edge8.i.i
---
> ; <label>:10                                      ; preds = %0
>   %11 = load i32* %shiftCount, align 4
>   %12 = icmp ne i32 %11, 0
>   br i1 %12, label %13, label %25
18554,18558c17129,17139
< ._crit_edge8.i.i:                                 ; preds = %97, %92
<   %99 = phi i8 [ %98, %97 ], [ %data.i.sroa.2.2.extract.trunc.i, %92 ]
<   %.pr12.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %100 = icmp eq i32 %.pr12.pr.i.i, 0
<   br i1 %100, label %io_read_chk_symb_l.exit.i, label %101
---
> ; <label>:13                                      ; preds = %10
>   %14 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %14)
>   %15 = load i8* %aSign, align 1
>   %16 = icmp ne i8 %15, 0
>   br i1 %16, label %17, label %23
> 
> ; <label>:17                                      ; preds = %13
>   %18 = load i32* %aExp, align 4
>   %19 = icmp eq i32 %18, 32767
>   br i1 %19, label %20, label %24
18560,18565c17141,17144
< ; <label>:101                                     ; preds = %._crit_edge8.i.i
<   %102 = add i64 %35, 3
<   %103 = and i64 %102, 4294967295
<   %104 = call i32 @s2e_is_mmio_symbolic_b(i64 %103) nounwind
<   %105 = icmp eq i32 %104, 0
<   br i1 %105, label %io_read_chk_symb_l.exit.i, label %106
---
> ; <label>:20                                      ; preds = %17
>   %21 = load i64* %aSig, align 8
>   %22 = icmp ne i64 %21, -9223372036854775808
>   br i1 %22, label %23, label %24
18567,18570c17146,17148
< ; <label>:106                                     ; preds = %101
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %107 = load i8* %ret.i.i.i, align 1
<   br label %io_read_chk_symb_l.exit.i
---
> ; <label>:23                                      ; preds = %20, %13
>   store i64 9223372036854775807, i64* %1
>   br label %35
18572,18587c17150,17152
< io_read_chk_symb_l.exit.i:                        ; preds = %106, %101, %._crit_edge8.i.i, %._crit_edge9.i.i, %._crit_edge10.i.i, %73
<   %108 = phi i8 [ %data.i.sroa.3.3.extract.trunc.i, %73 ], [ %data.i.sroa.3.3.extract.trunc.i, %._crit_edge10.i.i ], [ %data.i.sroa.3.3.extract.trunc.i, %._crit_edge9.i.i ], [ %data.i.sroa.3.3.extract.trunc.i, %._crit_edge8.i.i ], [ %data.i.sroa.3.3.extract.trunc.i, %101 ], [ %107, %106 ]
<   %109 = phi i8 [ %data.i.sroa.2.2.extract.trunc.i, %73 ], [ %data.i.sroa.2.2.extract.trunc.i, %._crit_edge10.i.i ], [ %data.i.sroa.2.2.extract.trunc.i, %._crit_edge9.i.i ], [ %99, %._crit_edge8.i.i ], [ %99, %101 ], [ %99, %106 ]
<   %110 = phi i8 [ %data.i.sroa.1.1.extract.trunc.i, %73 ], [ %data.i.sroa.1.1.extract.trunc.i, %._crit_edge10.i.i ], [ %90, %._crit_edge9.i.i ], [ %90, %._crit_edge8.i.i ], [ %90, %101 ], [ %90, %106 ]
<   %data.i.sroa.0.0.extract.trunc24.i = phi i8 [ %data.i.sroa.0.0.extract.trunc.i, %73 ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge10.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge9.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge8.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %101 ], [ %data.i.sroa.0.0.extract.trunc23.i, %106 ]
<   %data.i.sroa.3.3.insert.ext.i = zext i8 %108 to i32
<   %data.i.sroa.3.3.insert.shift.i = shl nuw i32 %data.i.sroa.3.3.insert.ext.i, 24
<   %data.i.sroa.2.2.insert.ext.i = zext i8 %109 to i32
<   %data.i.sroa.2.2.insert.shift.i = shl nuw nsw i32 %data.i.sroa.2.2.insert.ext.i, 16
<   %data.i.sroa.2.2.insert.insert.i = or i32 %data.i.sroa.2.2.insert.shift.i, %data.i.sroa.3.3.insert.shift.i
<   %data.i.sroa.1.1.insert.ext.i = zext i8 %110 to i32
<   %data.i.sroa.1.1.insert.shift.i = shl nuw nsw i32 %data.i.sroa.1.1.insert.ext.i, 8
<   %data.i.sroa.1.1.insert.insert.i = or i32 %data.i.sroa.2.2.insert.insert.i, %data.i.sroa.1.1.insert.shift.i
<   %data.i.sroa.0.0.insert.ext.i = zext i8 %data.i.sroa.0.0.extract.trunc24.i to i32
<   %data.i.sroa.0.0.insert.insert.i = or i32 %data.i.sroa.1.1.insert.insert.i, %data.i.sroa.0.0.insert.ext.i
<   br label %io_read_chkl_mmu.exit
---
> ; <label>:24                                      ; preds = %20, %17
>   store i64 -9223372036854775808, i64* %1
>   br label %35
18589,18591c17154,17156
< ; <label>:111                                     ; preds = %can_do_io.exit.thread.i
<   %112 = call i32 @io_readl_mmu(i64 %30, i32 %8, i8* null) nounwind
<   br label %io_read_chkl_mmu.exit
---
> ; <label>:25                                      ; preds = %10
>   store i64 0, i64* %aSigExtra, align 8
>   br label %29
18593,18598c17158,17162
< io_read_chkl_mmu.exit:                            ; preds = %111, %io_read_chk_symb_l.exit.i, %68
<   %.0.i = phi i32 [ %data.i.sroa.0.0.insert.insert.i, %io_read_chk_symb_l.exit.i ], [ %112, %111 ], [ %72, %68 ]
<   %113 = add i64 %30, %34
<   %114 = zext i32 %.0.i to i64
<   call void @tcg_llvm_trace_memory_access(i64 %34, i64 %113, i64 %114, i32 32, i8 zeroext 0, i8 zeroext 1) nounwind
<   br label %136
---
> ; <label>:26                                      ; preds = %0
>   %27 = load i64* %aSig, align 8
>   %28 = load i32* %shiftCount, align 4
>   call void @shift64ExtraRightJamming(i64 %27, i64 0, i32 %28, i64* %aSig, i64* %aSigExtra)
>   br label %29
18600,18604c17164,17171
< ; <label>:115                                     ; preds = %._crit_edge
<   %116 = and i32 %8, 127
<   %117 = add i32 %116, 3
<   %118 = icmp ugt i32 %117, 127
<   br i1 %118, label %119, label %121, !prof !1
---
> ; <label>:29                                      ; preds = %26, %25
>   %30 = load i8* %aSign, align 1
>   %31 = load i64* %aSig, align 8
>   %32 = load i64* %aSigExtra, align 8
>   %33 = load %struct.float_status** %2, align 4
>   %34 = call i64 @roundAndPackInt64(i8 zeroext %30, i64 %31, i64 %32, %struct.float_status* %33)
>   store i64 %34, i64* %1
>   br label %35
18606,18608c17173,17198
< ; <label>:119                                     ; preds = %115, %25
<   %120 = call fastcc i32 @slow_ldl_mmu(i32 %8, i32 %mmu_idx)
<   br label %136
---
> ; <label>:35                                      ; preds = %29, %24, %23
>   %36 = load i64* %1
>   ret i64 %36
> }
> 
> define internal i64 @floatx80_to_int64_round_to_zero(%struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %z = alloca i64, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %3, i64* %aSig, align 8
>   %4 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %4, i32* %aExp, align 4
>   %5 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %5, i8* %aSign, align 1
>   %6 = load i32* %aExp, align 4
>   %7 = sub nsw i32 %6, 16446
>   store i32 %7, i32* %shiftCount, align 4
>   %8 = load i32* %shiftCount, align 4
>   %9 = icmp sle i32 0, %8
>   br i1 %9, label %10, label %33
18610,18619c17200,17230
< ; <label>:121                                     ; preds = %115
<   %122 = getelementptr inbounds %struct.CPUX86State* %.lcssa28, i64 0, i32 73, i64 %14, i64 %13, i32 3
<   %123 = load i64* %122, align 8
<   %124 = and i64 %7, 4294967295
<   %125 = add i64 %123, %124
<   %126 = inttoptr i64 %125 to i32*
<   %127 = load i32* %126, align 4
<   %128 = zext i32 %127 to i64
<   call void @tcg_llvm_trace_memory_access(i64 %124, i64 %125, i64 %128, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %136
---
> ; <label>:10                                      ; preds = %0
>   %11 = load i64* %aSig, align 8
>   %12 = and i64 %11, 9223372036854775807
>   store i64 %12, i64* %aSig, align 8
>   %13 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %14 = load i16* %13, align 1
>   %15 = zext i16 %14 to i32
>   %16 = icmp ne i32 %15, 49214
>   br i1 %16, label %20, label %17
> 
> ; <label>:17                                      ; preds = %10
>   %18 = load i64* %aSig, align 8
>   %19 = icmp ne i64 %18, 0
>   br i1 %19, label %20, label %32
> 
> ; <label>:20                                      ; preds = %17, %10
>   %21 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %21)
>   %22 = load i8* %aSign, align 1
>   %23 = icmp ne i8 %22, 0
>   br i1 %23, label %24, label %30
> 
> ; <label>:24                                      ; preds = %20
>   %25 = load i32* %aExp, align 4
>   %26 = icmp eq i32 %25, 32767
>   br i1 %26, label %27, label %31
> 
> ; <label>:27                                      ; preds = %24
>   %28 = load i64* %aSig, align 8
>   %29 = icmp ne i64 %28, 0
>   br i1 %29, label %30, label %31
18621,18629c17232,17234
< ; <label>:129                                     ; preds = %129, %.lr.ph
<   %130 = phi %struct.CPUX86State* [ %15, %.lr.ph ], [ %131, %129 ]
<   call void @tlb_fill(%struct.CPUX86State* %130, i32 %8, i32 %22, i32 0, i32 %mmu_idx, i8* null)
<   %131 = load %struct.CPUX86State** @env, align 8
<   %132 = getelementptr inbounds %struct.CPUX86State* %131, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %133 = load i32* %132, align 4
<   %134 = and i32 %133, -4088
<   %135 = icmp eq i32 %18, %134
<   br i1 %135, label %._crit_edge, label %129, !prof !0
---
> ; <label>:30                                      ; preds = %27, %20
>   store i64 9223372036854775807, i64* %1
>   br label %78
18631,18634c17236,17237
< ; <label>:136                                     ; preds = %121, %119, %io_read_chkl_mmu.exit
<   %res.0 = phi i32 [ %120, %119 ], [ %.0.i, %io_read_chkl_mmu.exit ], [ %127, %121 ]
<   ret i32 %res.0
< }
---
> ; <label>:31                                      ; preds = %27, %24
>   br label %32
18636,18642c17239,17241
< define internal fastcc i32 @slow_ldl_mmu(i32 %addr, i32 %mmu_idx) nounwind uwtable {
<   %ret.i.i.i = alloca i8, align 1
<   %label.i = alloca [64 x i8], align 16
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %addr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:32                                      ; preds = %31, %17
>   store i64 -9223372036854775808, i64* %1
>   br label %78
18644,18646c17243,17246
< ; <label>:4                                       ; preds = %0
<   %5 = call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:33                                      ; preds = %0
>   %34 = load i32* %aExp, align 4
>   %35 = icmp slt i32 %34, 16383
>   br i1 %35, label %36, label %50
18648,18663c17248,17264
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = sext i32 %mmu_idx to i64
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %17 = load i32* %16, align 4
<   %18 = and i32 %8, -4096
<   %19 = and i32 %17, -4088
<   %20 = icmp eq i32 %18, %19
<   br i1 %20, label %._crit_edge, label %.lr.ph
---
> ; <label>:36                                      ; preds = %33
>   %37 = load i32* %aExp, align 4
>   %38 = sext i32 %37 to i64
>   %39 = load i64* %aSig, align 8
>   %40 = or i64 %38, %39
>   %41 = icmp ne i64 %40, 0
>   br i1 %41, label %42, label %49
> 
> ; <label>:42                                      ; preds = %36
>   %43 = load %struct.float_status** %2, align 4
>   %44 = getelementptr inbounds %struct.float_status* %43, i32 0, i32 2
>   %45 = load i8* %44, align 1
>   %46 = sext i8 %45 to i32
>   %47 = or i32 %46, 32
>   %48 = trunc i32 %47 to i8
>   store i8 %48, i8* %44, align 1
>   br label %49
18665,18668c17266,17268
< .lr.ph:                                           ; preds = %6
<   %21 = trunc i64 %11 to i32
<   %22 = shl i32 %21, 7
<   br label %138
---
> ; <label>:49                                      ; preds = %42, %36
>   store i64 0, i64* %1
>   br label %78
18670,18675c17270,17271
< ._crit_edge:                                      ; preds = %138, %6
<   %.lcssa3 = phi i32 [ %17, %6 ], [ %142, %138 ]
<   %.lcssa2 = phi %struct.CPUX86State* [ %15, %6 ], [ %140, %138 ]
<   %23 = and i32 %.lcssa3, 4095
<   %24 = icmp eq i32 %23, 0
<   br i1 %24, label %115, label %25
---
> ; <label>:50                                      ; preds = %33
>   br label %51
18677,18680c17273,17312
< ; <label>:25                                      ; preds = %._crit_edge
<   %26 = and i32 %8, 3
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %28, label %119
---
> ; <label>:51                                      ; preds = %50
>   %52 = load i64* %aSig, align 8
>   %53 = load i32* %shiftCount, align 4
>   %54 = sub nsw i32 0, %53
>   %55 = zext i32 %54 to i64
>   %56 = lshr i64 %52, %55
>   store i64 %56, i64* %z, align 8
>   %57 = load i64* %aSig, align 8
>   %58 = load i32* %shiftCount, align 4
>   %59 = and i32 %58, 63
>   %60 = zext i32 %59 to i64
>   %61 = shl i64 %57, %60
>   %62 = icmp ne i64 %61, 0
>   br i1 %62, label %63, label %70
> 
> ; <label>:63                                      ; preds = %51
>   %64 = load %struct.float_status** %2, align 4
>   %65 = getelementptr inbounds %struct.float_status* %64, i32 0, i32 2
>   %66 = load i8* %65, align 1
>   %67 = sext i8 %66 to i32
>   %68 = or i32 %67, 32
>   %69 = trunc i32 %68 to i8
>   store i8 %69, i8* %65, align 1
>   br label %70
> 
> ; <label>:70                                      ; preds = %63, %51
>   %71 = load i8* %aSign, align 1
>   %72 = icmp ne i8 %71, 0
>   br i1 %72, label %73, label %76
> 
> ; <label>:73                                      ; preds = %70
>   %74 = load i64* %z, align 8
>   %75 = sub nsw i64 0, %74
>   store i64 %75, i64* %z, align 8
>   br label %76
> 
> ; <label>:76                                      ; preds = %73, %70
>   %77 = load i64* %z, align 8
>   store i64 %77, i64* %1
>   br label %78
18682,18693c17314,17317
< ; <label>:28                                      ; preds = %25
<   %29 = getelementptr inbounds %struct.CPUX86State* %.lcssa2, i64 0, i32 75, i64 %14, i64 %13
<   %30 = load i64* %29, align 8
<   %31 = getelementptr inbounds [64 x i8]* %label.i, i64 0, i64 0
<   %32 = call %struct.MemoryRegion* @iotlb_to_region(i64 %30) nounwind
<   %33 = and i64 %30, 4294963200
<   %34 = and i64 %7, 4294967295
<   %35 = add i64 %33, %34
<   %36 = trunc i64 %35 to i32
<   %37 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %47, label %39
---
> ; <label>:78                                      ; preds = %76, %49, %32, %30
>   %79 = load i64* %1
>   ret i64 %79
> }
18695,18700c17319,17335
< ; <label>:39                                      ; preds = %28
<   %fold = add i64 %33, %7
<   %40 = and i64 %fold, 4294967295
<   %41 = call i32 @s2e_is_mmio_symbolic_l(i64 %40) nounwind
<   %42 = icmp eq i32 %41, 0
<   br i1 %42, label %47, label %43
---
> define internal i32 @floatx80_to_float32(%struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %3 = alloca %struct.commonNaNT, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %4 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %4, i64* %aSig, align 8
>   %5 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %5, i32* %aExp, align 4
>   %6 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %6, i8* %aSign, align 1
>   %7 = load i32* %aExp, align 4
>   %8 = icmp eq i32 %7, 32767
>   br i1 %8, label %9, label %20
18702,18707c17337,17341
< ; <label>:43                                      ; preds = %39
<   %44 = load %struct.CPUX86State** @env, align 8
<   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 5
<   %46 = load i32* %45, align 4
<   call void @trace_port(i8* %31, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %36, i32 %46) nounwind
<   br label %47
---
> ; <label>:9                                       ; preds = %0
>   %10 = load i64* %aSig, align 8
>   %11 = shl i64 %10, 1
>   %12 = icmp ne i64 %11, 0
>   br i1 %12, label %13, label %17
18709,18726c17343,17349
< ; <label>:47                                      ; preds = %43, %39, %28
<   %isSymb.0.i = phi i32 [ %41, %43 ], [ 0, %39 ], [ 0, %28 ]
<   %48 = load %struct.CPUX86State** @env, align 8
<   %49 = getelementptr inbounds %struct.CPUX86State* %48, i64 0, i32 68
<   store i64 0, i64* %49, align 8
<   %50 = icmp ne %struct.MemoryRegion* %32, @io_mem_ram
<   %51 = icmp ne %struct.MemoryRegion* %32, @io_mem_rom
<   %or.cond.i = and i1 %50, %51
<   %52 = icmp ne %struct.MemoryRegion* %32, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %52
<   %53 = icmp ne %struct.MemoryRegion* %32, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %53
<   %54 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %55 = load i32* @use_icount, align 4
<   %56 = icmp eq i32 %55, 0
<   %or.cond26.i = or i1 %56, %or.cond5.not.i
<   br i1 %or.cond26.i, label %can_do_io.exit.thread.i, label %57
---
> ; <label>:13                                      ; preds = %9
>   %14 = load %struct.float_status** %2, align 4
>   call void @floatx80ToCommonNaN(%struct.commonNaNT* sret %3, %struct.floatx80* byval align 4 %a, %struct.float_status* %14)
>   %15 = load %struct.float_status** %2, align 4
>   %16 = call i32 @commonNaNToFloat32(%struct.commonNaNT* byval align 4 %3, %struct.float_status* %15)
>   store i32 %16, i32* %1
>   br label %37
18728,18732c17351,17355
< ; <label>:57                                      ; preds = %47
<   %58 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 66
<   %59 = load %struct.TranslationBlock** %58, align 8
<   %60 = icmp eq %struct.TranslationBlock* %59, null
<   br i1 %60, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:17                                      ; preds = %9
>   %18 = load i8* %aSign, align 1
>   %19 = call i32 @packFloat32(i8 zeroext %18, i32 255, i32 0)
>   store i32 %19, i32* %1
>   br label %37
18734,18738c17357,17373
< can_do_io.exit.i:                                 ; preds = %57
<   %61 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 85
<   %62 = load i32* %61, align 4
<   %63 = icmp eq i32 %62, 0
<   br i1 %63, label %64, label %can_do_io.exit.thread.i
---
> ; <label>:20                                      ; preds = %0
>   %21 = load i64* %aSig, align 8
>   call void @shift64RightJamming(i64 %21, i32 33, i64* %aSig)
>   %22 = load i32* %aExp, align 4
>   %23 = icmp ne i32 %22, 0
>   br i1 %23, label %27, label %24
> 
> ; <label>:24                                      ; preds = %20
>   %25 = load i64* %aSig, align 8
>   %26 = icmp ne i64 %25, 0
>   br i1 %26, label %27, label %30
> 
> ; <label>:27                                      ; preds = %24, %20
>   %28 = load i32* %aExp, align 4
>   %29 = sub nsw i32 %28, 16257
>   store i32 %29, i32* %aExp, align 4
>   br label %30
18740,18742c17375,17383
< ; <label>:64                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %54, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:30                                      ; preds = %27, %24
>   %31 = load i8* %aSign, align 1
>   %32 = load i32* %aExp, align 4
>   %33 = load i64* %aSig, align 8
>   %34 = trunc i64 %33 to i32
>   %35 = load %struct.float_status** %2, align 4
>   %36 = call i32 @roundAndPackFloat32(i8 zeroext %31, i32 %32, i32 %34, %struct.float_status* %35)
>   store i32 %36, i32* %1
>   br label %37
18744,18749c17385,17388
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %57, %47
<   %65 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 69
<   store i32 %8, i32* %65, align 4
<   %66 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %32, i32 0) nounwind
<   %67 = icmp eq i32 %66, 0
<   br i1 %67, label %111, label %68
---
> ; <label>:37                                      ; preds = %30, %17, %13
>   %38 = load i32* %1
>   ret i32 %38
> }
18751,18756c17390,17396
< ; <label>:68                                      ; preds = %can_do_io.exit.thread.i
<   %69 = call i64 @s2e_notdirty_mem_write(i64 %30) nounwind
<   %70 = icmp eq i32 %isSymb.0.i, 0
<   %71 = inttoptr i64 %69 to i32*
<   %72 = load i32* %71, align 4
<   br i1 %70, label %io_read_chkl_mmu.exit, label %73
---
> define internal void @floatx80ToCommonNaN(%struct.commonNaNT* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %z = alloca %struct.commonNaNT, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %a)
>   %3 = icmp ne i32 %2, 0
>   br i1 %3, label %4, label %6
18758,18768c17398,17401
< ; <label>:73                                      ; preds = %68
<   %data.i.sroa.0.0.extract.trunc.i = trunc i32 %72 to i8
<   %data.i.sroa.1.1.extract.shift.i = lshr i32 %72, 8
<   %data.i.sroa.1.1.extract.trunc.i = trunc i32 %data.i.sroa.1.1.extract.shift.i to i8
<   %data.i.sroa.2.2.extract.shift.i = lshr i32 %72, 16
<   %data.i.sroa.2.2.extract.trunc.i = trunc i32 %data.i.sroa.2.2.extract.shift.i to i8
<   %data.i.sroa.3.3.extract.shift.i = lshr i32 %72, 24
<   %data.i.sroa.3.3.extract.trunc.i = trunc i32 %data.i.sroa.3.3.extract.shift.i to i8
<   %74 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %75 = icmp eq i32 %74, 0
<   br i1 %75, label %io_read_chk_symb_l.exit.i, label %76
---
> ; <label>:4                                       ; preds = %0
>   %5 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %5)
>   br label %6
18770,18775c17403,17408
< ; <label>:76                                      ; preds = %73
<   %fold1 = add i64 %33, %7
<   %77 = and i64 %fold1, 4294967295
<   %78 = call i32 @s2e_is_mmio_symbolic_b(i64 %77) nounwind
<   %79 = icmp eq i32 %78, 0
<   br i1 %79, label %._crit_edge10.i.i, label %80
---
> ; <label>:6                                       ; preds = %4, %0
>   %7 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %8 = load i64* %7, align 1
>   %9 = lshr i64 %8, 63
>   %10 = icmp ne i64 %9, 0
>   br i1 %10, label %11, label %23
18777,18780c17410,17425
< ; <label>:80                                      ; preds = %76
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %81 = load i8* %ret.i.i.i, align 1
<   br label %._crit_edge10.i.i
---
> ; <label>:11                                      ; preds = %6
>   %12 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %13 = load i16* %12, align 1
>   %14 = zext i16 %13 to i32
>   %15 = ashr i32 %14, 15
>   %16 = trunc i32 %15 to i8
>   %17 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 0
>   store i8 %16, i8* %17, align 1
>   %18 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 2
>   store i64 0, i64* %18, align 4
>   %19 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %20 = load i64* %19, align 1
>   %21 = shl i64 %20, 1
>   %22 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 1
>   store i64 %21, i64* %22, align 4
>   br label %27
18782,18786c17427,17434
< ._crit_edge10.i.i:                                ; preds = %80, %76
<   %data.i.sroa.0.0.extract.trunc23.i = phi i8 [ %81, %80 ], [ %data.i.sroa.0.0.extract.trunc.i, %76 ]
<   %.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %82 = icmp eq i32 %.pr.i.i, 0
<   br i1 %82, label %io_read_chk_symb_l.exit.i, label %83
---
> ; <label>:23                                      ; preds = %6
>   %24 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 0
>   store i8 1, i8* %24, align 1
>   %25 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 2
>   store i64 0, i64* %25, align 4
>   %26 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 1
>   store i64 -9223372036854775808, i64* %26, align 4
>   br label %27
18788,18793c17436,17441
< ; <label>:83                                      ; preds = %._crit_edge10.i.i
<   %84 = add i64 %35, 1
<   %85 = and i64 %84, 4294967295
<   %86 = call i32 @s2e_is_mmio_symbolic_b(i64 %85) nounwind
<   %87 = icmp eq i32 %86, 0
<   br i1 %87, label %._crit_edge9.i.i, label %88
---
> ; <label>:27                                      ; preds = %23, %11
>   %28 = bitcast %struct.commonNaNT* %agg.result to i8*
>   %29 = bitcast %struct.commonNaNT* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %28, i8* %29, i32 20, i32 4, i1 false)
>   ret void
> }
18795,18798c17443,17460
< ; <label>:88                                      ; preds = %83
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %89 = load i8* %ret.i.i.i, align 1
<   br label %._crit_edge9.i.i
---
> define internal i64 @floatx80_to_float64(%struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %zSig = alloca i64, align 8
>   %3 = alloca %struct.commonNaNT, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %4 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %4, i64* %aSig, align 8
>   %5 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %5, i32* %aExp, align 4
>   %6 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %6, i8* %aSign, align 1
>   %7 = load i32* %aExp, align 4
>   %8 = icmp eq i32 %7, 32767
>   br i1 %8, label %9, label %20
18800,18804c17462,17466
< ._crit_edge9.i.i:                                 ; preds = %88, %83
<   %90 = phi i8 [ %89, %88 ], [ %data.i.sroa.1.1.extract.trunc.i, %83 ]
<   %.pr11.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %91 = icmp eq i32 %.pr11.pr.i.i, 0
<   br i1 %91, label %io_read_chk_symb_l.exit.i, label %92
---
> ; <label>:9                                       ; preds = %0
>   %10 = load i64* %aSig, align 8
>   %11 = shl i64 %10, 1
>   %12 = icmp ne i64 %11, 0
>   br i1 %12, label %13, label %17
18806,18811c17468,17474
< ; <label>:92                                      ; preds = %._crit_edge9.i.i
<   %93 = add i64 %35, 2
<   %94 = and i64 %93, 4294967295
<   %95 = call i32 @s2e_is_mmio_symbolic_b(i64 %94) nounwind
<   %96 = icmp eq i32 %95, 0
<   br i1 %96, label %._crit_edge8.i.i, label %97
---
> ; <label>:13                                      ; preds = %9
>   %14 = load %struct.float_status** %2, align 4
>   call void @floatx80ToCommonNaN(%struct.commonNaNT* sret %3, %struct.floatx80* byval align 4 %a, %struct.float_status* %14)
>   %15 = load %struct.float_status** %2, align 4
>   %16 = call i64 @commonNaNToFloat64(%struct.commonNaNT* byval align 4 %3, %struct.float_status* %15)
>   store i64 %16, i64* %1
>   br label %36
18813,18816c17476,17480
< ; <label>:97                                      ; preds = %92
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %98 = load i8* %ret.i.i.i, align 1
<   br label %._crit_edge8.i.i
---
> ; <label>:17                                      ; preds = %9
>   %18 = load i8* %aSign, align 1
>   %19 = call i64 @packFloat64(i8 zeroext %18, i32 2047, i64 0)
>   store i64 %19, i64* %1
>   br label %36
18818,18822c17482,17498
< ._crit_edge8.i.i:                                 ; preds = %97, %92
<   %99 = phi i8 [ %98, %97 ], [ %data.i.sroa.2.2.extract.trunc.i, %92 ]
<   %.pr12.pr.i.i = load i32* @g_s2e_enable_mmio_checks, align 4
<   %100 = icmp eq i32 %.pr12.pr.i.i, 0
<   br i1 %100, label %io_read_chk_symb_l.exit.i, label %101
---
> ; <label>:20                                      ; preds = %0
>   %21 = load i64* %aSig, align 8
>   call void @shift64RightJamming(i64 %21, i32 1, i64* %zSig)
>   %22 = load i32* %aExp, align 4
>   %23 = icmp ne i32 %22, 0
>   br i1 %23, label %27, label %24
> 
> ; <label>:24                                      ; preds = %20
>   %25 = load i64* %aSig, align 8
>   %26 = icmp ne i64 %25, 0
>   br i1 %26, label %27, label %30
> 
> ; <label>:27                                      ; preds = %24, %20
>   %28 = load i32* %aExp, align 4
>   %29 = sub nsw i32 %28, 15361
>   store i32 %29, i32* %aExp, align 4
>   br label %30
18824,18829c17500,17507
< ; <label>:101                                     ; preds = %._crit_edge8.i.i
<   %102 = add i64 %35, 3
<   %103 = and i64 %102, 4294967295
<   %104 = call i32 @s2e_is_mmio_symbolic_b(i64 %103) nounwind
<   %105 = icmp eq i32 %104, 0
<   br i1 %105, label %io_read_chk_symb_l.exit.i, label %106
---
> ; <label>:30                                      ; preds = %27, %24
>   %31 = load i8* %aSign, align 1
>   %32 = load i32* %aExp, align 4
>   %33 = load i64* %zSig, align 8
>   %34 = load %struct.float_status** %2, align 4
>   %35 = call i64 @roundAndPackFloat64(i8 zeroext %31, i32 %32, i64 %33, %struct.float_status* %34)
>   store i64 %35, i64* %1
>   br label %36
18831,18834c17509,17531
< ; <label>:106                                     ; preds = %101
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %107 = load i8* %ret.i.i.i, align 1
<   br label %io_read_chk_symb_l.exit.i
---
> ; <label>:36                                      ; preds = %30, %17, %13
>   %37 = load i64* %1
>   ret i64 %37
> }
> 
> define internal void @floatx80_to_float128(%struct.float128* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %2 = alloca %struct.commonNaNT, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %3 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %3, i64* %aSig, align 8
>   %4 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %4, i32* %aExp, align 4
>   %5 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %5, i8* %aSign, align 1
>   %6 = load i32* %aExp, align 4
>   %7 = icmp eq i32 %6, 32767
>   br i1 %7, label %8, label %15
18836,18851c17533,17537
< io_read_chk_symb_l.exit.i:                        ; preds = %106, %101, %._crit_edge8.i.i, %._crit_edge9.i.i, %._crit_edge10.i.i, %73
<   %108 = phi i8 [ %data.i.sroa.3.3.extract.trunc.i, %73 ], [ %data.i.sroa.3.3.extract.trunc.i, %._crit_edge10.i.i ], [ %data.i.sroa.3.3.extract.trunc.i, %._crit_edge9.i.i ], [ %data.i.sroa.3.3.extract.trunc.i, %._crit_edge8.i.i ], [ %data.i.sroa.3.3.extract.trunc.i, %101 ], [ %107, %106 ]
<   %109 = phi i8 [ %data.i.sroa.2.2.extract.trunc.i, %73 ], [ %data.i.sroa.2.2.extract.trunc.i, %._crit_edge10.i.i ], [ %data.i.sroa.2.2.extract.trunc.i, %._crit_edge9.i.i ], [ %99, %._crit_edge8.i.i ], [ %99, %101 ], [ %99, %106 ]
<   %110 = phi i8 [ %data.i.sroa.1.1.extract.trunc.i, %73 ], [ %data.i.sroa.1.1.extract.trunc.i, %._crit_edge10.i.i ], [ %90, %._crit_edge9.i.i ], [ %90, %._crit_edge8.i.i ], [ %90, %101 ], [ %90, %106 ]
<   %data.i.sroa.0.0.extract.trunc24.i = phi i8 [ %data.i.sroa.0.0.extract.trunc.i, %73 ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge10.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge9.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %._crit_edge8.i.i ], [ %data.i.sroa.0.0.extract.trunc23.i, %101 ], [ %data.i.sroa.0.0.extract.trunc23.i, %106 ]
<   %data.i.sroa.3.3.insert.ext.i = zext i8 %108 to i32
<   %data.i.sroa.3.3.insert.shift.i = shl nuw i32 %data.i.sroa.3.3.insert.ext.i, 24
<   %data.i.sroa.2.2.insert.ext.i = zext i8 %109 to i32
<   %data.i.sroa.2.2.insert.shift.i = shl nuw nsw i32 %data.i.sroa.2.2.insert.ext.i, 16
<   %data.i.sroa.2.2.insert.insert.i = or i32 %data.i.sroa.2.2.insert.shift.i, %data.i.sroa.3.3.insert.shift.i
<   %data.i.sroa.1.1.insert.ext.i = zext i8 %110 to i32
<   %data.i.sroa.1.1.insert.shift.i = shl nuw nsw i32 %data.i.sroa.1.1.insert.ext.i, 8
<   %data.i.sroa.1.1.insert.insert.i = or i32 %data.i.sroa.2.2.insert.insert.i, %data.i.sroa.1.1.insert.shift.i
<   %data.i.sroa.0.0.insert.ext.i = zext i8 %data.i.sroa.0.0.extract.trunc24.i to i32
<   %data.i.sroa.0.0.insert.insert.i = or i32 %data.i.sroa.1.1.insert.insert.i, %data.i.sroa.0.0.insert.ext.i
<   br label %io_read_chkl_mmu.exit
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i64* %aSig, align 8
>   %10 = shl i64 %9, 1
>   %11 = icmp ne i64 %10, 0
>   br i1 %11, label %12, label %15
18853,18855c17539,17559
< ; <label>:111                                     ; preds = %can_do_io.exit.thread.i
<   %112 = call i32 @io_readl_mmu(i64 %30, i32 %8, i8* null) nounwind
<   br label %io_read_chkl_mmu.exit
---
> ; <label>:12                                      ; preds = %8
>   %13 = load %struct.float_status** %1, align 4
>   call void @floatx80ToCommonNaN(%struct.commonNaNT* sret %2, %struct.floatx80* byval align 4 %a, %struct.float_status* %13)
>   %14 = load %struct.float_status** %1, align 4
>   call void @commonNaNToFloat128(%struct.float128* sret %agg.result, %struct.commonNaNT* byval align 4 %2, %struct.float_status* %14)
>   br label %22
> 
> ; <label>:15                                      ; preds = %8, %0
>   %16 = load i64* %aSig, align 8
>   %17 = shl i64 %16, 1
>   call void @shift128Right(i64 %17, i64 0, i32 16, i64* %zSig0, i64* %zSig1)
>   %18 = load i8* %aSign, align 1
>   %19 = load i32* %aExp, align 4
>   %20 = load i64* %zSig0, align 8
>   %21 = load i64* %zSig1, align 8
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %18, i32 %19, i64 %20, i64 %21)
>   br label %22
> 
> ; <label>:22                                      ; preds = %15, %12
>   ret void
> }
18857,18862c17561,17574
< io_read_chkl_mmu.exit:                            ; preds = %111, %io_read_chk_symb_l.exit.i, %68
<   %.0.i = phi i32 [ %data.i.sroa.0.0.insert.insert.i, %io_read_chk_symb_l.exit.i ], [ %112, %111 ], [ %72, %68 ]
<   %113 = add i64 %30, %34
<   %114 = zext i32 %.0.i to i64
<   call void @tcg_llvm_trace_memory_access(i64 %34, i64 %113, i64 %114, i32 32, i8 zeroext 0, i8 zeroext 1) nounwind
<   br label %145
---
> define internal void @floatx80_round_to_int(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %lastBitMask = alloca i64, align 8
>   %roundBitsMask = alloca i64, align 8
>   %roundingMode = alloca i8, align 1
>   %z = alloca %struct.floatx80, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %2, i32* %aExp, align 4
>   %3 = load i32* %aExp, align 4
>   %4 = icmp sle i32 16446, %3
>   br i1 %4, label %5, label %17
18864,18868c17576,17585
< ; <label>:115                                     ; preds = %._crit_edge
<   %116 = and i32 %8, 127
<   %117 = add i32 %116, 3
<   %118 = icmp ugt i32 %117, 127
<   br i1 %118, label %119, label %130
---
> ; <label>:5                                       ; preds = %0
>   %6 = load i32* %aExp, align 4
>   %7 = icmp eq i32 %6, 32767
>   br i1 %7, label %8, label %14
> 
> ; <label>:8                                       ; preds = %5
>   %9 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %10 = shl i64 %9, 1
>   %11 = icmp ne i64 %10, 0
>   br i1 %11, label %12, label %14
18870,18881c17587,17590
< ; <label>:119                                     ; preds = %115, %25
<   %120 = and i32 %8, -4
<   %121 = add i32 %120, 4
<   %122 = call fastcc i32 @slow_ldl_mmu(i32 %120, i32 %mmu_idx)
<   %123 = call fastcc i32 @slow_ldl_mmu(i32 %121, i32 %mmu_idx)
<   %124 = shl i32 %8, 3
<   %125 = and i32 %124, 24
<   %126 = lshr i32 %122, %125
<   %127 = sub i32 32, %125
<   %128 = shl i32 %123, %127
<   %129 = or i32 %128, %126
<   br label %145
---
> ; <label>:12                                      ; preds = %8
>   %13 = load %struct.float_status** %1, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %a, %struct.float_status* %13)
>   br label %152
18883,18892c17592,17596
< ; <label>:130                                     ; preds = %115
<   %131 = getelementptr inbounds %struct.CPUX86State* %.lcssa2, i64 0, i32 73, i64 %14, i64 %13, i32 3
<   %132 = load i64* %131, align 8
<   %133 = and i64 %7, 4294967295
<   %134 = add i64 %132, %133
<   %135 = inttoptr i64 %134 to i32*
<   %136 = load i32* %135, align 4
<   %137 = zext i32 %136 to i64
<   call void @tcg_llvm_trace_memory_access(i64 %133, i64 %134, i64 %137, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %145
---
> ; <label>:14                                      ; preds = %8, %5
>   %15 = bitcast %struct.floatx80* %agg.result to i8*
>   %16 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %15, i8* %16, i32 10, i32 1, i1 false)
>   br label %152
18894,18902c17598,17601
< ; <label>:138                                     ; preds = %138, %.lr.ph
<   %139 = phi %struct.CPUX86State* [ %15, %.lr.ph ], [ %140, %138 ]
<   call void @tlb_fill(%struct.CPUX86State* %139, i32 %8, i32 %22, i32 0, i32 %mmu_idx, i8* null)
<   %140 = load %struct.CPUX86State** @env, align 8
<   %141 = getelementptr inbounds %struct.CPUX86State* %140, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %142 = load i32* %141, align 4
<   %143 = and i32 %142, -4088
<   %144 = icmp eq i32 %18, %143
<   br i1 %144, label %._crit_edge, label %138
---
> ; <label>:17                                      ; preds = %0
>   %18 = load i32* %aExp, align 4
>   %19 = icmp slt i32 %18, 16383
>   br i1 %19, label %20, label %68
18904,18907c17603,17606
< ; <label>:145                                     ; preds = %130, %119, %io_read_chkl_mmu.exit
<   %res.0 = phi i32 [ %129, %119 ], [ %.0.i, %io_read_chkl_mmu.exit ], [ %136, %130 ]
<   ret i32 %res.0
< }
---
> ; <label>:20                                      ; preds = %17
>   %21 = load i32* %aExp, align 4
>   %22 = icmp eq i32 %21, 0
>   br i1 %22, label %23, label %30
18909,18930c17608,17612
< define void @io_write_chkl_mmu(i64 %physaddr, i32 %val, i32 %addr, i8* %retaddr) nounwind uwtable inlinehint alwaysinline {
<   %1 = alloca i32, align 4
<   %2 = alloca i32, align 4
<   store i32 %val, i32* %1, align 4
<   store i32 %addr, i32* %2, align 4
<   %3 = call %struct.MemoryRegion* @iotlb_to_region(i64 %physaddr) nounwind
<   %4 = and i64 %physaddr, -4096
<   %5 = zext i32 %addr to i64
<   %6 = add i64 %5, %4
<   %7 = icmp ne %struct.MemoryRegion* %3, @io_mem_ram
<   %8 = icmp ne %struct.MemoryRegion* %3, @io_mem_rom
<   %or.cond = and i1 %7, %8
<   %9 = icmp ne %struct.MemoryRegion* %3, @io_mem_unassigned
<   %or.cond3 = and i1 %or.cond, %9
<   %10 = icmp ne %struct.MemoryRegion* %3, @io_mem_notdirty
<   %or.cond5 = and i1 %or.cond3, %10
<   %11 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not = xor i1 %or.cond5, true
<   %12 = load i32* @use_icount, align 4
<   %13 = icmp eq i32 %12, 0
<   %or.cond17 = or i1 %13, %or.cond5.not
<   br i1 %or.cond17, label %can_do_io.exit.thread, label %14
---
> ; <label>:23                                      ; preds = %20
>   %24 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %25 = shl i64 %24, 1
>   %26 = icmp eq i64 %25, 0
>   br i1 %26, label %27, label %30
18932,18936c17614,17618
< ; <label>:14                                      ; preds = %0
<   %15 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 66
<   %16 = load %struct.TranslationBlock** %15, align 8
<   %17 = icmp eq %struct.TranslationBlock* %16, null
<   br i1 %17, label %can_do_io.exit.thread, label %can_do_io.exit
---
> ; <label>:27                                      ; preds = %23
>   %28 = bitcast %struct.floatx80* %agg.result to i8*
>   %29 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %28, i8* %29, i32 10, i32 1, i1 false)
>   br label %152
18938,18942c17620,17638
< can_do_io.exit:                                   ; preds = %14
<   %18 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 85
<   %19 = load i32* %18, align 4
<   %20 = icmp eq i32 %19, 0
<   br i1 %20, label %21, label %can_do_io.exit.thread
---
> ; <label>:30                                      ; preds = %23, %20
>   %31 = load %struct.float_status** %1, align 4
>   %32 = getelementptr inbounds %struct.float_status* %31, i32 0, i32 2
>   %33 = load i8* %32, align 1
>   %34 = sext i8 %33 to i32
>   %35 = or i32 %34, 32
>   %36 = trunc i32 %35 to i8
>   store i8 %36, i8* %32, align 1
>   %37 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %37, i8* %aSign, align 1
>   %38 = load %struct.float_status** %1, align 4
>   %39 = getelementptr inbounds %struct.float_status* %38, i32 0, i32 1
>   %40 = load i8* %39, align 1
>   %41 = sext i8 %40 to i32
>   switch i32 %41, label %66 [
>     i32 0, label %42
>     i32 1, label %52
>     i32 2, label %59
>   ]
18944,18946c17640,17643
< ; <label>:21                                      ; preds = %can_do_io.exit
<   call void @cpu_io_recompile(%struct.CPUX86State* %11, i8* %retaddr) noreturn nounwind
<   unreachable
---
> ; <label>:42                                      ; preds = %30
>   %43 = load i32* %aExp, align 4
>   %44 = icmp eq i32 %43, 16382
>   br i1 %44, label %45, label %51
18948,18957c17645,17654
< can_do_io.exit.thread:                            ; preds = %can_do_io.exit, %14, %0
<   %22 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 69
<   store i32 %addr, i32* %22, align 4
<   %23 = ptrtoint i8* %retaddr to i64
<   %24 = load %struct.CPUX86State** @env, align 8
<   %25 = getelementptr inbounds %struct.CPUX86State* %24, i64 0, i32 68
<   store i64 %23, i64* %25, align 8
<   %26 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %3, i32 1) nounwind
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %32, label %28
---
> ; <label>:45                                      ; preds = %42
>   %46 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %47 = shl i64 %46, 1
>   %48 = icmp ne i64 %47, 0
>   br i1 %48, label %49, label %51
> 
> ; <label>:49                                      ; preds = %45
>   %50 = load i8* %aSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %50, i32 16383, i64 -9223372036854775808)
>   br label %152
18959,18964c17656,17657
< ; <label>:28                                      ; preds = %can_do_io.exit.thread
<   %29 = call i64 @s2e_notdirty_mem_write(i64 %6) nounwind
<   %30 = load i32* %1, align 4
<   %31 = inttoptr i64 %29 to i32*
<   store i32 %30, i32* %31, align 4
<   br label %45
---
> ; <label>:51                                      ; preds = %45, %42
>   br label %66
18966,18969c17659,17663
< ; <label>:32                                      ; preds = %can_do_io.exit.thread
<   %33 = load i32* @g_s2e_concretize_io_writes, align 4
<   %34 = icmp eq i32 %33, 0
<   br i1 %34, label %37, label %35
---
> ; <label>:52                                      ; preds = %30
>   %53 = load i8* %aSign, align 1
>   %54 = zext i8 %53 to i32
>   %55 = icmp ne i32 %54, 0
>   br i1 %55, label %56, label %57
18971,18974c17665,17667
< ; <label>:35                                      ; preds = %32
<   %36 = bitcast i32* %1 to i8*
<   call void @tcg_llvm_get_value(i8* %36, i32 4, i1 zeroext true) nounwind
<   br label %37
---
> ; <label>:56                                      ; preds = %52
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext 1, i32 16383, i64 -9223372036854775808)
>   br label %58
18976,18979c17669,17671
< ; <label>:37                                      ; preds = %35, %32
<   %38 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %39 = icmp eq i32 %38, 0
<   br i1 %39, label %42, label %40
---
> ; <label>:57                                      ; preds = %52
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext 0, i32 0, i64 0)
>   br label %58
18981,18984c17673,17674
< ; <label>:40                                      ; preds = %37
<   %41 = bitcast i32* %2 to i8*
<   call void @tcg_llvm_get_value(i8* %41, i32 4, i1 zeroext true) nounwind
<   br label %42
---
> ; <label>:58                                      ; preds = %57, %56
>   br label %152
18986,18990c17676,17680
< ; <label>:42                                      ; preds = %40, %37
<   %43 = load i32* %1, align 4
<   %44 = load i32* %2, align 4
<   call void @io_writel_mmu(i64 %physaddr, i32 %43, i32 %44, i8* %retaddr) nounwind
<   br label %45
---
> ; <label>:59                                      ; preds = %30
>   %60 = load i8* %aSign, align 1
>   %61 = zext i8 %60 to i32
>   %62 = icmp ne i32 %61, 0
>   br i1 %62, label %63, label %64
18992,18994c17682,17684
< ; <label>:45                                      ; preds = %42, %28
<   ret void
< }
---
> ; <label>:63                                      ; preds = %59
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext 1, i32 0, i64 0)
>   br label %65
18996c17686,17688
< declare void @io_writel_mmu(i64, i32, i32, i8*)
---
> ; <label>:64                                      ; preds = %59
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext 0, i32 16383, i64 -9223372036854775808)
>   br label %65
18998,19006c17690,17691
< define void @__stl_mmu(i32 %addr, i32 %val, i32 %mmu_idx) nounwind uwtable {
<   %1 = alloca i32, align 4
<   %2 = alloca i32, align 4
<   %3 = alloca i32, align 4
<   %4 = alloca i32, align 4
<   %5 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %6 = icmp eq i32 %5, 0
<   %7 = zext i32 %addr to i64
<   br i1 %6, label %10, label %8
---
> ; <label>:65                                      ; preds = %64, %63
>   br label %152
19008,19010c17693,17696
< ; <label>:8                                       ; preds = %0
<   %9 = call i64 @tcg_llvm_fork_and_concretize(i64 %7, i64 0, i64 4294967295) nounwind
<   br label %10
---
> ; <label>:66                                      ; preds = %51, %30
>   %67 = load i8* %aSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %67, i32 0, i64 0)
>   br label %152
19012,19032c17698,17719
< ; <label>:10                                      ; preds = %8, %0
<   %11 = phi i64 [ %9, %8 ], [ %7, %0 ]
<   %12 = trunc i64 %11 to i32
<   %13 = lshr i64 %11, 7
<   %14 = and i64 %13, 33554431
<   %15 = call i64 @tcg_llvm_fork_and_concretize(i64 %14, i64 0, i64 33554431) nounwind
<   %16 = lshr i64 %15, 5
<   %17 = and i64 %16, 255
<   %18 = sext i32 %mmu_idx to i64
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 73, i64 %18, i64 %17, i32 1
<   %21 = load i32* %20, align 4
<   %22 = and i32 %12, -4096
<   %23 = and i32 %21, -4088
<   %24 = icmp eq i32 %22, %23
<   br i1 %24, label %._crit_edge, label %.lr.ph, !prof !0
< 
< .lr.ph:                                           ; preds = %10
<   %25 = trunc i64 %15 to i32
<   %26 = shl i32 %25, 7
<   br label %190
---
> ; <label>:68                                      ; preds = %17
>   store i64 1, i64* %lastBitMask, align 8
>   %69 = load i32* %aExp, align 4
>   %70 = sub nsw i32 16446, %69
>   %71 = load i64* %lastBitMask, align 8
>   %72 = zext i32 %70 to i64
>   %73 = shl i64 %71, %72
>   store i64 %73, i64* %lastBitMask, align 8
>   %74 = load i64* %lastBitMask, align 8
>   %75 = sub i64 %74, 1
>   store i64 %75, i64* %roundBitsMask, align 8
>   %76 = bitcast %struct.floatx80* %z to i8*
>   %77 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %76, i8* %77, i32 10, i32 1, i1 false)
>   %78 = load %struct.float_status** %1, align 4
>   %79 = getelementptr inbounds %struct.float_status* %78, i32 0, i32 1
>   %80 = load i8* %79, align 1
>   store i8 %80, i8* %roundingMode, align 1
>   %81 = load i8* %roundingMode, align 1
>   %82 = sext i8 %81 to i32
>   %83 = icmp eq i32 %82, 0
>   br i1 %83, label %84, label %102
19034,19039c17721,17742
< ._crit_edge:                                      ; preds = %190, %10
<   %.lcssa33 = phi i32 [ %21, %10 ], [ %194, %190 ]
<   %.lcssa32 = phi %struct.CPUX86State* [ %19, %10 ], [ %192, %190 ]
<   %27 = and i32 %.lcssa33, 4095
<   %28 = icmp eq i32 %27, 0
<   br i1 %28, label %78, label %29, !prof !0
---
> ; <label>:84                                      ; preds = %68
>   %85 = load i64* %lastBitMask, align 8
>   %86 = lshr i64 %85, 1
>   %87 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   %88 = load i64* %87, align 1
>   %89 = add i64 %88, %86
>   store i64 %89, i64* %87, align 1
>   %90 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   %91 = load i64* %90, align 1
>   %92 = load i64* %roundBitsMask, align 8
>   %93 = and i64 %91, %92
>   %94 = icmp eq i64 %93, 0
>   br i1 %94, label %95, label %101
> 
> ; <label>:95                                      ; preds = %84
>   %96 = load i64* %lastBitMask, align 8
>   %97 = xor i64 %96, -1
>   %98 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   %99 = load i64* %98, align 1
>   %100 = and i64 %99, %97
>   store i64 %100, i64* %98, align 1
>   br label %101
19041,19044c17744,17745
< ; <label>:29                                      ; preds = %._crit_edge
<   %30 = and i32 %12, 3
<   %31 = icmp eq i32 %30, 0
<   br i1 %31, label %32, label %82
---
> ; <label>:101                                     ; preds = %95, %84
>   br label %122
19046,19069c17747,17770
< ; <label>:32                                      ; preds = %29
<   %33 = getelementptr inbounds %struct.CPUX86State* %.lcssa32, i64 0, i32 75, i64 %18, i64 %17
<   %34 = load i64* %33, align 8
<   %35 = bitcast i32* %3 to i8*
<   %36 = bitcast i32* %4 to i8*
<   store i32 %val, i32* %3, align 4
<   store i32 %12, i32* %4, align 4
<   %37 = call %struct.MemoryRegion* @iotlb_to_region(i64 %34) nounwind
<   %38 = and i64 %34, -4096
<   %39 = and i64 %11, 4294967295
<   %40 = add i64 %38, %39
<   %41 = icmp ne %struct.MemoryRegion* %37, @io_mem_ram
<   %42 = icmp ne %struct.MemoryRegion* %37, @io_mem_rom
<   %or.cond.i = and i1 %41, %42
<   %43 = icmp ne %struct.MemoryRegion* %37, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %43
<   %44 = icmp ne %struct.MemoryRegion* %37, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %44
<   %45 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %46 = load i32* @use_icount, align 4
<   %47 = icmp eq i32 %46, 0
<   %or.cond17.i = or i1 %47, %or.cond5.not.i
<   br i1 %or.cond17.i, label %can_do_io.exit.thread.i, label %48
---
> ; <label>:102                                     ; preds = %68
>   %103 = load i8* %roundingMode, align 1
>   %104 = sext i8 %103 to i32
>   %105 = icmp ne i32 %104, 3
>   br i1 %105, label %106, label %121
> 
> ; <label>:106                                     ; preds = %102
>   %107 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %z)
>   %108 = zext i8 %107 to i32
>   %109 = load i8* %roundingMode, align 1
>   %110 = sext i8 %109 to i32
>   %111 = icmp eq i32 %110, 2
>   %112 = zext i1 %111 to i32
>   %113 = xor i32 %108, %112
>   %114 = icmp ne i32 %113, 0
>   br i1 %114, label %115, label %120
> 
> ; <label>:115                                     ; preds = %106
>   %116 = load i64* %roundBitsMask, align 8
>   %117 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   %118 = load i64* %117, align 1
>   %119 = add i64 %118, %116
>   store i64 %119, i64* %117, align 1
>   br label %120
19071,19075c17772,17773
< ; <label>:48                                      ; preds = %32
<   %49 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 66
<   %50 = load %struct.TranslationBlock** %49, align 8
<   %51 = icmp eq %struct.TranslationBlock* %50, null
<   br i1 %51, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:120                                     ; preds = %115, %106
>   br label %121
19077,19081c17775,17776
< can_do_io.exit.i:                                 ; preds = %48
<   %52 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 85
<   %53 = load i32* %52, align 4
<   %54 = icmp eq i32 %53, 0
<   br i1 %54, label %55, label %can_do_io.exit.thread.i
---
> ; <label>:121                                     ; preds = %120, %102
>   br label %122
19083,19085c17778,17797
< ; <label>:55                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %45, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:122                                     ; preds = %121, %101
>   %123 = load i64* %roundBitsMask, align 8
>   %124 = xor i64 %123, -1
>   %125 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   %126 = load i64* %125, align 1
>   %127 = and i64 %126, %124
>   store i64 %127, i64* %125, align 1
>   %128 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   %129 = load i64* %128, align 1
>   %130 = icmp eq i64 %129, 0
>   br i1 %130, label %131, label %136
> 
> ; <label>:131                                     ; preds = %122
>   %132 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   %133 = load i16* %132, align 1
>   %134 = add i16 %133, 1
>   store i16 %134, i16* %132, align 1
>   %135 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 -9223372036854775808, i64* %135, align 1
>   br label %136
19087,19095c17799,17815
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %48, %32
<   %56 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 69
<   store i32 %12, i32* %56, align 4
<   %57 = load %struct.CPUX86State** @env, align 8
<   %58 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 68
<   store i64 0, i64* %58, align 8
<   %59 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %37, i32 1) nounwind
<   %60 = icmp eq i32 %59, 0
<   br i1 %60, label %65, label %61
---
> ; <label>:136                                     ; preds = %131, %122
>   %137 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   %138 = load i64* %137, align 1
>   %139 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %140 = load i64* %139, align 1
>   %141 = icmp ne i64 %138, %140
>   br i1 %141, label %142, label %149
> 
> ; <label>:142                                     ; preds = %136
>   %143 = load %struct.float_status** %1, align 4
>   %144 = getelementptr inbounds %struct.float_status* %143, i32 0, i32 2
>   %145 = load i8* %144, align 1
>   %146 = sext i8 %145 to i32
>   %147 = or i32 %146, 32
>   %148 = trunc i32 %147 to i8
>   store i8 %148, i8* %144, align 1
>   br label %149
19097,19102c17817,17821
< ; <label>:61                                      ; preds = %can_do_io.exit.thread.i
<   %62 = call i64 @s2e_notdirty_mem_write(i64 %40) nounwind
<   %63 = load i32* %3, align 4
<   %64 = inttoptr i64 %62 to i32*
<   store i32 %63, i32* %64, align 4
<   br label %io_write_chkl_mmu.exit
---
> ; <label>:149                                     ; preds = %142, %136
>   %150 = bitcast %struct.floatx80* %agg.result to i8*
>   %151 = bitcast %struct.floatx80* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %150, i8* %151, i32 10, i32 1, i1 false)
>   br label %152
19104,19107c17823,17825
< ; <label>:65                                      ; preds = %can_do_io.exit.thread.i
<   %66 = load i32* @g_s2e_concretize_io_writes, align 4
<   %67 = icmp eq i32 %66, 0
<   br i1 %67, label %69, label %68
---
> ; <label>:152                                     ; preds = %149, %66, %65, %58, %49, %27, %14, %12
>   ret void
> }
19109,19111c17827,17853
< ; <label>:68                                      ; preds = %65
<   call void @tcg_llvm_get_value(i8* %35, i32 4, i1 zeroext true) nounwind
<   br label %69
---
> define internal void @propagateFloatx80NaN(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aIsQuietNaN = alloca i8, align 1
>   %aIsSignalingNaN = alloca i8, align 1
>   %bIsQuietNaN = alloca i8, align 1
>   %bIsSignalingNaN = alloca i8, align 1
>   %aIsLargerSignificand = alloca i8, align 1
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call i32 @floatx80_is_quiet_nan(%struct.floatx80* byval align 4 %a)
>   %3 = trunc i32 %2 to i8
>   store i8 %3, i8* %aIsQuietNaN, align 1
>   %4 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %a)
>   %5 = trunc i32 %4 to i8
>   store i8 %5, i8* %aIsSignalingNaN, align 1
>   %6 = call i32 @floatx80_is_quiet_nan(%struct.floatx80* byval align 4 %b)
>   %7 = trunc i32 %6 to i8
>   store i8 %7, i8* %bIsQuietNaN, align 1
>   %8 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %b)
>   %9 = trunc i32 %8 to i8
>   store i8 %9, i8* %bIsSignalingNaN, align 1
>   %10 = load i8* %aIsSignalingNaN, align 1
>   %11 = zext i8 %10 to i32
>   %12 = load i8* %bIsSignalingNaN, align 1
>   %13 = zext i8 %12 to i32
>   %14 = or i32 %11, %13
>   %15 = icmp ne i32 %14, 0
>   br i1 %15, label %16, label %18
19113,19116c17855,17858
< ; <label>:69                                      ; preds = %68, %65
<   %70 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %71 = icmp eq i32 %70, 0
<   br i1 %71, label %73, label %72
---
> ; <label>:16                                      ; preds = %0
>   %17 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %17)
>   br label %18
19118,19120c17860,17865
< ; <label>:72                                      ; preds = %69
<   call void @tcg_llvm_get_value(i8* %36, i32 4, i1 zeroext true) nounwind
<   br label %73
---
> ; <label>:18                                      ; preds = %16, %0
>   %19 = load %struct.float_status** %1, align 4
>   %20 = getelementptr inbounds %struct.float_status* %19, i32 0, i32 6
>   %21 = load i8* %20, align 1
>   %22 = icmp ne i8 %21, 0
>   br i1 %22, label %23, label %28
19122,19138c17867,17875
< ; <label>:73                                      ; preds = %72, %69
<   %74 = load i32* %3, align 4
<   %75 = load i32* %4, align 4
<   call void @io_writel_mmu(i64 %34, i32 %74, i32 %75, i8* null) nounwind
<   br label %io_write_chkl_mmu.exit
< 
< io_write_chkl_mmu.exit:                           ; preds = %73, %61
<   %76 = add i64 %34, %39
<   %77 = zext i32 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %39, i64 %76, i64 %77, i32 32, i8 zeroext 1, i8 zeroext 1) nounwind
<   br label %slow_stl_mmu.exit
< 
< ; <label>:78                                      ; preds = %._crit_edge
<   %79 = and i32 %12, 127
<   %80 = add i32 %79, 3
<   %81 = icmp ugt i32 %80, 127
<   br i1 %81, label %82, label %183, !prof !1
---
> ; <label>:23                                      ; preds = %18
>   %24 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   store i64 -4611686018427387904, i64* %24, align 1
>   %25 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   store i16 -1, i16* %25, align 1
>   %26 = bitcast %struct.floatx80* %agg.result to i8*
>   %27 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %26, i8* %27, i32 10, i32 1, i1 false)
>   br label %63
19140,19144c17877,17883
< ; <label>:82                                      ; preds = %78, %29
<   %83 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %84 = icmp eq i32 %83, 0
<   %85 = and i64 %11, 4294967295
<   br i1 %84, label %88, label %86
---
> ; <label>:28                                      ; preds = %18
>   %29 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %30 = load i64* %29, align 1
>   %31 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %32 = load i64* %31, align 1
>   %33 = icmp ult i64 %30, %32
>   br i1 %33, label %34, label %35
19146,19148c17885,17887
< ; <label>:86                                      ; preds = %82
<   %87 = call i64 @tcg_llvm_fork_and_concretize(i64 %85, i64 0, i64 4294967295) nounwind
<   br label %88
---
> ; <label>:34                                      ; preds = %28
>   store i8 0, i8* %aIsLargerSignificand, align 1
>   br label %53
19150,19169c17889,17895
< ; <label>:88                                      ; preds = %86, %82
<   %89 = phi i64 [ %87, %86 ], [ %85, %82 ]
<   %90 = trunc i64 %89 to i32
<   %91 = lshr i64 %89, 7
<   %92 = and i64 %91, 33554431
<   %93 = call i64 @tcg_llvm_fork_and_concretize(i64 %92, i64 0, i64 33554431) nounwind
<   %94 = lshr i64 %93, 5
<   %95 = and i64 %94, 255
<   %96 = load %struct.CPUX86State** @env, align 8
<   %97 = getelementptr inbounds %struct.CPUX86State* %96, i64 0, i32 73, i64 %18, i64 %95, i32 1
<   %98 = load i32* %97, align 4
<   %99 = and i32 %90, -4096
<   %100 = and i32 %98, -4088
<   %101 = icmp eq i32 %99, %100
<   br i1 %101, label %._crit_edge.i, label %.lr.ph.i
< 
< .lr.ph.i:                                         ; preds = %88
<   %102 = trunc i64 %93 to i32
<   %103 = shl i32 %102, 7
<   br label %176
---
> ; <label>:35                                      ; preds = %28
>   %36 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %37 = load i64* %36, align 1
>   %38 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %39 = load i64* %38, align 1
>   %40 = icmp ult i64 %37, %39
>   br i1 %40, label %41, label %42
19171,19176c17897,17899
< ._crit_edge.i:                                    ; preds = %176, %88
<   %.lcssa3.i = phi i32 [ %98, %88 ], [ %180, %176 ]
<   %.lcssa2.i = phi %struct.CPUX86State* [ %96, %88 ], [ %178, %176 ]
<   %104 = and i32 %.lcssa3.i, 4095
<   %105 = icmp eq i32 %104, 0
<   br i1 %105, label %155, label %106
---
> ; <label>:41                                      ; preds = %35
>   store i8 1, i8* %aIsLargerSignificand, align 1
>   br label %52
19178,19181c17901,17912
< ; <label>:106                                     ; preds = %._crit_edge.i
<   %107 = and i32 %90, 3
<   %108 = icmp eq i32 %107, 0
<   br i1 %108, label %109, label %.preheader.i
---
> ; <label>:42                                      ; preds = %35
>   %43 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %44 = load i16* %43, align 1
>   %45 = zext i16 %44 to i32
>   %46 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %47 = load i16* %46, align 1
>   %48 = zext i16 %47 to i32
>   %49 = icmp slt i32 %45, %48
>   %50 = select i1 %49, i32 1, i32 0
>   %51 = trunc i32 %50 to i8
>   store i8 %51, i8* %aIsLargerSignificand, align 1
>   br label %52
19183,19218c17914,17915
< ; <label>:109                                     ; preds = %106
<   %110 = getelementptr inbounds %struct.CPUX86State* %.lcssa2.i, i64 0, i32 75, i64 %18, i64 %95
<   %111 = load i64* %110, align 8
<   %112 = bitcast i32* %1 to i8*
<   %113 = bitcast i32* %2 to i8*
<   store i32 %val, i32* %1, align 4
<   store i32 %90, i32* %2, align 4
<   %114 = call %struct.MemoryRegion* @iotlb_to_region(i64 %111) nounwind
<   %115 = and i64 %111, -4096
<   %116 = and i64 %89, 4294967295
<   %117 = add i64 %115, %116
<   %118 = icmp ne %struct.MemoryRegion* %114, @io_mem_ram
<   %119 = icmp ne %struct.MemoryRegion* %114, @io_mem_rom
<   %or.cond.i.i = and i1 %118, %119
<   %120 = icmp ne %struct.MemoryRegion* %114, @io_mem_unassigned
<   %or.cond3.i.i = and i1 %or.cond.i.i, %120
<   %121 = icmp ne %struct.MemoryRegion* %114, @io_mem_notdirty
<   %or.cond5.i.i = and i1 %or.cond3.i.i, %121
<   %122 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i.i = xor i1 %or.cond5.i.i, true
<   %123 = load i32* @use_icount, align 4
<   %124 = icmp eq i32 %123, 0
<   %or.cond17.i.i = or i1 %124, %or.cond5.not.i.i
<   br i1 %or.cond17.i.i, label %can_do_io.exit.thread.i.i, label %125
< 
< ; <label>:125                                     ; preds = %109
<   %126 = getelementptr inbounds %struct.CPUX86State* %122, i64 0, i32 66
<   %127 = load %struct.TranslationBlock** %126, align 8
<   %128 = icmp eq %struct.TranslationBlock* %127, null
<   br i1 %128, label %can_do_io.exit.thread.i.i, label %can_do_io.exit.i.i
< 
< can_do_io.exit.i.i:                               ; preds = %125
<   %129 = getelementptr inbounds %struct.CPUX86State* %122, i64 0, i32 85
<   %130 = load i32* %129, align 4
<   %131 = icmp eq i32 %130, 0
<   br i1 %131, label %132, label %can_do_io.exit.thread.i.i
---
> ; <label>:52                                      ; preds = %42, %41
>   br label %53
19220,19222c17917,17929
< ; <label>:132                                     ; preds = %can_do_io.exit.i.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %122, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:53                                      ; preds = %52, %34
>   %54 = load i8* %aIsQuietNaN, align 1
>   %55 = load i8* %aIsSignalingNaN, align 1
>   %56 = load i8* %bIsQuietNaN, align 1
>   %57 = load i8* %bIsSignalingNaN, align 1
>   %58 = load i8* %aIsLargerSignificand, align 1
>   %59 = call i32 @pickNaN(i8 zeroext %54, i8 zeroext %55, i8 zeroext %56, i8 zeroext %57, i8 zeroext %58)
>   %60 = icmp ne i32 %59, 0
>   br i1 %60, label %61, label %62
> 
> ; <label>:61                                      ; preds = %53
>   call void @floatx80_maybe_silence_nan(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %b)
>   br label %63
19224,19244c17931,17933
< can_do_io.exit.thread.i.i:                        ; preds = %can_do_io.exit.i.i, %125, %109
<   %133 = getelementptr inbounds %struct.CPUX86State* %122, i64 0, i32 69
<   store i32 %90, i32* %133, align 4
<   %134 = load %struct.CPUX86State** @env, align 8
<   %135 = getelementptr inbounds %struct.CPUX86State* %134, i64 0, i32 68
<   store i64 0, i64* %135, align 8
<   %136 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %114, i32 1) nounwind
<   %137 = icmp eq i32 %136, 0
<   br i1 %137, label %142, label %138
< 
< ; <label>:138                                     ; preds = %can_do_io.exit.thread.i.i
<   %139 = call i64 @s2e_notdirty_mem_write(i64 %117) nounwind
<   %140 = load i32* %1, align 4
<   %141 = inttoptr i64 %139 to i32*
<   store i32 %140, i32* %141, align 4
<   br label %io_write_chkl_mmu.exit.i
< 
< ; <label>:142                                     ; preds = %can_do_io.exit.thread.i.i
<   %143 = load i32* @g_s2e_concretize_io_writes, align 4
<   %144 = icmp eq i32 %143, 0
<   br i1 %144, label %146, label %145
---
> ; <label>:62                                      ; preds = %53
>   call void @floatx80_maybe_silence_nan(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a)
>   br label %63
19246,19248c17935,17937
< ; <label>:145                                     ; preds = %142
<   call void @tcg_llvm_get_value(i8* %112, i32 4, i1 zeroext true) nounwind
<   br label %146
---
> ; <label>:63                                      ; preds = %62, %61, %23
>   ret void
> }
19250,19253c17939,17953
< ; <label>:146                                     ; preds = %145, %142
<   %147 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %148 = icmp eq i32 %147, 0
<   br i1 %148, label %150, label %149
---
> define internal void @floatx80_add(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %2, i8* %aSign, align 1
>   %3 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %b)
>   store i8 %3, i8* %bSign, align 1
>   %4 = load i8* %aSign, align 1
>   %5 = zext i8 %4 to i32
>   %6 = load i8* %bSign, align 1
>   %7 = zext i8 %6 to i32
>   %8 = icmp eq i32 %5, %7
>   br i1 %8, label %9, label %12
19255,19257c17955,17959
< ; <label>:149                                     ; preds = %146
<   call void @tcg_llvm_get_value(i8* %113, i32 4, i1 zeroext true) nounwind
<   br label %150
---
> ; <label>:9                                       ; preds = %0
>   %10 = load i8* %aSign, align 1
>   %11 = load %struct.float_status** %1, align 4
>   call void @addFloatx80Sigs(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, i8 zeroext %10, %struct.float_status* %11)
>   br label %15
19259,19334c17961,17965
< ; <label>:150                                     ; preds = %149, %146
<   %151 = load i32* %1, align 4
<   %152 = load i32* %2, align 4
<   call void @io_writel_mmu(i64 %111, i32 %151, i32 %152, i8* null) nounwind
<   br label %io_write_chkl_mmu.exit.i
< 
< io_write_chkl_mmu.exit.i:                         ; preds = %150, %138
<   %153 = add i64 %111, %116
<   %154 = zext i32 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %116, i64 %153, i64 %154, i32 32, i8 zeroext 1, i8 zeroext 1) nounwind
<   br label %slow_stl_mmu.exit
< 
< ; <label>:155                                     ; preds = %._crit_edge.i
<   %156 = and i32 %90, 127
<   %157 = add i32 %156, 3
<   %158 = icmp ugt i32 %157, 127
<   br i1 %158, label %.preheader.i, label %169
< 
< .preheader.i:                                     ; preds = %155, %106
<   %159 = add i32 %90, 3
<   %160 = lshr i32 %val, 24
<   %161 = trunc i32 %160 to i8
<   call fastcc void @slow_stb_mmu(i32 %159, i8 zeroext %161, i32 %mmu_idx) nounwind
<   %162 = add i32 %90, 2
<   %163 = lshr i32 %val, 16
<   %164 = trunc i32 %163 to i8
<   call fastcc void @slow_stb_mmu(i32 %162, i8 zeroext %164, i32 %mmu_idx) nounwind
<   %165 = add i32 %90, 1
<   %166 = lshr i32 %val, 8
<   %167 = trunc i32 %166 to i8
<   call fastcc void @slow_stb_mmu(i32 %165, i8 zeroext %167, i32 %mmu_idx) nounwind
<   %168 = trunc i32 %val to i8
<   call fastcc void @slow_stb_mmu(i32 %90, i8 zeroext %168, i32 %mmu_idx) nounwind
<   br label %slow_stl_mmu.exit
< 
< ; <label>:169                                     ; preds = %155
<   %170 = getelementptr inbounds %struct.CPUX86State* %.lcssa2.i, i64 0, i32 73, i64 %18, i64 %95, i32 3
<   %171 = load i64* %170, align 8
<   %172 = and i64 %89, 4294967295
<   %173 = add i64 %171, %172
<   %174 = inttoptr i64 %173 to i32*
<   store i32 %val, i32* %174, align 4
<   %175 = zext i32 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %172, i64 %173, i64 %175, i32 32, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %slow_stl_mmu.exit
< 
< ; <label>:176                                     ; preds = %176, %.lr.ph.i
<   %177 = phi %struct.CPUX86State* [ %96, %.lr.ph.i ], [ %178, %176 ]
<   call void @tlb_fill(%struct.CPUX86State* %177, i32 %90, i32 %103, i32 1, i32 %mmu_idx, i8* null) nounwind
<   %178 = load %struct.CPUX86State** @env, align 8
<   %179 = getelementptr inbounds %struct.CPUX86State* %178, i64 0, i32 73, i64 %18, i64 %95, i32 1
<   %180 = load i32* %179, align 4
<   %181 = and i32 %180, -4088
<   %182 = icmp eq i32 %99, %181
<   br i1 %182, label %._crit_edge.i, label %176
< 
< ; <label>:183                                     ; preds = %78
<   %184 = getelementptr inbounds %struct.CPUX86State* %.lcssa32, i64 0, i32 73, i64 %18, i64 %17, i32 3
<   %185 = load i64* %184, align 8
<   %186 = and i64 %11, 4294967295
<   %187 = add i64 %185, %186
<   %188 = inttoptr i64 %187 to i32*
<   store i32 %val, i32* %188, align 4
<   %189 = zext i32 %val to i64
<   call void @tcg_llvm_trace_memory_access(i64 %186, i64 %187, i64 %189, i32 32, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %slow_stl_mmu.exit
< 
< ; <label>:190                                     ; preds = %190, %.lr.ph
<   %191 = phi %struct.CPUX86State* [ %19, %.lr.ph ], [ %192, %190 ]
<   call void @tlb_fill(%struct.CPUX86State* %191, i32 %12, i32 %26, i32 1, i32 %mmu_idx, i8* null)
<   %192 = load %struct.CPUX86State** @env, align 8
<   %193 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 73, i64 %18, i64 %17, i32 1
<   %194 = load i32* %193, align 4
<   %195 = and i32 %194, -4088
<   %196 = icmp eq i32 %22, %195
<   br i1 %196, label %._crit_edge, label %190, !prof !0
---
> ; <label>:12                                      ; preds = %0
>   %13 = load i8* %aSign, align 1
>   %14 = load %struct.float_status** %1, align 4
>   call void @subFloatx80Sigs(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, i8 zeroext %13, %struct.float_status* %14)
>   br label %15
19336c17967
< slow_stl_mmu.exit:                                ; preds = %183, %169, %.preheader.i, %io_write_chkl_mmu.exit.i, %io_write_chkl_mmu.exit
---
> ; <label>:15                                      ; preds = %12, %9
19340,19353c17971,17998
< define i64 @io_read_chkq_mmu(i64 %physaddr, i32 %addr, i8* %retaddr) nounwind uwtable inlinehint alwaysinline {
<   %ret.i.i28 = alloca i8, align 1
<   %data.i29 = alloca %union.anon.12, align 8
<   %ret.i.i = alloca i8, align 1
<   %data.i = alloca %union.anon.12, align 8
<   %label = alloca [64 x i8], align 16
<   %1 = call %struct.MemoryRegion* @iotlb_to_region(i64 %physaddr) nounwind
<   %2 = and i64 %physaddr, 4294963200
<   %3 = zext i32 %addr to i64
<   %4 = add i64 %3, %2
<   %5 = trunc i64 %4 to i32
<   %6 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %7 = icmp eq i32 %6, 0
<   br i1 %7, label %17, label %8
---
> define internal void @addFloatx80Sigs(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, i8 zeroext %zSign, %struct.float_status* %status) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca %struct.float_status*, align 4
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %expDiff = alloca i32, align 4
>   store i8 %zSign, i8* %1, align 1
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %3, i64* %aSig, align 8
>   %4 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %4, i32* %aExp, align 4
>   %5 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   store i64 %5, i64* %bSig, align 8
>   %6 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   store i32 %6, i32* %bExp, align 4
>   %7 = load i32* %aExp, align 4
>   %8 = load i32* %bExp, align 4
>   %9 = sub nsw i32 %7, %8
>   store i32 %9, i32* %expDiff, align 4
>   %10 = load i32* %expDiff, align 4
>   %11 = icmp slt i32 0, %10
>   br i1 %11, label %12, label %34
19355,19359c18000,18003
< ; <label>:8                                       ; preds = %0
<   %9 = and i64 %4, 4294967295
<   %10 = call i32 @s2e_is_mmio_symbolic_q(i64 %9) nounwind
<   %11 = icmp eq i32 %10, 0
<   br i1 %11, label %17, label %12
---
> ; <label>:12                                      ; preds = %0
>   %13 = load i32* %aExp, align 4
>   %14 = icmp eq i32 %13, 32767
>   br i1 %14, label %15, label %24
19361,19367c18005,18014
< ; <label>:12                                      ; preds = %8
<   %13 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 5
<   %16 = load i32* %15, align 4
<   call void @trace_port(i8* %13, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %5, i32 %16)
<   br label %17
---
> ; <label>:15                                      ; preds = %12
>   %16 = load i64* %aSig, align 8
>   %17 = shl i64 %16, 1
>   %18 = icmp ne i64 %17, 0
>   br i1 %18, label %19, label %21
> 
> ; <label>:19                                      ; preds = %15
>   %20 = load %struct.float_status** %2, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %20)
>   br label %108
19369,19387c18016,18020
< ; <label>:17                                      ; preds = %12, %8, %0
<   %isSymb.0 = phi i32 [ %10, %12 ], [ 0, %8 ], [ 0, %0 ]
<   %18 = ptrtoint i8* %retaddr to i64
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 68
<   store i64 %18, i64* %20, align 8
<   %21 = icmp ne %struct.MemoryRegion* %1, @io_mem_ram
<   %22 = icmp ne %struct.MemoryRegion* %1, @io_mem_rom
<   %or.cond = and i1 %21, %22
<   %23 = icmp ne %struct.MemoryRegion* %1, @io_mem_unassigned
<   %or.cond3 = and i1 %or.cond, %23
<   %24 = icmp ne %struct.MemoryRegion* %1, @io_mem_notdirty
<   %or.cond5 = and i1 %or.cond3, %24
<   %25 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not = xor i1 %or.cond5, true
<   %26 = load i32* @use_icount, align 4
<   %27 = icmp eq i32 %26, 0
<   %or.cond39 = or i1 %27, %or.cond5.not
<   br i1 %or.cond39, label %can_do_io.exit.thread, label %28
---
> ; <label>:21                                      ; preds = %15
>   %22 = bitcast %struct.floatx80* %agg.result to i8*
>   %23 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %22, i8* %23, i32 10, i32 1, i1 false)
>   br label %108
19389,19393c18022,18025
< ; <label>:28                                      ; preds = %17
<   %29 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 66
<   %30 = load %struct.TranslationBlock** %29, align 8
<   %31 = icmp eq %struct.TranslationBlock* %30, null
<   br i1 %31, label %can_do_io.exit.thread, label %can_do_io.exit
---
> ; <label>:24                                      ; preds = %12
>   %25 = load i32* %bExp, align 4
>   %26 = icmp eq i32 %25, 0
>   br i1 %26, label %27, label %30
19395,19399c18027,18031
< can_do_io.exit:                                   ; preds = %28
<   %32 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 85
<   %33 = load i32* %32, align 4
<   %34 = icmp eq i32 %33, 0
<   br i1 %34, label %35, label %can_do_io.exit.thread
---
> ; <label>:27                                      ; preds = %24
>   %28 = load i32* %expDiff, align 4
>   %29 = add nsw i32 %28, -1
>   store i32 %29, i32* %expDiff, align 4
>   br label %30
19401,19403c18033,18039
< ; <label>:35                                      ; preds = %can_do_io.exit
<   call void @cpu_io_recompile(%struct.CPUX86State* %25, i8* %retaddr) noreturn nounwind
<   unreachable
---
> ; <label>:30                                      ; preds = %27, %24
>   %31 = load i64* %bSig, align 8
>   %32 = load i32* %expDiff, align 4
>   call void @shift64ExtraRightJamming(i64 %31, i64 0, i32 %32, i64* %bSig, i64* %zSig1)
>   %33 = load i32* %aExp, align 4
>   store i32 %33, i32* %zExp, align 4
>   br label %84
19405,19410c18041,18044
< can_do_io.exit.thread:                            ; preds = %can_do_io.exit, %28, %17
<   %36 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 69
<   store i32 %addr, i32* %36, align 4
<   %37 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %1, i32 0) nounwind
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %87, label %39
---
> ; <label>:34                                      ; preds = %0
>   %35 = load i32* %expDiff, align 4
>   %36 = icmp slt i32 %35, 0
>   br i1 %36, label %37, label %59
19412,19415c18046,18049
< ; <label>:39                                      ; preds = %can_do_io.exit.thread
<   %40 = call i64 @s2e_notdirty_mem_write(i64 %physaddr) nounwind
<   %41 = icmp eq i32 %isSymb.0, 0
<   br i1 %41, label %79, label %42
---
> ; <label>:37                                      ; preds = %34
>   %38 = load i32* %bExp, align 4
>   %39 = icmp eq i32 %38, 32767
>   br i1 %39, label %40, label %48
19417,19430c18051,18065
< ; <label>:42                                      ; preds = %39
<   %43 = getelementptr inbounds [64 x i8]* %label, i64 0, i64 0
<   %44 = inttoptr i64 %40 to i64*
<   %45 = load i64* %44, align 8
<   %46 = getelementptr inbounds %union.anon.12* %data.i29, i64 0, i32 0
<   store i64 %45, i64* %46, align 8
<   %47 = bitcast %union.anon.12* %data.i29 to [8 x i8]*
<   br label %._crit_edge.i31
< 
< ._crit_edge.i31:                                  ; preds = %58, %42
<   %indvars.iv.i30 = phi i64 [ 0, %42 ], [ %indvars.iv.next.i32, %58 ]
<   %48 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %49 = icmp eq i32 %48, 0
<   br i1 %49, label %58, label %50
---
> ; <label>:40                                      ; preds = %37
>   %41 = load i64* %bSig, align 8
>   %42 = shl i64 %41, 1
>   %43 = icmp ne i64 %42, 0
>   br i1 %43, label %44, label %46
> 
> ; <label>:44                                      ; preds = %40
>   %45 = load %struct.float_status** %2, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %45)
>   br label %108
> 
> ; <label>:46                                      ; preds = %40
>   %47 = load i8* %1, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %47, i32 32767, i64 -9223372036854775808)
>   br label %108
19432,19437c18067,18070
< ; <label>:50                                      ; preds = %._crit_edge.i31
<   %51 = add i64 %indvars.iv.i30, %4
<   %52 = and i64 %51, 4294967295
<   %53 = call i32 @s2e_is_mmio_symbolic_b(i64 %52) nounwind
<   %54 = icmp eq i32 %53, 0
<   br i1 %54, label %58, label %55
---
> ; <label>:48                                      ; preds = %37
>   %49 = load i32* %aExp, align 4
>   %50 = icmp eq i32 %49, 0
>   br i1 %50, label %51, label %54
19439,19444c18072,18076
< ; <label>:55                                      ; preds = %50
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i28, i32 1, i8* %43) nounwind
<   %56 = load i8* %ret.i.i28, align 1
<   %57 = getelementptr inbounds [8 x i8]* %47, i64 0, i64 %indvars.iv.i30
<   store i8 %56, i8* %57, align 1
<   br label %58
---
> ; <label>:51                                      ; preds = %48
>   %52 = load i32* %expDiff, align 4
>   %53 = add nsw i32 %52, 1
>   store i32 %53, i32* %expDiff, align 4
>   br label %54
19446,19460c18078,18090
< ; <label>:58                                      ; preds = %55, %50, %._crit_edge.i31
<   %indvars.iv.next.i32 = add i64 %indvars.iv.i30, 1
<   %lftr.wideiv36 = trunc i64 %indvars.iv.next.i32 to i32
<   %exitcond37 = icmp eq i32 %lftr.wideiv36, 8
<   br i1 %exitcond37, label %io_read_chk_symb_q.exit35, label %._crit_edge.i31
< 
< io_read_chk_symb_q.exit35:                        ; preds = %58
<   %59 = load i64* %46, align 8
<   %60 = add i64 %40, 4
<   %61 = inttoptr i64 %60 to i64*
<   %62 = load i64* %61, align 8
<   %63 = getelementptr inbounds %union.anon.12* %data.i, i64 0, i32 0
<   store i64 %62, i64* %63, align 8
<   %64 = bitcast %union.anon.12* %data.i to [8 x i8]*
<   br label %._crit_edge.i
---
> ; <label>:54                                      ; preds = %51, %48
>   %55 = load i64* %aSig, align 8
>   %56 = load i32* %expDiff, align 4
>   %57 = sub nsw i32 0, %56
>   call void @shift64ExtraRightJamming(i64 %55, i64 0, i32 %57, i64* %aSig, i64* %zSig1)
>   %58 = load i32* %bExp, align 4
>   store i32 %58, i32* %zExp, align 4
>   br label %83
> 
> ; <label>:59                                      ; preds = %34
>   %60 = load i32* %aExp, align 4
>   %61 = icmp eq i32 %60, 32767
>   br i1 %61, label %62, label %73
19462,19473c18092,18119
< ._crit_edge.i:                                    ; preds = %75, %io_read_chk_symb_q.exit35
<   %indvars.iv.i = phi i64 [ 0, %io_read_chk_symb_q.exit35 ], [ %indvars.iv.next.i, %75 ]
<   %65 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %66 = icmp eq i32 %65, 0
<   br i1 %66, label %75, label %67
< 
< ; <label>:67                                      ; preds = %._crit_edge.i
<   %68 = add i64 %indvars.iv.i, %4
<   %69 = and i64 %68, 4294967295
<   %70 = call i32 @s2e_is_mmio_symbolic_b(i64 %69) nounwind
<   %71 = icmp eq i32 %70, 0
<   br i1 %71, label %75, label %72
---
> ; <label>:62                                      ; preds = %59
>   %63 = load i64* %aSig, align 8
>   %64 = load i64* %bSig, align 8
>   %65 = or i64 %63, %64
>   %66 = shl i64 %65, 1
>   %67 = icmp ne i64 %66, 0
>   br i1 %67, label %68, label %70
> 
> ; <label>:68                                      ; preds = %62
>   %69 = load %struct.float_status** %2, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %69)
>   br label %108
> 
> ; <label>:70                                      ; preds = %62
>   %71 = bitcast %struct.floatx80* %agg.result to i8*
>   %72 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %71, i8* %72, i32 10, i32 1, i1 false)
>   br label %108
> 
> ; <label>:73                                      ; preds = %59
>   store i64 0, i64* %zSig1, align 8
>   %74 = load i64* %aSig, align 8
>   %75 = load i64* %bSig, align 8
>   %76 = add i64 %74, %75
>   store i64 %76, i64* %zSig0, align 8
>   %77 = load i32* %aExp, align 4
>   %78 = icmp eq i32 %77, 0
>   br i1 %78, label %79, label %81
19475,19480c18121,18171
< ; <label>:72                                      ; preds = %67
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i, i32 1, i8* %43) nounwind
<   %73 = load i8* %ret.i.i, align 1
<   %74 = getelementptr inbounds [8 x i8]* %64, i64 0, i64 %indvars.iv.i
<   store i8 %73, i8* %74, align 1
<   br label %75
---
> ; <label>:79                                      ; preds = %73
>   %80 = load i64* %zSig0, align 8
>   call void @normalizeFloatx80Subnormal(i64 %80, i32* %zExp, i64* %zSig0)
>   br label %99
> 
> ; <label>:81                                      ; preds = %73
>   %82 = load i32* %aExp, align 4
>   store i32 %82, i32* %zExp, align 4
>   br label %92
> 
> ; <label>:83                                      ; preds = %54
>   br label %84
> 
> ; <label>:84                                      ; preds = %83, %30
>   %85 = load i64* %aSig, align 8
>   %86 = load i64* %bSig, align 8
>   %87 = add i64 %85, %86
>   store i64 %87, i64* %zSig0, align 8
>   %88 = load i64* %zSig0, align 8
>   %89 = icmp slt i64 %88, 0
>   br i1 %89, label %90, label %91
> 
> ; <label>:90                                      ; preds = %84
>   br label %99
> 
> ; <label>:91                                      ; preds = %84
>   br label %92
> 
> ; <label>:92                                      ; preds = %91, %81
>   %93 = load i64* %zSig0, align 8
>   %94 = load i64* %zSig1, align 8
>   call void @shift64ExtraRightJamming(i64 %93, i64 %94, i32 1, i64* %zSig0, i64* %zSig1)
>   %95 = load i64* %zSig0, align 8
>   %96 = or i64 %95, -9223372036854775808
>   store i64 %96, i64* %zSig0, align 8
>   %97 = load i32* %zExp, align 4
>   %98 = add nsw i32 %97, 1
>   store i32 %98, i32* %zExp, align 4
>   br label %99
> 
> ; <label>:99                                      ; preds = %92, %90, %79
>   %100 = load %struct.float_status** %2, align 4
>   %101 = getelementptr inbounds %struct.float_status* %100, i32 0, i32 3
>   %102 = load i8* %101, align 1
>   %103 = load i8* %1, align 1
>   %104 = load i32* %zExp, align 4
>   %105 = load i64* %zSig0, align 8
>   %106 = load i64* %zSig1, align 8
>   %107 = load %struct.float_status** %2, align 4
>   call void @roundAndPackFloatx80(%struct.floatx80* sret %agg.result, i8 signext %102, i8 zeroext %103, i32 %104, i64 %105, i64 %106, %struct.float_status* %107)
>   br label %108
19482,19492c18173,18175
< ; <label>:75                                      ; preds = %72, %67, %._crit_edge.i
<   %indvars.iv.next.i = add i64 %indvars.iv.i, 1
<   %lftr.wideiv = trunc i64 %indvars.iv.next.i to i32
<   %exitcond = icmp eq i32 %lftr.wideiv, 8
<   br i1 %exitcond, label %io_read_chk_symb_q.exit, label %._crit_edge.i
< 
< io_read_chk_symb_q.exit:                          ; preds = %75
<   %76 = load i64* %63, align 8
<   %77 = shl i64 %76, 32
<   %78 = or i64 %77, %59
<   br label %89
---
> ; <label>:108                                     ; preds = %99, %70, %68, %46, %44, %21, %19
>   ret void
> }
19494,19502c18177,18205
< ; <label>:79                                      ; preds = %39
<   %80 = inttoptr i64 %40 to i64*
<   %81 = load i64* %80, align 8
<   %82 = add i64 %40, 4
<   %83 = inttoptr i64 %82 to i64*
<   %84 = load i64* %83, align 8
<   %85 = shl i64 %84, 32
<   %86 = or i64 %85, %81
<   br label %89
---
> define internal void @subFloatx80Sigs(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, i8 zeroext %zSign, %struct.float_status* %status) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca %struct.float_status*, align 4
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %expDiff = alloca i32, align 4
>   %z = alloca %struct.floatx80, align 1
>   store i8 %zSign, i8* %1, align 1
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %3, i64* %aSig, align 8
>   %4 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %4, i32* %aExp, align 4
>   %5 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   store i64 %5, i64* %bSig, align 8
>   %6 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   store i32 %6, i32* %bExp, align 4
>   %7 = load i32* %aExp, align 4
>   %8 = load i32* %bExp, align 4
>   %9 = sub nsw i32 %7, %8
>   store i32 %9, i32* %expDiff, align 4
>   %10 = load i32* %expDiff, align 4
>   %11 = icmp slt i32 0, %10
>   br i1 %11, label %12, label %13
19504,19505c18207
< ; <label>:87                                      ; preds = %can_do_io.exit.thread
<   %88 = call i64 @io_readq_mmu(i64 %physaddr, i32 %addr, i8* %retaddr) nounwind
---
> ; <label>:12                                      ; preds = %0
19508,19526c18210,18213
< ; <label>:89                                      ; preds = %87, %79, %io_read_chk_symb_q.exit
<   %.0 = phi i64 [ %88, %87 ], [ %78, %io_read_chk_symb_q.exit ], [ %86, %79 ]
<   ret i64 %.0
< }
< 
< declare i32 @s2e_is_mmio_symbolic_q(i64)
< 
< declare i64 @io_readq_mmu(i64, i32, i8*)
< 
< define i64 @__ldq_mmu(i32 %addr, i32 %mmu_idx) nounwind uwtable {
<   %ret.i.i28.i = alloca i8, align 1
<   %data.i29.i = alloca %union.anon.12, align 8
<   %ret.i.i.i = alloca i8, align 1
<   %data.i.i = alloca %union.anon.12, align 8
<   %label.i = alloca [64 x i8], align 16
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %addr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:13                                      ; preds = %0
>   %14 = load i32* %expDiff, align 4
>   %15 = icmp slt i32 %14, 0
>   br i1 %15, label %16, label %17
19528,19530c18215,18216
< ; <label>:4                                       ; preds = %0
<   %5 = call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:16                                      ; preds = %13
>   br label %56
19532,19547c18218,18221
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = sext i32 %mmu_idx to i64
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %17 = load i32* %16, align 4
<   %18 = and i32 %8, -4096
<   %19 = and i32 %17, -4088
<   %20 = icmp eq i32 %18, %19
<   br i1 %20, label %._crit_edge, label %.lr.ph, !prof !0
---
> ; <label>:17                                      ; preds = %13
>   %18 = load i32* %aExp, align 4
>   %19 = icmp eq i32 %18, 32767
>   br i1 %19, label %20, label %34
19549,19552c18223,18234
< .lr.ph:                                           ; preds = %6
<   %21 = trunc i64 %11 to i32
<   %22 = shl i32 %21, 7
<   br label %129
---
> ; <label>:20                                      ; preds = %17
>   %21 = load i64* %aSig, align 8
>   %22 = load i64* %bSig, align 8
>   %23 = or i64 %21, %22
>   %24 = shl i64 %23, 1
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %20
>   %27 = load %struct.float_status** %2, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %27)
>   br label %124
19554,19559c18236,18246
< ._crit_edge:                                      ; preds = %129, %6
<   %.lcssa28 = phi i32 [ %17, %6 ], [ %133, %129 ]
<   %.lcssa27 = phi %struct.CPUX86State* [ %15, %6 ], [ %131, %129 ]
<   %23 = and i32 %.lcssa28, 4095
<   %24 = icmp eq i32 %23, 0
<   br i1 %24, label %116, label %25, !prof !0
---
> ; <label>:28                                      ; preds = %20
>   %29 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %29)
>   %30 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 -4611686018427387904, i64* %30, align 1
>   %31 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   store i16 -1, i16* %31, align 1
>   %32 = bitcast %struct.floatx80* %agg.result to i8*
>   %33 = bitcast %struct.floatx80* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %32, i8* %33, i32 10, i32 1, i1 false)
>   br label %124
19561,19564c18248,18251
< ; <label>:25                                      ; preds = %._crit_edge
<   %26 = and i32 %8, 7
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %28, label %120
---
> ; <label>:34                                      ; preds = %17
>   %35 = load i32* %aExp, align 4
>   %36 = icmp eq i32 %35, 0
>   br i1 %36, label %37, label %38
19566,19577c18253,18272
< ; <label>:28                                      ; preds = %25
<   %29 = getelementptr inbounds %struct.CPUX86State* %.lcssa27, i64 0, i32 75, i64 %14, i64 %13
<   %30 = load i64* %29, align 8
<   %31 = getelementptr inbounds [64 x i8]* %label.i, i64 0, i64 0
<   %32 = call %struct.MemoryRegion* @iotlb_to_region(i64 %30) nounwind
<   %33 = and i64 %30, 4294963200
<   %34 = and i64 %7, 4294967295
<   %35 = add i64 %33, %34
<   %36 = trunc i64 %35 to i32
<   %37 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %47, label %39
---
> ; <label>:37                                      ; preds = %34
>   store i32 1, i32* %aExp, align 4
>   store i32 1, i32* %bExp, align 4
>   br label %38
> 
> ; <label>:38                                      ; preds = %37, %34
>   store i64 0, i64* %zSig1, align 8
>   %39 = load i64* %bSig, align 8
>   %40 = load i64* %aSig, align 8
>   %41 = icmp ult i64 %39, %40
>   br i1 %41, label %42, label %43
> 
> ; <label>:42                                      ; preds = %38
>   br label %110
> 
> ; <label>:43                                      ; preds = %38
>   %44 = load i64* %aSig, align 8
>   %45 = load i64* %bSig, align 8
>   %46 = icmp ult i64 %44, %45
>   br i1 %46, label %47, label %48
19579,19584c18274,18275
< ; <label>:39                                      ; preds = %28
<   %fold = add i64 %33, %7
<   %40 = and i64 %fold, 4294967295
<   %41 = call i32 @s2e_is_mmio_symbolic_q(i64 %40) nounwind
<   %42 = icmp eq i32 %41, 0
<   br i1 %42, label %47, label %43
---
> ; <label>:47                                      ; preds = %43
>   br label %80
19586,19591c18277,18286
< ; <label>:43                                      ; preds = %39
<   %44 = load %struct.CPUX86State** @env, align 8
<   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 5
<   %46 = load i32* %45, align 4
<   call void @trace_port(i8* %31, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %36, i32 %46) nounwind
<   br label %47
---
> ; <label>:48                                      ; preds = %43
>   %49 = load %struct.float_status** %2, align 4
>   %50 = getelementptr inbounds %struct.float_status* %49, i32 0, i32 1
>   %51 = load i8* %50, align 1
>   %52 = sext i8 %51 to i32
>   %53 = icmp eq i32 %52, 1
>   %54 = zext i1 %53 to i32
>   %55 = trunc i32 %54 to i8
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %55, i32 0, i64 0)
>   br label %124
19593,19610c18288,18297
< ; <label>:47                                      ; preds = %43, %39, %28
<   %isSymb.0.i = phi i32 [ %41, %43 ], [ 0, %39 ], [ 0, %28 ]
<   %48 = load %struct.CPUX86State** @env, align 8
<   %49 = getelementptr inbounds %struct.CPUX86State* %48, i64 0, i32 68
<   store i64 0, i64* %49, align 8
<   %50 = icmp ne %struct.MemoryRegion* %32, @io_mem_ram
<   %51 = icmp ne %struct.MemoryRegion* %32, @io_mem_rom
<   %or.cond.i = and i1 %50, %51
<   %52 = icmp ne %struct.MemoryRegion* %32, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %52
<   %53 = icmp ne %struct.MemoryRegion* %32, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %53
<   %54 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %55 = load i32* @use_icount, align 4
<   %56 = icmp eq i32 %55, 0
<   %or.cond39.i = or i1 %56, %or.cond5.not.i
<   br i1 %or.cond39.i, label %can_do_io.exit.thread.i, label %57
---
> ; <label>:56                                      ; preds = %16
>   %57 = load i32* %bExp, align 4
>   %58 = icmp eq i32 %57, 32767
>   br i1 %58, label %59, label %70
> 
> ; <label>:59                                      ; preds = %56
>   %60 = load i64* %bSig, align 8
>   %61 = shl i64 %60, 1
>   %62 = icmp ne i64 %61, 0
>   br i1 %62, label %63, label %65
19612,19616c18299,18302
< ; <label>:57                                      ; preds = %47
<   %58 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 66
<   %59 = load %struct.TranslationBlock** %58, align 8
<   %60 = icmp eq %struct.TranslationBlock* %59, null
<   br i1 %60, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:63                                      ; preds = %59
>   %64 = load %struct.float_status** %2, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %64)
>   br label %124
19618,19622c18304,18310
< can_do_io.exit.i:                                 ; preds = %57
<   %61 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 85
<   %62 = load i32* %61, align 4
<   %63 = icmp eq i32 %62, 0
<   br i1 %63, label %64, label %can_do_io.exit.thread.i
---
> ; <label>:65                                      ; preds = %59
>   %66 = load i8* %1, align 1
>   %67 = zext i8 %66 to i32
>   %68 = xor i32 %67, 1
>   %69 = trunc i32 %68 to i8
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %69, i32 32767, i64 -9223372036854775808)
>   br label %124
19624,19626c18312,18342
< ; <label>:64                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %54, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:70                                      ; preds = %56
>   %71 = load i32* %aExp, align 4
>   %72 = icmp eq i32 %71, 0
>   br i1 %72, label %73, label %76
> 
> ; <label>:73                                      ; preds = %70
>   %74 = load i32* %expDiff, align 4
>   %75 = add nsw i32 %74, 1
>   store i32 %75, i32* %expDiff, align 4
>   br label %76
> 
> ; <label>:76                                      ; preds = %73, %70
>   %77 = load i64* %aSig, align 8
>   %78 = load i32* %expDiff, align 4
>   %79 = sub nsw i32 0, %78
>   call void @shift128RightJamming(i64 %77, i64 0, i32 %79, i64* %aSig, i64* %zSig1)
>   br label %80
> 
> ; <label>:80                                      ; preds = %76, %47
>   %81 = load i64* %bSig, align 8
>   %82 = load i64* %aSig, align 8
>   %83 = load i64* %zSig1, align 8
>   call void @sub128(i64 %81, i64 0, i64 %82, i64 %83, i64* %zSig0, i64* %zSig1)
>   %84 = load i32* %bExp, align 4
>   store i32 %84, i32* %zExp, align 4
>   %85 = load i8* %1, align 1
>   %86 = zext i8 %85 to i32
>   %87 = xor i32 %86, 1
>   %88 = trunc i32 %87 to i8
>   store i8 %88, i8* %1, align 1
>   br label %115
19628,19633c18344,18358
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %57, %47
<   %65 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 69
<   store i32 %8, i32* %65, align 4
<   %66 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %32, i32 0) nounwind
<   %67 = icmp eq i32 %66, 0
<   br i1 %67, label %113, label %68
---
> ; <label>:89                                      ; preds = %12
>   %90 = load i32* %aExp, align 4
>   %91 = icmp eq i32 %90, 32767
>   br i1 %91, label %92, label %101
> 
> ; <label>:92                                      ; preds = %89
>   %93 = load i64* %aSig, align 8
>   %94 = shl i64 %93, 1
>   %95 = icmp ne i64 %94, 0
>   br i1 %95, label %96, label %98
> 
> ; <label>:96                                      ; preds = %92
>   %97 = load %struct.float_status** %2, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %97)
>   br label %124
19635,19640c18360,18364
< ; <label>:68                                      ; preds = %can_do_io.exit.thread.i
<   %69 = call i64 @s2e_notdirty_mem_write(i64 %30) nounwind
<   %70 = icmp eq i32 %isSymb.0.i, 0
<   %71 = inttoptr i64 %69 to i64*
<   %72 = load i64* %71, align 8
<   br i1 %70, label %107, label %73
---
> ; <label>:98                                      ; preds = %92
>   %99 = bitcast %struct.floatx80* %agg.result to i8*
>   %100 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %99, i8* %100, i32 10, i32 1, i1 false)
>   br label %124
19642,19666c18366,18369
< ; <label>:73                                      ; preds = %68
<   %74 = getelementptr inbounds %union.anon.12* %data.i29.i, i64 0, i32 0
<   store i64 %72, i64* %74, align 8
<   %75 = bitcast %union.anon.12* %data.i29.i to [8 x i8]*
<   br label %._crit_edge.i31.i
< 
< ._crit_edge.i31.i:                                ; preds = %86, %73
<   %indvars.iv.i30.i = phi i64 [ 0, %73 ], [ %indvars.iv.next.i32.i, %86 ]
<   %76 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %77 = icmp eq i32 %76, 0
<   br i1 %77, label %86, label %78
< 
< ; <label>:78                                      ; preds = %._crit_edge.i31.i
<   %79 = add i64 %indvars.iv.i30.i, %35
<   %80 = and i64 %79, 4294967295
<   %81 = call i32 @s2e_is_mmio_symbolic_b(i64 %80) nounwind
<   %82 = icmp eq i32 %81, 0
<   br i1 %82, label %86, label %83
< 
< ; <label>:83                                      ; preds = %78
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i28.i, i32 1, i8* %31) nounwind
<   %84 = load i8* %ret.i.i28.i, align 1
<   %85 = getelementptr inbounds [8 x i8]* %75, i64 0, i64 %indvars.iv.i30.i
<   store i8 %84, i8* %85, align 1
<   br label %86
---
> ; <label>:101                                     ; preds = %89
>   %102 = load i32* %bExp, align 4
>   %103 = icmp eq i32 %102, 0
>   br i1 %103, label %104, label %107
19668,19695c18371,18390
< ; <label>:86                                      ; preds = %83, %78, %._crit_edge.i31.i
<   %indvars.iv.next.i32.i = add i64 %indvars.iv.i30.i, 1
<   %lftr.wideiv31 = trunc i64 %indvars.iv.next.i32.i to i32
<   %exitcond32 = icmp eq i32 %lftr.wideiv31, 8
<   br i1 %exitcond32, label %io_read_chk_symb_q.exit35.i, label %._crit_edge.i31.i
< 
< io_read_chk_symb_q.exit35.i:                      ; preds = %86
<   %87 = load i64* %74, align 8
<   %88 = add i64 %69, 4
<   %89 = inttoptr i64 %88 to i64*
<   %90 = load i64* %89, align 8
<   %91 = getelementptr inbounds %union.anon.12* %data.i.i, i64 0, i32 0
<   store i64 %90, i64* %91, align 8
<   %92 = bitcast %union.anon.12* %data.i.i to [8 x i8]*
<   br label %._crit_edge.i.i
< 
< ._crit_edge.i.i:                                  ; preds = %103, %io_read_chk_symb_q.exit35.i
<   %indvars.iv.i.i = phi i64 [ 0, %io_read_chk_symb_q.exit35.i ], [ %indvars.iv.next.i.i, %103 ]
<   %93 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %94 = icmp eq i32 %93, 0
<   br i1 %94, label %103, label %95
< 
< ; <label>:95                                      ; preds = %._crit_edge.i.i
<   %96 = add i64 %indvars.iv.i.i, %35
<   %97 = and i64 %96, 4294967295
<   %98 = call i32 @s2e_is_mmio_symbolic_b(i64 %97) nounwind
<   %99 = icmp eq i32 %98, 0
<   br i1 %99, label %103, label %100
---
> ; <label>:104                                     ; preds = %101
>   %105 = load i32* %expDiff, align 4
>   %106 = add nsw i32 %105, -1
>   store i32 %106, i32* %expDiff, align 4
>   br label %107
> 
> ; <label>:107                                     ; preds = %104, %101
>   %108 = load i64* %bSig, align 8
>   %109 = load i32* %expDiff, align 4
>   call void @shift128RightJamming(i64 %108, i64 0, i32 %109, i64* %bSig, i64* %zSig1)
>   br label %110
> 
> ; <label>:110                                     ; preds = %107, %42
>   %111 = load i64* %aSig, align 8
>   %112 = load i64* %bSig, align 8
>   %113 = load i64* %zSig1, align 8
>   call void @sub128(i64 %111, i64 0, i64 %112, i64 %113, i64* %zSig0, i64* %zSig1)
>   %114 = load i32* %aExp, align 4
>   store i32 %114, i32* %zExp, align 4
>   br label %115
19697,19702c18392,18402
< ; <label>:100                                     ; preds = %95
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %101 = load i8* %ret.i.i.i, align 1
<   %102 = getelementptr inbounds [8 x i8]* %92, i64 0, i64 %indvars.iv.i.i
<   store i8 %101, i8* %102, align 1
<   br label %103
---
> ; <label>:115                                     ; preds = %110, %80
>   %116 = load %struct.float_status** %2, align 4
>   %117 = getelementptr inbounds %struct.float_status* %116, i32 0, i32 3
>   %118 = load i8* %117, align 1
>   %119 = load i8* %1, align 1
>   %120 = load i32* %zExp, align 4
>   %121 = load i64* %zSig0, align 8
>   %122 = load i64* %zSig1, align 8
>   %123 = load %struct.float_status** %2, align 4
>   call void @normalizeRoundAndPackFloatx80(%struct.floatx80* sret %agg.result, i8 signext %118, i8 zeroext %119, i32 %120, i64 %121, i64 %122, %struct.float_status* %123)
>   br label %124
19704,19732c18404,18406
< ; <label>:103                                     ; preds = %100, %95, %._crit_edge.i.i
<   %indvars.iv.next.i.i = add i64 %indvars.iv.i.i, 1
<   %lftr.wideiv = trunc i64 %indvars.iv.next.i.i to i32
<   %exitcond = icmp eq i32 %lftr.wideiv, 8
<   br i1 %exitcond, label %io_read_chk_symb_q.exit.i, label %._crit_edge.i.i
< 
< io_read_chk_symb_q.exit.i:                        ; preds = %103
<   %104 = load i64* %91, align 8
<   %105 = shl i64 %104, 32
<   %106 = or i64 %105, %87
<   br label %io_read_chkq_mmu.exit
< 
< ; <label>:107                                     ; preds = %68
<   %108 = add i64 %69, 4
<   %109 = inttoptr i64 %108 to i64*
<   %110 = load i64* %109, align 8
<   %111 = shl i64 %110, 32
<   %112 = or i64 %111, %72
<   br label %io_read_chkq_mmu.exit
< 
< ; <label>:113                                     ; preds = %can_do_io.exit.thread.i
<   %114 = call i64 @io_readq_mmu(i64 %30, i32 %8, i8* null) nounwind
<   br label %io_read_chkq_mmu.exit
< 
< io_read_chkq_mmu.exit:                            ; preds = %113, %107, %io_read_chk_symb_q.exit.i
<   %.0.i = phi i64 [ %114, %113 ], [ %106, %io_read_chk_symb_q.exit.i ], [ %112, %107 ]
<   %115 = add i64 %30, %34
<   call void @tcg_llvm_trace_memory_access(i64 %34, i64 %115, i64 %.0.i, i32 64, i8 zeroext 0, i8 zeroext 1) nounwind
<   br label %136
---
> ; <label>:124                                     ; preds = %115, %98, %96, %65, %63, %48, %28, %26
>   ret void
> }
19734,19738c18408,18422
< ; <label>:116                                     ; preds = %._crit_edge
<   %117 = and i32 %8, 127
<   %118 = add i32 %117, 7
<   %119 = icmp ugt i32 %118, 127
<   br i1 %119, label %120, label %122, !prof !1
---
> define internal void @floatx80_sub(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %2, i8* %aSign, align 1
>   %3 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %b)
>   store i8 %3, i8* %bSign, align 1
>   %4 = load i8* %aSign, align 1
>   %5 = zext i8 %4 to i32
>   %6 = load i8* %bSign, align 1
>   %7 = zext i8 %6 to i32
>   %8 = icmp eq i32 %5, %7
>   br i1 %8, label %9, label %12
19740,19742c18424,18428
< ; <label>:120                                     ; preds = %116, %25
<   %121 = call fastcc i64 @slow_ldq_mmu(i32 %8, i32 %mmu_idx)
<   br label %136
---
> ; <label>:9                                       ; preds = %0
>   %10 = load i8* %aSign, align 1
>   %11 = load %struct.float_status** %1, align 4
>   call void @subFloatx80Sigs(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, i8 zeroext %10, %struct.float_status* %11)
>   br label %15
19744,19752c18430,18434
< ; <label>:122                                     ; preds = %116
<   %123 = getelementptr inbounds %struct.CPUX86State* %.lcssa27, i64 0, i32 73, i64 %14, i64 %13, i32 3
<   %124 = load i64* %123, align 8
<   %125 = and i64 %7, 4294967295
<   %126 = add i64 %124, %125
<   %127 = inttoptr i64 %126 to i64*
<   %128 = load i64* %127, align 8
<   call void @tcg_llvm_trace_memory_access(i64 %125, i64 %126, i64 %128, i32 64, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %136
---
> ; <label>:12                                      ; preds = %0
>   %13 = load i8* %aSign, align 1
>   %14 = load %struct.float_status** %1, align 4
>   call void @addFloatx80Sigs(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, i8 zeroext %13, %struct.float_status* %14)
>   br label %15
19754,19766c18436,18437
< ; <label>:129                                     ; preds = %129, %.lr.ph
<   %130 = phi %struct.CPUX86State* [ %15, %.lr.ph ], [ %131, %129 ]
<   call void @tlb_fill(%struct.CPUX86State* %130, i32 %8, i32 %22, i32 0, i32 %mmu_idx, i8* null)
<   %131 = load %struct.CPUX86State** @env, align 8
<   %132 = getelementptr inbounds %struct.CPUX86State* %131, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %133 = load i32* %132, align 4
<   %134 = and i32 %133, -4088
<   %135 = icmp eq i32 %18, %134
<   br i1 %135, label %._crit_edge, label %129, !prof !0
< 
< ; <label>:136                                     ; preds = %122, %120, %io_read_chkq_mmu.exit
<   %res.0 = phi i64 [ %121, %120 ], [ %.0.i, %io_read_chkq_mmu.exit ], [ %128, %122 ]
<   ret i64 %res.0
---
> ; <label>:15                                      ; preds = %12, %9
>   ret void
19769,19804c18440,18475
< define internal fastcc i64 @slow_ldq_mmu(i32 %addr, i32 %mmu_idx) nounwind uwtable {
<   %ret.i.i28.i = alloca i8, align 1
<   %data.i29.i = alloca %union.anon.12, align 8
<   %ret.i.i.i = alloca i8, align 1
<   %data.i.i = alloca %union.anon.12, align 8
<   %label.i = alloca [64 x i8], align 16
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %addr to i64
<   br i1 %2, label %6, label %4
< 
< ; <label>:4                                       ; preds = %0
<   %5 = call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
< 
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = sext i32 %mmu_idx to i64
<   %15 = load %struct.CPUX86State** @env, align 8
<   %16 = getelementptr inbounds %struct.CPUX86State* %15, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %17 = load i32* %16, align 4
<   %18 = and i32 %8, -4096
<   %19 = and i32 %17, -4088
<   %20 = icmp eq i32 %18, %19
<   br i1 %20, label %._crit_edge, label %.lr.ph
< 
< .lr.ph:                                           ; preds = %6
<   %21 = trunc i64 %11 to i32
<   %22 = shl i32 %21, 7
<   br label %140
---
> define internal void @floatx80_mul(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %z = alloca %struct.floatx80, align 1
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %2, i64* %aSig, align 8
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %3, i32* %aExp, align 4
>   %4 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %4, i8* %aSign, align 1
>   %5 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   store i64 %5, i64* %bSig, align 8
>   %6 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   store i32 %6, i32* %bExp, align 4
>   %7 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %b)
>   store i8 %7, i8* %bSign, align 1
>   %8 = load i8* %aSign, align 1
>   %9 = zext i8 %8 to i32
>   %10 = load i8* %bSign, align 1
>   %11 = zext i8 %10 to i32
>   %12 = xor i32 %9, %11
>   %13 = trunc i32 %12 to i8
>   store i8 %13, i8* %zSign, align 1
>   %14 = load i32* %aExp, align 4
>   %15 = icmp eq i32 %14, 32767
>   br i1 %15, label %16, label %38
19806,19811c18477,18492
< ._crit_edge:                                      ; preds = %140, %6
<   %.lcssa2 = phi i32 [ %17, %6 ], [ %144, %140 ]
<   %.lcssa1 = phi %struct.CPUX86State* [ %15, %6 ], [ %142, %140 ]
<   %23 = and i32 %.lcssa2, 4095
<   %24 = icmp eq i32 %23, 0
<   br i1 %24, label %116, label %25
---
> ; <label>:16                                      ; preds = %0
>   %17 = load i64* %aSig, align 8
>   %18 = shl i64 %17, 1
>   %19 = icmp ne i64 %18, 0
>   br i1 %19, label %27, label %20
> 
> ; <label>:20                                      ; preds = %16
>   %21 = load i32* %bExp, align 4
>   %22 = icmp eq i32 %21, 32767
>   br i1 %22, label %23, label %29
> 
> ; <label>:23                                      ; preds = %20
>   %24 = load i64* %bSig, align 8
>   %25 = shl i64 %24, 1
>   %26 = icmp ne i64 %25, 0
>   br i1 %26, label %27, label %29
19813,19816c18494,18505
< ; <label>:25                                      ; preds = %._crit_edge
<   %26 = and i32 %8, 7
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %28, label %120
---
> ; <label>:27                                      ; preds = %23, %16
>   %28 = load %struct.float_status** %1, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %28)
>   br label %105
> 
> ; <label>:29                                      ; preds = %23, %20
>   %30 = load i32* %bExp, align 4
>   %31 = sext i32 %30 to i64
>   %32 = load i64* %bSig, align 8
>   %33 = or i64 %31, %32
>   %34 = icmp eq i64 %33, 0
>   br i1 %34, label %35, label %36
19818,19829c18507,18508
< ; <label>:28                                      ; preds = %25
<   %29 = getelementptr inbounds %struct.CPUX86State* %.lcssa1, i64 0, i32 75, i64 %14, i64 %13
<   %30 = load i64* %29, align 8
<   %31 = getelementptr inbounds [64 x i8]* %label.i, i64 0, i64 0
<   %32 = call %struct.MemoryRegion* @iotlb_to_region(i64 %30) nounwind
<   %33 = and i64 %30, 4294963200
<   %34 = and i64 %7, 4294967295
<   %35 = add i64 %33, %34
<   %36 = trunc i64 %35 to i32
<   %37 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %38 = icmp eq i32 %37, 0
<   br i1 %38, label %47, label %39
---
> ; <label>:35                                      ; preds = %29
>   br label %54
19831,19836c18510,18518
< ; <label>:39                                      ; preds = %28
<   %fold = add i64 %33, %7
<   %40 = and i64 %fold, 4294967295
<   %41 = call i32 @s2e_is_mmio_symbolic_q(i64 %40) nounwind
<   %42 = icmp eq i32 %41, 0
<   br i1 %42, label %47, label %43
---
> ; <label>:36                                      ; preds = %29
>   %37 = load i8* %zSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %37, i32 32767, i64 -9223372036854775808)
>   br label %105
> 
> ; <label>:38                                      ; preds = %0
>   %39 = load i32* %bExp, align 4
>   %40 = icmp eq i32 %39, 32767
>   br i1 %40, label %41, label %62
19838,19843c18520,18524
< ; <label>:43                                      ; preds = %39
<   %44 = load %struct.CPUX86State** @env, align 8
<   %45 = getelementptr inbounds %struct.CPUX86State* %44, i64 0, i32 5
<   %46 = load i32* %45, align 4
<   call void @trace_port(i8* %31, i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i32 %36, i32 %46) nounwind
<   br label %47
---
> ; <label>:41                                      ; preds = %38
>   %42 = load i64* %bSig, align 8
>   %43 = shl i64 %42, 1
>   %44 = icmp ne i64 %43, 0
>   br i1 %44, label %45, label %47
19845,19862c18526,18537
< ; <label>:47                                      ; preds = %43, %39, %28
<   %isSymb.0.i = phi i32 [ %41, %43 ], [ 0, %39 ], [ 0, %28 ]
<   %48 = load %struct.CPUX86State** @env, align 8
<   %49 = getelementptr inbounds %struct.CPUX86State* %48, i64 0, i32 68
<   store i64 0, i64* %49, align 8
<   %50 = icmp ne %struct.MemoryRegion* %32, @io_mem_ram
<   %51 = icmp ne %struct.MemoryRegion* %32, @io_mem_rom
<   %or.cond.i = and i1 %50, %51
<   %52 = icmp ne %struct.MemoryRegion* %32, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %52
<   %53 = icmp ne %struct.MemoryRegion* %32, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %53
<   %54 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %55 = load i32* @use_icount, align 4
<   %56 = icmp eq i32 %55, 0
<   %or.cond39.i = or i1 %56, %or.cond5.not.i
<   br i1 %or.cond39.i, label %can_do_io.exit.thread.i, label %57
---
> ; <label>:45                                      ; preds = %41
>   %46 = load %struct.float_status** %1, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %46)
>   br label %105
> 
> ; <label>:47                                      ; preds = %41
>   %48 = load i32* %aExp, align 4
>   %49 = sext i32 %48 to i64
>   %50 = load i64* %aSig, align 8
>   %51 = or i64 %49, %50
>   %52 = icmp eq i64 %51, 0
>   br i1 %52, label %53, label %60
19864,19868c18539,18540
< ; <label>:57                                      ; preds = %47
<   %58 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 66
<   %59 = load %struct.TranslationBlock** %58, align 8
<   %60 = icmp eq %struct.TranslationBlock* %59, null
<   br i1 %60, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:53                                      ; preds = %47
>   br label %54
19870,19874c18542,18557
< can_do_io.exit.i:                                 ; preds = %57
<   %61 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 85
<   %62 = load i32* %61, align 4
<   %63 = icmp eq i32 %62, 0
<   br i1 %63, label %64, label %can_do_io.exit.thread.i
---
> ; <label>:54                                      ; preds = %53, %35
>   %55 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %55)
>   %56 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 -4611686018427387904, i64* %56, align 1
>   %57 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   store i16 -1, i16* %57, align 1
>   %58 = bitcast %struct.floatx80* %agg.result to i8*
>   %59 = bitcast %struct.floatx80* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %58, i8* %59, i32 10, i32 1, i1 false)
>   br label %105
> 
> ; <label>:60                                      ; preds = %47
>   %61 = load i8* %zSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %61, i32 32767, i64 -9223372036854775808)
>   br label %105
19876,19878c18559,18562
< ; <label>:64                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %54, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:62                                      ; preds = %38
>   %63 = load i32* %aExp, align 4
>   %64 = icmp eq i32 %63, 0
>   br i1 %64, label %65, label %72
19880,19885c18564,18567
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %57, %47
<   %65 = getelementptr inbounds %struct.CPUX86State* %54, i64 0, i32 69
<   store i32 %8, i32* %65, align 4
<   %66 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %32, i32 0) nounwind
<   %67 = icmp eq i32 %66, 0
<   br i1 %67, label %113, label %68
---
> ; <label>:65                                      ; preds = %62
>   %66 = load i64* %aSig, align 8
>   %67 = icmp eq i64 %66, 0
>   br i1 %67, label %68, label %70
19887,19892c18569,18577
< ; <label>:68                                      ; preds = %can_do_io.exit.thread.i
<   %69 = call i64 @s2e_notdirty_mem_write(i64 %30) nounwind
<   %70 = icmp eq i32 %isSymb.0.i, 0
<   %71 = inttoptr i64 %69 to i64*
<   %72 = load i64* %71, align 8
<   br i1 %70, label %107, label %73
---
> ; <label>:68                                      ; preds = %65
>   %69 = load i8* %zSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %69, i32 0, i64 0)
>   br label %105
> 
> ; <label>:70                                      ; preds = %65
>   %71 = load i64* %aSig, align 8
>   call void @normalizeFloatx80Subnormal(i64 %71, i32* %aExp, i64* %aSig)
>   br label %72
19894,19918c18579,18582
< ; <label>:73                                      ; preds = %68
<   %74 = getelementptr inbounds %union.anon.12* %data.i29.i, i64 0, i32 0
<   store i64 %72, i64* %74, align 8
<   %75 = bitcast %union.anon.12* %data.i29.i to [8 x i8]*
<   br label %._crit_edge.i31.i
< 
< ._crit_edge.i31.i:                                ; preds = %86, %73
<   %indvars.iv.i30.i = phi i64 [ 0, %73 ], [ %indvars.iv.next.i32.i, %86 ]
<   %76 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %77 = icmp eq i32 %76, 0
<   br i1 %77, label %86, label %78
< 
< ; <label>:78                                      ; preds = %._crit_edge.i31.i
<   %79 = add i64 %indvars.iv.i30.i, %35
<   %80 = and i64 %79, 4294967295
<   %81 = call i32 @s2e_is_mmio_symbolic_b(i64 %80) nounwind
<   %82 = icmp eq i32 %81, 0
<   br i1 %82, label %86, label %83
< 
< ; <label>:83                                      ; preds = %78
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i28.i, i32 1, i8* %31) nounwind
<   %84 = load i8* %ret.i.i28.i, align 1
<   %85 = getelementptr inbounds [8 x i8]* %75, i64 0, i64 %indvars.iv.i30.i
<   store i8 %84, i8* %85, align 1
<   br label %86
---
> ; <label>:72                                      ; preds = %70, %62
>   %73 = load i32* %bExp, align 4
>   %74 = icmp eq i32 %73, 0
>   br i1 %74, label %75, label %82
19920,19947c18584,18587
< ; <label>:86                                      ; preds = %83, %78, %._crit_edge.i31.i
<   %indvars.iv.next.i32.i = add i64 %indvars.iv.i30.i, 1
<   %lftr.wideiv5 = trunc i64 %indvars.iv.next.i32.i to i32
<   %exitcond6 = icmp eq i32 %lftr.wideiv5, 8
<   br i1 %exitcond6, label %io_read_chk_symb_q.exit35.i, label %._crit_edge.i31.i
< 
< io_read_chk_symb_q.exit35.i:                      ; preds = %86
<   %87 = load i64* %74, align 8
<   %88 = add i64 %69, 4
<   %89 = inttoptr i64 %88 to i64*
<   %90 = load i64* %89, align 8
<   %91 = getelementptr inbounds %union.anon.12* %data.i.i, i64 0, i32 0
<   store i64 %90, i64* %91, align 8
<   %92 = bitcast %union.anon.12* %data.i.i to [8 x i8]*
<   br label %._crit_edge.i.i
< 
< ._crit_edge.i.i:                                  ; preds = %103, %io_read_chk_symb_q.exit35.i
<   %indvars.iv.i.i = phi i64 [ 0, %io_read_chk_symb_q.exit35.i ], [ %indvars.iv.next.i.i, %103 ]
<   %93 = load i32* @g_s2e_enable_mmio_checks, align 4
<   %94 = icmp eq i32 %93, 0
<   br i1 %94, label %103, label %95
< 
< ; <label>:95                                      ; preds = %._crit_edge.i.i
<   %96 = add i64 %indvars.iv.i.i, %35
<   %97 = and i64 %96, 4294967295
<   %98 = call i32 @s2e_is_mmio_symbolic_b(i64 %97) nounwind
<   %99 = icmp eq i32 %98, 0
<   br i1 %99, label %103, label %100
---
> ; <label>:75                                      ; preds = %72
>   %76 = load i64* %bSig, align 8
>   %77 = icmp eq i64 %76, 0
>   br i1 %77, label %78, label %80
19949,19954c18589,18592
< ; <label>:100                                     ; preds = %95
<   call void @tcg_llvm_make_symbolic(i8* %ret.i.i.i, i32 1, i8* %31) nounwind
<   %101 = load i8* %ret.i.i.i, align 1
<   %102 = getelementptr inbounds [8 x i8]* %92, i64 0, i64 %indvars.iv.i.i
<   store i8 %101, i8* %102, align 1
<   br label %103
---
> ; <label>:78                                      ; preds = %75
>   %79 = load i8* %zSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %79, i32 0, i64 0)
>   br label %105
19956,19984c18594,18597
< ; <label>:103                                     ; preds = %100, %95, %._crit_edge.i.i
<   %indvars.iv.next.i.i = add i64 %indvars.iv.i.i, 1
<   %lftr.wideiv = trunc i64 %indvars.iv.next.i.i to i32
<   %exitcond = icmp eq i32 %lftr.wideiv, 8
<   br i1 %exitcond, label %io_read_chk_symb_q.exit.i, label %._crit_edge.i.i
< 
< io_read_chk_symb_q.exit.i:                        ; preds = %103
<   %104 = load i64* %91, align 8
<   %105 = shl i64 %104, 32
<   %106 = or i64 %105, %87
<   br label %io_read_chkq_mmu.exit
< 
< ; <label>:107                                     ; preds = %68
<   %108 = add i64 %69, 4
<   %109 = inttoptr i64 %108 to i64*
<   %110 = load i64* %109, align 8
<   %111 = shl i64 %110, 32
<   %112 = or i64 %111, %72
<   br label %io_read_chkq_mmu.exit
< 
< ; <label>:113                                     ; preds = %can_do_io.exit.thread.i
<   %114 = call i64 @io_readq_mmu(i64 %30, i32 %8, i8* null) nounwind
<   br label %io_read_chkq_mmu.exit
< 
< io_read_chkq_mmu.exit:                            ; preds = %113, %107, %io_read_chk_symb_q.exit.i
<   %.0.i = phi i64 [ %114, %113 ], [ %106, %io_read_chk_symb_q.exit.i ], [ %112, %107 ]
<   %115 = add i64 %30, %34
<   call void @tcg_llvm_trace_memory_access(i64 %34, i64 %115, i64 %.0.i, i32 64, i8 zeroext 0, i8 zeroext 1) nounwind
<   br label %147
---
> ; <label>:80                                      ; preds = %75
>   %81 = load i64* %bSig, align 8
>   call void @normalizeFloatx80Subnormal(i64 %81, i32* %bExp, i64* %bSig)
>   br label %82
19986,20005c18599,18610
< ; <label>:116                                     ; preds = %._crit_edge
<   %117 = and i32 %8, 127
<   %118 = add i32 %117, 7
<   %119 = icmp ugt i32 %118, 127
<   br i1 %119, label %120, label %133
< 
< ; <label>:120                                     ; preds = %116, %25
<   %121 = and i32 %8, -8
<   %122 = add i32 %121, 8
<   %123 = call fastcc i64 @slow_ldq_mmu(i32 %121, i32 %mmu_idx)
<   %124 = call fastcc i64 @slow_ldq_mmu(i32 %122, i32 %mmu_idx)
<   %125 = shl i32 %8, 3
<   %126 = and i32 %125, 56
<   %127 = zext i32 %126 to i64
<   %128 = lshr i64 %123, %127
<   %129 = sub i32 64, %126
<   %130 = zext i32 %129 to i64
<   %131 = shl i64 %124, %130
<   %132 = or i64 %131, %128
<   br label %147
---
> ; <label>:82                                      ; preds = %80, %72
>   %83 = load i32* %aExp, align 4
>   %84 = load i32* %bExp, align 4
>   %85 = add nsw i32 %83, %84
>   %86 = sub nsw i32 %85, 16382
>   store i32 %86, i32* %zExp, align 4
>   %87 = load i64* %aSig, align 8
>   %88 = load i64* %bSig, align 8
>   call void @mul64To128(i64 %87, i64 %88, i64* %zSig0, i64* %zSig1)
>   %89 = load i64* %zSig0, align 8
>   %90 = icmp slt i64 0, %89
>   br i1 %90, label %91, label %96
20007,20015c18612,18631
< ; <label>:133                                     ; preds = %116
<   %134 = getelementptr inbounds %struct.CPUX86State* %.lcssa1, i64 0, i32 73, i64 %14, i64 %13, i32 3
<   %135 = load i64* %134, align 8
<   %136 = and i64 %7, 4294967295
<   %137 = add i64 %135, %136
<   %138 = inttoptr i64 %137 to i64*
<   %139 = load i64* %138, align 8
<   call void @tcg_llvm_trace_memory_access(i64 %136, i64 %137, i64 %139, i32 64, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %147
---
> ; <label>:91                                      ; preds = %82
>   %92 = load i64* %zSig0, align 8
>   %93 = load i64* %zSig1, align 8
>   call void @shortShift128Left(i64 %92, i64 %93, i32 1, i64* %zSig0, i64* %zSig1)
>   %94 = load i32* %zExp, align 4
>   %95 = add nsw i32 %94, -1
>   store i32 %95, i32* %zExp, align 4
>   br label %96
> 
> ; <label>:96                                      ; preds = %91, %82
>   %97 = load %struct.float_status** %1, align 4
>   %98 = getelementptr inbounds %struct.float_status* %97, i32 0, i32 3
>   %99 = load i8* %98, align 1
>   %100 = load i8* %zSign, align 1
>   %101 = load i32* %zExp, align 4
>   %102 = load i64* %zSig0, align 8
>   %103 = load i64* %zSig1, align 8
>   %104 = load %struct.float_status** %1, align 4
>   call void @roundAndPackFloatx80(%struct.floatx80* sret %agg.result, i8 signext %99, i8 zeroext %100, i32 %101, i64 %102, i64 %103, %struct.float_status* %104)
>   br label %105
20017,20029c18633,18634
< ; <label>:140                                     ; preds = %140, %.lr.ph
<   %141 = phi %struct.CPUX86State* [ %15, %.lr.ph ], [ %142, %140 ]
<   call void @tlb_fill(%struct.CPUX86State* %141, i32 %8, i32 %22, i32 0, i32 %mmu_idx, i8* null)
<   %142 = load %struct.CPUX86State** @env, align 8
<   %143 = getelementptr inbounds %struct.CPUX86State* %142, i64 0, i32 73, i64 %14, i64 %13, i32 0
<   %144 = load i32* %143, align 4
<   %145 = and i32 %144, -4088
<   %146 = icmp eq i32 %18, %145
<   br i1 %146, label %._crit_edge, label %140
< 
< ; <label>:147                                     ; preds = %133, %120, %io_read_chkq_mmu.exit
<   %res.0 = phi i64 [ %132, %120 ], [ %.0.i, %io_read_chkq_mmu.exit ], [ %139, %133 ]
<   ret i64 %res.0
---
> ; <label>:105                                     ; preds = %96, %78, %68, %60, %54, %45, %36, %27
>   ret void
20032c18637
< define void @io_write_chkq_mmu(i64 %physaddr, i64 %val, i32 %addr, i8* %retaddr) nounwind uwtable inlinehint alwaysinline {
---
> define internal void @normalizeFloatx80Subnormal(i64 %aSig, i32* %zExpPtr, i64* %zSigPtr) nounwind {
20034,20069c18639,18661
<   %2 = alloca i32, align 4
<   store i64 %val, i64* %1, align 8
<   store i32 %addr, i32* %2, align 4
<   %3 = call %struct.MemoryRegion* @iotlb_to_region(i64 %physaddr) nounwind
<   %4 = and i64 %physaddr, -4096
<   %5 = zext i32 %addr to i64
<   %6 = add i64 %5, %4
<   %7 = icmp ne %struct.MemoryRegion* %3, @io_mem_ram
<   %8 = icmp ne %struct.MemoryRegion* %3, @io_mem_rom
<   %or.cond = and i1 %7, %8
<   %9 = icmp ne %struct.MemoryRegion* %3, @io_mem_unassigned
<   %or.cond3 = and i1 %or.cond, %9
<   %10 = icmp ne %struct.MemoryRegion* %3, @io_mem_notdirty
<   %or.cond5 = and i1 %or.cond3, %10
<   %11 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not = xor i1 %or.cond5, true
<   %12 = load i32* @use_icount, align 4
<   %13 = icmp eq i32 %12, 0
<   %or.cond18 = or i1 %13, %or.cond5.not
<   br i1 %or.cond18, label %can_do_io.exit.thread, label %14
< 
< ; <label>:14                                      ; preds = %0
<   %15 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 66
<   %16 = load %struct.TranslationBlock** %15, align 8
<   %17 = icmp eq %struct.TranslationBlock* %16, null
<   br i1 %17, label %can_do_io.exit.thread, label %can_do_io.exit
< 
< can_do_io.exit:                                   ; preds = %14
<   %18 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 85
<   %19 = load i32* %18, align 4
<   %20 = icmp eq i32 %19, 0
<   br i1 %20, label %21, label %can_do_io.exit.thread
< 
< ; <label>:21                                      ; preds = %can_do_io.exit
<   call void @cpu_io_recompile(%struct.CPUX86State* %11, i8* %retaddr) noreturn nounwind
<   unreachable
---
>   %2 = alloca i32*, align 4
>   %3 = alloca i64*, align 4
>   %shiftCount = alloca i8, align 1
>   store i64 %aSig, i64* %1, align 8
>   store i32* %zExpPtr, i32** %2, align 4
>   store i64* %zSigPtr, i64** %3, align 4
>   %4 = load i64* %1, align 8
>   %5 = call signext i8 @countLeadingZeros64(i64 %4)
>   store i8 %5, i8* %shiftCount, align 1
>   %6 = load i64* %1, align 8
>   %7 = load i8* %shiftCount, align 1
>   %8 = sext i8 %7 to i32
>   %9 = zext i32 %8 to i64
>   %10 = shl i64 %6, %9
>   %11 = load i64** %3, align 4
>   store i64 %10, i64* %11, align 4
>   %12 = load i8* %shiftCount, align 1
>   %13 = sext i8 %12 to i32
>   %14 = sub nsw i32 1, %13
>   %15 = load i32** %2, align 4
>   store i32 %14, i32* %15, align 4
>   ret void
> }
20071,20080c18663,18696
< can_do_io.exit.thread:                            ; preds = %can_do_io.exit, %14, %0
<   %22 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 69
<   store i32 %addr, i32* %22, align 4
<   %23 = ptrtoint i8* %retaddr to i64
<   %24 = load %struct.CPUX86State** @env, align 8
<   %25 = getelementptr inbounds %struct.CPUX86State* %24, i64 0, i32 68
<   store i64 %23, i64* %25, align 8
<   %26 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %3, i32 1) nounwind
<   %27 = icmp eq i32 %26, 0
<   br i1 %27, label %38, label %28
---
> define internal void @roundAndPackFloatx80(%struct.floatx80* noalias sret %agg.result, i8 signext %roundingPrecision, i8 zeroext %zSign, i32 %zExp, i64 %zSig0, i64 %zSig1, %struct.float_status* %status) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca i8, align 1
>   %3 = alloca i32, align 4
>   %4 = alloca i64, align 8
>   %5 = alloca i64, align 8
>   %6 = alloca %struct.float_status*, align 4
>   %roundingMode = alloca i8, align 1
>   %roundNearestEven = alloca i8, align 1
>   %increment = alloca i8, align 1
>   %isTiny = alloca i8, align 1
>   %roundIncrement = alloca i64, align 8
>   %roundMask = alloca i64, align 8
>   %roundBits = alloca i64, align 8
>   store i8 %roundingPrecision, i8* %1, align 1
>   store i8 %zSign, i8* %2, align 1
>   store i32 %zExp, i32* %3, align 4
>   store i64 %zSig0, i64* %4, align 8
>   store i64 %zSig1, i64* %5, align 8
>   store %struct.float_status* %status, %struct.float_status** %6, align 4
>   %7 = load %struct.float_status** %6, align 4
>   %8 = getelementptr inbounds %struct.float_status* %7, i32 0, i32 1
>   %9 = load i8* %8, align 1
>   store i8 %9, i8* %roundingMode, align 1
>   %10 = load i8* %roundingMode, align 1
>   %11 = sext i8 %10 to i32
>   %12 = icmp eq i32 %11, 0
>   %13 = zext i1 %12 to i32
>   %14 = trunc i32 %13 to i8
>   store i8 %14, i8* %roundNearestEven, align 1
>   %15 = load i8* %1, align 1
>   %16 = sext i8 %15 to i32
>   %17 = icmp eq i32 %16, 80
>   br i1 %17, label %18, label %19
20082,20094c18698,18699
< ; <label>:28                                      ; preds = %can_do_io.exit.thread
<   %29 = call i64 @s2e_notdirty_mem_write(i64 %6) nounwind
<   %30 = load i64* %1, align 8
<   %31 = trunc i64 %30 to i32
<   %32 = inttoptr i64 %29 to i32*
<   store i32 %31, i32* %32, align 4
<   %33 = add i64 %29, 4
<   %34 = load i64* %1, align 8
<   %35 = lshr i64 %34, 32
<   %36 = trunc i64 %35 to i32
<   %37 = inttoptr i64 %33 to i32*
<   store i32 %36, i32* %37, align 4
<   br label %51
---
> ; <label>:18                                      ; preds = %0
>   br label %215
20096,20099c18701,18710
< ; <label>:38                                      ; preds = %can_do_io.exit.thread
<   %39 = load i32* @g_s2e_concretize_io_writes, align 4
<   %40 = icmp eq i32 %39, 0
<   br i1 %40, label %43, label %41
---
> ; <label>:19                                      ; preds = %0
>   %20 = load i8* %1, align 1
>   %21 = sext i8 %20 to i32
>   %22 = icmp eq i32 %21, 64
>   br i1 %22, label %23, label %24
> 
> ; <label>:23                                      ; preds = %19
>   store i64 1024, i64* %roundIncrement, align 8
>   store i64 2047, i64* %roundMask, align 8
>   br label %31
20101,20104c18712,18721
< ; <label>:41                                      ; preds = %38
<   %42 = bitcast i64* %1 to i8*
<   call void @tcg_llvm_get_value(i8* %42, i32 8, i1 zeroext true) nounwind
<   br label %43
---
> ; <label>:24                                      ; preds = %19
>   %25 = load i8* %1, align 1
>   %26 = sext i8 %25 to i32
>   %27 = icmp eq i32 %26, 32
>   br i1 %27, label %28, label %29
> 
> ; <label>:28                                      ; preds = %24
>   store i64 549755813888, i64* %roundIncrement, align 8
>   store i64 1099511627775, i64* %roundMask, align 8
>   br label %30
20106,20109c18723,18724
< ; <label>:43                                      ; preds = %41, %38
<   %44 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %45 = icmp eq i32 %44, 0
<   br i1 %45, label %48, label %46
---
> ; <label>:29                                      ; preds = %24
>   br label %215
20111,20114c18726,18727
< ; <label>:46                                      ; preds = %43
<   %47 = bitcast i32* %2 to i8*
<   call void @tcg_llvm_get_value(i8* %47, i32 4, i1 zeroext true) nounwind
<   br label %48
---
> ; <label>:30                                      ; preds = %28
>   br label %31
20116,20120c18729,18745
< ; <label>:48                                      ; preds = %46, %43
<   %49 = load i64* %1, align 8
<   %50 = load i32* %2, align 4
<   call void @io_writeq_mmu(i64 %physaddr, i64 %49, i32 %50, i8* %retaddr) nounwind
<   br label %51
---
> ; <label>:31                                      ; preds = %30, %23
>   %32 = load i64* %5, align 8
>   %33 = icmp ne i64 %32, 0
>   %34 = zext i1 %33 to i32
>   %35 = sext i32 %34 to i64
>   %36 = load i64* %4, align 8
>   %37 = or i64 %36, %35
>   store i64 %37, i64* %4, align 8
>   %38 = load i8* %roundNearestEven, align 1
>   %39 = icmp ne i8 %38, 0
>   br i1 %39, label %63, label %40
> 
> ; <label>:40                                      ; preds = %31
>   %41 = load i8* %roundingMode, align 1
>   %42 = sext i8 %41 to i32
>   %43 = icmp eq i32 %42, 3
>   br i1 %43, label %44, label %45
20122,20124c18747,18762
< ; <label>:51                                      ; preds = %48, %28
<   ret void
< }
---
> ; <label>:44                                      ; preds = %40
>   store i64 0, i64* %roundIncrement, align 8
>   br label %62
> 
> ; <label>:45                                      ; preds = %40
>   %46 = load i64* %roundMask, align 8
>   store i64 %46, i64* %roundIncrement, align 8
>   %47 = load i8* %2, align 1
>   %48 = icmp ne i8 %47, 0
>   br i1 %48, label %49, label %55
> 
> ; <label>:49                                      ; preds = %45
>   %50 = load i8* %roundingMode, align 1
>   %51 = sext i8 %50 to i32
>   %52 = icmp eq i32 %51, 2
>   br i1 %52, label %53, label %54
20126c18764,18766
< declare void @io_writeq_mmu(i64, i64, i32, i8*)
---
> ; <label>:53                                      ; preds = %49
>   store i64 0, i64* %roundIncrement, align 8
>   br label %54
20128,20136c18768,18769
< define void @__stq_mmu(i32 %addr, i64 %val, i32 %mmu_idx) nounwind uwtable {
<   %1 = alloca i64, align 8
<   %2 = alloca i32, align 4
<   %3 = alloca i64, align 8
<   %4 = alloca i32, align 4
<   %5 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %6 = icmp eq i32 %5, 0
<   %7 = zext i32 %addr to i64
<   br i1 %6, label %10, label %8
---
> ; <label>:54                                      ; preds = %53, %49
>   br label %61
20138,20140c18771,18775
< ; <label>:8                                       ; preds = %0
<   %9 = call i64 @tcg_llvm_fork_and_concretize(i64 %7, i64 0, i64 4294967295) nounwind
<   br label %10
---
> ; <label>:55                                      ; preds = %45
>   %56 = load i8* %roundingMode, align 1
>   %57 = sext i8 %56 to i32
>   %58 = icmp eq i32 %57, 1
>   br i1 %58, label %59, label %60
20142,20169c18777,18779
< ; <label>:10                                      ; preds = %8, %0
<   %11 = phi i64 [ %9, %8 ], [ %7, %0 ]
<   %12 = trunc i64 %11 to i32
<   %13 = lshr i64 %11, 7
<   %14 = and i64 %13, 33554431
<   %15 = call i64 @tcg_llvm_fork_and_concretize(i64 %14, i64 0, i64 33554431) nounwind
<   %16 = lshr i64 %15, 5
<   %17 = and i64 %16, 255
<   %18 = sext i32 %mmu_idx to i64
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 73, i64 %18, i64 %17, i32 1
<   %21 = load i32* %20, align 4
<   %22 = and i32 %12, -4096
<   %23 = and i32 %21, -4088
<   %24 = icmp eq i32 %22, %23
<   br i1 %24, label %._crit_edge, label %.lr.ph, !prof !0
< 
< .lr.ph:                                           ; preds = %10
<   %25 = trunc i64 %15 to i32
<   %26 = shl i32 %25, 7
<   br label %210
< 
< ._crit_edge:                                      ; preds = %210, %10
<   %.lcssa33 = phi i32 [ %21, %10 ], [ %214, %210 ]
<   %.lcssa32 = phi %struct.CPUX86State* [ %19, %10 ], [ %212, %210 ]
<   %27 = and i32 %.lcssa33, 4095
<   %28 = icmp eq i32 %27, 0
<   br i1 %28, label %83, label %29, !prof !0
---
> ; <label>:59                                      ; preds = %55
>   store i64 0, i64* %roundIncrement, align 8
>   br label %60
20171,20174c18781,18782
< ; <label>:29                                      ; preds = %._crit_edge
<   %30 = and i32 %12, 7
<   %31 = icmp eq i32 %30, 0
<   br i1 %31, label %32, label %87
---
> ; <label>:60                                      ; preds = %59, %55
>   br label %61
20176,20199c18784,18785
< ; <label>:32                                      ; preds = %29
<   %33 = getelementptr inbounds %struct.CPUX86State* %.lcssa32, i64 0, i32 75, i64 %18, i64 %17
<   %34 = load i64* %33, align 8
<   %35 = bitcast i64* %3 to i8*
<   %36 = bitcast i32* %4 to i8*
<   store i64 %val, i64* %3, align 8
<   store i32 %12, i32* %4, align 4
<   %37 = call %struct.MemoryRegion* @iotlb_to_region(i64 %34) nounwind
<   %38 = and i64 %34, -4096
<   %39 = and i64 %11, 4294967295
<   %40 = add i64 %38, %39
<   %41 = icmp ne %struct.MemoryRegion* %37, @io_mem_ram
<   %42 = icmp ne %struct.MemoryRegion* %37, @io_mem_rom
<   %or.cond.i = and i1 %41, %42
<   %43 = icmp ne %struct.MemoryRegion* %37, @io_mem_unassigned
<   %or.cond3.i = and i1 %or.cond.i, %43
<   %44 = icmp ne %struct.MemoryRegion* %37, @io_mem_notdirty
<   %or.cond5.i = and i1 %or.cond3.i, %44
<   %45 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i = xor i1 %or.cond5.i, true
<   %46 = load i32* @use_icount, align 4
<   %47 = icmp eq i32 %46, 0
<   %or.cond18.i = or i1 %47, %or.cond5.not.i
<   br i1 %or.cond18.i, label %can_do_io.exit.thread.i, label %48
---
> ; <label>:61                                      ; preds = %60, %54
>   br label %62
20201,20205c18787,18788
< ; <label>:48                                      ; preds = %32
<   %49 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 66
<   %50 = load %struct.TranslationBlock** %49, align 8
<   %51 = icmp eq %struct.TranslationBlock* %50, null
<   br i1 %51, label %can_do_io.exit.thread.i, label %can_do_io.exit.i
---
> ; <label>:62                                      ; preds = %61, %44
>   br label %63
20207,20211c18790,18803
< can_do_io.exit.i:                                 ; preds = %48
<   %52 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 85
<   %53 = load i32* %52, align 4
<   %54 = icmp eq i32 %53, 0
<   br i1 %54, label %55, label %can_do_io.exit.thread.i
---
> ; <label>:63                                      ; preds = %62, %31
>   %64 = load i64* %4, align 8
>   %65 = load i64* %roundMask, align 8
>   %66 = and i64 %64, %65
>   store i64 %66, i64* %roundBits, align 8
>   %67 = load i32* %3, align 4
>   %68 = sub nsw i32 %67, 1
>   %69 = icmp ule i32 32765, %68
>   br i1 %69, label %70, label %168
> 
> ; <label>:70                                      ; preds = %63
>   %71 = load i32* %3, align 4
>   %72 = icmp slt i32 32766, %71
>   br i1 %72, label %82, label %73
20213,20215c18805,18808
< ; <label>:55                                      ; preds = %can_do_io.exit.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %45, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:73                                      ; preds = %70
>   %74 = load i32* %3, align 4
>   %75 = icmp eq i32 %74, 32766
>   br i1 %75, label %76, label %83
20217,20225c18810,18831
< can_do_io.exit.thread.i:                          ; preds = %can_do_io.exit.i, %48, %32
<   %56 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 69
<   store i32 %12, i32* %56, align 4
<   %57 = load %struct.CPUX86State** @env, align 8
<   %58 = getelementptr inbounds %struct.CPUX86State* %57, i64 0, i32 68
<   store i64 0, i64* %58, align 8
<   %59 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %37, i32 1) nounwind
<   %60 = icmp eq i32 %59, 0
<   br i1 %60, label %71, label %61
---
> ; <label>:76                                      ; preds = %73
>   %77 = load i64* %4, align 8
>   %78 = load i64* %roundIncrement, align 8
>   %79 = add i64 %77, %78
>   %80 = load i64* %4, align 8
>   %81 = icmp ult i64 %79, %80
>   br i1 %81, label %82, label %83
> 
> ; <label>:82                                      ; preds = %76, %70
>   br label %272
> 
> ; <label>:83                                      ; preds = %76, %73
>   %84 = load i32* %3, align 4
>   %85 = icmp sle i32 %84, 0
>   br i1 %85, label %86, label %167
> 
> ; <label>:86                                      ; preds = %83
>   %87 = load %struct.float_status** %6, align 4
>   %88 = getelementptr inbounds %struct.float_status* %87, i32 0, i32 4
>   %89 = load i8* %88, align 1
>   %90 = icmp ne i8 %89, 0
>   br i1 %90, label %91, label %94
20227,20244c18833,18859
< ; <label>:61                                      ; preds = %can_do_io.exit.thread.i
<   %62 = call i64 @s2e_notdirty_mem_write(i64 %40) nounwind
<   %63 = load i64* %3, align 8
<   %64 = trunc i64 %63 to i32
<   %65 = inttoptr i64 %62 to i32*
<   store i32 %64, i32* %65, align 4
<   %66 = add i64 %62, 4
<   %67 = load i64* %3, align 8
<   %68 = lshr i64 %67, 32
<   %69 = trunc i64 %68 to i32
<   %70 = inttoptr i64 %66 to i32*
<   store i32 %69, i32* %70, align 4
<   br label %io_write_chkq_mmu.exit
< 
< ; <label>:71                                      ; preds = %can_do_io.exit.thread.i
<   %72 = load i32* @g_s2e_concretize_io_writes, align 4
<   %73 = icmp eq i32 %72, 0
<   br i1 %73, label %75, label %74
---
> ; <label>:91                                      ; preds = %86
>   %92 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext -128, %struct.float_status* %92)
>   %93 = load i8* %2, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %93, i32 0, i64 0)
>   br label %445
> 
> ; <label>:94                                      ; preds = %86
>   %95 = load %struct.float_status** %6, align 4
>   %96 = getelementptr inbounds %struct.float_status* %95, i32 0, i32 0
>   %97 = load i8* %96, align 1
>   %98 = sext i8 %97 to i32
>   %99 = icmp eq i32 %98, 1
>   br i1 %99, label %109, label %100
> 
> ; <label>:100                                     ; preds = %94
>   %101 = load i32* %3, align 4
>   %102 = icmp slt i32 %101, 0
>   br i1 %102, label %109, label %103
> 
> ; <label>:103                                     ; preds = %100
>   %104 = load i64* %4, align 8
>   %105 = load i64* %4, align 8
>   %106 = load i64* %roundIncrement, align 8
>   %107 = add i64 %105, %106
>   %108 = icmp ule i64 %104, %107
>   br label %109
20246,20248c18861,18932
< ; <label>:74                                      ; preds = %71
<   call void @tcg_llvm_get_value(i8* %35, i32 8, i1 zeroext true) nounwind
<   br label %75
---
> ; <label>:109                                     ; preds = %103, %100, %94
>   %110 = phi i1 [ true, %100 ], [ true, %94 ], [ %108, %103 ]
>   %111 = zext i1 %110 to i32
>   %112 = trunc i32 %111 to i8
>   store i8 %112, i8* %isTiny, align 1
>   %113 = load i64* %4, align 8
>   %114 = load i32* %3, align 4
>   %115 = sub nsw i32 1, %114
>   call void @shift64RightJamming(i64 %113, i32 %115, i64* %4)
>   store i32 0, i32* %3, align 4
>   %116 = load i64* %4, align 8
>   %117 = load i64* %roundMask, align 8
>   %118 = and i64 %116, %117
>   store i64 %118, i64* %roundBits, align 8
>   %119 = load i8* %isTiny, align 1
>   %120 = zext i8 %119 to i32
>   %121 = icmp ne i32 %120, 0
>   br i1 %121, label %122, label %127
> 
> ; <label>:122                                     ; preds = %109
>   %123 = load i64* %roundBits, align 8
>   %124 = icmp ne i64 %123, 0
>   br i1 %124, label %125, label %127
> 
> ; <label>:125                                     ; preds = %122
>   %126 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 16, %struct.float_status* %126)
>   br label %127
> 
> ; <label>:127                                     ; preds = %125, %122, %109
>   %128 = load i64* %roundBits, align 8
>   %129 = icmp ne i64 %128, 0
>   br i1 %129, label %130, label %137
> 
> ; <label>:130                                     ; preds = %127
>   %131 = load %struct.float_status** %6, align 4
>   %132 = getelementptr inbounds %struct.float_status* %131, i32 0, i32 2
>   %133 = load i8* %132, align 1
>   %134 = sext i8 %133 to i32
>   %135 = or i32 %134, 32
>   %136 = trunc i32 %135 to i8
>   store i8 %136, i8* %132, align 1
>   br label %137
> 
> ; <label>:137                                     ; preds = %130, %127
>   %138 = load i64* %roundIncrement, align 8
>   %139 = load i64* %4, align 8
>   %140 = add i64 %139, %138
>   store i64 %140, i64* %4, align 8
>   %141 = load i64* %4, align 8
>   %142 = icmp slt i64 %141, 0
>   br i1 %142, label %143, label %144
> 
> ; <label>:143                                     ; preds = %137
>   store i32 1, i32* %3, align 4
>   br label %144
> 
> ; <label>:144                                     ; preds = %143, %137
>   %145 = load i64* %roundMask, align 8
>   %146 = add nsw i64 %145, 1
>   store i64 %146, i64* %roundIncrement, align 8
>   %147 = load i8* %roundNearestEven, align 1
>   %148 = zext i8 %147 to i32
>   %149 = icmp ne i32 %148, 0
>   br i1 %149, label %150, label %159
> 
> ; <label>:150                                     ; preds = %144
>   %151 = load i64* %roundBits, align 8
>   %152 = shl i64 %151, 1
>   %153 = load i64* %roundIncrement, align 8
>   %154 = icmp eq i64 %152, %153
>   br i1 %154, label %155, label %159
20250,20253c18934,18951
< ; <label>:75                                      ; preds = %74, %71
<   %76 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %77 = icmp eq i32 %76, 0
<   br i1 %77, label %79, label %78
---
> ; <label>:155                                     ; preds = %150
>   %156 = load i64* %roundIncrement, align 8
>   %157 = load i64* %roundMask, align 8
>   %158 = or i64 %157, %156
>   store i64 %158, i64* %roundMask, align 8
>   br label %159
> 
> ; <label>:159                                     ; preds = %155, %150, %144
>   %160 = load i64* %roundMask, align 8
>   %161 = xor i64 %160, -1
>   %162 = load i64* %4, align 8
>   %163 = and i64 %162, %161
>   store i64 %163, i64* %4, align 8
>   %164 = load i8* %2, align 1
>   %165 = load i32* %3, align 4
>   %166 = load i64* %4, align 8
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %164, i32 %165, i64 %166)
>   br label %445
20255,20257c18953,18954
< ; <label>:78                                      ; preds = %75
<   call void @tcg_llvm_get_value(i8* %36, i32 4, i1 zeroext true) nounwind
<   br label %79
---
> ; <label>:167                                     ; preds = %83
>   br label %168
20259,20274c18956,18969
< ; <label>:79                                      ; preds = %78, %75
<   %80 = load i64* %3, align 8
<   %81 = load i32* %4, align 4
<   call void @io_writeq_mmu(i64 %34, i64 %80, i32 %81, i8* null) nounwind
<   br label %io_write_chkq_mmu.exit
< 
< io_write_chkq_mmu.exit:                           ; preds = %79, %61
<   %82 = add i64 %34, %39
<   call void @tcg_llvm_trace_memory_access(i64 %39, i64 %82, i64 %val, i32 64, i8 zeroext 1, i8 zeroext 1) nounwind
<   br label %slow_stq_mmu.exit
< 
< ; <label>:83                                      ; preds = %._crit_edge
<   %84 = and i32 %12, 127
<   %85 = add i32 %84, 7
<   %86 = icmp ugt i32 %85, 127
<   br i1 %86, label %87, label %204, !prof !1
---
> ; <label>:168                                     ; preds = %167, %63
>   %169 = load i64* %roundBits, align 8
>   %170 = icmp ne i64 %169, 0
>   br i1 %170, label %171, label %178
> 
> ; <label>:171                                     ; preds = %168
>   %172 = load %struct.float_status** %6, align 4
>   %173 = getelementptr inbounds %struct.float_status* %172, i32 0, i32 2
>   %174 = load i8* %173, align 1
>   %175 = sext i8 %174 to i32
>   %176 = or i32 %175, 32
>   %177 = trunc i32 %176 to i8
>   store i8 %177, i8* %173, align 1
>   br label %178
20276,20280c18971,19084
< ; <label>:87                                      ; preds = %83, %29
<   %88 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %89 = icmp eq i32 %88, 0
<   %90 = and i64 %11, 4294967295
<   br i1 %89, label %93, label %91
---
> ; <label>:178                                     ; preds = %171, %168
>   %179 = load i64* %roundIncrement, align 8
>   %180 = load i64* %4, align 8
>   %181 = add i64 %180, %179
>   store i64 %181, i64* %4, align 8
>   %182 = load i64* %4, align 8
>   %183 = load i64* %roundIncrement, align 8
>   %184 = icmp ult i64 %182, %183
>   br i1 %184, label %185, label %188
> 
> ; <label>:185                                     ; preds = %178
>   %186 = load i32* %3, align 4
>   %187 = add nsw i32 %186, 1
>   store i32 %187, i32* %3, align 4
>   store i64 -9223372036854775808, i64* %4, align 8
>   br label %188
> 
> ; <label>:188                                     ; preds = %185, %178
>   %189 = load i64* %roundMask, align 8
>   %190 = add nsw i64 %189, 1
>   store i64 %190, i64* %roundIncrement, align 8
>   %191 = load i8* %roundNearestEven, align 1
>   %192 = zext i8 %191 to i32
>   %193 = icmp ne i32 %192, 0
>   br i1 %193, label %194, label %203
> 
> ; <label>:194                                     ; preds = %188
>   %195 = load i64* %roundBits, align 8
>   %196 = shl i64 %195, 1
>   %197 = load i64* %roundIncrement, align 8
>   %198 = icmp eq i64 %196, %197
>   br i1 %198, label %199, label %203
> 
> ; <label>:199                                     ; preds = %194
>   %200 = load i64* %roundIncrement, align 8
>   %201 = load i64* %roundMask, align 8
>   %202 = or i64 %201, %200
>   store i64 %202, i64* %roundMask, align 8
>   br label %203
> 
> ; <label>:203                                     ; preds = %199, %194, %188
>   %204 = load i64* %roundMask, align 8
>   %205 = xor i64 %204, -1
>   %206 = load i64* %4, align 8
>   %207 = and i64 %206, %205
>   store i64 %207, i64* %4, align 8
>   %208 = load i64* %4, align 8
>   %209 = icmp eq i64 %208, 0
>   br i1 %209, label %210, label %211
> 
> ; <label>:210                                     ; preds = %203
>   store i32 0, i32* %3, align 4
>   br label %211
> 
> ; <label>:211                                     ; preds = %210, %203
>   %212 = load i8* %2, align 1
>   %213 = load i32* %3, align 4
>   %214 = load i64* %4, align 8
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %212, i32 %213, i64 %214)
>   br label %445
> 
> ; <label>:215                                     ; preds = %29, %18
>   %216 = load i64* %5, align 8
>   %217 = icmp slt i64 %216, 0
>   %218 = zext i1 %217 to i32
>   %219 = trunc i32 %218 to i8
>   store i8 %219, i8* %increment, align 1
>   %220 = load i8* %roundNearestEven, align 1
>   %221 = icmp ne i8 %220, 0
>   br i1 %221, label %254, label %222
> 
> ; <label>:222                                     ; preds = %215
>   %223 = load i8* %roundingMode, align 1
>   %224 = sext i8 %223 to i32
>   %225 = icmp eq i32 %224, 3
>   br i1 %225, label %226, label %227
> 
> ; <label>:226                                     ; preds = %222
>   store i8 0, i8* %increment, align 1
>   br label %253
> 
> ; <label>:227                                     ; preds = %222
>   %228 = load i8* %2, align 1
>   %229 = icmp ne i8 %228, 0
>   br i1 %229, label %230, label %241
> 
> ; <label>:230                                     ; preds = %227
>   %231 = load i8* %roundingMode, align 1
>   %232 = sext i8 %231 to i32
>   %233 = icmp eq i32 %232, 1
>   br i1 %233, label %234, label %237
> 
> ; <label>:234                                     ; preds = %230
>   %235 = load i64* %5, align 8
>   %236 = icmp ne i64 %235, 0
>   br label %237
> 
> ; <label>:237                                     ; preds = %234, %230
>   %238 = phi i1 [ false, %230 ], [ %236, %234 ]
>   %239 = zext i1 %238 to i32
>   %240 = trunc i32 %239 to i8
>   store i8 %240, i8* %increment, align 1
>   br label %252
> 
> ; <label>:241                                     ; preds = %227
>   %242 = load i8* %roundingMode, align 1
>   %243 = sext i8 %242 to i32
>   %244 = icmp eq i32 %243, 2
>   br i1 %244, label %245, label %248
> 
> ; <label>:245                                     ; preds = %241
>   %246 = load i64* %5, align 8
>   %247 = icmp ne i64 %246, 0
>   br label %248
20282,20317c19086,19142
< ; <label>:91                                      ; preds = %87
<   %92 = call i64 @tcg_llvm_fork_and_concretize(i64 %90, i64 0, i64 4294967295) nounwind
<   br label %93
< 
< ; <label>:93                                      ; preds = %91, %87
<   %94 = phi i64 [ %92, %91 ], [ %90, %87 ]
<   %95 = trunc i64 %94 to i32
<   %96 = lshr i64 %94, 7
<   %97 = and i64 %96, 33554431
<   %98 = call i64 @tcg_llvm_fork_and_concretize(i64 %97, i64 0, i64 33554431) nounwind
<   %99 = lshr i64 %98, 5
<   %100 = and i64 %99, 255
<   %101 = load %struct.CPUX86State** @env, align 8
<   %102 = getelementptr inbounds %struct.CPUX86State* %101, i64 0, i32 73, i64 %18, i64 %100, i32 1
<   %103 = load i32* %102, align 4
<   %104 = and i32 %95, -4096
<   %105 = and i32 %103, -4088
<   %106 = icmp eq i32 %104, %105
<   br i1 %106, label %._crit_edge.i, label %.lr.ph.i
< 
< .lr.ph.i:                                         ; preds = %93
<   %107 = trunc i64 %98 to i32
<   %108 = shl i32 %107, 7
<   br label %197
< 
< ._crit_edge.i:                                    ; preds = %197, %93
<   %.lcssa3.i = phi i32 [ %103, %93 ], [ %201, %197 ]
<   %.lcssa2.i = phi %struct.CPUX86State* [ %101, %93 ], [ %199, %197 ]
<   %109 = and i32 %.lcssa3.i, 4095
<   %110 = icmp eq i32 %109, 0
<   br i1 %110, label %165, label %111
< 
< ; <label>:111                                     ; preds = %._crit_edge.i
<   %112 = and i32 %95, 7
<   %113 = icmp eq i32 %112, 0
<   br i1 %113, label %114, label %.preheader.i
---
> ; <label>:248                                     ; preds = %245, %241
>   %249 = phi i1 [ false, %241 ], [ %247, %245 ]
>   %250 = zext i1 %249 to i32
>   %251 = trunc i32 %250 to i8
>   store i8 %251, i8* %increment, align 1
>   br label %252
> 
> ; <label>:252                                     ; preds = %248, %237
>   br label %253
> 
> ; <label>:253                                     ; preds = %252, %226
>   br label %254
> 
> ; <label>:254                                     ; preds = %253, %215
>   %255 = load i32* %3, align 4
>   %256 = sub nsw i32 %255, 1
>   %257 = icmp ule i32 32765, %256
>   br i1 %257, label %258, label %402
> 
> ; <label>:258                                     ; preds = %254
>   %259 = load i32* %3, align 4
>   %260 = icmp slt i32 32766, %259
>   br i1 %260, label %271, label %261
> 
> ; <label>:261                                     ; preds = %258
>   %262 = load i32* %3, align 4
>   %263 = icmp eq i32 %262, 32766
>   br i1 %263, label %264, label %298
> 
> ; <label>:264                                     ; preds = %261
>   %265 = load i64* %4, align 8
>   %266 = icmp eq i64 %265, -1
>   br i1 %266, label %267, label %298
> 
> ; <label>:267                                     ; preds = %264
>   %268 = load i8* %increment, align 1
>   %269 = zext i8 %268 to i32
>   %270 = icmp ne i32 %269, 0
>   br i1 %270, label %271, label %298
> 
> ; <label>:271                                     ; preds = %267, %258
>   store i64 0, i64* %roundMask, align 8
>   br label %272
> 
> ; <label>:272                                     ; preds = %271, %82
>   %273 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 40, %struct.float_status* %273)
>   %274 = load i8* %roundingMode, align 1
>   %275 = sext i8 %274 to i32
>   %276 = icmp eq i32 %275, 3
>   br i1 %276, label %292, label %277
> 
> ; <label>:277                                     ; preds = %272
>   %278 = load i8* %2, align 1
>   %279 = zext i8 %278 to i32
>   %280 = icmp ne i32 %279, 0
>   br i1 %280, label %281, label %285
20319,20354c19144,19176
< ; <label>:114                                     ; preds = %111
<   %115 = getelementptr inbounds %struct.CPUX86State* %.lcssa2.i, i64 0, i32 75, i64 %18, i64 %100
<   %116 = load i64* %115, align 8
<   %117 = bitcast i64* %1 to i8*
<   %118 = bitcast i32* %2 to i8*
<   store i64 %val, i64* %1, align 8
<   store i32 %95, i32* %2, align 4
<   %119 = call %struct.MemoryRegion* @iotlb_to_region(i64 %116) nounwind
<   %120 = and i64 %116, -4096
<   %121 = and i64 %94, 4294967295
<   %122 = add i64 %120, %121
<   %123 = icmp ne %struct.MemoryRegion* %119, @io_mem_ram
<   %124 = icmp ne %struct.MemoryRegion* %119, @io_mem_rom
<   %or.cond.i.i = and i1 %123, %124
<   %125 = icmp ne %struct.MemoryRegion* %119, @io_mem_unassigned
<   %or.cond3.i.i = and i1 %or.cond.i.i, %125
<   %126 = icmp ne %struct.MemoryRegion* %119, @io_mem_notdirty
<   %or.cond5.i.i = and i1 %or.cond3.i.i, %126
<   %127 = load %struct.CPUX86State** @env, align 8
<   %or.cond5.not.i.i = xor i1 %or.cond5.i.i, true
<   %128 = load i32* @use_icount, align 4
<   %129 = icmp eq i32 %128, 0
<   %or.cond18.i.i = or i1 %129, %or.cond5.not.i.i
<   br i1 %or.cond18.i.i, label %can_do_io.exit.thread.i.i, label %130
< 
< ; <label>:130                                     ; preds = %114
<   %131 = getelementptr inbounds %struct.CPUX86State* %127, i64 0, i32 66
<   %132 = load %struct.TranslationBlock** %131, align 8
<   %133 = icmp eq %struct.TranslationBlock* %132, null
<   br i1 %133, label %can_do_io.exit.thread.i.i, label %can_do_io.exit.i.i
< 
< can_do_io.exit.i.i:                               ; preds = %130
<   %134 = getelementptr inbounds %struct.CPUX86State* %127, i64 0, i32 85
<   %135 = load i32* %134, align 4
<   %136 = icmp eq i32 %135, 0
<   br i1 %136, label %137, label %can_do_io.exit.thread.i.i
---
> ; <label>:281                                     ; preds = %277
>   %282 = load i8* %roundingMode, align 1
>   %283 = sext i8 %282 to i32
>   %284 = icmp eq i32 %283, 2
>   br i1 %284, label %292, label %285
> 
> ; <label>:285                                     ; preds = %281, %277
>   %286 = load i8* %2, align 1
>   %287 = icmp ne i8 %286, 0
>   br i1 %287, label %296, label %288
> 
> ; <label>:288                                     ; preds = %285
>   %289 = load i8* %roundingMode, align 1
>   %290 = sext i8 %289 to i32
>   %291 = icmp eq i32 %290, 1
>   br i1 %291, label %292, label %296
> 
> ; <label>:292                                     ; preds = %288, %281, %272
>   %293 = load i8* %2, align 1
>   %294 = load i64* %roundMask, align 8
>   %295 = xor i64 %294, -1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %293, i32 32766, i64 %295)
>   br label %445
> 
> ; <label>:296                                     ; preds = %288, %285
>   %297 = load i8* %2, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %297, i32 32767, i64 -9223372036854775808)
>   br label %445
> 
> ; <label>:298                                     ; preds = %267, %264, %261
>   %299 = load i32* %3, align 4
>   %300 = icmp sle i32 %299, 0
>   br i1 %300, label %301, label %401
20356,20358c19178,19184
< ; <label>:137                                     ; preds = %can_do_io.exit.i.i
<   call void @cpu_io_recompile(%struct.CPUX86State* %127, i8* null) noreturn nounwind
<   unreachable
---
> ; <label>:301                                     ; preds = %298
>   %302 = load %struct.float_status** %6, align 4
>   %303 = getelementptr inbounds %struct.float_status* %302, i32 0, i32 0
>   %304 = load i8* %303, align 1
>   %305 = sext i8 %304 to i32
>   %306 = icmp eq i32 %305, 1
>   br i1 %306, label %316, label %307
20360,20387c19186,19199
< can_do_io.exit.thread.i.i:                        ; preds = %can_do_io.exit.i.i, %130, %114
<   %138 = getelementptr inbounds %struct.CPUX86State* %127, i64 0, i32 69
<   store i32 %95, i32* %138, align 4
<   %139 = load %struct.CPUX86State** @env, align 8
<   %140 = getelementptr inbounds %struct.CPUX86State* %139, i64 0, i32 68
<   store i64 0, i64* %140, align 8
<   %141 = call i32 @s2e_ismemfunc(%struct.MemoryRegion* %119, i32 1) nounwind
<   %142 = icmp eq i32 %141, 0
<   br i1 %142, label %153, label %143
< 
< ; <label>:143                                     ; preds = %can_do_io.exit.thread.i.i
<   %144 = call i64 @s2e_notdirty_mem_write(i64 %122) nounwind
<   %145 = load i64* %1, align 8
<   %146 = trunc i64 %145 to i32
<   %147 = inttoptr i64 %144 to i32*
<   store i32 %146, i32* %147, align 4
<   %148 = add i64 %144, 4
<   %149 = load i64* %1, align 8
<   %150 = lshr i64 %149, 32
<   %151 = trunc i64 %150 to i32
<   %152 = inttoptr i64 %148 to i32*
<   store i32 %151, i32* %152, align 4
<   br label %io_write_chkq_mmu.exit.i
< 
< ; <label>:153                                     ; preds = %can_do_io.exit.thread.i.i
<   %154 = load i32* @g_s2e_concretize_io_writes, align 4
<   %155 = icmp eq i32 %154, 0
<   br i1 %155, label %157, label %156
---
> ; <label>:307                                     ; preds = %301
>   %308 = load i32* %3, align 4
>   %309 = icmp slt i32 %308, 0
>   br i1 %309, label %316, label %310
> 
> ; <label>:310                                     ; preds = %307
>   %311 = load i8* %increment, align 1
>   %312 = icmp ne i8 %311, 0
>   br i1 %312, label %313, label %316
> 
> ; <label>:313                                     ; preds = %310
>   %314 = load i64* %4, align 8
>   %315 = icmp ult i64 %314, -1
>   br label %316
20389,20391c19201,19282
< ; <label>:156                                     ; preds = %153
<   call void @tcg_llvm_get_value(i8* %117, i32 8, i1 zeroext true) nounwind
<   br label %157
---
> ; <label>:316                                     ; preds = %313, %310, %307, %301
>   %317 = phi i1 [ true, %310 ], [ true, %307 ], [ true, %301 ], [ %315, %313 ]
>   %318 = zext i1 %317 to i32
>   %319 = trunc i32 %318 to i8
>   store i8 %319, i8* %isTiny, align 1
>   %320 = load i64* %4, align 8
>   %321 = load i64* %5, align 8
>   %322 = load i32* %3, align 4
>   %323 = sub nsw i32 1, %322
>   call void @shift64ExtraRightJamming(i64 %320, i64 %321, i32 %323, i64* %4, i64* %5)
>   store i32 0, i32* %3, align 4
>   %324 = load i8* %isTiny, align 1
>   %325 = zext i8 %324 to i32
>   %326 = icmp ne i32 %325, 0
>   br i1 %326, label %327, label %332
> 
> ; <label>:327                                     ; preds = %316
>   %328 = load i64* %5, align 8
>   %329 = icmp ne i64 %328, 0
>   br i1 %329, label %330, label %332
> 
> ; <label>:330                                     ; preds = %327
>   %331 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 16, %struct.float_status* %331)
>   br label %332
> 
> ; <label>:332                                     ; preds = %330, %327, %316
>   %333 = load i64* %5, align 8
>   %334 = icmp ne i64 %333, 0
>   br i1 %334, label %335, label %342
> 
> ; <label>:335                                     ; preds = %332
>   %336 = load %struct.float_status** %6, align 4
>   %337 = getelementptr inbounds %struct.float_status* %336, i32 0, i32 2
>   %338 = load i8* %337, align 1
>   %339 = sext i8 %338 to i32
>   %340 = or i32 %339, 32
>   %341 = trunc i32 %340 to i8
>   store i8 %341, i8* %337, align 1
>   br label %342
> 
> ; <label>:342                                     ; preds = %335, %332
>   %343 = load i8* %roundNearestEven, align 1
>   %344 = icmp ne i8 %343, 0
>   br i1 %344, label %345, label %350
> 
> ; <label>:345                                     ; preds = %342
>   %346 = load i64* %5, align 8
>   %347 = icmp slt i64 %346, 0
>   %348 = zext i1 %347 to i32
>   %349 = trunc i32 %348 to i8
>   store i8 %349, i8* %increment, align 1
>   br label %376
> 
> ; <label>:350                                     ; preds = %342
>   %351 = load i8* %2, align 1
>   %352 = icmp ne i8 %351, 0
>   br i1 %352, label %353, label %364
> 
> ; <label>:353                                     ; preds = %350
>   %354 = load i8* %roundingMode, align 1
>   %355 = sext i8 %354 to i32
>   %356 = icmp eq i32 %355, 1
>   br i1 %356, label %357, label %360
> 
> ; <label>:357                                     ; preds = %353
>   %358 = load i64* %5, align 8
>   %359 = icmp ne i64 %358, 0
>   br label %360
> 
> ; <label>:360                                     ; preds = %357, %353
>   %361 = phi i1 [ false, %353 ], [ %359, %357 ]
>   %362 = zext i1 %361 to i32
>   %363 = trunc i32 %362 to i8
>   store i8 %363, i8* %increment, align 1
>   br label %375
> 
> ; <label>:364                                     ; preds = %350
>   %365 = load i8* %roundingMode, align 1
>   %366 = sext i8 %365 to i32
>   %367 = icmp eq i32 %366, 2
>   br i1 %367, label %368, label %371
20393,20396c19284,19374
< ; <label>:157                                     ; preds = %156, %153
<   %158 = load i32* @g_s2e_concretize_io_addresses, align 4
<   %159 = icmp eq i32 %158, 0
<   br i1 %159, label %161, label %160
---
> ; <label>:368                                     ; preds = %364
>   %369 = load i64* %5, align 8
>   %370 = icmp ne i64 %369, 0
>   br label %371
> 
> ; <label>:371                                     ; preds = %368, %364
>   %372 = phi i1 [ false, %364 ], [ %370, %368 ]
>   %373 = zext i1 %372 to i32
>   %374 = trunc i32 %373 to i8
>   store i8 %374, i8* %increment, align 1
>   br label %375
> 
> ; <label>:375                                     ; preds = %371, %360
>   br label %376
> 
> ; <label>:376                                     ; preds = %375, %345
>   %377 = load i8* %increment, align 1
>   %378 = icmp ne i8 %377, 0
>   br i1 %378, label %379, label %397
> 
> ; <label>:379                                     ; preds = %376
>   %380 = load i64* %4, align 8
>   %381 = add i64 %380, 1
>   store i64 %381, i64* %4, align 8
>   %382 = load i64* %5, align 8
>   %383 = shl i64 %382, 1
>   %384 = icmp eq i64 %383, 0
>   %385 = zext i1 %384 to i32
>   %386 = load i8* %roundNearestEven, align 1
>   %387 = zext i8 %386 to i32
>   %388 = and i32 %385, %387
>   %389 = xor i32 %388, -1
>   %390 = sext i32 %389 to i64
>   %391 = load i64* %4, align 8
>   %392 = and i64 %391, %390
>   store i64 %392, i64* %4, align 8
>   %393 = load i64* %4, align 8
>   %394 = icmp slt i64 %393, 0
>   br i1 %394, label %395, label %396
> 
> ; <label>:395                                     ; preds = %379
>   store i32 1, i32* %3, align 4
>   br label %396
> 
> ; <label>:396                                     ; preds = %395, %379
>   br label %397
> 
> ; <label>:397                                     ; preds = %396, %376
>   %398 = load i8* %2, align 1
>   %399 = load i32* %3, align 4
>   %400 = load i64* %4, align 8
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %398, i32 %399, i64 %400)
>   br label %445
> 
> ; <label>:401                                     ; preds = %298
>   br label %402
> 
> ; <label>:402                                     ; preds = %401, %254
>   %403 = load i64* %5, align 8
>   %404 = icmp ne i64 %403, 0
>   br i1 %404, label %405, label %412
> 
> ; <label>:405                                     ; preds = %402
>   %406 = load %struct.float_status** %6, align 4
>   %407 = getelementptr inbounds %struct.float_status* %406, i32 0, i32 2
>   %408 = load i8* %407, align 1
>   %409 = sext i8 %408 to i32
>   %410 = or i32 %409, 32
>   %411 = trunc i32 %410 to i8
>   store i8 %411, i8* %407, align 1
>   br label %412
> 
> ; <label>:412                                     ; preds = %405, %402
>   %413 = load i8* %increment, align 1
>   %414 = icmp ne i8 %413, 0
>   br i1 %414, label %415, label %436
> 
> ; <label>:415                                     ; preds = %412
>   %416 = load i64* %4, align 8
>   %417 = add i64 %416, 1
>   store i64 %417, i64* %4, align 8
>   %418 = load i64* %4, align 8
>   %419 = icmp eq i64 %418, 0
>   br i1 %419, label %420, label %423
> 
> ; <label>:420                                     ; preds = %415
>   %421 = load i32* %3, align 4
>   %422 = add nsw i32 %421, 1
>   store i32 %422, i32* %3, align 4
>   store i64 -9223372036854775808, i64* %4, align 8
>   br label %435
20398,20400c19376,19458
< ; <label>:160                                     ; preds = %157
<   call void @tcg_llvm_get_value(i8* %118, i32 4, i1 zeroext true) nounwind
<   br label %161
---
> ; <label>:423                                     ; preds = %415
>   %424 = load i64* %5, align 8
>   %425 = shl i64 %424, 1
>   %426 = icmp eq i64 %425, 0
>   %427 = zext i1 %426 to i32
>   %428 = load i8* %roundNearestEven, align 1
>   %429 = zext i8 %428 to i32
>   %430 = and i32 %427, %429
>   %431 = xor i32 %430, -1
>   %432 = sext i32 %431 to i64
>   %433 = load i64* %4, align 8
>   %434 = and i64 %433, %432
>   store i64 %434, i64* %4, align 8
>   br label %435
> 
> ; <label>:435                                     ; preds = %423, %420
>   br label %441
> 
> ; <label>:436                                     ; preds = %412
>   %437 = load i64* %4, align 8
>   %438 = icmp eq i64 %437, 0
>   br i1 %438, label %439, label %440
> 
> ; <label>:439                                     ; preds = %436
>   store i32 0, i32* %3, align 4
>   br label %440
> 
> ; <label>:440                                     ; preds = %439, %436
>   br label %441
> 
> ; <label>:441                                     ; preds = %440, %435
>   %442 = load i8* %2, align 1
>   %443 = load i32* %3, align 4
>   %444 = load i64* %4, align 8
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %442, i32 %443, i64 %444)
>   br label %445
> 
> ; <label>:445                                     ; preds = %441, %397, %296, %292, %211, %159, %91
>   ret void
> }
> 
> define internal void @floatx80_div(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %rem0 = alloca i64, align 8
>   %rem1 = alloca i64, align 8
>   %rem2 = alloca i64, align 8
>   %term0 = alloca i64, align 8
>   %term1 = alloca i64, align 8
>   %term2 = alloca i64, align 8
>   %z = alloca %struct.floatx80, align 1
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %2, i64* %aSig, align 8
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %3, i32* %aExp, align 4
>   %4 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %4, i8* %aSign, align 1
>   %5 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   store i64 %5, i64* %bSig, align 8
>   %6 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   store i32 %6, i32* %bExp, align 4
>   %7 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %b)
>   store i8 %7, i8* %bSign, align 1
>   %8 = load i8* %aSign, align 1
>   %9 = zext i8 %8 to i32
>   %10 = load i8* %bSign, align 1
>   %11 = zext i8 %10 to i32
>   %12 = xor i32 %9, %11
>   %13 = trunc i32 %12 to i8
>   store i8 %13, i8* %zSign, align 1
>   %14 = load i32* %aExp, align 4
>   %15 = icmp eq i32 %14, 32767
>   br i1 %15, label %16, label %34
20402,20450c19460,19464
< ; <label>:161                                     ; preds = %160, %157
<   %162 = load i64* %1, align 8
<   %163 = load i32* %2, align 4
<   call void @io_writeq_mmu(i64 %116, i64 %162, i32 %163, i8* null) nounwind
<   br label %io_write_chkq_mmu.exit.i
< 
< io_write_chkq_mmu.exit.i:                         ; preds = %161, %143
<   %164 = add i64 %116, %121
<   call void @tcg_llvm_trace_memory_access(i64 %121, i64 %164, i64 %val, i32 64, i8 zeroext 1, i8 zeroext 1) nounwind
<   br label %slow_stq_mmu.exit
< 
< ; <label>:165                                     ; preds = %._crit_edge.i
<   %166 = and i32 %95, 127
<   %167 = add i32 %166, 7
<   %168 = icmp ugt i32 %167, 127
<   br i1 %168, label %.preheader.i, label %191
< 
< .preheader.i:                                     ; preds = %165, %111
<   %169 = add i32 %95, 7
<   %170 = lshr i64 %val, 56
<   %171 = trunc i64 %170 to i8
<   call fastcc void @slow_stb_mmu(i32 %169, i8 zeroext %171, i32 %mmu_idx) nounwind
<   %172 = add i32 %95, 6
<   %173 = lshr i64 %val, 48
<   %174 = trunc i64 %173 to i8
<   call fastcc void @slow_stb_mmu(i32 %172, i8 zeroext %174, i32 %mmu_idx) nounwind
<   %175 = add i32 %95, 5
<   %176 = lshr i64 %val, 40
<   %177 = trunc i64 %176 to i8
<   call fastcc void @slow_stb_mmu(i32 %175, i8 zeroext %177, i32 %mmu_idx) nounwind
<   %178 = add i32 %95, 4
<   %179 = lshr i64 %val, 32
<   %180 = trunc i64 %179 to i8
<   call fastcc void @slow_stb_mmu(i32 %178, i8 zeroext %180, i32 %mmu_idx) nounwind
<   %181 = add i32 %95, 3
<   %182 = lshr i64 %val, 24
<   %183 = trunc i64 %182 to i8
<   call fastcc void @slow_stb_mmu(i32 %181, i8 zeroext %183, i32 %mmu_idx) nounwind
<   %184 = add i32 %95, 2
<   %185 = lshr i64 %val, 16
<   %186 = trunc i64 %185 to i8
<   call fastcc void @slow_stb_mmu(i32 %184, i8 zeroext %186, i32 %mmu_idx) nounwind
<   %187 = add i32 %95, 1
<   %188 = lshr i64 %val, 8
<   %189 = trunc i64 %188 to i8
<   call fastcc void @slow_stb_mmu(i32 %187, i8 zeroext %189, i32 %mmu_idx) nounwind
<   %190 = trunc i64 %val to i8
<   call fastcc void @slow_stb_mmu(i32 %95, i8 zeroext %190, i32 %mmu_idx) nounwind
<   br label %slow_stq_mmu.exit
---
> ; <label>:16                                      ; preds = %0
>   %17 = load i64* %aSig, align 8
>   %18 = shl i64 %17, 1
>   %19 = icmp ne i64 %18, 0
>   br i1 %19, label %20, label %22
20452,20490c19466,19469
< ; <label>:191                                     ; preds = %165
<   %192 = getelementptr inbounds %struct.CPUX86State* %.lcssa2.i, i64 0, i32 73, i64 %18, i64 %100, i32 3
<   %193 = load i64* %192, align 8
<   %194 = and i64 %94, 4294967295
<   %195 = add i64 %193, %194
<   %196 = inttoptr i64 %195 to i64*
<   store i64 %val, i64* %196, align 8
<   call void @tcg_llvm_trace_memory_access(i64 %194, i64 %195, i64 %val, i32 64, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %slow_stq_mmu.exit
< 
< ; <label>:197                                     ; preds = %197, %.lr.ph.i
<   %198 = phi %struct.CPUX86State* [ %101, %.lr.ph.i ], [ %199, %197 ]
<   call void @tlb_fill(%struct.CPUX86State* %198, i32 %95, i32 %108, i32 1, i32 %mmu_idx, i8* null) nounwind
<   %199 = load %struct.CPUX86State** @env, align 8
<   %200 = getelementptr inbounds %struct.CPUX86State* %199, i64 0, i32 73, i64 %18, i64 %100, i32 1
<   %201 = load i32* %200, align 4
<   %202 = and i32 %201, -4088
<   %203 = icmp eq i32 %104, %202
<   br i1 %203, label %._crit_edge.i, label %197
< 
< ; <label>:204                                     ; preds = %83
<   %205 = getelementptr inbounds %struct.CPUX86State* %.lcssa32, i64 0, i32 73, i64 %18, i64 %17, i32 3
<   %206 = load i64* %205, align 8
<   %207 = and i64 %11, 4294967295
<   %208 = add i64 %206, %207
<   %209 = inttoptr i64 %208 to i64*
<   store i64 %val, i64* %209, align 8
<   call void @tcg_llvm_trace_memory_access(i64 %207, i64 %208, i64 %val, i32 64, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %slow_stq_mmu.exit
< 
< ; <label>:210                                     ; preds = %210, %.lr.ph
<   %211 = phi %struct.CPUX86State* [ %19, %.lr.ph ], [ %212, %210 ]
<   call void @tlb_fill(%struct.CPUX86State* %211, i32 %12, i32 %26, i32 1, i32 %mmu_idx, i8* null)
<   %212 = load %struct.CPUX86State** @env, align 8
<   %213 = getelementptr inbounds %struct.CPUX86State* %212, i64 0, i32 73, i64 %18, i64 %17, i32 1
<   %214 = load i32* %213, align 4
<   %215 = and i32 %214, -4088
<   %216 = icmp eq i32 %22, %215
<   br i1 %216, label %._crit_edge, label %210, !prof !0
---
> ; <label>:20                                      ; preds = %16
>   %21 = load %struct.float_status** %1, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %21)
>   br label %151
20492,20494c19471,19480
< slow_stq_mmu.exit:                                ; preds = %204, %191, %.preheader.i, %io_write_chkq_mmu.exit.i, %io_write_chkq_mmu.exit
<   ret void
< }
---
> ; <label>:22                                      ; preds = %16
>   %23 = load i32* %bExp, align 4
>   %24 = icmp eq i32 %23, 32767
>   br i1 %24, label %25, label %32
> 
> ; <label>:25                                      ; preds = %22
>   %26 = load i64* %bSig, align 8
>   %27 = shl i64 %26, 1
>   %28 = icmp ne i64 %27, 0
>   br i1 %28, label %29, label %31
20496c19482,19485
< declare void @s2e_on_tlb_miss(%struct.S2E*, %struct.S2EExecutionState*, i64, i32)
---
> ; <label>:29                                      ; preds = %25
>   %30 = load %struct.float_status** %1, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %30)
>   br label %151
20498c19487,19488
< declare i32 @cpu_x86_handle_mmu_fault(%struct.CPUX86State*, i32, i32, i32)
---
> ; <label>:31                                      ; preds = %25
>   br label %58
20500c19490,19493
< declare void @stq_phys(i64, i64)
---
> ; <label>:32                                      ; preds = %22
>   %33 = load i8* %zSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %33, i32 32767, i64 -9223372036854775808)
>   br label %151
20502c19495,19498
< declare %struct.TranslationBlock* @tb_find_pc(i64)
---
> ; <label>:34                                      ; preds = %0
>   %35 = load i32* %bExp, align 4
>   %36 = icmp eq i32 %35, 32767
>   br i1 %36, label %37, label %45
20504c19500,19509
< declare i32 @cpu_restore_state(%struct.TranslationBlock*, %struct.CPUX86State*, i64)
---
> ; <label>:37                                      ; preds = %34
>   %38 = load i64* %bSig, align 8
>   %39 = shl i64 %38, 1
>   %40 = icmp ne i64 %39, 0
>   br i1 %40, label %41, label %43
> 
> ; <label>:41                                      ; preds = %37
>   %42 = load %struct.float_status** %1, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %42)
>   br label %151
20506c19511,19514
< declare void @s2e_on_page_fault(%struct.S2E*, %struct.S2EExecutionState*, i64, i32)
---
> ; <label>:43                                      ; preds = %37
>   %44 = load i8* %zSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %44, i32 0, i64 0)
>   br label %151
20508,20514c19516,19519
< define void @helper_vmrun(i32 %aflag, i32 %next_eip_addend) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
---
> ; <label>:45                                      ; preds = %34
>   %46 = load i32* %bExp, align 4
>   %47 = icmp eq i32 %46, 0
>   br i1 %47, label %48, label %69
20516,20521c19521,19524
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 4294967296
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
---
> ; <label>:48                                      ; preds = %45
>   %49 = load i64* %bSig, align 8
>   %50 = icmp eq i64 %49, 0
>   br i1 %50, label %51, label %67
20523,20525c19526,19532
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 128, i64 0) nounwind
<   unreachable
---
> ; <label>:51                                      ; preds = %48
>   %52 = load i32* %aExp, align 4
>   %53 = sext i32 %52 to i64
>   %54 = load i64* %aSig, align 8
>   %55 = or i64 %53, %54
>   %56 = icmp eq i64 %55, 0
>   br i1 %56, label %57, label %64
20527,20533c19534,19535
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %12 = load i32* %11, align 4
<   %13 = load i32* @loglevel, align 4
<   %14 = and i32 %13, 2
<   %15 = icmp eq i32 %14, 0
<   br i1 %15, label %19, label %16
---
> ; <label>:57                                      ; preds = %51
>   br label %58
20535,20539c19537,19547
< ; <label>:16                                      ; preds = %helper_svm_check_intercept_param.exit
<   %17 = load %struct._IO_FILE** @logfile, align 8
<   %18 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %17, i8* getelementptr inbounds ([13 x i8]* @.str10, i64 0, i64 0), i32 %12) nounwind
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %19
---
> ; <label>:58                                      ; preds = %57, %31
>   %59 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %59)
>   %60 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 -4611686018427387904, i64* %60, align 1
>   %61 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   store i16 -1, i16* %61, align 1
>   %62 = bitcast %struct.floatx80* %agg.result to i8*
>   %63 = bitcast %struct.floatx80* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %62, i8* %63, i32 10, i32 1, i1 false)
>   br label %151
20541,21046c19549,19554
< ; <label>:19                                      ; preds = %16, %helper_svm_check_intercept_param.exit
<   %20 = phi %struct.CPUX86State* [ %1, %helper_svm_check_intercept_param.exit ], [ %.pre, %16 ]
<   %21 = zext i32 %12 to i64
<   %22 = getelementptr inbounds %struct.CPUX86State* %20, i64 0, i32 39
<   store i64 %21, i64* %22, align 8
<   %23 = load %struct.CPUX86State** @env, align 8
<   %24 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 38
<   %25 = load i64* %24, align 8
<   %26 = add i64 %25, 1128
<   %27 = getelementptr inbounds %struct.CPUX86State* %23, i64 0, i32 13, i32 1
<   %28 = load i32* %27, align 4
<   %29 = zext i32 %28 to i64
<   tail call void @stq_phys(i64 %26, i64 %29) nounwind
<   %30 = load %struct.CPUX86State** @env, align 8
<   %31 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 38
<   %32 = load i64* %31, align 8
<   %33 = add i64 %32, 1124
<   %34 = getelementptr inbounds %struct.CPUX86State* %30, i64 0, i32 13, i32 2
<   %35 = load i32* %34, align 4
<   tail call void @stl_phys(i64 %33, i32 %35) nounwind
<   %36 = load %struct.CPUX86State** @env, align 8
<   %37 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 38
<   %38 = load i64* %37, align 8
<   %39 = add i64 %38, 1160
<   %40 = getelementptr inbounds %struct.CPUX86State* %36, i64 0, i32 14, i32 1
<   %41 = load i32* %40, align 4
<   %42 = zext i32 %41 to i64
<   tail call void @stq_phys(i64 %39, i64 %42) nounwind
<   %43 = load %struct.CPUX86State** @env, align 8
<   %44 = getelementptr inbounds %struct.CPUX86State* %43, i64 0, i32 38
<   %45 = load i64* %44, align 8
<   %46 = add i64 %45, 1156
<   %47 = getelementptr inbounds %struct.CPUX86State* %43, i64 0, i32 14, i32 2
<   %48 = load i32* %47, align 4
<   tail call void @stl_phys(i64 %46, i32 %48) nounwind
<   %49 = load %struct.CPUX86State** @env, align 8
<   %50 = getelementptr inbounds %struct.CPUX86State* %49, i64 0, i32 38
<   %51 = load i64* %50, align 8
<   %52 = add i64 %51, 1368
<   %53 = getelementptr inbounds %struct.CPUX86State* %49, i64 0, i32 15, i64 0
<   %54 = load i32* %53, align 4
<   %55 = zext i32 %54 to i64
<   tail call void @stq_phys(i64 %52, i64 %55) nounwind
<   %56 = load %struct.CPUX86State** @env, align 8
<   %57 = getelementptr inbounds %struct.CPUX86State* %56, i64 0, i32 38
<   %58 = load i64* %57, align 8
<   %59 = add i64 %58, 1600
<   %60 = getelementptr inbounds %struct.CPUX86State* %56, i64 0, i32 15, i64 2
<   %61 = load i32* %60, align 4
<   %62 = zext i32 %61 to i64
<   tail call void @stq_phys(i64 %59, i64 %62) nounwind
<   %63 = load %struct.CPUX86State** @env, align 8
<   %64 = getelementptr inbounds %struct.CPUX86State* %63, i64 0, i32 38
<   %65 = load i64* %64, align 8
<   %66 = add i64 %65, 1360
<   %67 = getelementptr inbounds %struct.CPUX86State* %63, i64 0, i32 15, i64 3
<   %68 = load i32* %67, align 4
<   %69 = zext i32 %68 to i64
<   tail call void @stq_phys(i64 %66, i64 %69) nounwind
<   %70 = load %struct.CPUX86State** @env, align 8
<   %71 = getelementptr inbounds %struct.CPUX86State* %70, i64 0, i32 38
<   %72 = load i64* %71, align 8
<   %73 = add i64 %72, 1352
<   %74 = getelementptr inbounds %struct.CPUX86State* %70, i64 0, i32 15, i64 4
<   %75 = load i32* %74, align 4
<   %76 = zext i32 %75 to i64
<   tail call void @stq_phys(i64 %73, i64 %76) nounwind
<   %77 = load %struct.CPUX86State** @env, align 8
<   %78 = getelementptr inbounds %struct.CPUX86State* %77, i64 0, i32 38
<   %79 = load i64* %78, align 8
<   %80 = add i64 %79, 1384
<   %81 = getelementptr inbounds %struct.CPUX86State* %77, i64 0, i32 58, i64 6
<   %82 = load i32* %81, align 4
<   %83 = zext i32 %82 to i64
<   tail call void @stq_phys(i64 %80, i64 %83) nounwind
<   %84 = load %struct.CPUX86State** @env, align 8
<   %85 = getelementptr inbounds %struct.CPUX86State* %84, i64 0, i32 38
<   %86 = load i64* %85, align 8
<   %87 = add i64 %86, 1376
<   %88 = getelementptr inbounds %struct.CPUX86State* %84, i64 0, i32 58, i64 7
<   %89 = load i32* %88, align 4
<   %90 = zext i32 %89 to i64
<   tail call void @stq_phys(i64 %87, i64 %90) nounwind
<   %91 = load %struct.CPUX86State** @env, align 8
<   %92 = getelementptr inbounds %struct.CPUX86State* %91, i64 0, i32 38
<   %93 = load i64* %92, align 8
<   %94 = add i64 %93, 1232
<   %95 = getelementptr inbounds %struct.CPUX86State* %91, i64 0, i32 36
<   %96 = load i64* %95, align 8
<   tail call void @stq_phys(i64 %94, i64 %96) nounwind
<   %97 = load %struct.CPUX86State** @env, align 8
<   %98 = getelementptr inbounds %struct.CPUX86State* %97, i64 0, i32 38
<   %99 = load i64* %98, align 8
<   %100 = add i64 %99, 1392
<   %101 = getelementptr inbounds %struct.CPUX86State* %97, i64 0, i32 7
<   %102 = load i32* %101, align 4
<   %103 = getelementptr inbounds %struct.CPUX86State* %97, i64 0, i32 1
<   %104 = load i32* %103, align 4
<   %105 = tail call i32 @helper_cc_compute_all(i32 %104) nounwind
<   %106 = or i32 %105, %102
<   %107 = getelementptr inbounds %struct.CPUX86State* %97, i64 0, i32 6
<   %108 = load i32* %107, align 4
<   %109 = and i32 %108, 1024
<   %110 = or i32 %106, %109
<   %111 = zext i32 %110 to i64
<   tail call void @stq_phys(i64 %100, i64 %111) nounwind
<   %112 = load %struct.CPUX86State** @env, align 8
<   %113 = getelementptr inbounds %struct.CPUX86State* %112, i64 0, i32 38
<   %114 = load i64* %113, align 8
<   %115 = add i64 %114, 1024
<   %116 = getelementptr inbounds %struct.CPUX86State* %112, i64 0, i32 10, i64 0, i32 0
<   %117 = load i32* %116, align 4
<   tail call void @stw_phys(i64 %115, i32 %117) nounwind
<   %118 = add i64 %114, 1032
<   %119 = getelementptr inbounds %struct.CPUX86State* %112, i64 0, i32 10, i64 0, i32 1
<   %120 = load i32* %119, align 4
<   %121 = zext i32 %120 to i64
<   tail call void @stq_phys(i64 %118, i64 %121) nounwind
<   %122 = add i64 %114, 1028
<   %123 = getelementptr inbounds %struct.CPUX86State* %112, i64 0, i32 10, i64 0, i32 2
<   %124 = load i32* %123, align 4
<   tail call void @stl_phys(i64 %122, i32 %124) nounwind
<   %125 = add i64 %114, 1026
<   %126 = getelementptr inbounds %struct.CPUX86State* %112, i64 0, i32 10, i64 0, i32 3
<   %127 = load i32* %126, align 4
<   %128 = lshr i32 %127, 8
<   %129 = and i32 %128, 255
<   %130 = lshr i32 %127, 12
<   %131 = and i32 %130, 3840
<   %132 = or i32 %129, %131
<   tail call void @stw_phys(i64 %125, i32 %132) nounwind
<   %133 = load %struct.CPUX86State** @env, align 8
<   %134 = getelementptr inbounds %struct.CPUX86State* %133, i64 0, i32 38
<   %135 = load i64* %134, align 8
<   %136 = add i64 %135, 1040
<   %137 = getelementptr inbounds %struct.CPUX86State* %133, i64 0, i32 10, i64 1, i32 0
<   %138 = load i32* %137, align 4
<   tail call void @stw_phys(i64 %136, i32 %138) nounwind
<   %139 = add i64 %135, 1048
<   %140 = getelementptr inbounds %struct.CPUX86State* %133, i64 0, i32 10, i64 1, i32 1
<   %141 = load i32* %140, align 4
<   %142 = zext i32 %141 to i64
<   tail call void @stq_phys(i64 %139, i64 %142) nounwind
<   %143 = add i64 %135, 1044
<   %144 = getelementptr inbounds %struct.CPUX86State* %133, i64 0, i32 10, i64 1, i32 2
<   %145 = load i32* %144, align 4
<   tail call void @stl_phys(i64 %143, i32 %145) nounwind
<   %146 = add i64 %135, 1042
<   %147 = getelementptr inbounds %struct.CPUX86State* %133, i64 0, i32 10, i64 1, i32 3
<   %148 = load i32* %147, align 4
<   %149 = lshr i32 %148, 8
<   %150 = and i32 %149, 255
<   %151 = lshr i32 %148, 12
<   %152 = and i32 %151, 3840
<   %153 = or i32 %150, %152
<   tail call void @stw_phys(i64 %146, i32 %153) nounwind
<   %154 = load %struct.CPUX86State** @env, align 8
<   %155 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 38
<   %156 = load i64* %155, align 8
<   %157 = add i64 %156, 1056
<   %158 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 10, i64 2, i32 0
<   %159 = load i32* %158, align 4
<   tail call void @stw_phys(i64 %157, i32 %159) nounwind
<   %160 = add i64 %156, 1064
<   %161 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 10, i64 2, i32 1
<   %162 = load i32* %161, align 4
<   %163 = zext i32 %162 to i64
<   tail call void @stq_phys(i64 %160, i64 %163) nounwind
<   %164 = add i64 %156, 1060
<   %165 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 10, i64 2, i32 2
<   %166 = load i32* %165, align 4
<   tail call void @stl_phys(i64 %164, i32 %166) nounwind
<   %167 = add i64 %156, 1058
<   %168 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 10, i64 2, i32 3
<   %169 = load i32* %168, align 4
<   %170 = lshr i32 %169, 8
<   %171 = and i32 %170, 255
<   %172 = lshr i32 %169, 12
<   %173 = and i32 %172, 3840
<   %174 = or i32 %171, %173
<   tail call void @stw_phys(i64 %167, i32 %174) nounwind
<   %175 = load %struct.CPUX86State** @env, align 8
<   %176 = getelementptr inbounds %struct.CPUX86State* %175, i64 0, i32 38
<   %177 = load i64* %176, align 8
<   %178 = add i64 %177, 1072
<   %179 = getelementptr inbounds %struct.CPUX86State* %175, i64 0, i32 10, i64 3, i32 0
<   %180 = load i32* %179, align 4
<   tail call void @stw_phys(i64 %178, i32 %180) nounwind
<   %181 = add i64 %177, 1080
<   %182 = getelementptr inbounds %struct.CPUX86State* %175, i64 0, i32 10, i64 3, i32 1
<   %183 = load i32* %182, align 4
<   %184 = zext i32 %183 to i64
<   tail call void @stq_phys(i64 %181, i64 %184) nounwind
<   %185 = add i64 %177, 1076
<   %186 = getelementptr inbounds %struct.CPUX86State* %175, i64 0, i32 10, i64 3, i32 2
<   %187 = load i32* %186, align 4
<   tail call void @stl_phys(i64 %185, i32 %187) nounwind
<   %188 = add i64 %177, 1074
<   %189 = getelementptr inbounds %struct.CPUX86State* %175, i64 0, i32 10, i64 3, i32 3
<   %190 = load i32* %189, align 4
<   %191 = lshr i32 %190, 8
<   %192 = and i32 %191, 255
<   %193 = lshr i32 %190, 12
<   %194 = and i32 %193, 3840
<   %195 = or i32 %192, %194
<   tail call void @stw_phys(i64 %188, i32 %195) nounwind
<   %196 = load %struct.CPUX86State** @env, align 8
<   %197 = getelementptr inbounds %struct.CPUX86State* %196, i64 0, i32 38
<   %198 = load i64* %197, align 8
<   %199 = add i64 %198, 1400
<   %200 = getelementptr inbounds %struct.CPUX86State* %196, i64 0, i32 5
<   %201 = load i32* %200, align 4
<   %202 = add i32 %201, %next_eip_addend
<   %203 = zext i32 %202 to i64
<   tail call void @stq_phys(i64 %199, i64 %203) nounwind
<   %204 = load %struct.CPUX86State** @env, align 8
<   %205 = getelementptr inbounds %struct.CPUX86State* %204, i64 0, i32 38
<   %206 = load i64* %205, align 8
<   %207 = add i64 %206, 1496
<   %208 = getelementptr inbounds %struct.CPUX86State* %204, i64 0, i32 0, i64 4
<   %209 = load i32* %208, align 4
<   %210 = zext i32 %209 to i64
<   tail call void @stq_phys(i64 %207, i64 %210) nounwind
<   %211 = load %struct.CPUX86State** @env, align 8
<   %212 = getelementptr inbounds %struct.CPUX86State* %211, i64 0, i32 38
<   %213 = load i64* %212, align 8
<   %214 = add i64 %213, 1528
<   %215 = getelementptr inbounds %struct.CPUX86State* %211, i64 0, i32 0, i64 0
<   %216 = load i32* %215, align 4
<   %217 = zext i32 %216 to i64
<   tail call void @stq_phys(i64 %214, i64 %217) nounwind
<   %218 = load %struct.CPUX86State** @env, align 8
<   %219 = getelementptr inbounds %struct.CPUX86State* %218, i64 0, i32 39
<   %220 = load i64* %219, align 8
<   %221 = add i64 %220, 12
<   %222 = tail call i64 @ldq_phys(i64 %221) nounwind
<   %223 = load %struct.CPUX86State** @env, align 8
<   %224 = getelementptr inbounds %struct.CPUX86State* %223, i64 0, i32 41
<   store i64 %222, i64* %224, align 8
<   %225 = load %struct.CPUX86State** @env, align 8
<   %226 = getelementptr inbounds %struct.CPUX86State* %225, i64 0, i32 39
<   %227 = load i64* %226, align 8
<   %228 = tail call i32 @lduw_phys(i64 %227) nounwind
<   %229 = trunc i32 %228 to i16
<   %230 = load %struct.CPUX86State** @env, align 8
<   %231 = getelementptr inbounds %struct.CPUX86State* %230, i64 0, i32 42
<   store i16 %229, i16* %231, align 2
<   %232 = load %struct.CPUX86State** @env, align 8
<   %233 = getelementptr inbounds %struct.CPUX86State* %232, i64 0, i32 39
<   %234 = load i64* %233, align 8
<   %235 = add i64 %234, 2
<   %236 = tail call i32 @lduw_phys(i64 %235) nounwind
<   %237 = trunc i32 %236 to i16
<   %238 = load %struct.CPUX86State** @env, align 8
<   %239 = getelementptr inbounds %struct.CPUX86State* %238, i64 0, i32 43
<   store i16 %237, i16* %239, align 2
<   %240 = load %struct.CPUX86State** @env, align 8
<   %241 = getelementptr inbounds %struct.CPUX86State* %240, i64 0, i32 39
<   %242 = load i64* %241, align 8
<   %243 = add i64 %242, 4
<   %244 = tail call i32 @lduw_phys(i64 %243) nounwind
<   %245 = trunc i32 %244 to i16
<   %246 = load %struct.CPUX86State** @env, align 8
<   %247 = getelementptr inbounds %struct.CPUX86State* %246, i64 0, i32 44
<   store i16 %245, i16* %247, align 2
<   %248 = load %struct.CPUX86State** @env, align 8
<   %249 = getelementptr inbounds %struct.CPUX86State* %248, i64 0, i32 39
<   %250 = load i64* %249, align 8
<   %251 = add i64 %250, 6
<   %252 = tail call i32 @lduw_phys(i64 %251) nounwind
<   %253 = trunc i32 %252 to i16
<   %254 = load %struct.CPUX86State** @env, align 8
<   %255 = getelementptr inbounds %struct.CPUX86State* %254, i64 0, i32 45
<   store i16 %253, i16* %255, align 2
<   %256 = load %struct.CPUX86State** @env, align 8
<   %257 = getelementptr inbounds %struct.CPUX86State* %256, i64 0, i32 39
<   %258 = load i64* %257, align 8
<   %259 = add i64 %258, 8
<   %260 = tail call i32 @ldl_phys(i64 %259) nounwind
<   %261 = load %struct.CPUX86State** @env, align 8
<   %262 = getelementptr inbounds %struct.CPUX86State* %261, i64 0, i32 46
<   store i32 %260, i32* %262, align 4
<   %263 = load %struct.CPUX86State** @env, align 8
<   %264 = getelementptr inbounds %struct.CPUX86State* %263, i64 0, i32 8
<   %265 = load i32* %264, align 4
<   %266 = or i32 %265, 2097152
<   store i32 %266, i32* %264, align 4
<   %267 = load %struct.CPUX86State** @env, align 8
<   %268 = getelementptr inbounds %struct.CPUX86State* %267, i64 0, i32 39
<   %269 = load i64* %268, align 8
<   %270 = add i64 %269, 80
<   %271 = tail call i64 @ldq_phys(i64 %270) nounwind
<   %272 = load %struct.CPUX86State** @env, align 8
<   %273 = getelementptr inbounds %struct.CPUX86State* %272, i64 0, i32 40
<   store i64 %271, i64* %273, align 8
<   %274 = load %struct.CPUX86State** @env, align 8
<   %275 = getelementptr inbounds %struct.CPUX86State* %274, i64 0, i32 39
<   %276 = load i64* %275, align 8
<   %277 = add i64 %276, 1128
<   %278 = tail call i64 @ldq_phys(i64 %277) nounwind
<   %279 = trunc i64 %278 to i32
<   %280 = load %struct.CPUX86State** @env, align 8
<   %281 = getelementptr inbounds %struct.CPUX86State* %280, i64 0, i32 13, i32 1
<   store i32 %279, i32* %281, align 4
<   %282 = load %struct.CPUX86State** @env, align 8
<   %283 = getelementptr inbounds %struct.CPUX86State* %282, i64 0, i32 39
<   %284 = load i64* %283, align 8
<   %285 = add i64 %284, 1124
<   %286 = tail call i32 @ldl_phys(i64 %285) nounwind
<   %287 = load %struct.CPUX86State** @env, align 8
<   %288 = getelementptr inbounds %struct.CPUX86State* %287, i64 0, i32 13, i32 2
<   store i32 %286, i32* %288, align 4
<   %289 = load %struct.CPUX86State** @env, align 8
<   %290 = getelementptr inbounds %struct.CPUX86State* %289, i64 0, i32 39
<   %291 = load i64* %290, align 8
<   %292 = add i64 %291, 1160
<   %293 = tail call i64 @ldq_phys(i64 %292) nounwind
<   %294 = trunc i64 %293 to i32
<   %295 = load %struct.CPUX86State** @env, align 8
<   %296 = getelementptr inbounds %struct.CPUX86State* %295, i64 0, i32 14, i32 1
<   store i32 %294, i32* %296, align 4
<   %297 = load %struct.CPUX86State** @env, align 8
<   %298 = getelementptr inbounds %struct.CPUX86State* %297, i64 0, i32 39
<   %299 = load i64* %298, align 8
<   %300 = add i64 %299, 1156
<   %301 = tail call i32 @ldl_phys(i64 %300) nounwind
<   %302 = load %struct.CPUX86State** @env, align 8
<   %303 = getelementptr inbounds %struct.CPUX86State* %302, i64 0, i32 14, i32 2
<   store i32 %301, i32* %303, align 4
<   %304 = load %struct.CPUX86State** @env, align 8
<   %305 = getelementptr inbounds %struct.CPUX86State* %304, i64 0, i32 39
<   %306 = load i64* %305, align 8
<   %307 = add i64 %306, 128
<   tail call void @stq_phys(i64 %307, i64 0) nounwind
<   %308 = load %struct.CPUX86State** @env, align 8
<   %309 = getelementptr inbounds %struct.CPUX86State* %308, i64 0, i32 39
<   %310 = load i64* %309, align 8
<   %311 = add i64 %310, 1368
<   %312 = tail call i64 @ldq_phys(i64 %311) nounwind
<   %313 = trunc i64 %312 to i32
<   tail call void @cpu_x86_update_cr0(%struct.CPUX86State* %308, i32 %313) nounwind
<   %314 = load %struct.CPUX86State** @env, align 8
<   %315 = getelementptr inbounds %struct.CPUX86State* %314, i64 0, i32 39
<   %316 = load i64* %315, align 8
<   %317 = add i64 %316, 1352
<   %318 = tail call i64 @ldq_phys(i64 %317) nounwind
<   %319 = trunc i64 %318 to i32
<   tail call void @cpu_x86_update_cr4(%struct.CPUX86State* %314, i32 %319) nounwind
<   %320 = load %struct.CPUX86State** @env, align 8
<   %321 = getelementptr inbounds %struct.CPUX86State* %320, i64 0, i32 39
<   %322 = load i64* %321, align 8
<   %323 = add i64 %322, 1360
<   %324 = tail call i64 @ldq_phys(i64 %323) nounwind
<   %325 = trunc i64 %324 to i32
<   tail call void @cpu_x86_update_cr3(%struct.CPUX86State* %320, i32 %325) nounwind
<   %326 = load %struct.CPUX86State** @env, align 8
<   %327 = getelementptr inbounds %struct.CPUX86State* %326, i64 0, i32 39
<   %328 = load i64* %327, align 8
<   %329 = add i64 %328, 1600
<   %330 = tail call i64 @ldq_phys(i64 %329) nounwind
<   %331 = trunc i64 %330 to i32
<   %332 = load %struct.CPUX86State** @env, align 8
<   %333 = getelementptr inbounds %struct.CPUX86State* %332, i64 0, i32 15, i64 2
<   store i32 %331, i32* %333, align 4
<   %334 = load %struct.CPUX86State** @env, align 8
<   %335 = getelementptr inbounds %struct.CPUX86State* %334, i64 0, i32 39
<   %336 = load i64* %335, align 8
<   %337 = add i64 %336, 96
<   %338 = tail call i32 @ldl_phys(i64 %337) nounwind
<   %339 = load %struct.CPUX86State** @env, align 8
<   %340 = getelementptr inbounds %struct.CPUX86State* %339, i64 0, i32 9
<   %341 = load i32* %340, align 4
<   %342 = and i32 %341, -11
<   store i32 %342, i32* %340, align 4
<   %343 = and i32 %338, 16777216
<   %344 = icmp eq i32 %343, 0
<   br i1 %344, label %._crit_edge23, label %345
< 
< ; <label>:345                                     ; preds = %19
<   %.tr = trunc i32 %338 to i8
<   %346 = and i8 %.tr, 15
<   %347 = load %struct.CPUX86State** @env, align 8
<   %348 = getelementptr inbounds %struct.CPUX86State* %347, i64 0, i32 47
<   store i8 %346, i8* %348, align 1
<   %349 = load %struct.CPUX86State** @env, align 8
<   %350 = getelementptr inbounds %struct.CPUX86State* %349, i64 0, i32 9
<   %351 = load i32* %350, align 4
<   %352 = or i32 %351, 8
<   store i32 %352, i32* %350, align 4
<   %353 = load %struct.CPUX86State** @env, align 8
<   %354 = getelementptr inbounds %struct.CPUX86State* %353, i64 0, i32 7
<   %355 = load i32* %354, align 4
<   %356 = and i32 %355, 512
<   %357 = icmp eq i32 %356, 0
<   br i1 %357, label %._crit_edge23, label %358
< 
< ; <label>:358                                     ; preds = %345
<   %359 = getelementptr inbounds %struct.CPUX86State* %353, i64 0, i32 9
<   %360 = load i32* %359, align 4
<   %361 = or i32 %360, 2
<   store i32 %361, i32* %359, align 4
<   br label %._crit_edge23
< 
< ._crit_edge23:                                    ; preds = %358, %345, %19
<   %362 = load %struct.CPUX86State** @env, align 8
<   %363 = getelementptr inbounds %struct.CPUX86State* %362, i64 0, i32 39
<   %364 = load i64* %363, align 8
<   %365 = add i64 %364, 1232
<   %366 = tail call i64 @ldq_phys(i64 %365) nounwind
<   %367 = getelementptr inbounds %struct.CPUX86State* %362, i64 0, i32 36
<   store i64 %366, i64* %367, align 8
<   %368 = getelementptr inbounds %struct.CPUX86State* %362, i64 0, i32 8
<   %369 = load i32* %368, align 4
<   %370 = and i32 %369, -1064961
<   %371 = and i64 %366, 1024
<   %372 = icmp eq i64 %371, 0
<   %373 = or i32 %370, 16384
<   %storemerge.i = select i1 %372, i32 %370, i32 %373
<   %374 = and i64 %366, 4096
<   %375 = icmp eq i64 %374, 0
<   %376 = or i32 %storemerge.i, 1048576
<   %storemerge..i = select i1 %375, i32 %storemerge.i, i32 %376
<   store i32 %storemerge..i, i32* %368, align 4
<   %377 = load %struct.CPUX86State** @env, align 8
<   %378 = getelementptr inbounds %struct.CPUX86State* %377, i64 0, i32 7
<   store i32 0, i32* %378, align 4
<   %379 = load %struct.CPUX86State** @env, align 8
<   %380 = getelementptr inbounds %struct.CPUX86State* %379, i64 0, i32 39
<   %381 = load i64* %380, align 8
<   %382 = add i64 %381, 1392
<   %383 = tail call i64 @ldq_phys(i64 %382) nounwind
<   %384 = trunc i64 %383 to i32
<   %385 = and i32 %384, 2261
<   %386 = load %struct.CPUX86State** @env, align 8
<   %387 = getelementptr inbounds %struct.CPUX86State* %386, i64 0, i32 2
<   store i32 %385, i32* %387, align 4
<   %388 = lshr i32 %384, 9
<   %389 = and i32 %388, 2
<   %390 = xor i32 %389, 2
<   %391 = add i32 %390, -1
<   %392 = load %struct.CPUX86State** @env, align 8
<   %393 = getelementptr inbounds %struct.CPUX86State* %392, i64 0, i32 6
<   store i32 %391, i32* %393, align 4
<   %394 = load %struct.CPUX86State** @env, align 8
<   %395 = getelementptr inbounds %struct.CPUX86State* %394, i64 0, i32 7
<   %396 = load i32* %395, align 4
<   %397 = and i32 %396, 3285
<   %398 = and i32 %384, -3286
<   %399 = or i32 %397, %398
<   store i32 %399, i32* %395, align 4
<   %400 = load %struct.CPUX86State** @env, align 8
<   %401 = getelementptr inbounds %struct.CPUX86State* %400, i64 0, i32 1
<   store i32 1, i32* %401, align 4
<   %402 = load %struct.CPUX86State** @env, align 8
<   %403 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 39
<   %404 = load i64* %403, align 8
<   %405 = add i64 %404, 1024
<   %406 = tail call i32 @lduw_phys(i64 %405) nounwind
<   %407 = add i64 %404, 1032
<   %408 = tail call i64 @ldq_phys(i64 %407) nounwind
<   %409 = trunc i64 %408 to i32
<   %410 = add i64 %404, 1028
<   %411 = tail call i32 @ldl_phys(i64 %410) nounwind
<   %412 = add i64 %404, 1026
<   %413 = tail call i32 @lduw_phys(i64 %412) nounwind
<   %414 = shl i32 %413, 8
<   %415 = and i32 %414, 65280
<   %416 = shl i32 %413, 12
<   %417 = and i32 %416, 15728640
<   %418 = or i32 %415, %417
<   %419 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 10, i64 0, i32 0
<   store i32 %406, i32* %419, align 4
<   %420 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 10, i64 0, i32 1
<   store i32 %409, i32* %420, align 4
<   %421 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 10, i64 0, i32 2
<   store i32 %411, i32* %421, align 4
<   %422 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 10, i64 0, i32 3
<   store i32 %418, i32* %422, align 4
<   %.phi.trans.insert.i.i = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 8
<   %.pre.i.i = load i32* %.phi.trans.insert.i.i, align 4
<   %423 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 10, i64 2, i32 3
<   %424 = load i32* %423, align 4
<   %425 = lshr i32 %424, 17
<   %426 = and i32 %425, 32
<   %427 = and i32 %.pre.i.i, 32768
<   %428 = icmp eq i32 %427, 0
<   br i1 %428, label %429, label %svm_load_seg_cache.exit
< 
< ; <label>:429                                     ; preds = %._crit_edge23
<   %430 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 15, i64 0
<   %431 = load i32* %430, align 4
<   %432 = and i32 %431, 1
<   %433 = icmp eq i32 %432, 0
<   br i1 %433, label %442, label %434
< 
< ; <label>:434                                     ; preds = %429
<   %435 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 7
<   %436 = load i32* %435, align 4
<   %437 = and i32 %436, 131072
<   %438 = icmp eq i32 %437, 0
<   br i1 %438, label %439, label %442
< 
< ; <label>:439                                     ; preds = %434
<   %440 = and i32 %.pre.i.i, 16
<   %441 = icmp eq i32 %440, 0
<   br i1 %441, label %442, label %444
---
> ; <label>:64                                      ; preds = %51
>   %65 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 4, %struct.float_status* %65)
>   %66 = load i8* %zSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %66, i32 32767, i64 -9223372036854775808)
>   br label %151
21048,21050c19556,19559
< ; <label>:442                                     ; preds = %439, %434, %429
<   %443 = or i32 %426, 64
<   br label %svm_load_seg_cache.exit
---
> ; <label>:67                                      ; preds = %48
>   %68 = load i64* %bSig, align 8
>   call void @normalizeFloatx80Subnormal(i64 %68, i32* %bExp, i64* %bSig)
>   br label %69
21052,21063c19561,19564
< ; <label>:444                                     ; preds = %439
<   %445 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 10, i64 3, i32 1
<   %446 = load i32* %445, align 4
<   %447 = or i32 %446, %409
<   %448 = getelementptr inbounds %struct.CPUX86State* %402, i64 0, i32 10, i64 2, i32 1
<   %449 = load i32* %448, align 4
<   %450 = or i32 %447, %449
<   %451 = icmp ne i32 %450, 0
<   %452 = zext i1 %451 to i32
<   %453 = shl nuw nsw i32 %452, 6
<   %454 = or i32 %453, %426
<   br label %svm_load_seg_cache.exit
---
> ; <label>:69                                      ; preds = %67, %45
>   %70 = load i32* %aExp, align 4
>   %71 = icmp eq i32 %70, 0
>   br i1 %71, label %72, label %79
21065,21183c19566,19574
< svm_load_seg_cache.exit:                          ; preds = %444, %442, %._crit_edge23
<   %new_hflags.0.i.i = phi i32 [ %426, %._crit_edge23 ], [ %443, %442 ], [ %454, %444 ]
<   %455 = and i32 %.pre.i.i, -97
<   %456 = or i32 %new_hflags.0.i.i, %455
<   store i32 %456, i32* %.phi.trans.insert.i.i, align 4
<   %457 = load %struct.CPUX86State** @env, align 8
<   %458 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 39
<   %459 = load i64* %458, align 8
<   %460 = add i64 %459, 1040
<   %461 = tail call i32 @lduw_phys(i64 %460) nounwind
<   %462 = add i64 %459, 1048
<   %463 = tail call i64 @ldq_phys(i64 %462) nounwind
<   %464 = trunc i64 %463 to i32
<   %465 = add i64 %459, 1044
<   %466 = tail call i32 @ldl_phys(i64 %465) nounwind
<   %467 = add i64 %459, 1042
<   %468 = tail call i32 @lduw_phys(i64 %467) nounwind
<   %469 = shl i32 %468, 8
<   %470 = and i32 %469, 65280
<   %471 = shl i32 %468, 12
<   %472 = and i32 %471, 15728640
<   %473 = or i32 %470, %472
<   %474 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 10, i64 1, i32 0
<   store i32 %461, i32* %474, align 4
<   %475 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 10, i64 1, i32 1
<   store i32 %464, i32* %475, align 4
<   %476 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 10, i64 1, i32 2
<   store i32 %466, i32* %476, align 4
<   %477 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 10, i64 1, i32 3
<   store i32 %473, i32* %477, align 4
<   %478 = lshr exact i32 %472, 18
<   %479 = and i32 %478, 16
<   %480 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 8
<   %481 = load i32* %480, align 4
<   %482 = and i32 %481, -32785
<   %483 = or i32 %479, %482
<   store i32 %483, i32* %480, align 4
<   %484 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 10, i64 2, i32 3
<   %485 = load i32* %484, align 4
<   %486 = lshr i32 %485, 17
<   %487 = and i32 %486, 32
<   %488 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 15, i64 0
<   %489 = load i32* %488, align 4
<   %490 = and i32 %489, 1
<   %491 = icmp eq i32 %490, 0
<   br i1 %491, label %498, label %492
< 
< ; <label>:492                                     ; preds = %svm_load_seg_cache.exit
<   %493 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 7
<   %494 = load i32* %493, align 4
<   %495 = and i32 %494, 131072
<   %496 = icmp ne i32 %495, 0
<   %497 = icmp eq i32 %479, 0
<   %or.cond = or i1 %496, %497
<   br i1 %or.cond, label %498, label %500
< 
< ; <label>:498                                     ; preds = %492, %svm_load_seg_cache.exit
<   %499 = or i32 %487, 64
<   br label %svm_load_seg_cache.exit14
< 
< ; <label>:500                                     ; preds = %492
<   %501 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 10, i64 3, i32 1
<   %502 = load i32* %501, align 4
<   %503 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 10, i64 0, i32 1
<   %504 = load i32* %503, align 4
<   %505 = or i32 %504, %502
<   %506 = getelementptr inbounds %struct.CPUX86State* %457, i64 0, i32 10, i64 2, i32 1
<   %507 = load i32* %506, align 4
<   %508 = or i32 %505, %507
<   %509 = icmp ne i32 %508, 0
<   %510 = zext i1 %509 to i32
<   %511 = shl nuw nsw i32 %510, 6
<   %512 = or i32 %511, %487
<   br label %svm_load_seg_cache.exit14
< 
< svm_load_seg_cache.exit14:                        ; preds = %500, %498
<   %new_hflags.0.i.i13 = phi i32 [ %499, %498 ], [ %512, %500 ]
<   %513 = and i32 %483, -32865
<   %514 = or i32 %new_hflags.0.i.i13, %513
<   store i32 %514, i32* %480, align 4
<   %515 = load %struct.CPUX86State** @env, align 8
<   %516 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 39
<   %517 = load i64* %516, align 8
<   %518 = add i64 %517, 1056
<   %519 = tail call i32 @lduw_phys(i64 %518) nounwind
<   %520 = add i64 %517, 1064
<   %521 = tail call i64 @ldq_phys(i64 %520) nounwind
<   %522 = trunc i64 %521 to i32
<   %523 = add i64 %517, 1060
<   %524 = tail call i32 @ldl_phys(i64 %523) nounwind
<   %525 = add i64 %517, 1058
<   %526 = tail call i32 @lduw_phys(i64 %525) nounwind
<   %527 = shl i32 %526, 8
<   %528 = and i32 %527, 65280
<   %529 = shl i32 %526, 12
<   %530 = and i32 %529, 15728640
<   %531 = or i32 %528, %530
<   %532 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 10, i64 2, i32 0
<   store i32 %519, i32* %532, align 4
<   %533 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 10, i64 2, i32 1
<   store i32 %522, i32* %533, align 4
<   %534 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 10, i64 2, i32 2
<   store i32 %524, i32* %534, align 4
<   %535 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 10, i64 2, i32 3
<   store i32 %531, i32* %535, align 4
<   %.phi.trans.insert.i.i15 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 8
<   %.pre.i.i16 = load i32* %.phi.trans.insert.i.i15, align 4
<   %536 = lshr exact i32 %530, 17
<   %537 = and i32 %536, 32
<   %538 = and i32 %.pre.i.i16, 32768
<   %539 = icmp eq i32 %538, 0
<   br i1 %539, label %540, label %svm_load_seg_cache.exit18
< 
< ; <label>:540                                     ; preds = %svm_load_seg_cache.exit14
<   %541 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 15, i64 0
<   %542 = load i32* %541, align 4
<   %543 = and i32 %542, 1
<   %544 = icmp eq i32 %543, 0
<   br i1 %544, label %553, label %545
---
> ; <label>:72                                      ; preds = %69
>   %73 = load i64* %aSig, align 8
>   %74 = icmp eq i64 %73, 0
>   br i1 %74, label %75, label %77
> 
> ; <label>:75                                      ; preds = %72
>   %76 = load i8* %zSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %76, i32 0, i64 0)
>   br label %151
21185,21391c19576,19579
< ; <label>:545                                     ; preds = %540
<   %546 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 7
<   %547 = load i32* %546, align 4
<   %548 = and i32 %547, 131072
<   %549 = icmp eq i32 %548, 0
<   br i1 %549, label %550, label %553
< 
< ; <label>:550                                     ; preds = %545
<   %551 = and i32 %.pre.i.i16, 16
<   %552 = icmp eq i32 %551, 0
<   br i1 %552, label %553, label %555
< 
< ; <label>:553                                     ; preds = %550, %545, %540
<   %554 = or i32 %537, 64
<   br label %svm_load_seg_cache.exit18
< 
< ; <label>:555                                     ; preds = %550
<   %556 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 10, i64 3, i32 1
<   %557 = load i32* %556, align 4
<   %558 = getelementptr inbounds %struct.CPUX86State* %515, i64 0, i32 10, i64 0, i32 1
<   %559 = load i32* %558, align 4
<   %560 = or i32 %557, %522
<   %561 = or i32 %560, %559
<   %562 = icmp ne i32 %561, 0
<   %563 = zext i1 %562 to i32
<   %564 = shl nuw nsw i32 %563, 6
<   %565 = or i32 %564, %537
<   br label %svm_load_seg_cache.exit18
< 
< svm_load_seg_cache.exit18:                        ; preds = %555, %553, %svm_load_seg_cache.exit14
<   %new_hflags.0.i.i17 = phi i32 [ %537, %svm_load_seg_cache.exit14 ], [ %554, %553 ], [ %565, %555 ]
<   %566 = and i32 %.pre.i.i16, -97
<   %567 = or i32 %new_hflags.0.i.i17, %566
<   store i32 %567, i32* %.phi.trans.insert.i.i15, align 4
<   %568 = load %struct.CPUX86State** @env, align 8
<   %569 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 39
<   %570 = load i64* %569, align 8
<   %571 = add i64 %570, 1072
<   %572 = tail call i32 @lduw_phys(i64 %571) nounwind
<   %573 = add i64 %570, 1080
<   %574 = tail call i64 @ldq_phys(i64 %573) nounwind
<   %575 = trunc i64 %574 to i32
<   %576 = add i64 %570, 1076
<   %577 = tail call i32 @ldl_phys(i64 %576) nounwind
<   %578 = add i64 %570, 1074
<   %579 = tail call i32 @lduw_phys(i64 %578) nounwind
<   %580 = shl i32 %579, 8
<   %581 = and i32 %580, 65280
<   %582 = shl i32 %579, 12
<   %583 = and i32 %582, 15728640
<   %584 = or i32 %581, %583
<   %585 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 10, i64 3, i32 0
<   store i32 %572, i32* %585, align 4
<   %586 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 10, i64 3, i32 1
<   store i32 %575, i32* %586, align 4
<   %587 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 10, i64 3, i32 2
<   store i32 %577, i32* %587, align 4
<   %588 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 10, i64 3, i32 3
<   store i32 %584, i32* %588, align 4
<   %.phi.trans.insert.i.i19 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 8
<   %.pre.i.i20 = load i32* %.phi.trans.insert.i.i19, align 4
<   %589 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 10, i64 2, i32 3
<   %590 = load i32* %589, align 4
<   %591 = lshr i32 %590, 17
<   %592 = and i32 %591, 32
<   %593 = and i32 %.pre.i.i20, 32768
<   %594 = icmp eq i32 %593, 0
<   br i1 %594, label %595, label %svm_load_seg_cache.exit22
< 
< ; <label>:595                                     ; preds = %svm_load_seg_cache.exit18
<   %596 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 15, i64 0
<   %597 = load i32* %596, align 4
<   %598 = and i32 %597, 1
<   %599 = icmp eq i32 %598, 0
<   br i1 %599, label %608, label %600
< 
< ; <label>:600                                     ; preds = %595
<   %601 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 7
<   %602 = load i32* %601, align 4
<   %603 = and i32 %602, 131072
<   %604 = icmp eq i32 %603, 0
<   br i1 %604, label %605, label %608
< 
< ; <label>:605                                     ; preds = %600
<   %606 = and i32 %.pre.i.i20, 16
<   %607 = icmp eq i32 %606, 0
<   br i1 %607, label %608, label %610
< 
< ; <label>:608                                     ; preds = %605, %600, %595
<   %609 = or i32 %592, 64
<   br label %svm_load_seg_cache.exit22
< 
< ; <label>:610                                     ; preds = %605
<   %611 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 10, i64 0, i32 1
<   %612 = load i32* %611, align 4
<   %613 = or i32 %612, %575
<   %614 = getelementptr inbounds %struct.CPUX86State* %568, i64 0, i32 10, i64 2, i32 1
<   %615 = load i32* %614, align 4
<   %616 = or i32 %613, %615
<   %617 = icmp ne i32 %616, 0
<   %618 = zext i1 %617 to i32
<   %619 = shl nuw nsw i32 %618, 6
<   %620 = or i32 %619, %592
<   br label %svm_load_seg_cache.exit22
< 
< svm_load_seg_cache.exit22:                        ; preds = %610, %608, %svm_load_seg_cache.exit18
<   %new_hflags.0.i.i21 = phi i32 [ %592, %svm_load_seg_cache.exit18 ], [ %609, %608 ], [ %620, %610 ]
<   %621 = and i32 %.pre.i.i20, -97
<   %622 = or i32 %new_hflags.0.i.i21, %621
<   store i32 %622, i32* %.phi.trans.insert.i.i19, align 4
<   %623 = load %struct.CPUX86State** @env, align 8
<   %624 = getelementptr inbounds %struct.CPUX86State* %623, i64 0, i32 39
<   %625 = load i64* %624, align 8
<   %626 = add i64 %625, 1400
<   %627 = tail call i64 @ldq_phys(i64 %626) nounwind
<   %628 = trunc i64 %627 to i32
<   %629 = load %struct.CPUX86State** @env, align 8
<   %630 = getelementptr inbounds %struct.CPUX86State* %629, i64 0, i32 5
<   store i32 %628, i32* %630, align 4
<   %631 = load %struct.CPUX86State** @env, align 8
<   %632 = getelementptr inbounds %struct.CPUX86State* %631, i64 0, i32 39
<   %633 = load i64* %632, align 8
<   %634 = add i64 %633, 1496
<   %635 = tail call i64 @ldq_phys(i64 %634) nounwind
<   %636 = trunc i64 %635 to i32
<   %637 = load %struct.CPUX86State** @env, align 8
<   %638 = getelementptr inbounds %struct.CPUX86State* %637, i64 0, i32 0, i64 4
<   store i32 %636, i32* %638, align 4
<   %639 = load %struct.CPUX86State** @env, align 8
<   %640 = getelementptr inbounds %struct.CPUX86State* %639, i64 0, i32 39
<   %641 = load i64* %640, align 8
<   %642 = add i64 %641, 1528
<   %643 = tail call i64 @ldq_phys(i64 %642) nounwind
<   %644 = trunc i64 %643 to i32
<   %645 = load %struct.CPUX86State** @env, align 8
<   %646 = getelementptr inbounds %struct.CPUX86State* %645, i64 0, i32 0, i64 0
<   store i32 %644, i32* %646, align 4
<   %647 = load %struct.CPUX86State** @env, align 8
<   %648 = getelementptr inbounds %struct.CPUX86State* %647, i64 0, i32 39
<   %649 = load i64* %648, align 8
<   %650 = add i64 %649, 1376
<   %651 = tail call i64 @ldq_phys(i64 %650) nounwind
<   %652 = trunc i64 %651 to i32
<   %653 = load %struct.CPUX86State** @env, align 8
<   %654 = getelementptr inbounds %struct.CPUX86State* %653, i64 0, i32 58, i64 7
<   store i32 %652, i32* %654, align 4
<   %655 = load %struct.CPUX86State** @env, align 8
<   %656 = getelementptr inbounds %struct.CPUX86State* %655, i64 0, i32 39
<   %657 = load i64* %656, align 8
<   %658 = add i64 %657, 1384
<   %659 = tail call i64 @ldq_phys(i64 %658) nounwind
<   %660 = trunc i64 %659 to i32
<   %661 = load %struct.CPUX86State** @env, align 8
<   %662 = getelementptr inbounds %struct.CPUX86State* %661, i64 0, i32 58, i64 6
<   store i32 %660, i32* %662, align 4
<   %663 = load %struct.CPUX86State** @env, align 8
<   %664 = getelementptr inbounds %struct.CPUX86State* %663, i64 0, i32 39
<   %665 = load i64* %664, align 8
<   %666 = add i64 %665, 1227
<   %667 = tail call i32 @ldub_phys(i64 %666) nounwind
<   %668 = getelementptr inbounds %struct.CPUX86State* %663, i64 0, i32 8
<   %669 = load i32* %668, align 4
<   %670 = and i32 %669, 3
<   tail call void @s2e_on_privilege_change(i32 %670, i32 %667) nounwind
<   %671 = load i32* %668, align 4
<   %672 = and i32 %671, -4
<   %673 = or i32 %672, %667
<   store i32 %673, i32* %668, align 4
<   %674 = load %struct.CPUX86State** @env, align 8
<   %675 = getelementptr inbounds %struct.CPUX86State* %674, i64 0, i32 39
<   %676 = load i64* %675, align 8
<   %677 = add i64 %676, 92
<   %678 = tail call i32 @ldub_phys(i64 %677) nounwind
<   %cond = icmp eq i32 %678, 1
<   br i1 %cond, label %679, label %681
< 
< ; <label>:679                                     ; preds = %svm_load_seg_cache.exit22
<   %680 = load %struct.CPUX86State** @env, align 8
<   tail call void @tlb_flush(%struct.CPUX86State* %680, i32 1) nounwind
<   br label %681
< 
< ; <label>:681                                     ; preds = %679, %svm_load_seg_cache.exit22
<   %682 = load %struct.CPUX86State** @env, align 8
<   %683 = getelementptr inbounds %struct.CPUX86State* %682, i64 0, i32 9
<   %684 = load i32* %683, align 4
<   %685 = or i32 %684, 1
<   store i32 %685, i32* %683, align 4
<   %686 = and i32 %338, 256
<   %687 = icmp eq i32 %686, 0
<   br i1 %687, label %693, label %688
< 
< ; <label>:688                                     ; preds = %681
<   %689 = load %struct.CPUX86State** @env, align 8
<   %690 = getelementptr inbounds %struct.CPUX86State* %689, i64 0, i32 71
<   %691 = load i32* %690, align 4
<   %692 = or i32 %691, 256
<   store i32 %692, i32* %690, align 4
<   br label %693
< 
< ; <label>:693                                     ; preds = %688, %681
<   %694 = load %struct.CPUX86State** @env, align 8
<   %695 = getelementptr inbounds %struct.CPUX86State* %694, i64 0, i32 39
<   %696 = load i64* %695, align 8
<   %697 = add i64 %696, 168
<   %698 = tail call i32 @ldl_phys(i64 %697) nounwind
<   %699 = icmp slt i32 %698, 0
<   br i1 %699, label %700, label %800
---
> ; <label>:77                                      ; preds = %72
>   %78 = load i64* %aSig, align 8
>   call void @normalizeFloatx80Subnormal(i64 %78, i32* %aExp, i64* %aSig)
>   br label %79
21393,21417c19581,19630
< ; <label>:700                                     ; preds = %693
<   %701 = load %struct.CPUX86State** @env, align 8
<   %702 = getelementptr inbounds %struct.CPUX86State* %701, i64 0, i32 39
<   %703 = load i64* %702, align 8
<   %704 = add i64 %703, 172
<   %705 = tail call i32 @ldl_phys(i64 %704) nounwind
<   %706 = load i32* @loglevel, align 4
<   %707 = and i32 %706, 2
<   %708 = icmp eq i32 %707, 0
<   br i1 %708, label %713, label %709
< 
< ; <label>:709                                     ; preds = %700
<   %710 = and i32 %698, 2048
<   %711 = load %struct._IO_FILE** @logfile, align 8
<   %712 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %711, i8* getelementptr inbounds ([18 x i8]* @.str11, i64 0, i64 0), i32 %710) nounwind
<   br label %713
< 
< ; <label>:713                                     ; preds = %709, %700
<   %714 = and i32 %698, 1792
<   switch i32 %714, label %._crit_edge [
<     i32 0, label %715
<     i32 512, label %732
<     i32 768, label %751
<     i32 1024, label %769
<   ]
---
> ; <label>:79                                      ; preds = %77, %69
>   %80 = load i32* %aExp, align 4
>   %81 = load i32* %bExp, align 4
>   %82 = sub nsw i32 %80, %81
>   %83 = add nsw i32 %82, 16382
>   store i32 %83, i32* %zExp, align 4
>   store i64 0, i64* %rem1, align 8
>   %84 = load i64* %bSig, align 8
>   %85 = load i64* %aSig, align 8
>   %86 = icmp ule i64 %84, %85
>   br i1 %86, label %87, label %91
> 
> ; <label>:87                                      ; preds = %79
>   %88 = load i64* %aSig, align 8
>   call void @shift128Right(i64 %88, i64 0, i32 1, i64* %aSig, i64* %rem1)
>   %89 = load i32* %zExp, align 4
>   %90 = add nsw i32 %89, 1
>   store i32 %90, i32* %zExp, align 4
>   br label %91
> 
> ; <label>:91                                      ; preds = %87, %79
>   %92 = load i64* %aSig, align 8
>   %93 = load i64* %rem1, align 8
>   %94 = load i64* %bSig, align 8
>   %95 = call i64 @estimateDiv128To64(i64 %92, i64 %93, i64 %94)
>   store i64 %95, i64* %zSig0, align 8
>   %96 = load i64* %bSig, align 8
>   %97 = load i64* %zSig0, align 8
>   call void @mul64To128(i64 %96, i64 %97, i64* %term0, i64* %term1)
>   %98 = load i64* %aSig, align 8
>   %99 = load i64* %rem1, align 8
>   %100 = load i64* %term0, align 8
>   %101 = load i64* %term1, align 8
>   call void @sub128(i64 %98, i64 %99, i64 %100, i64 %101, i64* %rem0, i64* %rem1)
>   br label %102
> 
> ; <label>:102                                     ; preds = %105, %91
>   %103 = load i64* %rem0, align 8
>   %104 = icmp slt i64 %103, 0
>   br i1 %104, label %105, label %111
> 
> ; <label>:105                                     ; preds = %102
>   %106 = load i64* %zSig0, align 8
>   %107 = add i64 %106, -1
>   store i64 %107, i64* %zSig0, align 8
>   %108 = load i64* %rem0, align 8
>   %109 = load i64* %rem1, align 8
>   %110 = load i64* %bSig, align 8
>   call void @add128(i64 %108, i64 %109, i64 0, i64 %110, i64* %rem0, i64* %rem1)
>   br label %102
21419,21475c19632,19650
< ; <label>:715                                     ; preds = %713
<   %716 = and i32 %698, 255
<   %717 = load %struct.CPUX86State** @env, align 8
<   %718 = getelementptr inbounds %struct.CPUX86State* %717, i64 0, i32 92
<   store i32 %716, i32* %718, align 4
<   %719 = load %struct.CPUX86State** @env, align 8
<   %720 = getelementptr inbounds %struct.CPUX86State* %719, i64 0, i32 55
<   store i32 %705, i32* %720, align 4
<   %721 = load %struct.CPUX86State** @env, align 8
<   %722 = getelementptr inbounds %struct.CPUX86State* %721, i64 0, i32 56
<   store i32 0, i32* %722, align 4
<   %723 = load %struct.CPUX86State** @env, align 8
<   %724 = getelementptr inbounds %struct.CPUX86State* %723, i64 0, i32 57
<   store i32 -1, i32* %724, align 4
<   %725 = load i32* @loglevel, align 4
<   %726 = and i32 %725, 2
<   %727 = icmp eq i32 %726, 0
<   br i1 %727, label %731, label %728
< 
< ; <label>:728                                     ; preds = %715
<   %729 = load %struct._IO_FILE** @logfile, align 8
<   %730 = tail call i64 @fwrite(i8* getelementptr inbounds ([5 x i8]* @.str12, i64 0, i64 0), i64 4, i64 1, %struct._IO_FILE* %729)
<   br label %731
< 
< ; <label>:731                                     ; preds = %728, %715
<   tail call void @do_interrupt_all(i32 %716, i32 0, i32 0, i32 0, i32 1) nounwind
<   br label %._crit_edge
< 
< ; <label>:732                                     ; preds = %713
<   %733 = load %struct.CPUX86State** @env, align 8
<   %734 = getelementptr inbounds %struct.CPUX86State* %733, i64 0, i32 92
<   store i32 2, i32* %734, align 4
<   %735 = load %struct.CPUX86State** @env, align 8
<   %736 = getelementptr inbounds %struct.CPUX86State* %735, i64 0, i32 55
<   store i32 %705, i32* %736, align 4
<   %737 = load %struct.CPUX86State** @env, align 8
<   %738 = getelementptr inbounds %struct.CPUX86State* %737, i64 0, i32 56
<   store i32 0, i32* %738, align 4
<   %739 = load %struct.CPUX86State** @env, align 8
<   %740 = getelementptr inbounds %struct.CPUX86State* %739, i64 0, i32 5
<   %741 = load i32* %740, align 4
<   %742 = getelementptr inbounds %struct.CPUX86State* %739, i64 0, i32 57
<   store i32 %741, i32* %742, align 4
<   %743 = load i32* @loglevel, align 4
<   %744 = and i32 %743, 2
<   %745 = icmp eq i32 %744, 0
<   br i1 %745, label %749, label %746
< 
< ; <label>:746                                     ; preds = %732
<   %747 = load %struct._IO_FILE** @logfile, align 8
<   %748 = tail call i64 @fwrite(i8* getelementptr inbounds ([4 x i8]* @.str13, i64 0, i64 0), i64 3, i64 1, %struct._IO_FILE* %747)
<   br label %749
< 
< ; <label>:749                                     ; preds = %746, %732
<   %750 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_loop_exit(%struct.CPUX86State* %750) noreturn nounwind
<   unreachable
---
> ; <label>:111                                     ; preds = %102
>   %112 = load i64* %rem1, align 8
>   %113 = load i64* %bSig, align 8
>   %114 = call i64 @estimateDiv128To64(i64 %112, i64 0, i64 %113)
>   store i64 %114, i64* %zSig1, align 8
>   %115 = load i64* %zSig1, align 8
>   %116 = shl i64 %115, 1
>   %117 = icmp ule i64 %116, 8
>   br i1 %117, label %118, label %142
> 
> ; <label>:118                                     ; preds = %111
>   %119 = load i64* %bSig, align 8
>   %120 = load i64* %zSig1, align 8
>   call void @mul64To128(i64 %119, i64 %120, i64* %term1, i64* %term2)
>   %121 = load i64* %rem1, align 8
>   %122 = load i64* %term1, align 8
>   %123 = load i64* %term2, align 8
>   call void @sub128(i64 %121, i64 0, i64 %122, i64 %123, i64* %rem1, i64* %rem2)
>   br label %124
21477,21504c19652,19655
< ; <label>:751                                     ; preds = %713
<   %752 = and i32 %698, 255
<   %753 = load %struct.CPUX86State** @env, align 8
<   %754 = getelementptr inbounds %struct.CPUX86State* %753, i64 0, i32 92
<   store i32 %752, i32* %754, align 4
<   %755 = load %struct.CPUX86State** @env, align 8
<   %756 = getelementptr inbounds %struct.CPUX86State* %755, i64 0, i32 55
<   store i32 %705, i32* %756, align 4
<   %757 = load %struct.CPUX86State** @env, align 8
<   %758 = getelementptr inbounds %struct.CPUX86State* %757, i64 0, i32 56
<   store i32 0, i32* %758, align 4
<   %759 = load %struct.CPUX86State** @env, align 8
<   %760 = getelementptr inbounds %struct.CPUX86State* %759, i64 0, i32 57
<   store i32 -1, i32* %760, align 4
<   %761 = load i32* @loglevel, align 4
<   %762 = and i32 %761, 2
<   %763 = icmp eq i32 %762, 0
<   br i1 %763, label %767, label %764
< 
< ; <label>:764                                     ; preds = %751
<   %765 = load %struct._IO_FILE** @logfile, align 8
<   %766 = tail call i64 @fwrite(i8* getelementptr inbounds ([6 x i8]* @.str14, i64 0, i64 0), i64 5, i64 1, %struct._IO_FILE* %765)
<   br label %767
< 
< ; <label>:767                                     ; preds = %764, %751
<   %768 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_loop_exit(%struct.CPUX86State* %768) noreturn nounwind
<   unreachable
---
> ; <label>:124                                     ; preds = %127, %118
>   %125 = load i64* %rem1, align 8
>   %126 = icmp slt i64 %125, 0
>   br i1 %126, label %127, label %133
21506,21535c19657,19665
< ; <label>:769                                     ; preds = %713
<   %770 = and i32 %698, 255
<   %771 = load %struct.CPUX86State** @env, align 8
<   %772 = getelementptr inbounds %struct.CPUX86State* %771, i64 0, i32 92
<   store i32 %770, i32* %772, align 4
<   %773 = load %struct.CPUX86State** @env, align 8
<   %774 = getelementptr inbounds %struct.CPUX86State* %773, i64 0, i32 55
<   store i32 %705, i32* %774, align 4
<   %775 = load %struct.CPUX86State** @env, align 8
<   %776 = getelementptr inbounds %struct.CPUX86State* %775, i64 0, i32 56
<   store i32 1, i32* %776, align 4
<   %777 = load %struct.CPUX86State** @env, align 8
<   %778 = getelementptr inbounds %struct.CPUX86State* %777, i64 0, i32 5
<   %779 = load i32* %778, align 4
<   %780 = getelementptr inbounds %struct.CPUX86State* %777, i64 0, i32 57
<   store i32 %779, i32* %780, align 4
<   %781 = load i32* @loglevel, align 4
<   %782 = and i32 %781, 2
<   %783 = icmp eq i32 %782, 0
<   br i1 %783, label %787, label %784
< 
< ; <label>:784                                     ; preds = %769
<   %785 = load %struct._IO_FILE** @logfile, align 8
<   %786 = tail call i64 @fwrite(i8* getelementptr inbounds ([5 x i8]* @.str15, i64 0, i64 0), i64 4, i64 1, %struct._IO_FILE* %785)
<   br label %787
< 
< ; <label>:787                                     ; preds = %784, %769
<   %788 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_loop_exit(%struct.CPUX86State* %788) noreturn nounwind
<   unreachable
---
> ; <label>:127                                     ; preds = %124
>   %128 = load i64* %zSig1, align 8
>   %129 = add i64 %128, -1
>   store i64 %129, i64* %zSig1, align 8
>   %130 = load i64* %rem1, align 8
>   %131 = load i64* %rem2, align 8
>   %132 = load i64* %bSig, align 8
>   call void @add128(i64 %130, i64 %131, i64 0, i64 %132, i64* %rem1, i64* %rem2)
>   br label %124
21537,21551c19667,19689
< ._crit_edge:                                      ; preds = %731, %713
<   %789 = load i32* @loglevel, align 4
<   %790 = and i32 %789, 2
<   %791 = icmp eq i32 %790, 0
<   br i1 %791, label %800, label %792
< 
< ; <label>:792                                     ; preds = %._crit_edge
<   %793 = load %struct._IO_FILE** @logfile, align 8
<   %794 = load %struct.CPUX86State** @env, align 8
<   %795 = getelementptr inbounds %struct.CPUX86State* %794, i64 0, i32 92
<   %796 = load i32* %795, align 4
<   %797 = getelementptr inbounds %struct.CPUX86State* %794, i64 0, i32 55
<   %798 = load i32* %797, align 4
<   %799 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %793, i8* getelementptr inbounds ([10 x i8]* @.str16, i64 0, i64 0), i32 %796, i32 %798) nounwind
<   br label %800
---
> ; <label>:133                                     ; preds = %124
>   %134 = load i64* %rem1, align 8
>   %135 = load i64* %rem2, align 8
>   %136 = or i64 %134, %135
>   %137 = icmp ne i64 %136, 0
>   %138 = zext i1 %137 to i32
>   %139 = sext i32 %138 to i64
>   %140 = load i64* %zSig1, align 8
>   %141 = or i64 %140, %139
>   store i64 %141, i64* %zSig1, align 8
>   br label %142
> 
> ; <label>:142                                     ; preds = %133, %111
>   %143 = load %struct.float_status** %1, align 4
>   %144 = getelementptr inbounds %struct.float_status* %143, i32 0, i32 3
>   %145 = load i8* %144, align 1
>   %146 = load i8* %zSign, align 1
>   %147 = load i32* %zExp, align 4
>   %148 = load i64* %zSig0, align 8
>   %149 = load i64* %zSig1, align 8
>   %150 = load %struct.float_status** %1, align 4
>   call void @roundAndPackFloatx80(%struct.floatx80* sret %agg.result, i8 signext %145, i8 zeroext %146, i32 %147, i64 %148, i64 %149, %struct.float_status* %150)
>   br label %151
21553c19691
< ; <label>:800                                     ; preds = %792, %._crit_edge, %693
---
> ; <label>:151                                     ; preds = %142, %75, %64, %58, %43, %41, %32, %29, %20
21557,21559c19695,19724
< declare i64 @ldq_phys(i64)
< 
< declare i32 @lduw_phys(i64)
---
> define internal void @floatx80_rem(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %expDiff = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %bSig = alloca i64, align 8
>   %q = alloca i64, align 8
>   %term0 = alloca i64, align 8
>   %term1 = alloca i64, align 8
>   %alternateASig0 = alloca i64, align 8
>   %alternateASig1 = alloca i64, align 8
>   %z = alloca %struct.floatx80, align 1
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %2, i64* %aSig0, align 8
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %3, i32* %aExp, align 4
>   %4 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %4, i8* %aSign, align 1
>   %5 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   store i64 %5, i64* %bSig, align 8
>   %6 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   store i32 %6, i32* %bExp, align 4
>   %7 = load i32* %aExp, align 4
>   %8 = icmp eq i32 %7, 32767
>   br i1 %8, label %9, label %23
21561c19726,19730
< declare i32 @ldub_phys(i64)
---
> ; <label>:9                                       ; preds = %0
>   %10 = load i64* %aSig0, align 8
>   %11 = shl i64 %10, 1
>   %12 = icmp ne i64 %11, 0
>   br i1 %12, label %20, label %13
21563c19732,19741
< declare void @tlb_flush(%struct.CPUX86State*, i32)
---
> ; <label>:13                                      ; preds = %9
>   %14 = load i32* %bExp, align 4
>   %15 = icmp eq i32 %14, 32767
>   br i1 %15, label %16, label %22
> 
> ; <label>:16                                      ; preds = %13
>   %17 = load i64* %bSig, align 8
>   %18 = shl i64 %17, 1
>   %19 = icmp ne i64 %18, 0
>   br i1 %19, label %20, label %22
21565,21571c19743,19746
< define void @helper_vmmcall() noreturn nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
---
> ; <label>:20                                      ; preds = %16, %9
>   %21 = load %struct.float_status** %1, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %21)
>   br label %213
21573,21578c19748,19749
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 8589934592
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
---
> ; <label>:22                                      ; preds = %16, %13
>   br label %42
21580,21582c19751,19765
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 129, i64 0) nounwind
<   unreachable
---
> ; <label>:23                                      ; preds = %0
>   %24 = load i32* %bExp, align 4
>   %25 = icmp eq i32 %24, 32767
>   br i1 %25, label %26, label %35
> 
> ; <label>:26                                      ; preds = %23
>   %27 = load i64* %bSig, align 8
>   %28 = shl i64 %27, 1
>   %29 = icmp ne i64 %28, 0
>   br i1 %29, label %30, label %32
> 
> ; <label>:30                                      ; preds = %26
>   %31 = load %struct.float_status** %1, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %31)
>   br label %213
21584,21587c19767,19771
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   tail call fastcc void @raise_exception(i32 6) noreturn
<   unreachable
< }
---
> ; <label>:32                                      ; preds = %26
>   %33 = bitcast %struct.floatx80* %agg.result to i8*
>   %34 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %33, i8* %34, i32 10, i32 1, i1 false)
>   br label %213
21589,21595c19773,19776
< define void @helper_vmload(i32 %aflag) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
---
> ; <label>:35                                      ; preds = %23
>   %36 = load i32* %bExp, align 4
>   %37 = icmp eq i32 %36, 0
>   br i1 %37, label %38, label %50
21597,21602c19778,19781
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 17179869184
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
---
> ; <label>:38                                      ; preds = %35
>   %39 = load i64* %bSig, align 8
>   %40 = icmp eq i64 %39, 0
>   br i1 %40, label %41, label %48
21604,21606c19783,19784
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 130, i64 0) nounwind
<   unreachable
---
> ; <label>:41                                      ; preds = %38
>   br label %42
21608,21619c19786,19801
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %12 = load i32* %11, align 4
<   %13 = load i32* @loglevel, align 4
<   %14 = and i32 %13, 2
<   %15 = icmp eq i32 %14, 0
<   br i1 %15, label %helper_svm_check_intercept_param.exit._crit_edge, label %16
< 
< helper_svm_check_intercept_param.exit._crit_edge: ; preds = %helper_svm_check_intercept_param.exit
<   %.pre14 = zext i32 %12 to i64
<   %.pre15 = add i64 %.pre14, 1096
<   br label %25
---
> ; <label>:42                                      ; preds = %41, %22
>   %43 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %43)
>   %44 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 -4611686018427387904, i64* %44, align 1
>   %45 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   store i16 -1, i16* %45, align 1
>   %46 = bitcast %struct.floatx80* %agg.result to i8*
>   %47 = bitcast %struct.floatx80* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %46, i8* %47, i32 10, i32 1, i1 false)
>   br label %213
> 
> ; <label>:48                                      ; preds = %38
>   %49 = load i64* %bSig, align 8
>   call void @normalizeFloatx80Subnormal(i64 %49, i32* %bExp, i64* %bSig)
>   br label %50
21621,21631c19803,19806
< ; <label>:16                                      ; preds = %helper_svm_check_intercept_param.exit
<   %17 = load %struct._IO_FILE** @logfile, align 8
<   %18 = zext i32 %12 to i64
<   %19 = add i64 %18, 1096
<   %20 = tail call i64 @ldq_phys(i64 %19) nounwind
<   %21 = load %struct.CPUX86State** @env, align 8
<   %22 = getelementptr inbounds %struct.CPUX86State* %21, i64 0, i32 10, i64 4, i32 1
<   %23 = load i32* %22, align 4
<   %24 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %17, i8* getelementptr inbounds ([32 x i8]* @.str17, i64 0, i64 0), i32 %12, i64 %20, i32 %23) nounwind
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %25
---
> ; <label>:50                                      ; preds = %48, %35
>   %51 = load i32* %aExp, align 4
>   %52 = icmp eq i32 %51, 0
>   br i1 %52, label %53, label %62
21633,21666c19808,19843
< ; <label>:25                                      ; preds = %16, %helper_svm_check_intercept_param.exit._crit_edge
<   %.pre-phi16 = phi i64 [ %.pre15, %helper_svm_check_intercept_param.exit._crit_edge ], [ %19, %16 ]
<   %.pre-phi = phi i64 [ %.pre14, %helper_svm_check_intercept_param.exit._crit_edge ], [ %18, %16 ]
<   %26 = phi %struct.CPUX86State* [ %1, %helper_svm_check_intercept_param.exit._crit_edge ], [ %.pre, %16 ]
<   %27 = add i64 %.pre-phi, 1088
<   %28 = tail call i32 @lduw_phys(i64 %27) nounwind
<   %29 = tail call i64 @ldq_phys(i64 %.pre-phi16) nounwind
<   %30 = trunc i64 %29 to i32
<   %31 = add i64 %.pre-phi, 1092
<   %32 = tail call i32 @ldl_phys(i64 %31) nounwind
<   %33 = add i64 %.pre-phi, 1090
<   %34 = tail call i32 @lduw_phys(i64 %33) nounwind
<   %35 = shl i32 %34, 8
<   %36 = and i32 %35, 65280
<   %37 = shl i32 %34, 12
<   %38 = and i32 %37, 15728640
<   %39 = or i32 %36, %38
<   %40 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 4, i32 0
<   store i32 %28, i32* %40, align 4
<   %41 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 4, i32 1
<   store i32 %30, i32* %41, align 4
<   %42 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 4, i32 2
<   store i32 %32, i32* %42, align 4
<   %43 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 4, i32 3
<   store i32 %39, i32* %43, align 4
<   %.phi.trans.insert.i.i = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 8
<   %.pre.i.i = load i32* %.phi.trans.insert.i.i, align 4
<   %44 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 2, i32 3
<   %45 = load i32* %44, align 4
<   %46 = lshr i32 %45, 17
<   %47 = and i32 %46, 32
<   %48 = and i32 %.pre.i.i, 32768
<   %49 = icmp eq i32 %48, 0
<   br i1 %49, label %50, label %svm_load_seg_cache.exit
---
> ; <label>:53                                      ; preds = %50
>   %54 = load i64* %aSig0, align 8
>   %55 = shl i64 %54, 1
>   %56 = icmp eq i64 %55, 0
>   br i1 %56, label %57, label %60
> 
> ; <label>:57                                      ; preds = %53
>   %58 = bitcast %struct.floatx80* %agg.result to i8*
>   %59 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %58, i8* %59, i32 10, i32 1, i1 false)
>   br label %213
> 
> ; <label>:60                                      ; preds = %53
>   %61 = load i64* %aSig0, align 8
>   call void @normalizeFloatx80Subnormal(i64 %61, i32* %aExp, i64* %aSig0)
>   br label %62
> 
> ; <label>:62                                      ; preds = %60, %50
>   %63 = load i64* %bSig, align 8
>   %64 = or i64 %63, -9223372036854775808
>   store i64 %64, i64* %bSig, align 8
>   %65 = load i8* %aSign, align 1
>   store i8 %65, i8* %zSign, align 1
>   %66 = load i32* %aExp, align 4
>   %67 = load i32* %bExp, align 4
>   %68 = sub nsw i32 %66, %67
>   store i32 %68, i32* %expDiff, align 4
>   store i64 0, i64* %aSig1, align 8
>   %69 = load i32* %expDiff, align 4
>   %70 = icmp slt i32 %69, 0
>   br i1 %70, label %71, label %79
> 
> ; <label>:71                                      ; preds = %62
>   %72 = load i32* %expDiff, align 4
>   %73 = icmp slt i32 %72, -1
>   br i1 %73, label %74, label %77
21668,21673c19845,19855
< ; <label>:50                                      ; preds = %25
<   %51 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 15, i64 0
<   %52 = load i32* %51, align 4
<   %53 = and i32 %52, 1
<   %54 = icmp eq i32 %53, 0
<   br i1 %54, label %63, label %55
---
> ; <label>:74                                      ; preds = %71
>   %75 = bitcast %struct.floatx80* %agg.result to i8*
>   %76 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %75, i8* %76, i32 10, i32 1, i1 false)
>   br label %213
> 
> ; <label>:77                                      ; preds = %71
>   %78 = load i64* %aSig0, align 8
>   call void @shift128Right(i64 %78, i64 0, i32 1, i64* %aSig0, i64* %aSig1)
>   store i32 0, i32* %expDiff, align 4
>   br label %79
21675,21680c19857,19884
< ; <label>:55                                      ; preds = %50
<   %56 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 7
<   %57 = load i32* %56, align 4
<   %58 = and i32 %57, 131072
<   %59 = icmp eq i32 %58, 0
<   br i1 %59, label %60, label %63
---
> ; <label>:79                                      ; preds = %77, %62
>   %80 = load i64* %bSig, align 8
>   %81 = load i64* %aSig0, align 8
>   %82 = icmp ule i64 %80, %81
>   %83 = zext i1 %82 to i32
>   %84 = sext i32 %83 to i64
>   store i64 %84, i64* %q, align 8
>   %85 = load i64* %q, align 8
>   %86 = icmp ne i64 %85, 0
>   br i1 %86, label %87, label %91
> 
> ; <label>:87                                      ; preds = %79
>   %88 = load i64* %bSig, align 8
>   %89 = load i64* %aSig0, align 8
>   %90 = sub i64 %89, %88
>   store i64 %90, i64* %aSig0, align 8
>   br label %91
> 
> ; <label>:91                                      ; preds = %87, %79
>   %92 = load i32* %expDiff, align 4
>   %93 = sub nsw i32 %92, 64
>   store i32 %93, i32* %expDiff, align 4
>   br label %94
> 
> ; <label>:94                                      ; preds = %108, %91
>   %95 = load i32* %expDiff, align 4
>   %96 = icmp slt i32 0, %95
>   br i1 %96, label %97, label %120
21682,21685c19886,19944
< ; <label>:60                                      ; preds = %55
<   %61 = and i32 %.pre.i.i, 16
<   %62 = icmp eq i32 %61, 0
<   br i1 %62, label %63, label %65
---
> ; <label>:97                                      ; preds = %94
>   %98 = load i64* %aSig0, align 8
>   %99 = load i64* %aSig1, align 8
>   %100 = load i64* %bSig, align 8
>   %101 = call i64 @estimateDiv128To64(i64 %98, i64 %99, i64 %100)
>   store i64 %101, i64* %q, align 8
>   %102 = load i64* %q, align 8
>   %103 = icmp ult i64 2, %102
>   br i1 %103, label %104, label %107
> 
> ; <label>:104                                     ; preds = %97
>   %105 = load i64* %q, align 8
>   %106 = sub i64 %105, 2
>   br label %108
> 
> ; <label>:107                                     ; preds = %97
>   br label %108
> 
> ; <label>:108                                     ; preds = %107, %104
>   %109 = phi i64 [ %106, %104 ], [ 0, %107 ]
>   store i64 %109, i64* %q, align 8
>   %110 = load i64* %bSig, align 8
>   %111 = load i64* %q, align 8
>   call void @mul64To128(i64 %110, i64 %111, i64* %term0, i64* %term1)
>   %112 = load i64* %aSig0, align 8
>   %113 = load i64* %aSig1, align 8
>   %114 = load i64* %term0, align 8
>   %115 = load i64* %term1, align 8
>   call void @sub128(i64 %112, i64 %113, i64 %114, i64 %115, i64* %aSig0, i64* %aSig1)
>   %116 = load i64* %aSig0, align 8
>   %117 = load i64* %aSig1, align 8
>   call void @shortShift128Left(i64 %116, i64 %117, i32 62, i64* %aSig0, i64* %aSig1)
>   %118 = load i32* %expDiff, align 4
>   %119 = sub nsw i32 %118, 62
>   store i32 %119, i32* %expDiff, align 4
>   br label %94
> 
> ; <label>:120                                     ; preds = %94
>   %121 = load i32* %expDiff, align 4
>   %122 = add nsw i32 %121, 64
>   store i32 %122, i32* %expDiff, align 4
>   %123 = load i32* %expDiff, align 4
>   %124 = icmp slt i32 0, %123
>   br i1 %124, label %125, label %171
> 
> ; <label>:125                                     ; preds = %120
>   %126 = load i64* %aSig0, align 8
>   %127 = load i64* %aSig1, align 8
>   %128 = load i64* %bSig, align 8
>   %129 = call i64 @estimateDiv128To64(i64 %126, i64 %127, i64 %128)
>   store i64 %129, i64* %q, align 8
>   %130 = load i64* %q, align 8
>   %131 = icmp ult i64 2, %130
>   br i1 %131, label %132, label %135
> 
> ; <label>:132                                     ; preds = %125
>   %133 = load i64* %q, align 8
>   %134 = sub i64 %133, 2
>   br label %136
21687,21689c19946,19947
< ; <label>:63                                      ; preds = %60, %55, %50
<   %64 = or i32 %47, 64
<   br label %svm_load_seg_cache.exit
---
> ; <label>:135                                     ; preds = %125
>   br label %136
21691,21704c19949,20058
< ; <label>:65                                      ; preds = %60
<   %66 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 3, i32 1
<   %67 = load i32* %66, align 4
<   %68 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 0, i32 1
<   %69 = load i32* %68, align 4
<   %70 = or i32 %69, %67
<   %71 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 2, i32 1
<   %72 = load i32* %71, align 4
<   %73 = or i32 %70, %72
<   %74 = icmp ne i32 %73, 0
<   %75 = zext i1 %74 to i32
<   %76 = shl nuw nsw i32 %75, 6
<   %77 = or i32 %76, %47
<   br label %svm_load_seg_cache.exit
---
> ; <label>:136                                     ; preds = %135, %132
>   %137 = phi i64 [ %134, %132 ], [ 0, %135 ]
>   store i64 %137, i64* %q, align 8
>   %138 = load i32* %expDiff, align 4
>   %139 = sub nsw i32 64, %138
>   %140 = load i64* %q, align 8
>   %141 = zext i32 %139 to i64
>   %142 = lshr i64 %140, %141
>   store i64 %142, i64* %q, align 8
>   %143 = load i64* %bSig, align 8
>   %144 = load i64* %q, align 8
>   %145 = load i32* %expDiff, align 4
>   %146 = sub nsw i32 64, %145
>   %147 = zext i32 %146 to i64
>   %148 = shl i64 %144, %147
>   call void @mul64To128(i64 %143, i64 %148, i64* %term0, i64* %term1)
>   %149 = load i64* %aSig0, align 8
>   %150 = load i64* %aSig1, align 8
>   %151 = load i64* %term0, align 8
>   %152 = load i64* %term1, align 8
>   call void @sub128(i64 %149, i64 %150, i64 %151, i64 %152, i64* %aSig0, i64* %aSig1)
>   %153 = load i64* %bSig, align 8
>   %154 = load i32* %expDiff, align 4
>   %155 = sub nsw i32 64, %154
>   call void @shortShift128Left(i64 0, i64 %153, i32 %155, i64* %term0, i64* %term1)
>   br label %156
> 
> ; <label>:156                                     ; preds = %163, %136
>   %157 = load i64* %term0, align 8
>   %158 = load i64* %term1, align 8
>   %159 = load i64* %aSig0, align 8
>   %160 = load i64* %aSig1, align 8
>   %161 = call zeroext i8 @le128(i64 %157, i64 %158, i64 %159, i64 %160)
>   %162 = icmp ne i8 %161, 0
>   br i1 %162, label %163, label %170
> 
> ; <label>:163                                     ; preds = %156
>   %164 = load i64* %q, align 8
>   %165 = add i64 %164, 1
>   store i64 %165, i64* %q, align 8
>   %166 = load i64* %aSig0, align 8
>   %167 = load i64* %aSig1, align 8
>   %168 = load i64* %term0, align 8
>   %169 = load i64* %term1, align 8
>   call void @sub128(i64 %166, i64 %167, i64 %168, i64 %169, i64* %aSig0, i64* %aSig1)
>   br label %156
> 
> ; <label>:170                                     ; preds = %156
>   br label %173
> 
> ; <label>:171                                     ; preds = %120
>   store i64 0, i64* %term1, align 8
>   %172 = load i64* %bSig, align 8
>   store i64 %172, i64* %term0, align 8
>   br label %173
> 
> ; <label>:173                                     ; preds = %171, %170
>   %174 = load i64* %term0, align 8
>   %175 = load i64* %term1, align 8
>   %176 = load i64* %aSig0, align 8
>   %177 = load i64* %aSig1, align 8
>   call void @sub128(i64 %174, i64 %175, i64 %176, i64 %177, i64* %alternateASig0, i64* %alternateASig1)
>   %178 = load i64* %alternateASig0, align 8
>   %179 = load i64* %alternateASig1, align 8
>   %180 = load i64* %aSig0, align 8
>   %181 = load i64* %aSig1, align 8
>   %182 = call zeroext i8 @lt128(i64 %178, i64 %179, i64 %180, i64 %181)
>   %183 = zext i8 %182 to i32
>   %184 = icmp ne i32 %183, 0
>   br i1 %184, label %197, label %185
> 
> ; <label>:185                                     ; preds = %173
>   %186 = load i64* %alternateASig0, align 8
>   %187 = load i64* %alternateASig1, align 8
>   %188 = load i64* %aSig0, align 8
>   %189 = load i64* %aSig1, align 8
>   %190 = call zeroext i8 @eq128(i64 %186, i64 %187, i64 %188, i64 %189)
>   %191 = zext i8 %190 to i32
>   %192 = icmp ne i32 %191, 0
>   br i1 %192, label %193, label %205
> 
> ; <label>:193                                     ; preds = %185
>   %194 = load i64* %q, align 8
>   %195 = and i64 %194, 1
>   %196 = icmp ne i64 %195, 0
>   br i1 %196, label %197, label %205
> 
> ; <label>:197                                     ; preds = %193, %173
>   %198 = load i64* %alternateASig0, align 8
>   store i64 %198, i64* %aSig0, align 8
>   %199 = load i64* %alternateASig1, align 8
>   store i64 %199, i64* %aSig1, align 8
>   %200 = load i8* %zSign, align 1
>   %201 = icmp ne i8 %200, 0
>   %202 = xor i1 %201, true
>   %203 = zext i1 %202 to i32
>   %204 = trunc i32 %203 to i8
>   store i8 %204, i8* %zSign, align 1
>   br label %205
> 
> ; <label>:205                                     ; preds = %197, %193, %185
>   %206 = load i8* %zSign, align 1
>   %207 = load i32* %bExp, align 4
>   %208 = load i32* %expDiff, align 4
>   %209 = add nsw i32 %207, %208
>   %210 = load i64* %aSig0, align 8
>   %211 = load i64* %aSig1, align 8
>   %212 = load %struct.float_status** %1, align 4
>   call void @normalizeRoundAndPackFloatx80(%struct.floatx80* sret %agg.result, i8 signext 80, i8 zeroext %206, i32 %209, i64 %210, i64 %211, %struct.float_status* %212)
>   br label %213
21706,21855c20060
< svm_load_seg_cache.exit:                          ; preds = %65, %63, %25
<   %new_hflags.0.i.i = phi i32 [ %47, %25 ], [ %64, %63 ], [ %77, %65 ]
<   %78 = and i32 %.pre.i.i, -97
<   %79 = or i32 %new_hflags.0.i.i, %78
<   store i32 %79, i32* %.phi.trans.insert.i.i, align 4
<   %80 = add i64 %.pre-phi, 1104
<   %81 = load %struct.CPUX86State** @env, align 8
<   %82 = tail call i32 @lduw_phys(i64 %80) nounwind
<   %83 = add i64 %.pre-phi, 1112
<   %84 = tail call i64 @ldq_phys(i64 %83) nounwind
<   %85 = trunc i64 %84 to i32
<   %86 = add i64 %.pre-phi, 1108
<   %87 = tail call i32 @ldl_phys(i64 %86) nounwind
<   %88 = add i64 %.pre-phi, 1106
<   %89 = tail call i32 @lduw_phys(i64 %88) nounwind
<   %90 = shl i32 %89, 8
<   %91 = and i32 %90, 65280
<   %92 = shl i32 %89, 12
<   %93 = and i32 %92, 15728640
<   %94 = or i32 %91, %93
<   %95 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 10, i64 5, i32 0
<   store i32 %82, i32* %95, align 4
<   %96 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 10, i64 5, i32 1
<   store i32 %85, i32* %96, align 4
<   %97 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 10, i64 5, i32 2
<   store i32 %87, i32* %97, align 4
<   %98 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 10, i64 5, i32 3
<   store i32 %94, i32* %98, align 4
<   %.phi.trans.insert.i.i10 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 8
<   %.pre.i.i11 = load i32* %.phi.trans.insert.i.i10, align 4
<   %99 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 10, i64 2, i32 3
<   %100 = load i32* %99, align 4
<   %101 = lshr i32 %100, 17
<   %102 = and i32 %101, 32
<   %103 = and i32 %.pre.i.i11, 32768
<   %104 = icmp eq i32 %103, 0
<   br i1 %104, label %105, label %svm_load_seg_cache.exit13
< 
< ; <label>:105                                     ; preds = %svm_load_seg_cache.exit
<   %106 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 15, i64 0
<   %107 = load i32* %106, align 4
<   %108 = and i32 %107, 1
<   %109 = icmp eq i32 %108, 0
<   br i1 %109, label %118, label %110
< 
< ; <label>:110                                     ; preds = %105
<   %111 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 7
<   %112 = load i32* %111, align 4
<   %113 = and i32 %112, 131072
<   %114 = icmp eq i32 %113, 0
<   br i1 %114, label %115, label %118
< 
< ; <label>:115                                     ; preds = %110
<   %116 = and i32 %.pre.i.i11, 16
<   %117 = icmp eq i32 %116, 0
<   br i1 %117, label %118, label %120
< 
< ; <label>:118                                     ; preds = %115, %110, %105
<   %119 = or i32 %102, 64
<   br label %svm_load_seg_cache.exit13
< 
< ; <label>:120                                     ; preds = %115
<   %121 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 10, i64 3, i32 1
<   %122 = load i32* %121, align 4
<   %123 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 10, i64 0, i32 1
<   %124 = load i32* %123, align 4
<   %125 = or i32 %124, %122
<   %126 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 10, i64 2, i32 1
<   %127 = load i32* %126, align 4
<   %128 = or i32 %125, %127
<   %129 = icmp ne i32 %128, 0
<   %130 = zext i1 %129 to i32
<   %131 = shl nuw nsw i32 %130, 6
<   %132 = or i32 %131, %102
<   br label %svm_load_seg_cache.exit13
< 
< svm_load_seg_cache.exit13:                        ; preds = %120, %118, %svm_load_seg_cache.exit
<   %new_hflags.0.i.i12 = phi i32 [ %102, %svm_load_seg_cache.exit ], [ %119, %118 ], [ %132, %120 ]
<   %133 = and i32 %.pre.i.i11, -97
<   %134 = or i32 %new_hflags.0.i.i12, %133
<   store i32 %134, i32* %.phi.trans.insert.i.i10, align 4
<   %135 = add i64 %.pre-phi, 1168
<   %136 = load %struct.CPUX86State** @env, align 8
<   %137 = tail call i32 @lduw_phys(i64 %135) nounwind
<   %138 = getelementptr inbounds %struct.CPUX86State* %136, i64 0, i32 12, i32 0
<   store i32 %137, i32* %138, align 4
<   %139 = add i64 %.pre-phi, 1176
<   %140 = tail call i64 @ldq_phys(i64 %139) nounwind
<   %141 = trunc i64 %140 to i32
<   %142 = getelementptr inbounds %struct.CPUX86State* %136, i64 0, i32 12, i32 1
<   store i32 %141, i32* %142, align 4
<   %143 = add i64 %.pre-phi, 1172
<   %144 = tail call i32 @ldl_phys(i64 %143) nounwind
<   %145 = getelementptr inbounds %struct.CPUX86State* %136, i64 0, i32 12, i32 2
<   store i32 %144, i32* %145, align 4
<   %146 = add i64 %.pre-phi, 1170
<   %147 = tail call i32 @lduw_phys(i64 %146) nounwind
<   %148 = shl i32 %147, 8
<   %149 = and i32 %148, 65280
<   %150 = shl i32 %147, 12
<   %151 = and i32 %150, 15728640
<   %152 = or i32 %149, %151
<   %153 = getelementptr inbounds %struct.CPUX86State* %136, i64 0, i32 12, i32 3
<   store i32 %152, i32* %153, align 4
<   %154 = add i64 %.pre-phi, 1136
<   %155 = load %struct.CPUX86State** @env, align 8
<   %156 = tail call i32 @lduw_phys(i64 %154) nounwind
<   %157 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 11, i32 0
<   store i32 %156, i32* %157, align 4
<   %158 = add i64 %.pre-phi, 1144
<   %159 = tail call i64 @ldq_phys(i64 %158) nounwind
<   %160 = trunc i64 %159 to i32
<   %161 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 11, i32 1
<   store i32 %160, i32* %161, align 4
<   %162 = add i64 %.pre-phi, 1140
<   %163 = tail call i32 @ldl_phys(i64 %162) nounwind
<   %164 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 11, i32 2
<   store i32 %163, i32* %164, align 4
<   %165 = add i64 %.pre-phi, 1138
<   %166 = tail call i32 @lduw_phys(i64 %165) nounwind
<   %167 = shl i32 %166, 8
<   %168 = and i32 %167, 65280
<   %169 = shl i32 %166, 12
<   %170 = and i32 %169, 15728640
<   %171 = or i32 %168, %170
<   %172 = getelementptr inbounds %struct.CPUX86State* %155, i64 0, i32 11, i32 3
<   store i32 %171, i32* %172, align 4
<   %173 = add i64 %.pre-phi, 1536
<   %174 = tail call i64 @ldq_phys(i64 %173) nounwind
<   %175 = load %struct.CPUX86State** @env, align 8
<   %176 = getelementptr inbounds %struct.CPUX86State* %175, i64 0, i32 37
<   store i64 %174, i64* %176, align 8
<   %177 = add i64 %.pre-phi, 1576
<   %178 = tail call i64 @ldq_phys(i64 %177) nounwind
<   %179 = trunc i64 %178 to i32
<   %180 = load %struct.CPUX86State** @env, align 8
<   %181 = getelementptr inbounds %struct.CPUX86State* %180, i64 0, i32 33
<   store i32 %179, i32* %181, align 4
<   %182 = add i64 %.pre-phi, 1584
<   %183 = tail call i64 @ldq_phys(i64 %182) nounwind
<   %184 = trunc i64 %183 to i32
<   %185 = load %struct.CPUX86State** @env, align 8
<   %186 = getelementptr inbounds %struct.CPUX86State* %185, i64 0, i32 34
<   store i32 %184, i32* %186, align 4
<   %187 = add i64 %.pre-phi, 1592
<   %188 = tail call i64 @ldq_phys(i64 %187) nounwind
<   %189 = trunc i64 %188 to i32
<   %190 = load %struct.CPUX86State** @env, align 8
<   %191 = getelementptr inbounds %struct.CPUX86State* %190, i64 0, i32 35
<   store i32 %189, i32* %191, align 4
---
> ; <label>:213                                     ; preds = %205, %74, %57, %42, %32, %30, %20
21859,21872c20064,20076
< define void @helper_vmsave(i32 %aflag) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
< 
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 34359738368
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
---
> define internal zeroext i8 @le128(i64 %a0, i64 %a1, i64 %b0, i64 %b1) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %b0, i64* %3, align 8
>   store i64 %b1, i64* %4, align 8
>   %5 = load i64* %1, align 8
>   %6 = load i64* %3, align 8
>   %7 = icmp ult i64 %5, %6
>   br i1 %7, label %18, label %8
21874,21876c20078,20082
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 131, i64 0) nounwind
<   unreachable
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i64* %1, align 8
>   %10 = load i64* %3, align 8
>   %11 = icmp eq i64 %9, %10
>   br i1 %11, label %12, label %16
21878,21889c20084,20088
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %12 = load i32* %11, align 4
<   %13 = load i32* @loglevel, align 4
<   %14 = and i32 %13, 2
<   %15 = icmp eq i32 %14, 0
<   br i1 %15, label %helper_svm_check_intercept_param.exit._crit_edge, label %16
< 
< helper_svm_check_intercept_param.exit._crit_edge: ; preds = %helper_svm_check_intercept_param.exit
<   %.pre10 = zext i32 %12 to i64
<   %.pre11 = add i64 %.pre10, 1096
<   br label %25
---
> ; <label>:12                                      ; preds = %8
>   %13 = load i64* %2, align 8
>   %14 = load i64* %4, align 8
>   %15 = icmp ule i64 %13, %14
>   br label %16
21891,21901c20090,20092
< ; <label>:16                                      ; preds = %helper_svm_check_intercept_param.exit
<   %17 = load %struct._IO_FILE** @logfile, align 8
<   %18 = zext i32 %12 to i64
<   %19 = add i64 %18, 1096
<   %20 = tail call i64 @ldq_phys(i64 %19) nounwind
<   %21 = load %struct.CPUX86State** @env, align 8
<   %22 = getelementptr inbounds %struct.CPUX86State* %21, i64 0, i32 10, i64 4, i32 1
<   %23 = load i32* %22, align 4
<   %24 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %17, i8* getelementptr inbounds ([32 x i8]* @.str18, i64 0, i64 0), i32 %12, i64 %20, i32 %23) nounwind
<   %.pre = load %struct.CPUX86State** @env, align 8
<   br label %25
---
> ; <label>:16                                      ; preds = %12, %8
>   %17 = phi i1 [ false, %8 ], [ %15, %12 ]
>   br label %18
21903,22020c20094,20098
< ; <label>:25                                      ; preds = %16, %helper_svm_check_intercept_param.exit._crit_edge
<   %.pre-phi12 = phi i64 [ %.pre11, %helper_svm_check_intercept_param.exit._crit_edge ], [ %19, %16 ]
<   %.pre-phi = phi i64 [ %.pre10, %helper_svm_check_intercept_param.exit._crit_edge ], [ %18, %16 ]
<   %26 = phi %struct.CPUX86State* [ %1, %helper_svm_check_intercept_param.exit._crit_edge ], [ %.pre, %16 ]
<   %27 = add i64 %.pre-phi, 1088
<   %28 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 4, i32 0
<   %29 = load i32* %28, align 4
<   tail call void @stw_phys(i64 %27, i32 %29) nounwind
<   %30 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 4, i32 1
<   %31 = load i32* %30, align 4
<   %32 = zext i32 %31 to i64
<   tail call void @stq_phys(i64 %.pre-phi12, i64 %32) nounwind
<   %33 = add i64 %.pre-phi, 1092
<   %34 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 4, i32 2
<   %35 = load i32* %34, align 4
<   tail call void @stl_phys(i64 %33, i32 %35) nounwind
<   %36 = add i64 %.pre-phi, 1090
<   %37 = getelementptr inbounds %struct.CPUX86State* %26, i64 0, i32 10, i64 4, i32 3
<   %38 = load i32* %37, align 4
<   %39 = lshr i32 %38, 8
<   %40 = and i32 %39, 255
<   %41 = lshr i32 %38, 12
<   %42 = and i32 %41, 3840
<   %43 = or i32 %40, %42
<   tail call void @stw_phys(i64 %36, i32 %43) nounwind
<   %44 = add i64 %.pre-phi, 1104
<   %45 = load %struct.CPUX86State** @env, align 8
<   %46 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 10, i64 5, i32 0
<   %47 = load i32* %46, align 4
<   tail call void @stw_phys(i64 %44, i32 %47) nounwind
<   %48 = add i64 %.pre-phi, 1112
<   %49 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 10, i64 5, i32 1
<   %50 = load i32* %49, align 4
<   %51 = zext i32 %50 to i64
<   tail call void @stq_phys(i64 %48, i64 %51) nounwind
<   %52 = add i64 %.pre-phi, 1108
<   %53 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 10, i64 5, i32 2
<   %54 = load i32* %53, align 4
<   tail call void @stl_phys(i64 %52, i32 %54) nounwind
<   %55 = add i64 %.pre-phi, 1106
<   %56 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 10, i64 5, i32 3
<   %57 = load i32* %56, align 4
<   %58 = lshr i32 %57, 8
<   %59 = and i32 %58, 255
<   %60 = lshr i32 %57, 12
<   %61 = and i32 %60, 3840
<   %62 = or i32 %59, %61
<   tail call void @stw_phys(i64 %55, i32 %62) nounwind
<   %63 = add i64 %.pre-phi, 1168
<   %64 = load %struct.CPUX86State** @env, align 8
<   %65 = getelementptr inbounds %struct.CPUX86State* %64, i64 0, i32 12, i32 0
<   %66 = load i32* %65, align 4
<   tail call void @stw_phys(i64 %63, i32 %66) nounwind
<   %67 = add i64 %.pre-phi, 1176
<   %68 = getelementptr inbounds %struct.CPUX86State* %64, i64 0, i32 12, i32 1
<   %69 = load i32* %68, align 4
<   %70 = zext i32 %69 to i64
<   tail call void @stq_phys(i64 %67, i64 %70) nounwind
<   %71 = add i64 %.pre-phi, 1172
<   %72 = getelementptr inbounds %struct.CPUX86State* %64, i64 0, i32 12, i32 2
<   %73 = load i32* %72, align 4
<   tail call void @stl_phys(i64 %71, i32 %73) nounwind
<   %74 = add i64 %.pre-phi, 1170
<   %75 = getelementptr inbounds %struct.CPUX86State* %64, i64 0, i32 12, i32 3
<   %76 = load i32* %75, align 4
<   %77 = lshr i32 %76, 8
<   %78 = and i32 %77, 255
<   %79 = lshr i32 %76, 12
<   %80 = and i32 %79, 3840
<   %81 = or i32 %78, %80
<   tail call void @stw_phys(i64 %74, i32 %81) nounwind
<   %82 = add i64 %.pre-phi, 1136
<   %83 = load %struct.CPUX86State** @env, align 8
<   %84 = getelementptr inbounds %struct.CPUX86State* %83, i64 0, i32 11, i32 0
<   %85 = load i32* %84, align 4
<   tail call void @stw_phys(i64 %82, i32 %85) nounwind
<   %86 = add i64 %.pre-phi, 1144
<   %87 = getelementptr inbounds %struct.CPUX86State* %83, i64 0, i32 11, i32 1
<   %88 = load i32* %87, align 4
<   %89 = zext i32 %88 to i64
<   tail call void @stq_phys(i64 %86, i64 %89) nounwind
<   %90 = add i64 %.pre-phi, 1140
<   %91 = getelementptr inbounds %struct.CPUX86State* %83, i64 0, i32 11, i32 2
<   %92 = load i32* %91, align 4
<   tail call void @stl_phys(i64 %90, i32 %92) nounwind
<   %93 = add i64 %.pre-phi, 1138
<   %94 = getelementptr inbounds %struct.CPUX86State* %83, i64 0, i32 11, i32 3
<   %95 = load i32* %94, align 4
<   %96 = lshr i32 %95, 8
<   %97 = and i32 %96, 255
<   %98 = lshr i32 %95, 12
<   %99 = and i32 %98, 3840
<   %100 = or i32 %97, %99
<   tail call void @stw_phys(i64 %93, i32 %100) nounwind
<   %101 = add i64 %.pre-phi, 1536
<   %102 = load %struct.CPUX86State** @env, align 8
<   %103 = getelementptr inbounds %struct.CPUX86State* %102, i64 0, i32 37
<   %104 = load i64* %103, align 8
<   tail call void @stq_phys(i64 %101, i64 %104) nounwind
<   %105 = add i64 %.pre-phi, 1576
<   %106 = load %struct.CPUX86State** @env, align 8
<   %107 = getelementptr inbounds %struct.CPUX86State* %106, i64 0, i32 33
<   %108 = load i32* %107, align 4
<   %109 = zext i32 %108 to i64
<   tail call void @stq_phys(i64 %105, i64 %109) nounwind
<   %110 = add i64 %.pre-phi, 1584
<   %111 = load %struct.CPUX86State** @env, align 8
<   %112 = getelementptr inbounds %struct.CPUX86State* %111, i64 0, i32 34
<   %113 = load i32* %112, align 4
<   %114 = zext i32 %113 to i64
<   tail call void @stq_phys(i64 %110, i64 %114) nounwind
<   %115 = add i64 %.pre-phi, 1592
<   %116 = load %struct.CPUX86State** @env, align 8
<   %117 = getelementptr inbounds %struct.CPUX86State* %116, i64 0, i32 35
<   %118 = load i32* %117, align 4
<   %119 = zext i32 %118 to i64
<   tail call void @stq_phys(i64 %115, i64 %119) nounwind
<   ret void
---
> ; <label>:18                                      ; preds = %16, %0
>   %19 = phi i1 [ true, %0 ], [ %17, %16 ]
>   %20 = zext i1 %19 to i32
>   %21 = trunc i32 %20 to i8
>   ret i8 %21
22023,22029c20101,20113
< define void @helper_stgi() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
---
> define internal zeroext i8 @eq128(i64 %a0, i64 %a1, i64 %b0, i64 %b1) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %b0, i64* %3, align 8
>   store i64 %b1, i64* %4, align 8
>   %5 = load i64* %1, align 8
>   %6 = load i64* %3, align 8
>   %7 = icmp eq i64 %5, %6
>   br i1 %7, label %8, label %12
22031,22036c20115,20119
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 68719476736
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i64* %2, align 8
>   %10 = load i64* %4, align 8
>   %11 = icmp eq i64 %9, %10
>   br label %12
22038,22040c20121,20126
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 132, i64 0) nounwind
<   unreachable
---
> ; <label>:12                                      ; preds = %8, %0
>   %13 = phi i1 [ false, %0 ], [ %11, %8 ]
>   %14 = zext i1 %13 to i32
>   %15 = trunc i32 %14 to i8
>   ret i8 %15
> }
22042,22046c20128,20175
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 9
<   %12 = load i32* %11, align 4
<   %13 = or i32 %12, 1
<   store i32 %13, i32* %11, align 4
---
> define internal void @normalizeRoundAndPackFloatx80(%struct.floatx80* noalias sret %agg.result, i8 signext %roundingPrecision, i8 zeroext %zSign, i32 %zExp, i64 %zSig0, i64 %zSig1, %struct.float_status* %status) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca i8, align 1
>   %3 = alloca i32, align 4
>   %4 = alloca i64, align 8
>   %5 = alloca i64, align 8
>   %6 = alloca %struct.float_status*, align 4
>   %shiftCount = alloca i8, align 1
>   store i8 %roundingPrecision, i8* %1, align 1
>   store i8 %zSign, i8* %2, align 1
>   store i32 %zExp, i32* %3, align 4
>   store i64 %zSig0, i64* %4, align 8
>   store i64 %zSig1, i64* %5, align 8
>   store %struct.float_status* %status, %struct.float_status** %6, align 4
>   %7 = load i64* %4, align 8
>   %8 = icmp eq i64 %7, 0
>   br i1 %8, label %9, label %13
> 
> ; <label>:9                                       ; preds = %0
>   %10 = load i64* %5, align 8
>   store i64 %10, i64* %4, align 8
>   store i64 0, i64* %5, align 8
>   %11 = load i32* %3, align 4
>   %12 = sub nsw i32 %11, 64
>   store i32 %12, i32* %3, align 4
>   br label %13
> 
> ; <label>:13                                      ; preds = %9, %0
>   %14 = load i64* %4, align 8
>   %15 = call signext i8 @countLeadingZeros64(i64 %14)
>   store i8 %15, i8* %shiftCount, align 1
>   %16 = load i64* %4, align 8
>   %17 = load i64* %5, align 8
>   %18 = load i8* %shiftCount, align 1
>   %19 = sext i8 %18 to i32
>   call void @shortShift128Left(i64 %16, i64 %17, i32 %19, i64* %4, i64* %5)
>   %20 = load i8* %shiftCount, align 1
>   %21 = sext i8 %20 to i32
>   %22 = load i32* %3, align 4
>   %23 = sub nsw i32 %22, %21
>   store i32 %23, i32* %3, align 4
>   %24 = load i8* %1, align 1
>   %25 = load i8* %2, align 1
>   %26 = load i32* %3, align 4
>   %27 = load i64* %4, align 8
>   %28 = load i64* %5, align 8
>   %29 = load %struct.float_status** %6, align 4
>   call void @roundAndPackFloatx80(%struct.floatx80* sret %agg.result, i8 signext %24, i8 zeroext %25, i32 %26, i64 %27, i64 %28, %struct.float_status* %29)
22050,22056c20179,20207
< define void @helper_clgi() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
---
> define internal void @floatx80_sqrt(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %doubleZSig0 = alloca i64, align 8
>   %rem0 = alloca i64, align 8
>   %rem1 = alloca i64, align 8
>   %rem2 = alloca i64, align 8
>   %rem3 = alloca i64, align 8
>   %term0 = alloca i64, align 8
>   %term1 = alloca i64, align 8
>   %term2 = alloca i64, align 8
>   %term3 = alloca i64, align 8
>   %z = alloca %struct.floatx80, align 1
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %2, i64* %aSig0, align 8
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %3, i32* %aExp, align 4
>   %4 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %4, i8* %aSign, align 1
>   %5 = load i32* %aExp, align 4
>   %6 = icmp eq i32 %5, 32767
>   br i1 %6, label %7, label %20
22058,22063c20209,20223
< ; <label>:5                                       ; preds = %0
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 137438953472
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
---
> ; <label>:7                                       ; preds = %0
>   %8 = load i64* %aSig0, align 8
>   %9 = shl i64 %8, 1
>   %10 = icmp ne i64 %9, 0
>   br i1 %10, label %11, label %13
> 
> ; <label>:11                                      ; preds = %7
>   %12 = load %struct.float_status** %1, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %a, %struct.float_status* %12)
>   br label %156
> 
> ; <label>:13                                      ; preds = %7
>   %14 = load i8* %aSign, align 1
>   %15 = icmp ne i8 %14, 0
>   br i1 %15, label %19, label %16
22065,22067c20225,20229
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 133, i64 0) nounwind
<   unreachable
---
> ; <label>:16                                      ; preds = %13
>   %17 = bitcast %struct.floatx80* %agg.result to i8*
>   %18 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %17, i8* %18, i32 10, i32 1, i1 false)
>   br label %156
22069,22073c20231,20442
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 9
<   %12 = load i32* %11, align 4
<   %13 = and i32 %12, -2
<   store i32 %13, i32* %11, align 4
---
> ; <label>:19                                      ; preds = %13
>   br label %33
> 
> ; <label>:20                                      ; preds = %0
>   %21 = load i8* %aSign, align 1
>   %22 = icmp ne i8 %21, 0
>   br i1 %22, label %23, label %39
> 
> ; <label>:23                                      ; preds = %20
>   %24 = load i32* %aExp, align 4
>   %25 = sext i32 %24 to i64
>   %26 = load i64* %aSig0, align 8
>   %27 = or i64 %25, %26
>   %28 = icmp eq i64 %27, 0
>   br i1 %28, label %29, label %32
> 
> ; <label>:29                                      ; preds = %23
>   %30 = bitcast %struct.floatx80* %agg.result to i8*
>   %31 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %30, i8* %31, i32 10, i32 1, i1 false)
>   br label %156
> 
> ; <label>:32                                      ; preds = %23
>   br label %33
> 
> ; <label>:33                                      ; preds = %32, %19
>   %34 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %34)
>   %35 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 0
>   store i64 -4611686018427387904, i64* %35, align 1
>   %36 = getelementptr inbounds %struct.floatx80* %z, i32 0, i32 1
>   store i16 -1, i16* %36, align 1
>   %37 = bitcast %struct.floatx80* %agg.result to i8*
>   %38 = bitcast %struct.floatx80* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %37, i8* %38, i32 10, i32 1, i1 false)
>   br label %156
> 
> ; <label>:39                                      ; preds = %20
>   %40 = load i32* %aExp, align 4
>   %41 = icmp eq i32 %40, 0
>   br i1 %41, label %42, label %48
> 
> ; <label>:42                                      ; preds = %39
>   %43 = load i64* %aSig0, align 8
>   %44 = icmp eq i64 %43, 0
>   br i1 %44, label %45, label %46
> 
> ; <label>:45                                      ; preds = %42
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext 0, i32 0, i64 0)
>   br label %156
> 
> ; <label>:46                                      ; preds = %42
>   %47 = load i64* %aSig0, align 8
>   call void @normalizeFloatx80Subnormal(i64 %47, i32* %aExp, i64* %aSig0)
>   br label %48
> 
> ; <label>:48                                      ; preds = %46, %39
>   %49 = load i32* %aExp, align 4
>   %50 = sub nsw i32 %49, 16383
>   %51 = ashr i32 %50, 1
>   %52 = add nsw i32 %51, 16383
>   store i32 %52, i32* %zExp, align 4
>   %53 = load i32* %aExp, align 4
>   %54 = load i64* %aSig0, align 8
>   %55 = lshr i64 %54, 32
>   %56 = trunc i64 %55 to i32
>   %57 = call i32 @estimateSqrt32(i32 %53, i32 %56)
>   %58 = zext i32 %57 to i64
>   store i64 %58, i64* %zSig0, align 8
>   %59 = load i64* %aSig0, align 8
>   %60 = load i32* %aExp, align 4
>   %61 = and i32 %60, 1
>   %62 = add nsw i32 2, %61
>   call void @shift128Right(i64 %59, i64 0, i32 %62, i64* %aSig0, i64* %aSig1)
>   %63 = load i64* %aSig0, align 8
>   %64 = load i64* %aSig1, align 8
>   %65 = load i64* %zSig0, align 8
>   %66 = shl i64 %65, 32
>   %67 = call i64 @estimateDiv128To64(i64 %63, i64 %64, i64 %66)
>   %68 = load i64* %zSig0, align 8
>   %69 = shl i64 %68, 30
>   %70 = add i64 %67, %69
>   store i64 %70, i64* %zSig0, align 8
>   %71 = load i64* %zSig0, align 8
>   %72 = shl i64 %71, 1
>   store i64 %72, i64* %doubleZSig0, align 8
>   %73 = load i64* %zSig0, align 8
>   %74 = load i64* %zSig0, align 8
>   call void @mul64To128(i64 %73, i64 %74, i64* %term0, i64* %term1)
>   %75 = load i64* %aSig0, align 8
>   %76 = load i64* %aSig1, align 8
>   %77 = load i64* %term0, align 8
>   %78 = load i64* %term1, align 8
>   call void @sub128(i64 %75, i64 %76, i64 %77, i64 %78, i64* %rem0, i64* %rem1)
>   br label %79
> 
> ; <label>:79                                      ; preds = %82, %48
>   %80 = load i64* %rem0, align 8
>   %81 = icmp slt i64 %80, 0
>   br i1 %81, label %82, label %93
> 
> ; <label>:82                                      ; preds = %79
>   %83 = load i64* %zSig0, align 8
>   %84 = add i64 %83, -1
>   store i64 %84, i64* %zSig0, align 8
>   %85 = load i64* %doubleZSig0, align 8
>   %86 = sub i64 %85, 2
>   store i64 %86, i64* %doubleZSig0, align 8
>   %87 = load i64* %rem0, align 8
>   %88 = load i64* %rem1, align 8
>   %89 = load i64* %zSig0, align 8
>   %90 = lshr i64 %89, 63
>   %91 = load i64* %doubleZSig0, align 8
>   %92 = or i64 %91, 1
>   call void @add128(i64 %87, i64 %88, i64 %90, i64 %92, i64* %rem0, i64* %rem1)
>   br label %79
> 
> ; <label>:93                                      ; preds = %79
>   %94 = load i64* %rem1, align 8
>   %95 = load i64* %doubleZSig0, align 8
>   %96 = call i64 @estimateDiv128To64(i64 %94, i64 0, i64 %95)
>   store i64 %96, i64* %zSig1, align 8
>   %97 = load i64* %zSig1, align 8
>   %98 = and i64 %97, 4611686018427387903
>   %99 = icmp ule i64 %98, 5
>   br i1 %99, label %100, label %144
> 
> ; <label>:100                                     ; preds = %93
>   %101 = load i64* %zSig1, align 8
>   %102 = icmp eq i64 %101, 0
>   br i1 %102, label %103, label %104
> 
> ; <label>:103                                     ; preds = %100
>   store i64 1, i64* %zSig1, align 8
>   br label %104
> 
> ; <label>:104                                     ; preds = %103, %100
>   %105 = load i64* %doubleZSig0, align 8
>   %106 = load i64* %zSig1, align 8
>   call void @mul64To128(i64 %105, i64 %106, i64* %term1, i64* %term2)
>   %107 = load i64* %rem1, align 8
>   %108 = load i64* %term1, align 8
>   %109 = load i64* %term2, align 8
>   call void @sub128(i64 %107, i64 0, i64 %108, i64 %109, i64* %rem1, i64* %rem2)
>   %110 = load i64* %zSig1, align 8
>   %111 = load i64* %zSig1, align 8
>   call void @mul64To128(i64 %110, i64 %111, i64* %term2, i64* %term3)
>   %112 = load i64* %rem1, align 8
>   %113 = load i64* %rem2, align 8
>   %114 = load i64* %term2, align 8
>   %115 = load i64* %term3, align 8
>   call void @sub192(i64 %112, i64 %113, i64 0, i64 0, i64 %114, i64 %115, i64* %rem1, i64* %rem2, i64* %rem3)
>   br label %116
> 
> ; <label>:116                                     ; preds = %119, %104
>   %117 = load i64* %rem1, align 8
>   %118 = icmp slt i64 %117, 0
>   br i1 %118, label %119, label %133
> 
> ; <label>:119                                     ; preds = %116
>   %120 = load i64* %zSig1, align 8
>   %121 = add i64 %120, -1
>   store i64 %121, i64* %zSig1, align 8
>   %122 = load i64* %zSig1, align 8
>   call void @shortShift128Left(i64 0, i64 %122, i32 1, i64* %term2, i64* %term3)
>   %123 = load i64* %term3, align 8
>   %124 = or i64 %123, 1
>   store i64 %124, i64* %term3, align 8
>   %125 = load i64* %doubleZSig0, align 8
>   %126 = load i64* %term2, align 8
>   %127 = or i64 %126, %125
>   store i64 %127, i64* %term2, align 8
>   %128 = load i64* %rem1, align 8
>   %129 = load i64* %rem2, align 8
>   %130 = load i64* %rem3, align 8
>   %131 = load i64* %term2, align 8
>   %132 = load i64* %term3, align 8
>   call void @add192(i64 %128, i64 %129, i64 %130, i64 0, i64 %131, i64 %132, i64* %rem1, i64* %rem2, i64* %rem3)
>   br label %116
> 
> ; <label>:133                                     ; preds = %116
>   %134 = load i64* %rem1, align 8
>   %135 = load i64* %rem2, align 8
>   %136 = or i64 %134, %135
>   %137 = load i64* %rem3, align 8
>   %138 = or i64 %136, %137
>   %139 = icmp ne i64 %138, 0
>   %140 = zext i1 %139 to i32
>   %141 = sext i32 %140 to i64
>   %142 = load i64* %zSig1, align 8
>   %143 = or i64 %142, %141
>   store i64 %143, i64* %zSig1, align 8
>   br label %144
> 
> ; <label>:144                                     ; preds = %133, %93
>   %145 = load i64* %zSig1, align 8
>   call void @shortShift128Left(i64 0, i64 %145, i32 1, i64* %zSig0, i64* %zSig1)
>   %146 = load i64* %doubleZSig0, align 8
>   %147 = load i64* %zSig0, align 8
>   %148 = or i64 %147, %146
>   store i64 %148, i64* %zSig0, align 8
>   %149 = load %struct.float_status** %1, align 4
>   %150 = getelementptr inbounds %struct.float_status* %149, i32 0, i32 3
>   %151 = load i8* %150, align 1
>   %152 = load i32* %zExp, align 4
>   %153 = load i64* %zSig0, align 8
>   %154 = load i64* %zSig1, align 8
>   %155 = load %struct.float_status** %1, align 4
>   call void @roundAndPackFloatx80(%struct.floatx80* sret %agg.result, i8 signext %151, i8 zeroext 0, i32 %152, i64 %153, i64 %154, %struct.float_status* %155)
>   br label %156
> 
> ; <label>:156                                     ; preds = %144, %45, %33, %29, %16, %11
22077,22083c20446,20610
< define void @helper_skinit() noreturn nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
---
> define internal void @sub192(i64 %a0, i64 %a1, i64 %a2, i64 %b0, i64 %b1, i64 %b2, i64* %z0Ptr, i64* %z1Ptr, i64* %z2Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca i64, align 8
>   %6 = alloca i64, align 8
>   %7 = alloca i64*, align 4
>   %8 = alloca i64*, align 4
>   %9 = alloca i64*, align 4
>   %z0 = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   %z2 = alloca i64, align 8
>   %borrow0 = alloca i8, align 1
>   %borrow1 = alloca i8, align 1
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %a2, i64* %3, align 8
>   store i64 %b0, i64* %4, align 8
>   store i64 %b1, i64* %5, align 8
>   store i64 %b2, i64* %6, align 8
>   store i64* %z0Ptr, i64** %7, align 4
>   store i64* %z1Ptr, i64** %8, align 4
>   store i64* %z2Ptr, i64** %9, align 4
>   %10 = load i64* %3, align 8
>   %11 = load i64* %6, align 8
>   %12 = sub i64 %10, %11
>   store i64 %12, i64* %z2, align 8
>   %13 = load i64* %3, align 8
>   %14 = load i64* %6, align 8
>   %15 = icmp ult i64 %13, %14
>   %16 = zext i1 %15 to i32
>   %17 = trunc i32 %16 to i8
>   store i8 %17, i8* %borrow1, align 1
>   %18 = load i64* %2, align 8
>   %19 = load i64* %5, align 8
>   %20 = sub i64 %18, %19
>   store i64 %20, i64* %z1, align 8
>   %21 = load i64* %2, align 8
>   %22 = load i64* %5, align 8
>   %23 = icmp ult i64 %21, %22
>   %24 = zext i1 %23 to i32
>   %25 = trunc i32 %24 to i8
>   store i8 %25, i8* %borrow0, align 1
>   %26 = load i64* %1, align 8
>   %27 = load i64* %4, align 8
>   %28 = sub i64 %26, %27
>   store i64 %28, i64* %z0, align 8
>   %29 = load i64* %z1, align 8
>   %30 = load i8* %borrow1, align 1
>   %31 = sext i8 %30 to i64
>   %32 = icmp ult i64 %29, %31
>   %33 = zext i1 %32 to i32
>   %34 = sext i32 %33 to i64
>   %35 = load i64* %z0, align 8
>   %36 = sub i64 %35, %34
>   store i64 %36, i64* %z0, align 8
>   %37 = load i8* %borrow1, align 1
>   %38 = sext i8 %37 to i64
>   %39 = load i64* %z1, align 8
>   %40 = sub i64 %39, %38
>   store i64 %40, i64* %z1, align 8
>   %41 = load i8* %borrow0, align 1
>   %42 = sext i8 %41 to i64
>   %43 = load i64* %z0, align 8
>   %44 = sub i64 %43, %42
>   store i64 %44, i64* %z0, align 8
>   %45 = load i64* %z2, align 8
>   %46 = load i64** %9, align 4
>   store i64 %45, i64* %46, align 4
>   %47 = load i64* %z1, align 8
>   %48 = load i64** %8, align 4
>   store i64 %47, i64* %48, align 4
>   %49 = load i64* %z0, align 8
>   %50 = load i64** %7, align 4
>   store i64 %49, i64* %50, align 4
>   ret void
> }
> 
> define internal void @add192(i64 %a0, i64 %a1, i64 %a2, i64 %b0, i64 %b1, i64 %b2, i64* %z0Ptr, i64* %z1Ptr, i64* %z2Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca i64, align 8
>   %6 = alloca i64, align 8
>   %7 = alloca i64*, align 4
>   %8 = alloca i64*, align 4
>   %9 = alloca i64*, align 4
>   %z0 = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   %z2 = alloca i64, align 8
>   %carry0 = alloca i8, align 1
>   %carry1 = alloca i8, align 1
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %a2, i64* %3, align 8
>   store i64 %b0, i64* %4, align 8
>   store i64 %b1, i64* %5, align 8
>   store i64 %b2, i64* %6, align 8
>   store i64* %z0Ptr, i64** %7, align 4
>   store i64* %z1Ptr, i64** %8, align 4
>   store i64* %z2Ptr, i64** %9, align 4
>   %10 = load i64* %3, align 8
>   %11 = load i64* %6, align 8
>   %12 = add i64 %10, %11
>   store i64 %12, i64* %z2, align 8
>   %13 = load i64* %z2, align 8
>   %14 = load i64* %3, align 8
>   %15 = icmp ult i64 %13, %14
>   %16 = zext i1 %15 to i32
>   %17 = trunc i32 %16 to i8
>   store i8 %17, i8* %carry1, align 1
>   %18 = load i64* %2, align 8
>   %19 = load i64* %5, align 8
>   %20 = add i64 %18, %19
>   store i64 %20, i64* %z1, align 8
>   %21 = load i64* %z1, align 8
>   %22 = load i64* %2, align 8
>   %23 = icmp ult i64 %21, %22
>   %24 = zext i1 %23 to i32
>   %25 = trunc i32 %24 to i8
>   store i8 %25, i8* %carry0, align 1
>   %26 = load i64* %1, align 8
>   %27 = load i64* %4, align 8
>   %28 = add i64 %26, %27
>   store i64 %28, i64* %z0, align 8
>   %29 = load i8* %carry1, align 1
>   %30 = sext i8 %29 to i64
>   %31 = load i64* %z1, align 8
>   %32 = add i64 %31, %30
>   store i64 %32, i64* %z1, align 8
>   %33 = load i64* %z1, align 8
>   %34 = load i8* %carry1, align 1
>   %35 = sext i8 %34 to i64
>   %36 = icmp ult i64 %33, %35
>   %37 = zext i1 %36 to i32
>   %38 = sext i32 %37 to i64
>   %39 = load i64* %z0, align 8
>   %40 = add i64 %39, %38
>   store i64 %40, i64* %z0, align 8
>   %41 = load i8* %carry0, align 1
>   %42 = sext i8 %41 to i64
>   %43 = load i64* %z0, align 8
>   %44 = add i64 %43, %42
>   store i64 %44, i64* %z0, align 8
>   %45 = load i64* %z2, align 8
>   %46 = load i64** %9, align 4
>   store i64 %45, i64* %46, align 4
>   %47 = load i64* %z1, align 8
>   %48 = load i64** %8, align 4
>   store i64 %47, i64* %48, align 4
>   %49 = load i64* %z0, align 8
>   %50 = load i64** %7, align 4
>   store i64 %49, i64* %50, align 4
>   ret void
> }
> 
> define internal i32 @floatx80_eq(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   %4 = icmp eq i32 %3, 32767
>   br i1 %4, label %5, label %9
22086,22090c20613,20621
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 274877906944
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
---
>   %6 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %7 = shl i64 %6, 1
>   %8 = icmp ne i64 %7, 0
>   br i1 %8, label %16, label %9
> 
> ; <label>:9                                       ; preds = %5, %0
>   %10 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   %11 = icmp eq i32 %10, 32767
>   br i1 %11, label %12, label %18
22092,22094c20623,20657
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 134, i64 0) nounwind
<   unreachable
---
> ; <label>:12                                      ; preds = %9
>   %13 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   %14 = shl i64 %13, 1
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %18
> 
> ; <label>:16                                      ; preds = %12, %5
>   %17 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %17)
>   store i32 0, i32* %1
>   br label %55
> 
> ; <label>:18                                      ; preds = %12, %9
>   %19 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %20 = load i64* %19, align 1
>   %21 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %22 = load i64* %21, align 1
>   %23 = icmp eq i64 %20, %22
>   br i1 %23, label %24, label %52
> 
> ; <label>:24                                      ; preds = %18
>   %25 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %26 = load i16* %25, align 1
>   %27 = zext i16 %26 to i32
>   %28 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %29 = load i16* %28, align 1
>   %30 = zext i16 %29 to i32
>   %31 = icmp eq i32 %27, %30
>   br i1 %31, label %50, label %32
> 
> ; <label>:32                                      ; preds = %24
>   %33 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %34 = load i64* %33, align 1
>   %35 = icmp eq i64 %34, 0
>   br i1 %35, label %36, label %48
22096,22098c20659,20689
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   tail call fastcc void @raise_exception(i32 6) noreturn
<   unreachable
---
> ; <label>:36                                      ; preds = %32
>   %37 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %38 = load i16* %37, align 1
>   %39 = zext i16 %38 to i32
>   %40 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %41 = load i16* %40, align 1
>   %42 = zext i16 %41 to i32
>   %43 = or i32 %39, %42
>   %44 = shl i32 %43, 1
>   %45 = trunc i32 %44 to i16
>   %46 = zext i16 %45 to i32
>   %47 = icmp eq i32 %46, 0
>   br label %48
> 
> ; <label>:48                                      ; preds = %36, %32
>   %49 = phi i1 [ false, %32 ], [ %47, %36 ]
>   br label %50
> 
> ; <label>:50                                      ; preds = %48, %24
>   %51 = phi i1 [ true, %24 ], [ %49, %48 ]
>   br label %52
> 
> ; <label>:52                                      ; preds = %50, %18
>   %53 = phi i1 [ false, %18 ], [ %51, %50 ]
>   %54 = zext i1 %53 to i32
>   store i32 %54, i32* %1
>   br label %55
> 
> ; <label>:55                                      ; preds = %52, %16
>   %56 = load i32* %1
>   ret i32 %56
22101,22107c20692,20700
< define void @helper_invlpga(i32 %aflag) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 8
<   %3 = load i32* %2, align 4
<   %.lobit.i = and i32 %3, 2097152
<   %4 = icmp eq i32 %.lobit.i, 0
<   br i1 %4, label %helper_svm_check_intercept_param.exit, label %5, !prof !0
---
> define internal i32 @floatx80_le(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   %4 = icmp eq i32 %3, 32767
>   br i1 %4, label %5, label %9
22110,22114c20703,20711
<   %6 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %7 = load i64* %6, align 8
<   %8 = and i64 %7, 67108864
<   %9 = icmp eq i64 %8, 0
<   br i1 %9, label %helper_svm_check_intercept_param.exit, label %10
---
>   %6 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %7 = shl i64 %6, 1
>   %8 = icmp ne i64 %7, 0
>   br i1 %8, label %16, label %9
> 
> ; <label>:9                                       ; preds = %5, %0
>   %10 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   %11 = icmp eq i32 %10, 32767
>   br i1 %11, label %12, label %18
22116,22118c20713,20735
< ; <label>:10                                      ; preds = %5
<   tail call void @helper_vmexit(i32 122, i64 0) nounwind
<   unreachable
---
> ; <label>:12                                      ; preds = %9
>   %13 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   %14 = shl i64 %13, 1
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %18
> 
> ; <label>:16                                      ; preds = %12, %5
>   %17 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %17)
>   store i32 0, i32* %1
>   br label %83
> 
> ; <label>:18                                      ; preds = %12, %9
>   %19 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %19, i8* %aSign, align 1
>   %20 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %b)
>   store i8 %20, i8* %bSign, align 1
>   %21 = load i8* %aSign, align 1
>   %22 = zext i8 %21 to i32
>   %23 = load i8* %bSign, align 1
>   %24 = zext i8 %23 to i32
>   %25 = icmp ne i32 %22, %24
>   br i1 %25, label %26, label %51
22120,22124c20737,20812
< helper_svm_check_intercept_param.exit:            ; preds = %5, %0
<   %11 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 0, i64 0
<   %12 = load i32* %11, align 4
<   tail call void @tlb_flush_page(%struct.CPUX86State* %1, i32 %12) nounwind
<   ret void
---
> ; <label>:26                                      ; preds = %18
>   %27 = load i8* %aSign, align 1
>   %28 = zext i8 %27 to i32
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %48, label %30
> 
> ; <label>:30                                      ; preds = %26
>   %31 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %32 = load i16* %31, align 1
>   %33 = zext i16 %32 to i32
>   %34 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %35 = load i16* %34, align 1
>   %36 = zext i16 %35 to i32
>   %37 = or i32 %33, %36
>   %38 = shl i32 %37, 1
>   %39 = trunc i32 %38 to i16
>   %40 = zext i16 %39 to i64
>   %41 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %42 = load i64* %41, align 1
>   %43 = or i64 %40, %42
>   %44 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %45 = load i64* %44, align 1
>   %46 = or i64 %43, %45
>   %47 = icmp eq i64 %46, 0
>   br label %48
> 
> ; <label>:48                                      ; preds = %30, %26
>   %49 = phi i1 [ true, %26 ], [ %47, %30 ]
>   %50 = zext i1 %49 to i32
>   store i32 %50, i32* %1
>   br label %83
> 
> ; <label>:51                                      ; preds = %18
>   %52 = load i8* %aSign, align 1
>   %53 = zext i8 %52 to i32
>   %54 = icmp ne i32 %53, 0
>   br i1 %54, label %55, label %68
> 
> ; <label>:55                                      ; preds = %51
>   %56 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %57 = load i16* %56, align 1
>   %58 = zext i16 %57 to i64
>   %59 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %60 = load i64* %59, align 1
>   %61 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %62 = load i16* %61, align 1
>   %63 = zext i16 %62 to i64
>   %64 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %65 = load i64* %64, align 1
>   %66 = call zeroext i8 @le128(i64 %58, i64 %60, i64 %63, i64 %65)
>   %67 = zext i8 %66 to i32
>   br label %81
> 
> ; <label>:68                                      ; preds = %51
>   %69 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %70 = load i16* %69, align 1
>   %71 = zext i16 %70 to i64
>   %72 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %73 = load i64* %72, align 1
>   %74 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %75 = load i16* %74, align 1
>   %76 = zext i16 %75 to i64
>   %77 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %78 = load i64* %77, align 1
>   %79 = call zeroext i8 @le128(i64 %71, i64 %73, i64 %76, i64 %78)
>   %80 = zext i8 %79 to i32
>   br label %81
> 
> ; <label>:81                                      ; preds = %68, %55
>   %82 = phi i32 [ %67, %55 ], [ %80, %68 ]
>   store i32 %82, i32* %1
>   br label %83
> 
> ; <label>:83                                      ; preds = %81, %48, %16
>   %84 = load i32* %1
>   ret i32 %84
22127,22131c20815,20823
< define void @helper_vmexit(i32 %exit_code, i64 %exit_info_1) noreturn nounwind uwtable {
<   %1 = load i32* @loglevel, align 4
<   %2 = and i32 %1, 2
<   %3 = icmp eq i32 %2, 0
<   br i1 %3, label %15, label %4
---
> define internal i32 @floatx80_lt(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   %4 = icmp eq i32 %3, 32767
>   br i1 %4, label %5, label %9
22133,22144c20825,20834
< ; <label>:4                                       ; preds = %0
<   %5 = load %struct._IO_FILE** @logfile, align 8
<   %6 = load %struct.CPUX86State** @env, align 8
<   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 39
<   %8 = load i64* %7, align 8
<   %9 = add i64 %8, 128
<   %10 = tail call i64 @ldq_phys(i64 %9) nounwind
<   %11 = load %struct.CPUX86State** @env, align 8
<   %12 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 5
<   %13 = load i32* %12, align 4
<   %14 = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %5, i8* getelementptr inbounds ([37 x i8]* @.str19, i64 0, i64 0), i32 %exit_code, i64 %exit_info_1, i64 %10, i32 %13) nounwind
<   br label %15
---
> ; <label>:5                                       ; preds = %0
>   %6 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %7 = shl i64 %6, 1
>   %8 = icmp ne i64 %7, 0
>   br i1 %8, label %16, label %9
> 
> ; <label>:9                                       ; preds = %5, %0
>   %10 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   %11 = icmp eq i32 %10, 32767
>   br i1 %11, label %12, label %18
22146,22155c20836,20858
< ; <label>:15                                      ; preds = %4, %0
<   %16 = load %struct.CPUX86State** @env, align 8
<   %17 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 8
<   %18 = load i32* %17, align 4
<   %19 = and i32 %18, 8
<   %20 = icmp eq i32 %19, 0
<   %21 = getelementptr inbounds %struct.CPUX86State* %16, i64 0, i32 39
<   %22 = load i64* %21, align 8
<   %23 = add i64 %22, 104
<   br i1 %20, label %29, label %24
---
> ; <label>:12                                      ; preds = %9
>   %13 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   %14 = shl i64 %13, 1
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %18
> 
> ; <label>:16                                      ; preds = %12, %5
>   %17 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %17)
>   store i32 0, i32* %1
>   br label %83
> 
> ; <label>:18                                      ; preds = %12, %9
>   %19 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %19, i8* %aSign, align 1
>   %20 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %b)
>   store i8 %20, i8* %bSign, align 1
>   %21 = load i8* %aSign, align 1
>   %22 = zext i8 %21 to i32
>   %23 = load i8* %bSign, align 1
>   %24 = zext i8 %23 to i32
>   %25 = icmp ne i32 %22, %24
>   br i1 %25, label %26, label %51
22157,22164c20860,20864
< ; <label>:24                                      ; preds = %15
<   tail call void @stl_phys(i64 %23, i32 1) nounwind
<   %25 = load %struct.CPUX86State** @env, align 8
<   %26 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 8
<   %27 = load i32* %26, align 4
<   %28 = and i32 %27, -9
<   store i32 %28, i32* %26, align 4
<   br label %30
---
> ; <label>:26                                      ; preds = %18
>   %27 = load i8* %aSign, align 1
>   %28 = zext i8 %27 to i32
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %30, label %48
22166,22168c20866,20884
< ; <label>:29                                      ; preds = %15
<   tail call void @stl_phys(i64 %23, i32 0) nounwind
<   br label %30
---
> ; <label>:30                                      ; preds = %26
>   %31 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %32 = load i16* %31, align 1
>   %33 = zext i16 %32 to i32
>   %34 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %35 = load i16* %34, align 1
>   %36 = zext i16 %35 to i32
>   %37 = or i32 %33, %36
>   %38 = shl i32 %37, 1
>   %39 = trunc i32 %38 to i16
>   %40 = zext i16 %39 to i64
>   %41 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %42 = load i64* %41, align 1
>   %43 = or i64 %40, %42
>   %44 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %45 = load i64* %44, align 1
>   %46 = or i64 %43, %45
>   %47 = icmp ne i64 %46, 0
>   br label %48
22170,22588c20886,26428
< ; <label>:30                                      ; preds = %29, %24
<   %31 = load %struct.CPUX86State** @env, align 8
<   %32 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 39
<   %33 = load i64* %32, align 8
<   %34 = add i64 %33, 1024
<   %35 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 10, i64 0, i32 0
<   %36 = load i32* %35, align 4
<   tail call void @stw_phys(i64 %34, i32 %36) nounwind
<   %37 = add i64 %33, 1032
<   %38 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 10, i64 0, i32 1
<   %39 = load i32* %38, align 4
<   %40 = zext i32 %39 to i64
<   tail call void @stq_phys(i64 %37, i64 %40) nounwind
<   %41 = add i64 %33, 1028
<   %42 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 10, i64 0, i32 2
<   %43 = load i32* %42, align 4
<   tail call void @stl_phys(i64 %41, i32 %43) nounwind
<   %44 = add i64 %33, 1026
<   %45 = getelementptr inbounds %struct.CPUX86State* %31, i64 0, i32 10, i64 0, i32 3
<   %46 = load i32* %45, align 4
<   %47 = lshr i32 %46, 8
<   %48 = and i32 %47, 255
<   %49 = lshr i32 %46, 12
<   %50 = and i32 %49, 3840
<   %51 = or i32 %48, %50
<   tail call void @stw_phys(i64 %44, i32 %51) nounwind
<   %52 = load %struct.CPUX86State** @env, align 8
<   %53 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 39
<   %54 = load i64* %53, align 8
<   %55 = add i64 %54, 1040
<   %56 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 10, i64 1, i32 0
<   %57 = load i32* %56, align 4
<   tail call void @stw_phys(i64 %55, i32 %57) nounwind
<   %58 = add i64 %54, 1048
<   %59 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 10, i64 1, i32 1
<   %60 = load i32* %59, align 4
<   %61 = zext i32 %60 to i64
<   tail call void @stq_phys(i64 %58, i64 %61) nounwind
<   %62 = add i64 %54, 1044
<   %63 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 10, i64 1, i32 2
<   %64 = load i32* %63, align 4
<   tail call void @stl_phys(i64 %62, i32 %64) nounwind
<   %65 = add i64 %54, 1042
<   %66 = getelementptr inbounds %struct.CPUX86State* %52, i64 0, i32 10, i64 1, i32 3
<   %67 = load i32* %66, align 4
<   %68 = lshr i32 %67, 8
<   %69 = and i32 %68, 255
<   %70 = lshr i32 %67, 12
<   %71 = and i32 %70, 3840
<   %72 = or i32 %69, %71
<   tail call void @stw_phys(i64 %65, i32 %72) nounwind
<   %73 = load %struct.CPUX86State** @env, align 8
<   %74 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 39
<   %75 = load i64* %74, align 8
<   %76 = add i64 %75, 1056
<   %77 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 10, i64 2, i32 0
<   %78 = load i32* %77, align 4
<   tail call void @stw_phys(i64 %76, i32 %78) nounwind
<   %79 = add i64 %75, 1064
<   %80 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 10, i64 2, i32 1
<   %81 = load i32* %80, align 4
<   %82 = zext i32 %81 to i64
<   tail call void @stq_phys(i64 %79, i64 %82) nounwind
<   %83 = add i64 %75, 1060
<   %84 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 10, i64 2, i32 2
<   %85 = load i32* %84, align 4
<   tail call void @stl_phys(i64 %83, i32 %85) nounwind
<   %86 = add i64 %75, 1058
<   %87 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 10, i64 2, i32 3
<   %88 = load i32* %87, align 4
<   %89 = lshr i32 %88, 8
<   %90 = and i32 %89, 255
<   %91 = lshr i32 %88, 12
<   %92 = and i32 %91, 3840
<   %93 = or i32 %90, %92
<   tail call void @stw_phys(i64 %86, i32 %93) nounwind
<   %94 = load %struct.CPUX86State** @env, align 8
<   %95 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 39
<   %96 = load i64* %95, align 8
<   %97 = add i64 %96, 1072
<   %98 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 10, i64 3, i32 0
<   %99 = load i32* %98, align 4
<   tail call void @stw_phys(i64 %97, i32 %99) nounwind
<   %100 = add i64 %96, 1080
<   %101 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 10, i64 3, i32 1
<   %102 = load i32* %101, align 4
<   %103 = zext i32 %102 to i64
<   tail call void @stq_phys(i64 %100, i64 %103) nounwind
<   %104 = add i64 %96, 1076
<   %105 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 10, i64 3, i32 2
<   %106 = load i32* %105, align 4
<   tail call void @stl_phys(i64 %104, i32 %106) nounwind
<   %107 = add i64 %96, 1074
<   %108 = getelementptr inbounds %struct.CPUX86State* %94, i64 0, i32 10, i64 3, i32 3
<   %109 = load i32* %108, align 4
<   %110 = lshr i32 %109, 8
<   %111 = and i32 %110, 255
<   %112 = lshr i32 %109, 12
<   %113 = and i32 %112, 3840
<   %114 = or i32 %111, %113
<   tail call void @stw_phys(i64 %107, i32 %114) nounwind
<   %115 = load %struct.CPUX86State** @env, align 8
<   %116 = getelementptr inbounds %struct.CPUX86State* %115, i64 0, i32 39
<   %117 = load i64* %116, align 8
<   %118 = add i64 %117, 1128
<   %119 = getelementptr inbounds %struct.CPUX86State* %115, i64 0, i32 13, i32 1
<   %120 = load i32* %119, align 4
<   %121 = zext i32 %120 to i64
<   tail call void @stq_phys(i64 %118, i64 %121) nounwind
<   %122 = load %struct.CPUX86State** @env, align 8
<   %123 = getelementptr inbounds %struct.CPUX86State* %122, i64 0, i32 39
<   %124 = load i64* %123, align 8
<   %125 = add i64 %124, 1124
<   %126 = getelementptr inbounds %struct.CPUX86State* %122, i64 0, i32 13, i32 2
<   %127 = load i32* %126, align 4
<   tail call void @stl_phys(i64 %125, i32 %127) nounwind
<   %128 = load %struct.CPUX86State** @env, align 8
<   %129 = getelementptr inbounds %struct.CPUX86State* %128, i64 0, i32 39
<   %130 = load i64* %129, align 8
<   %131 = add i64 %130, 1160
<   %132 = getelementptr inbounds %struct.CPUX86State* %128, i64 0, i32 14, i32 1
<   %133 = load i32* %132, align 4
<   %134 = zext i32 %133 to i64
<   tail call void @stq_phys(i64 %131, i64 %134) nounwind
<   %135 = load %struct.CPUX86State** @env, align 8
<   %136 = getelementptr inbounds %struct.CPUX86State* %135, i64 0, i32 39
<   %137 = load i64* %136, align 8
<   %138 = add i64 %137, 1156
<   %139 = getelementptr inbounds %struct.CPUX86State* %135, i64 0, i32 14, i32 2
<   %140 = load i32* %139, align 4
<   tail call void @stl_phys(i64 %138, i32 %140) nounwind
<   %141 = load %struct.CPUX86State** @env, align 8
<   %142 = getelementptr inbounds %struct.CPUX86State* %141, i64 0, i32 39
<   %143 = load i64* %142, align 8
<   %144 = add i64 %143, 1232
<   %145 = getelementptr inbounds %struct.CPUX86State* %141, i64 0, i32 36
<   %146 = load i64* %145, align 8
<   tail call void @stq_phys(i64 %144, i64 %146) nounwind
<   %147 = load %struct.CPUX86State** @env, align 8
<   %148 = getelementptr inbounds %struct.CPUX86State* %147, i64 0, i32 39
<   %149 = load i64* %148, align 8
<   %150 = add i64 %149, 1368
<   %151 = getelementptr inbounds %struct.CPUX86State* %147, i64 0, i32 15, i64 0
<   %152 = load i32* %151, align 4
<   %153 = zext i32 %152 to i64
<   tail call void @stq_phys(i64 %150, i64 %153) nounwind
<   %154 = load %struct.CPUX86State** @env, align 8
<   %155 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 39
<   %156 = load i64* %155, align 8
<   %157 = add i64 %156, 1600
<   %158 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 15, i64 2
<   %159 = load i32* %158, align 4
<   %160 = zext i32 %159 to i64
<   tail call void @stq_phys(i64 %157, i64 %160) nounwind
<   %161 = load %struct.CPUX86State** @env, align 8
<   %162 = getelementptr inbounds %struct.CPUX86State* %161, i64 0, i32 39
<   %163 = load i64* %162, align 8
<   %164 = add i64 %163, 1360
<   %165 = getelementptr inbounds %struct.CPUX86State* %161, i64 0, i32 15, i64 3
<   %166 = load i32* %165, align 4
<   %167 = zext i32 %166 to i64
<   tail call void @stq_phys(i64 %164, i64 %167) nounwind
<   %168 = load %struct.CPUX86State** @env, align 8
<   %169 = getelementptr inbounds %struct.CPUX86State* %168, i64 0, i32 39
<   %170 = load i64* %169, align 8
<   %171 = add i64 %170, 1352
<   %172 = getelementptr inbounds %struct.CPUX86State* %168, i64 0, i32 15, i64 4
<   %173 = load i32* %172, align 4
<   %174 = zext i32 %173 to i64
<   tail call void @stq_phys(i64 %171, i64 %174) nounwind
<   %175 = load %struct.CPUX86State** @env, align 8
<   %176 = getelementptr inbounds %struct.CPUX86State* %175, i64 0, i32 39
<   %177 = load i64* %176, align 8
<   %178 = add i64 %177, 96
<   %179 = tail call i32 @ldl_phys(i64 %178) nounwind
<   %180 = and i32 %179, -272
<   %181 = load %struct.CPUX86State** @env, align 8
<   %182 = getelementptr inbounds %struct.CPUX86State* %181, i64 0, i32 47
<   %183 = load i8* %182, align 1
<   %184 = zext i8 %183 to i32
<   %185 = and i32 %184, 15
<   %186 = or i32 %185, %180
<   %187 = getelementptr inbounds %struct.CPUX86State* %181, i64 0, i32 71
<   %188 = load i32* %187, align 4
<   %189 = and i32 %188, 256
<   %190 = icmp eq i32 %189, 0
<   %191 = or i32 %186, 256
<   %int_ctl.0 = select i1 %190, i32 %186, i32 %191
<   %192 = getelementptr inbounds %struct.CPUX86State* %181, i64 0, i32 39
<   %193 = load i64* %192, align 8
<   %194 = add i64 %193, 96
<   tail call void @stl_phys(i64 %194, i32 %int_ctl.0) nounwind
<   %195 = load %struct.CPUX86State** @env, align 8
<   %196 = getelementptr inbounds %struct.CPUX86State* %195, i64 0, i32 39
<   %197 = load i64* %196, align 8
<   %198 = add i64 %197, 1392
<   %199 = getelementptr inbounds %struct.CPUX86State* %195, i64 0, i32 7
<   %200 = load i32* %199, align 4
<   %201 = getelementptr inbounds %struct.CPUX86State* %195, i64 0, i32 1
<   %202 = load i32* %201, align 4
<   %203 = tail call i32 @helper_cc_compute_all(i32 %202) nounwind
<   %204 = or i32 %203, %200
<   %205 = getelementptr inbounds %struct.CPUX86State* %195, i64 0, i32 6
<   %206 = load i32* %205, align 4
<   %207 = and i32 %206, 1024
<   %208 = or i32 %204, %207
<   %209 = zext i32 %208 to i64
<   tail call void @stq_phys(i64 %198, i64 %209) nounwind
<   %210 = load %struct.CPUX86State** @env, align 8
<   %211 = getelementptr inbounds %struct.CPUX86State* %210, i64 0, i32 39
<   %212 = load i64* %211, align 8
<   %213 = add i64 %212, 1400
<   %214 = getelementptr inbounds %struct.CPUX86State* %210, i64 0, i32 5
<   %215 = load i32* %214, align 4
<   %216 = zext i32 %215 to i64
<   tail call void @stq_phys(i64 %213, i64 %216) nounwind
<   %217 = load %struct.CPUX86State** @env, align 8
<   %218 = getelementptr inbounds %struct.CPUX86State* %217, i64 0, i32 39
<   %219 = load i64* %218, align 8
<   %220 = add i64 %219, 1496
<   %221 = getelementptr inbounds %struct.CPUX86State* %217, i64 0, i32 0, i64 4
<   %222 = load i32* %221, align 4
<   %223 = zext i32 %222 to i64
<   tail call void @stq_phys(i64 %220, i64 %223) nounwind
<   %224 = load %struct.CPUX86State** @env, align 8
<   %225 = getelementptr inbounds %struct.CPUX86State* %224, i64 0, i32 39
<   %226 = load i64* %225, align 8
<   %227 = add i64 %226, 1528
<   %228 = getelementptr inbounds %struct.CPUX86State* %224, i64 0, i32 0, i64 0
<   %229 = load i32* %228, align 4
<   %230 = zext i32 %229 to i64
<   tail call void @stq_phys(i64 %227, i64 %230) nounwind
<   %231 = load %struct.CPUX86State** @env, align 8
<   %232 = getelementptr inbounds %struct.CPUX86State* %231, i64 0, i32 39
<   %233 = load i64* %232, align 8
<   %234 = add i64 %233, 1376
<   %235 = getelementptr inbounds %struct.CPUX86State* %231, i64 0, i32 58, i64 7
<   %236 = load i32* %235, align 4
<   %237 = zext i32 %236 to i64
<   tail call void @stq_phys(i64 %234, i64 %237) nounwind
<   %238 = load %struct.CPUX86State** @env, align 8
<   %239 = getelementptr inbounds %struct.CPUX86State* %238, i64 0, i32 39
<   %240 = load i64* %239, align 8
<   %241 = add i64 %240, 1384
<   %242 = getelementptr inbounds %struct.CPUX86State* %238, i64 0, i32 58, i64 6
<   %243 = load i32* %242, align 4
<   %244 = zext i32 %243 to i64
<   tail call void @stq_phys(i64 %241, i64 %244) nounwind
<   %245 = load %struct.CPUX86State** @env, align 8
<   %246 = getelementptr inbounds %struct.CPUX86State* %245, i64 0, i32 39
<   %247 = load i64* %246, align 8
<   %248 = add i64 %247, 1227
<   %249 = getelementptr inbounds %struct.CPUX86State* %245, i64 0, i32 8
<   %250 = load i32* %249, align 4
<   %251 = and i32 %250, 3
<   tail call void @stb_phys(i64 %248, i32 %251) nounwind
<   %252 = load %struct.CPUX86State** @env, align 8
<   %253 = getelementptr inbounds %struct.CPUX86State* %252, i64 0, i32 9
<   %254 = load i32* %253, align 4
<   %255 = and i32 %254, -11
<   store i32 %255, i32* %253, align 4
<   %256 = load %struct.CPUX86State** @env, align 8
<   %257 = getelementptr inbounds %struct.CPUX86State* %256, i64 0, i32 8
<   %258 = load i32* %257, align 4
<   %259 = and i32 %258, -2097153
<   store i32 %259, i32* %257, align 4
<   %260 = load %struct.CPUX86State** @env, align 8
<   %261 = getelementptr inbounds %struct.CPUX86State* %260, i64 0, i32 41
<   store i64 0, i64* %261, align 8
<   %262 = load %struct.CPUX86State** @env, align 8
<   %263 = getelementptr inbounds %struct.CPUX86State* %262, i64 0, i32 46
<   store i32 0, i32* %263, align 4
<   %264 = load %struct.CPUX86State** @env, align 8
<   %265 = getelementptr inbounds %struct.CPUX86State* %264, i64 0, i32 71
<   %266 = load i32* %265, align 4
<   %267 = and i32 %266, -257
<   store i32 %267, i32* %265, align 4
<   %268 = load %struct.CPUX86State** @env, align 8
<   %269 = getelementptr inbounds %struct.CPUX86State* %268, i64 0, i32 40
<   store i64 0, i64* %269, align 8
<   %270 = load %struct.CPUX86State** @env, align 8
<   %271 = getelementptr inbounds %struct.CPUX86State* %270, i64 0, i32 38
<   %272 = load i64* %271, align 8
<   %273 = add i64 %272, 1128
<   %274 = tail call i64 @ldq_phys(i64 %273) nounwind
<   %275 = trunc i64 %274 to i32
<   %276 = load %struct.CPUX86State** @env, align 8
<   %277 = getelementptr inbounds %struct.CPUX86State* %276, i64 0, i32 13, i32 1
<   store i32 %275, i32* %277, align 4
<   %278 = load %struct.CPUX86State** @env, align 8
<   %279 = getelementptr inbounds %struct.CPUX86State* %278, i64 0, i32 38
<   %280 = load i64* %279, align 8
<   %281 = add i64 %280, 1124
<   %282 = tail call i32 @ldl_phys(i64 %281) nounwind
<   %283 = load %struct.CPUX86State** @env, align 8
<   %284 = getelementptr inbounds %struct.CPUX86State* %283, i64 0, i32 13, i32 2
<   store i32 %282, i32* %284, align 4
<   %285 = load %struct.CPUX86State** @env, align 8
<   %286 = getelementptr inbounds %struct.CPUX86State* %285, i64 0, i32 38
<   %287 = load i64* %286, align 8
<   %288 = add i64 %287, 1160
<   %289 = tail call i64 @ldq_phys(i64 %288) nounwind
<   %290 = trunc i64 %289 to i32
<   %291 = load %struct.CPUX86State** @env, align 8
<   %292 = getelementptr inbounds %struct.CPUX86State* %291, i64 0, i32 14, i32 1
<   store i32 %290, i32* %292, align 4
<   %293 = load %struct.CPUX86State** @env, align 8
<   %294 = getelementptr inbounds %struct.CPUX86State* %293, i64 0, i32 38
<   %295 = load i64* %294, align 8
<   %296 = add i64 %295, 1156
<   %297 = tail call i32 @ldl_phys(i64 %296) nounwind
<   %298 = load %struct.CPUX86State** @env, align 8
<   %299 = getelementptr inbounds %struct.CPUX86State* %298, i64 0, i32 14, i32 2
<   store i32 %297, i32* %299, align 4
<   %300 = load %struct.CPUX86State** @env, align 8
<   %301 = getelementptr inbounds %struct.CPUX86State* %300, i64 0, i32 38
<   %302 = load i64* %301, align 8
<   %303 = add i64 %302, 1368
<   %304 = tail call i64 @ldq_phys(i64 %303) nounwind
<   %305 = or i64 %304, 1
<   %306 = trunc i64 %305 to i32
<   tail call void @cpu_x86_update_cr0(%struct.CPUX86State* %300, i32 %306) nounwind
<   %307 = load %struct.CPUX86State** @env, align 8
<   %308 = getelementptr inbounds %struct.CPUX86State* %307, i64 0, i32 38
<   %309 = load i64* %308, align 8
<   %310 = add i64 %309, 1352
<   %311 = tail call i64 @ldq_phys(i64 %310) nounwind
<   %312 = trunc i64 %311 to i32
<   tail call void @cpu_x86_update_cr4(%struct.CPUX86State* %307, i32 %312) nounwind
<   %313 = load %struct.CPUX86State** @env, align 8
<   %314 = getelementptr inbounds %struct.CPUX86State* %313, i64 0, i32 38
<   %315 = load i64* %314, align 8
<   %316 = add i64 %315, 1360
<   %317 = tail call i64 @ldq_phys(i64 %316) nounwind
<   %318 = trunc i64 %317 to i32
<   tail call void @cpu_x86_update_cr3(%struct.CPUX86State* %313, i32 %318) nounwind
<   %319 = load %struct.CPUX86State** @env, align 8
<   %320 = getelementptr inbounds %struct.CPUX86State* %319, i64 0, i32 38
<   %321 = load i64* %320, align 8
<   %322 = add i64 %321, 1232
<   %323 = tail call i64 @ldq_phys(i64 %322) nounwind
<   %324 = getelementptr inbounds %struct.CPUX86State* %319, i64 0, i32 36
<   store i64 %323, i64* %324, align 8
<   %325 = getelementptr inbounds %struct.CPUX86State* %319, i64 0, i32 8
<   %326 = load i32* %325, align 4
<   %327 = and i32 %326, -1064961
<   %328 = and i64 %323, 1024
<   %329 = icmp eq i64 %328, 0
<   %330 = or i32 %327, 16384
<   %storemerge.i = select i1 %329, i32 %327, i32 %330
<   %331 = and i64 %323, 4096
<   %332 = icmp eq i64 %331, 0
<   %333 = or i32 %storemerge.i, 1048576
<   %storemerge..i = select i1 %332, i32 %storemerge.i, i32 %333
<   store i32 %storemerge..i, i32* %325, align 4
<   %334 = load %struct.CPUX86State** @env, align 8
<   %335 = getelementptr inbounds %struct.CPUX86State* %334, i64 0, i32 7
<   store i32 0, i32* %335, align 4
<   %336 = load %struct.CPUX86State** @env, align 8
<   %337 = getelementptr inbounds %struct.CPUX86State* %336, i64 0, i32 38
<   %338 = load i64* %337, align 8
<   %339 = add i64 %338, 1392
<   %340 = tail call i64 @ldq_phys(i64 %339) nounwind
<   %341 = trunc i64 %340 to i32
<   %342 = and i32 %341, 2261
<   %343 = load %struct.CPUX86State** @env, align 8
<   %344 = getelementptr inbounds %struct.CPUX86State* %343, i64 0, i32 2
<   store i32 %342, i32* %344, align 4
<   %345 = lshr i32 %341, 9
<   %346 = and i32 %345, 2
<   %347 = xor i32 %346, 2
<   %348 = add i32 %347, -1
<   %349 = load %struct.CPUX86State** @env, align 8
<   %350 = getelementptr inbounds %struct.CPUX86State* %349, i64 0, i32 6
<   store i32 %348, i32* %350, align 4
<   %351 = load %struct.CPUX86State** @env, align 8
<   %352 = getelementptr inbounds %struct.CPUX86State* %351, i64 0, i32 7
<   %353 = load i32* %352, align 4
<   %354 = and i32 %353, 3285
<   %355 = and i32 %341, -3286
<   %356 = or i32 %354, %355
<   store i32 %356, i32* %352, align 4
<   %357 = load %struct.CPUX86State** @env, align 8
<   %358 = getelementptr inbounds %struct.CPUX86State* %357, i64 0, i32 1
<   store i32 1, i32* %358, align 4
<   %359 = load %struct.CPUX86State** @env, align 8
<   %360 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 38
<   %361 = load i64* %360, align 8
<   %362 = add i64 %361, 1024
<   %363 = tail call i32 @lduw_phys(i64 %362) nounwind
<   %364 = add i64 %361, 1032
<   %365 = tail call i64 @ldq_phys(i64 %364) nounwind
<   %366 = trunc i64 %365 to i32
<   %367 = add i64 %361, 1028
<   %368 = tail call i32 @ldl_phys(i64 %367) nounwind
<   %369 = add i64 %361, 1026
<   %370 = tail call i32 @lduw_phys(i64 %369) nounwind
<   %371 = shl i32 %370, 8
<   %372 = and i32 %371, 65280
<   %373 = shl i32 %370, 12
<   %374 = and i32 %373, 15728640
<   %375 = or i32 %372, %374
<   %376 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 0, i32 0
<   store i32 %363, i32* %376, align 4
<   %377 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 0, i32 1
<   store i32 %366, i32* %377, align 4
<   %378 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 0, i32 2
<   store i32 %368, i32* %378, align 4
<   %379 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 0, i32 3
<   store i32 %375, i32* %379, align 4
<   %.phi.trans.insert.i.i = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 8
<   %.pre.i.i = load i32* %.phi.trans.insert.i.i, align 4
<   %380 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 2, i32 3
<   %381 = load i32* %380, align 4
<   %382 = lshr i32 %381, 17
<   %383 = and i32 %382, 32
<   %384 = and i32 %.pre.i.i, 32768
<   %385 = icmp eq i32 %384, 0
<   br i1 %385, label %386, label %svm_load_seg_cache.exit
---
> ; <label>:48                                      ; preds = %30, %26
>   %49 = phi i1 [ false, %26 ], [ %47, %30 ]
>   %50 = zext i1 %49 to i32
>   store i32 %50, i32* %1
>   br label %83
> 
> ; <label>:51                                      ; preds = %18
>   %52 = load i8* %aSign, align 1
>   %53 = zext i8 %52 to i32
>   %54 = icmp ne i32 %53, 0
>   br i1 %54, label %55, label %68
> 
> ; <label>:55                                      ; preds = %51
>   %56 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %57 = load i16* %56, align 1
>   %58 = zext i16 %57 to i64
>   %59 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %60 = load i64* %59, align 1
>   %61 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %62 = load i16* %61, align 1
>   %63 = zext i16 %62 to i64
>   %64 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %65 = load i64* %64, align 1
>   %66 = call zeroext i8 @lt128(i64 %58, i64 %60, i64 %63, i64 %65)
>   %67 = zext i8 %66 to i32
>   br label %81
> 
> ; <label>:68                                      ; preds = %51
>   %69 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %70 = load i16* %69, align 1
>   %71 = zext i16 %70 to i64
>   %72 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %73 = load i64* %72, align 1
>   %74 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %75 = load i16* %74, align 1
>   %76 = zext i16 %75 to i64
>   %77 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %78 = load i64* %77, align 1
>   %79 = call zeroext i8 @lt128(i64 %71, i64 %73, i64 %76, i64 %78)
>   %80 = zext i8 %79 to i32
>   br label %81
> 
> ; <label>:81                                      ; preds = %68, %55
>   %82 = phi i32 [ %67, %55 ], [ %80, %68 ]
>   store i32 %82, i32* %1
>   br label %83
> 
> ; <label>:83                                      ; preds = %81, %48, %16
>   %84 = load i32* %1
>   ret i32 %84
> }
> 
> define internal i32 @floatx80_unordered(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   %4 = icmp eq i32 %3, 32767
>   br i1 %4, label %5, label %9
> 
> ; <label>:5                                       ; preds = %0
>   %6 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %7 = shl i64 %6, 1
>   %8 = icmp ne i64 %7, 0
>   br i1 %8, label %16, label %9
> 
> ; <label>:9                                       ; preds = %5, %0
>   %10 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   %11 = icmp eq i32 %10, 32767
>   br i1 %11, label %12, label %18
> 
> ; <label>:12                                      ; preds = %9
>   %13 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   %14 = shl i64 %13, 1
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %18
> 
> ; <label>:16                                      ; preds = %12, %5
>   %17 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %17)
>   store i32 1, i32* %1
>   br label %19
> 
> ; <label>:18                                      ; preds = %12, %9
>   store i32 0, i32* %1
>   br label %19
> 
> ; <label>:19                                      ; preds = %18, %16
>   %20 = load i32* %1
>   ret i32 %20
> }
> 
> define internal i32 @floatx80_eq_quiet(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   %4 = icmp eq i32 %3, 32767
>   br i1 %4, label %5, label %9
> 
> ; <label>:5                                       ; preds = %0
>   %6 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %7 = shl i64 %6, 1
>   %8 = icmp ne i64 %7, 0
>   br i1 %8, label %16, label %9
> 
> ; <label>:9                                       ; preds = %5, %0
>   %10 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   %11 = icmp eq i32 %10, 32767
>   br i1 %11, label %12, label %25
> 
> ; <label>:12                                      ; preds = %9
>   %13 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   %14 = shl i64 %13, 1
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %25
> 
> ; <label>:16                                      ; preds = %12, %5
>   %17 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %a)
>   %18 = icmp ne i32 %17, 0
>   br i1 %18, label %22, label %19
> 
> ; <label>:19                                      ; preds = %16
>   %20 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %b)
>   %21 = icmp ne i32 %20, 0
>   br i1 %21, label %22, label %24
> 
> ; <label>:22                                      ; preds = %19, %16
>   %23 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %23)
>   br label %24
> 
> ; <label>:24                                      ; preds = %22, %19
>   store i32 0, i32* %1
>   br label %62
> 
> ; <label>:25                                      ; preds = %12, %9
>   %26 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %27 = load i64* %26, align 1
>   %28 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %29 = load i64* %28, align 1
>   %30 = icmp eq i64 %27, %29
>   br i1 %30, label %31, label %59
> 
> ; <label>:31                                      ; preds = %25
>   %32 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %33 = load i16* %32, align 1
>   %34 = zext i16 %33 to i32
>   %35 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %36 = load i16* %35, align 1
>   %37 = zext i16 %36 to i32
>   %38 = icmp eq i32 %34, %37
>   br i1 %38, label %57, label %39
> 
> ; <label>:39                                      ; preds = %31
>   %40 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %41 = load i64* %40, align 1
>   %42 = icmp eq i64 %41, 0
>   br i1 %42, label %43, label %55
> 
> ; <label>:43                                      ; preds = %39
>   %44 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %45 = load i16* %44, align 1
>   %46 = zext i16 %45 to i32
>   %47 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %48 = load i16* %47, align 1
>   %49 = zext i16 %48 to i32
>   %50 = or i32 %46, %49
>   %51 = shl i32 %50, 1
>   %52 = trunc i32 %51 to i16
>   %53 = zext i16 %52 to i32
>   %54 = icmp eq i32 %53, 0
>   br label %55
> 
> ; <label>:55                                      ; preds = %43, %39
>   %56 = phi i1 [ false, %39 ], [ %54, %43 ]
>   br label %57
> 
> ; <label>:57                                      ; preds = %55, %31
>   %58 = phi i1 [ true, %31 ], [ %56, %55 ]
>   br label %59
> 
> ; <label>:59                                      ; preds = %57, %25
>   %60 = phi i1 [ false, %25 ], [ %58, %57 ]
>   %61 = zext i1 %60 to i32
>   store i32 %61, i32* %1
>   br label %62
> 
> ; <label>:62                                      ; preds = %59, %24
>   %63 = load i32* %1
>   ret i32 %63
> }
> 
> define internal i32 @floatx80_le_quiet(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   %4 = icmp eq i32 %3, 32767
>   br i1 %4, label %5, label %9
> 
> ; <label>:5                                       ; preds = %0
>   %6 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %7 = shl i64 %6, 1
>   %8 = icmp ne i64 %7, 0
>   br i1 %8, label %16, label %9
> 
> ; <label>:9                                       ; preds = %5, %0
>   %10 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   %11 = icmp eq i32 %10, 32767
>   br i1 %11, label %12, label %25
> 
> ; <label>:12                                      ; preds = %9
>   %13 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   %14 = shl i64 %13, 1
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %25
> 
> ; <label>:16                                      ; preds = %12, %5
>   %17 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %a)
>   %18 = icmp ne i32 %17, 0
>   br i1 %18, label %22, label %19
> 
> ; <label>:19                                      ; preds = %16
>   %20 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %b)
>   %21 = icmp ne i32 %20, 0
>   br i1 %21, label %22, label %24
> 
> ; <label>:22                                      ; preds = %19, %16
>   %23 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %23)
>   br label %24
> 
> ; <label>:24                                      ; preds = %22, %19
>   store i32 0, i32* %1
>   br label %90
> 
> ; <label>:25                                      ; preds = %12, %9
>   %26 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %26, i8* %aSign, align 1
>   %27 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %b)
>   store i8 %27, i8* %bSign, align 1
>   %28 = load i8* %aSign, align 1
>   %29 = zext i8 %28 to i32
>   %30 = load i8* %bSign, align 1
>   %31 = zext i8 %30 to i32
>   %32 = icmp ne i32 %29, %31
>   br i1 %32, label %33, label %58
> 
> ; <label>:33                                      ; preds = %25
>   %34 = load i8* %aSign, align 1
>   %35 = zext i8 %34 to i32
>   %36 = icmp ne i32 %35, 0
>   br i1 %36, label %55, label %37
> 
> ; <label>:37                                      ; preds = %33
>   %38 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %39 = load i16* %38, align 1
>   %40 = zext i16 %39 to i32
>   %41 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %42 = load i16* %41, align 1
>   %43 = zext i16 %42 to i32
>   %44 = or i32 %40, %43
>   %45 = shl i32 %44, 1
>   %46 = trunc i32 %45 to i16
>   %47 = zext i16 %46 to i64
>   %48 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %49 = load i64* %48, align 1
>   %50 = or i64 %47, %49
>   %51 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %52 = load i64* %51, align 1
>   %53 = or i64 %50, %52
>   %54 = icmp eq i64 %53, 0
>   br label %55
> 
> ; <label>:55                                      ; preds = %37, %33
>   %56 = phi i1 [ true, %33 ], [ %54, %37 ]
>   %57 = zext i1 %56 to i32
>   store i32 %57, i32* %1
>   br label %90
> 
> ; <label>:58                                      ; preds = %25
>   %59 = load i8* %aSign, align 1
>   %60 = zext i8 %59 to i32
>   %61 = icmp ne i32 %60, 0
>   br i1 %61, label %62, label %75
> 
> ; <label>:62                                      ; preds = %58
>   %63 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %64 = load i16* %63, align 1
>   %65 = zext i16 %64 to i64
>   %66 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %67 = load i64* %66, align 1
>   %68 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %69 = load i16* %68, align 1
>   %70 = zext i16 %69 to i64
>   %71 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %72 = load i64* %71, align 1
>   %73 = call zeroext i8 @le128(i64 %65, i64 %67, i64 %70, i64 %72)
>   %74 = zext i8 %73 to i32
>   br label %88
> 
> ; <label>:75                                      ; preds = %58
>   %76 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %77 = load i16* %76, align 1
>   %78 = zext i16 %77 to i64
>   %79 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %80 = load i64* %79, align 1
>   %81 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %82 = load i16* %81, align 1
>   %83 = zext i16 %82 to i64
>   %84 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %85 = load i64* %84, align 1
>   %86 = call zeroext i8 @le128(i64 %78, i64 %80, i64 %83, i64 %85)
>   %87 = zext i8 %86 to i32
>   br label %88
> 
> ; <label>:88                                      ; preds = %75, %62
>   %89 = phi i32 [ %74, %62 ], [ %87, %75 ]
>   store i32 %89, i32* %1
>   br label %90
> 
> ; <label>:90                                      ; preds = %88, %55, %24
>   %91 = load i32* %1
>   ret i32 %91
> }
> 
> define internal i32 @floatx80_lt_quiet(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   %4 = icmp eq i32 %3, 32767
>   br i1 %4, label %5, label %9
> 
> ; <label>:5                                       ; preds = %0
>   %6 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %7 = shl i64 %6, 1
>   %8 = icmp ne i64 %7, 0
>   br i1 %8, label %16, label %9
> 
> ; <label>:9                                       ; preds = %5, %0
>   %10 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   %11 = icmp eq i32 %10, 32767
>   br i1 %11, label %12, label %25
> 
> ; <label>:12                                      ; preds = %9
>   %13 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   %14 = shl i64 %13, 1
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %25
> 
> ; <label>:16                                      ; preds = %12, %5
>   %17 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %a)
>   %18 = icmp ne i32 %17, 0
>   br i1 %18, label %22, label %19
> 
> ; <label>:19                                      ; preds = %16
>   %20 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %b)
>   %21 = icmp ne i32 %20, 0
>   br i1 %21, label %22, label %24
> 
> ; <label>:22                                      ; preds = %19, %16
>   %23 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %23)
>   br label %24
> 
> ; <label>:24                                      ; preds = %22, %19
>   store i32 0, i32* %1
>   br label %90
> 
> ; <label>:25                                      ; preds = %12, %9
>   %26 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %26, i8* %aSign, align 1
>   %27 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %b)
>   store i8 %27, i8* %bSign, align 1
>   %28 = load i8* %aSign, align 1
>   %29 = zext i8 %28 to i32
>   %30 = load i8* %bSign, align 1
>   %31 = zext i8 %30 to i32
>   %32 = icmp ne i32 %29, %31
>   br i1 %32, label %33, label %58
> 
> ; <label>:33                                      ; preds = %25
>   %34 = load i8* %aSign, align 1
>   %35 = zext i8 %34 to i32
>   %36 = icmp ne i32 %35, 0
>   br i1 %36, label %37, label %55
> 
> ; <label>:37                                      ; preds = %33
>   %38 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %39 = load i16* %38, align 1
>   %40 = zext i16 %39 to i32
>   %41 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %42 = load i16* %41, align 1
>   %43 = zext i16 %42 to i32
>   %44 = or i32 %40, %43
>   %45 = shl i32 %44, 1
>   %46 = trunc i32 %45 to i16
>   %47 = zext i16 %46 to i64
>   %48 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %49 = load i64* %48, align 1
>   %50 = or i64 %47, %49
>   %51 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %52 = load i64* %51, align 1
>   %53 = or i64 %50, %52
>   %54 = icmp ne i64 %53, 0
>   br label %55
> 
> ; <label>:55                                      ; preds = %37, %33
>   %56 = phi i1 [ false, %33 ], [ %54, %37 ]
>   %57 = zext i1 %56 to i32
>   store i32 %57, i32* %1
>   br label %90
> 
> ; <label>:58                                      ; preds = %25
>   %59 = load i8* %aSign, align 1
>   %60 = zext i8 %59 to i32
>   %61 = icmp ne i32 %60, 0
>   br i1 %61, label %62, label %75
> 
> ; <label>:62                                      ; preds = %58
>   %63 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %64 = load i16* %63, align 1
>   %65 = zext i16 %64 to i64
>   %66 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %67 = load i64* %66, align 1
>   %68 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %69 = load i16* %68, align 1
>   %70 = zext i16 %69 to i64
>   %71 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %72 = load i64* %71, align 1
>   %73 = call zeroext i8 @lt128(i64 %65, i64 %67, i64 %70, i64 %72)
>   %74 = zext i8 %73 to i32
>   br label %88
> 
> ; <label>:75                                      ; preds = %58
>   %76 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %77 = load i16* %76, align 1
>   %78 = zext i16 %77 to i64
>   %79 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %80 = load i64* %79, align 1
>   %81 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %82 = load i16* %81, align 1
>   %83 = zext i16 %82 to i64
>   %84 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %85 = load i64* %84, align 1
>   %86 = call zeroext i8 @lt128(i64 %78, i64 %80, i64 %83, i64 %85)
>   %87 = zext i8 %86 to i32
>   br label %88
> 
> ; <label>:88                                      ; preds = %75, %62
>   %89 = phi i32 [ %74, %62 ], [ %87, %75 ]
>   store i32 %89, i32* %1
>   br label %90
> 
> ; <label>:90                                      ; preds = %88, %55, %24
>   %91 = load i32* %1
>   ret i32 %91
> }
> 
> define internal i32 @floatx80_unordered_quiet(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   %4 = icmp eq i32 %3, 32767
>   br i1 %4, label %5, label %9
> 
> ; <label>:5                                       ; preds = %0
>   %6 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %7 = shl i64 %6, 1
>   %8 = icmp ne i64 %7, 0
>   br i1 %8, label %16, label %9
> 
> ; <label>:9                                       ; preds = %5, %0
>   %10 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   %11 = icmp eq i32 %10, 32767
>   br i1 %11, label %12, label %25
> 
> ; <label>:12                                      ; preds = %9
>   %13 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   %14 = shl i64 %13, 1
>   %15 = icmp ne i64 %14, 0
>   br i1 %15, label %16, label %25
> 
> ; <label>:16                                      ; preds = %12, %5
>   %17 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %a)
>   %18 = icmp ne i32 %17, 0
>   br i1 %18, label %22, label %19
> 
> ; <label>:19                                      ; preds = %16
>   %20 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %b)
>   %21 = icmp ne i32 %20, 0
>   br i1 %21, label %22, label %24
> 
> ; <label>:22                                      ; preds = %19, %16
>   %23 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %23)
>   br label %24
> 
> ; <label>:24                                      ; preds = %22, %19
>   store i32 1, i32* %1
>   br label %26
> 
> ; <label>:25                                      ; preds = %12, %9
>   store i32 0, i32* %1
>   br label %26
> 
> ; <label>:26                                      ; preds = %25, %24
>   %27 = load i32* %1
>   ret i32 %27
> }
> 
> define internal i32 @float128_to_int32(i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %5 = load i64* %4, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %7 = load i64* %6, align 4
>   %8 = call i64 @extractFloat128Frac1(i64 %5, i64 %7)
>   store i64 %8, i64* %aSig1, align 8
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %10 = load i64* %9, align 4
>   %11 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %12 = load i64* %11, align 4
>   %13 = call i64 @extractFloat128Frac0(i64 %10, i64 %12)
>   store i64 %13, i64* %aSig0, align 8
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i32 @extractFloat128Exp(i64 %15, i64 %17)
>   store i32 %18, i32* %aExp, align 4
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call zeroext i8 @extractFloat128Sign(i64 %20, i64 %22)
>   store i8 %23, i8* %aSign, align 1
>   %24 = load i32* %aExp, align 4
>   %25 = icmp eq i32 %24, 32767
>   br i1 %25, label %26, label %32
> 
> ; <label>:26                                      ; preds = %0
>   %27 = load i64* %aSig0, align 8
>   %28 = load i64* %aSig1, align 8
>   %29 = or i64 %27, %28
>   %30 = icmp ne i64 %29, 0
>   br i1 %30, label %31, label %32
> 
> ; <label>:31                                      ; preds = %26
>   store i8 0, i8* %aSign, align 1
>   br label %32
> 
> ; <label>:32                                      ; preds = %31, %26, %0
>   %33 = load i32* %aExp, align 4
>   %34 = icmp ne i32 %33, 0
>   br i1 %34, label %35, label %38
> 
> ; <label>:35                                      ; preds = %32
>   %36 = load i64* %aSig0, align 8
>   %37 = or i64 %36, 281474976710656
>   store i64 %37, i64* %aSig0, align 8
>   br label %38
> 
> ; <label>:38                                      ; preds = %35, %32
>   %39 = load i64* %aSig1, align 8
>   %40 = icmp ne i64 %39, 0
>   %41 = zext i1 %40 to i32
>   %42 = sext i32 %41 to i64
>   %43 = load i64* %aSig0, align 8
>   %44 = or i64 %43, %42
>   store i64 %44, i64* %aSig0, align 8
>   %45 = load i32* %aExp, align 4
>   %46 = sub nsw i32 16424, %45
>   store i32 %46, i32* %shiftCount, align 4
>   %47 = load i32* %shiftCount, align 4
>   %48 = icmp slt i32 0, %47
>   br i1 %48, label %49, label %52
> 
> ; <label>:49                                      ; preds = %38
>   %50 = load i64* %aSig0, align 8
>   %51 = load i32* %shiftCount, align 4
>   call void @shift64RightJamming(i64 %50, i32 %51, i64* %aSig0)
>   br label %52
> 
> ; <label>:52                                      ; preds = %49, %38
>   %53 = load i8* %aSign, align 1
>   %54 = load i64* %aSig0, align 8
>   %55 = load %struct.float_status** %1, align 4
>   %56 = call i32 @roundAndPackInt32(i8 zeroext %53, i64 %54, %struct.float_status* %55)
>   ret i32 %56
> }
> 
> define internal i64 @extractFloat128Frac1(i64 %a.0, i64 %a.1) nounwind inlinehint {
>   %a = alloca %struct.float128, align 4
>   %1 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %1, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %4 = load i64* %3, align 4
>   ret i64 %4
> }
> 
> define internal i64 @extractFloat128Frac0(i64 %a.0, i64 %a.1) nounwind inlinehint {
>   %a = alloca %struct.float128, align 4
>   %1 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %1, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %4 = load i64* %3, align 4
>   %5 = and i64 %4, 281474976710655
>   ret i64 %5
> }
> 
> define internal i32 @extractFloat128Exp(i64 %a.0, i64 %a.1) nounwind inlinehint {
>   %a = alloca %struct.float128, align 4
>   %1 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %1, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %4 = load i64* %3, align 4
>   %5 = lshr i64 %4, 48
>   %6 = and i64 %5, 32767
>   %7 = trunc i64 %6 to i32
>   ret i32 %7
> }
> 
> define internal zeroext i8 @extractFloat128Sign(i64 %a.0, i64 %a.1) nounwind inlinehint {
>   %a = alloca %struct.float128, align 4
>   %1 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %1, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %4 = load i64* %3, align 4
>   %5 = lshr i64 %4, 63
>   %6 = trunc i64 %5 to i8
>   ret i8 %6
> }
> 
> define internal i32 @float128_to_int32_round_to_zero(i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %savedASig = alloca i64, align 8
>   %z = alloca i32, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %5 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %6 = load i64* %5, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %8 = load i64* %7, align 4
>   %9 = call i64 @extractFloat128Frac1(i64 %6, i64 %8)
>   store i64 %9, i64* %aSig1, align 8
>   %10 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %11 = load i64* %10, align 4
>   %12 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %13 = load i64* %12, align 4
>   %14 = call i64 @extractFloat128Frac0(i64 %11, i64 %13)
>   store i64 %14, i64* %aSig0, align 8
>   %15 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %16 = load i64* %15, align 4
>   %17 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %18 = load i64* %17, align 4
>   %19 = call i32 @extractFloat128Exp(i64 %16, i64 %18)
>   store i32 %19, i32* %aExp, align 4
>   %20 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %21 = load i64* %20, align 4
>   %22 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %23 = load i64* %22, align 4
>   %24 = call zeroext i8 @extractFloat128Sign(i64 %21, i64 %23)
>   store i8 %24, i8* %aSign, align 1
>   %25 = load i64* %aSig1, align 8
>   %26 = icmp ne i64 %25, 0
>   %27 = zext i1 %26 to i32
>   %28 = sext i32 %27 to i64
>   %29 = load i64* %aSig0, align 8
>   %30 = or i64 %29, %28
>   store i64 %30, i64* %aSig0, align 8
>   %31 = load i32* %aExp, align 4
>   %32 = icmp slt i32 16414, %31
>   br i1 %32, label %33, label %41
> 
> ; <label>:33                                      ; preds = %0
>   %34 = load i32* %aExp, align 4
>   %35 = icmp eq i32 %34, 32767
>   br i1 %35, label %36, label %40
> 
> ; <label>:36                                      ; preds = %33
>   %37 = load i64* %aSig0, align 8
>   %38 = icmp ne i64 %37, 0
>   br i1 %38, label %39, label %40
> 
> ; <label>:39                                      ; preds = %36
>   store i8 0, i8* %aSign, align 1
>   br label %40
> 
> ; <label>:40                                      ; preds = %39, %36, %33
>   br label %85
> 
> ; <label>:41                                      ; preds = %0
>   %42 = load i32* %aExp, align 4
>   %43 = icmp slt i32 %42, 16383
>   br i1 %43, label %44, label %58
> 
> ; <label>:44                                      ; preds = %41
>   %45 = load i32* %aExp, align 4
>   %46 = icmp ne i32 %45, 0
>   br i1 %46, label %50, label %47
> 
> ; <label>:47                                      ; preds = %44
>   %48 = load i64* %aSig0, align 8
>   %49 = icmp ne i64 %48, 0
>   br i1 %49, label %50, label %57
> 
> ; <label>:50                                      ; preds = %47, %44
>   %51 = load %struct.float_status** %2, align 4
>   %52 = getelementptr inbounds %struct.float_status* %51, i32 0, i32 2
>   %53 = load i8* %52, align 1
>   %54 = sext i8 %53 to i32
>   %55 = or i32 %54, 32
>   %56 = trunc i32 %55 to i8
>   store i8 %56, i8* %52, align 1
>   br label %57
> 
> ; <label>:57                                      ; preds = %50, %47
>   store i32 0, i32* %1
>   br label %107
> 
> ; <label>:58                                      ; preds = %41
>   br label %59
> 
> ; <label>:59                                      ; preds = %58
>   %60 = load i64* %aSig0, align 8
>   %61 = or i64 %60, 281474976710656
>   store i64 %61, i64* %aSig0, align 8
>   %62 = load i32* %aExp, align 4
>   %63 = sub nsw i32 16431, %62
>   store i32 %63, i32* %shiftCount, align 4
>   %64 = load i64* %aSig0, align 8
>   store i64 %64, i64* %savedASig, align 8
>   %65 = load i32* %shiftCount, align 4
>   %66 = load i64* %aSig0, align 8
>   %67 = zext i32 %65 to i64
>   %68 = lshr i64 %66, %67
>   store i64 %68, i64* %aSig0, align 8
>   %69 = load i64* %aSig0, align 8
>   %70 = trunc i64 %69 to i32
>   store i32 %70, i32* %z, align 4
>   %71 = load i8* %aSign, align 1
>   %72 = icmp ne i8 %71, 0
>   br i1 %72, label %73, label %76
> 
> ; <label>:73                                      ; preds = %59
>   %74 = load i32* %z, align 4
>   %75 = sub nsw i32 0, %74
>   store i32 %75, i32* %z, align 4
>   br label %76
> 
> ; <label>:76                                      ; preds = %73, %59
>   %77 = load i32* %z, align 4
>   %78 = icmp slt i32 %77, 0
>   %79 = zext i1 %78 to i32
>   %80 = load i8* %aSign, align 1
>   %81 = zext i8 %80 to i32
>   %82 = xor i32 %79, %81
>   %83 = icmp ne i32 %82, 0
>   br i1 %83, label %84, label %91
> 
> ; <label>:84                                      ; preds = %76
>   br label %85
> 
> ; <label>:85                                      ; preds = %84, %40
>   %86 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %86)
>   %87 = load i8* %aSign, align 1
>   %88 = zext i8 %87 to i32
>   %89 = icmp ne i32 %88, 0
>   %90 = select i1 %89, i32 -2147483648, i32 2147483647
>   store i32 %90, i32* %1
>   br label %107
> 
> ; <label>:91                                      ; preds = %76
>   %92 = load i64* %aSig0, align 8
>   %93 = load i32* %shiftCount, align 4
>   %94 = zext i32 %93 to i64
>   %95 = shl i64 %92, %94
>   %96 = load i64* %savedASig, align 8
>   %97 = icmp ne i64 %95, %96
>   br i1 %97, label %98, label %105
> 
> ; <label>:98                                      ; preds = %91
>   %99 = load %struct.float_status** %2, align 4
>   %100 = getelementptr inbounds %struct.float_status* %99, i32 0, i32 2
>   %101 = load i8* %100, align 1
>   %102 = sext i8 %101 to i32
>   %103 = or i32 %102, 32
>   %104 = trunc i32 %103 to i8
>   store i8 %104, i8* %100, align 1
>   br label %105
> 
> ; <label>:105                                     ; preds = %98, %91
>   %106 = load i32* %z, align 4
>   store i32 %106, i32* %1
>   br label %107
> 
> ; <label>:107                                     ; preds = %105, %85, %57
>   %108 = load i32* %1
>   ret i32 %108
> }
> 
> define internal i64 @float128_to_int64(i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %a = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %5 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %6 = load i64* %5, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %8 = load i64* %7, align 4
>   %9 = call i64 @extractFloat128Frac1(i64 %6, i64 %8)
>   store i64 %9, i64* %aSig1, align 8
>   %10 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %11 = load i64* %10, align 4
>   %12 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %13 = load i64* %12, align 4
>   %14 = call i64 @extractFloat128Frac0(i64 %11, i64 %13)
>   store i64 %14, i64* %aSig0, align 8
>   %15 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %16 = load i64* %15, align 4
>   %17 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %18 = load i64* %17, align 4
>   %19 = call i32 @extractFloat128Exp(i64 %16, i64 %18)
>   store i32 %19, i32* %aExp, align 4
>   %20 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %21 = load i64* %20, align 4
>   %22 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %23 = load i64* %22, align 4
>   %24 = call zeroext i8 @extractFloat128Sign(i64 %21, i64 %23)
>   store i8 %24, i8* %aSign, align 1
>   %25 = load i32* %aExp, align 4
>   %26 = icmp ne i32 %25, 0
>   br i1 %26, label %27, label %30
> 
> ; <label>:27                                      ; preds = %0
>   %28 = load i64* %aSig0, align 8
>   %29 = or i64 %28, 281474976710656
>   store i64 %29, i64* %aSig0, align 8
>   br label %30
> 
> ; <label>:30                                      ; preds = %27, %0
>   %31 = load i32* %aExp, align 4
>   %32 = sub nsw i32 16431, %31
>   store i32 %32, i32* %shiftCount, align 4
>   %33 = load i32* %shiftCount, align 4
>   %34 = icmp sle i32 %33, 0
>   br i1 %34, label %35, label %58
> 
> ; <label>:35                                      ; preds = %30
>   %36 = load i32* %aExp, align 4
>   %37 = icmp slt i32 16446, %36
>   br i1 %37, label %38, label %53
> 
> ; <label>:38                                      ; preds = %35
>   %39 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %39)
>   %40 = load i8* %aSign, align 1
>   %41 = icmp ne i8 %40, 0
>   br i1 %41, label %42, label %51
> 
> ; <label>:42                                      ; preds = %38
>   %43 = load i32* %aExp, align 4
>   %44 = icmp eq i32 %43, 32767
>   br i1 %44, label %45, label %52
> 
> ; <label>:45                                      ; preds = %42
>   %46 = load i64* %aSig1, align 8
>   %47 = icmp ne i64 %46, 0
>   br i1 %47, label %51, label %48
> 
> ; <label>:48                                      ; preds = %45
>   %49 = load i64* %aSig0, align 8
>   %50 = icmp ne i64 %49, 281474976710656
>   br i1 %50, label %51, label %52
> 
> ; <label>:51                                      ; preds = %48, %45, %38
>   store i64 9223372036854775807, i64* %1
>   br label %68
> 
> ; <label>:52                                      ; preds = %48, %42
>   store i64 -9223372036854775808, i64* %1
>   br label %68
> 
> ; <label>:53                                      ; preds = %35
>   %54 = load i64* %aSig0, align 8
>   %55 = load i64* %aSig1, align 8
>   %56 = load i32* %shiftCount, align 4
>   %57 = sub nsw i32 0, %56
>   call void @shortShift128Left(i64 %54, i64 %55, i32 %57, i64* %aSig0, i64* %aSig1)
>   br label %62
> 
> ; <label>:58                                      ; preds = %30
>   %59 = load i64* %aSig0, align 8
>   %60 = load i64* %aSig1, align 8
>   %61 = load i32* %shiftCount, align 4
>   call void @shift64ExtraRightJamming(i64 %59, i64 %60, i32 %61, i64* %aSig0, i64* %aSig1)
>   br label %62
> 
> ; <label>:62                                      ; preds = %58, %53
>   %63 = load i8* %aSign, align 1
>   %64 = load i64* %aSig0, align 8
>   %65 = load i64* %aSig1, align 8
>   %66 = load %struct.float_status** %2, align 4
>   %67 = call i64 @roundAndPackInt64(i8 zeroext %63, i64 %64, i64 %65, %struct.float_status* %66)
>   store i64 %67, i64* %1
>   br label %68
> 
> ; <label>:68                                      ; preds = %62, %52, %51
>   %69 = load i64* %1
>   ret i64 %69
> }
> 
> define internal i64 @float128_to_int64_round_to_zero(i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %a = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %shiftCount = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %z = alloca i64, align 8
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %5 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %6 = load i64* %5, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %8 = load i64* %7, align 4
>   %9 = call i64 @extractFloat128Frac1(i64 %6, i64 %8)
>   store i64 %9, i64* %aSig1, align 8
>   %10 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %11 = load i64* %10, align 4
>   %12 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %13 = load i64* %12, align 4
>   %14 = call i64 @extractFloat128Frac0(i64 %11, i64 %13)
>   store i64 %14, i64* %aSig0, align 8
>   %15 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %16 = load i64* %15, align 4
>   %17 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %18 = load i64* %17, align 4
>   %19 = call i32 @extractFloat128Exp(i64 %16, i64 %18)
>   store i32 %19, i32* %aExp, align 4
>   %20 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %21 = load i64* %20, align 4
>   %22 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %23 = load i64* %22, align 4
>   %24 = call zeroext i8 @extractFloat128Sign(i64 %21, i64 %23)
>   store i8 %24, i8* %aSign, align 1
>   %25 = load i32* %aExp, align 4
>   %26 = icmp ne i32 %25, 0
>   br i1 %26, label %27, label %30
> 
> ; <label>:27                                      ; preds = %0
>   %28 = load i64* %aSig0, align 8
>   %29 = or i64 %28, 281474976710656
>   store i64 %29, i64* %aSig0, align 8
>   br label %30
> 
> ; <label>:30                                      ; preds = %27, %0
>   %31 = load i32* %aExp, align 4
>   %32 = sub nsw i32 %31, 16431
>   store i32 %32, i32* %shiftCount, align 4
>   %33 = load i32* %shiftCount, align 4
>   %34 = icmp slt i32 0, %33
>   br i1 %34, label %35, label %98
> 
> ; <label>:35                                      ; preds = %30
>   %36 = load i32* %aExp, align 4
>   %37 = icmp sle i32 16446, %36
>   br i1 %37, label %38, label %73
> 
> ; <label>:38                                      ; preds = %35
>   %39 = load i64* %aSig0, align 8
>   %40 = and i64 %39, 281474976710655
>   store i64 %40, i64* %aSig0, align 8
>   %41 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   %43 = icmp eq i64 %42, -4594234569871327232
>   br i1 %43, label %44, label %58
> 
> ; <label>:44                                      ; preds = %38
>   %45 = load i64* %aSig1, align 8
>   %46 = icmp ult i64 %45, 562949953421312
>   br i1 %46, label %47, label %58
> 
> ; <label>:47                                      ; preds = %44
>   %48 = load i64* %aSig1, align 8
>   %49 = icmp ne i64 %48, 0
>   br i1 %49, label %50, label %57
> 
> ; <label>:50                                      ; preds = %47
>   %51 = load %struct.float_status** %2, align 4
>   %52 = getelementptr inbounds %struct.float_status* %51, i32 0, i32 2
>   %53 = load i8* %52, align 1
>   %54 = sext i8 %53 to i32
>   %55 = or i32 %54, 32
>   %56 = trunc i32 %55 to i8
>   store i8 %56, i8* %52, align 1
>   br label %57
> 
> ; <label>:57                                      ; preds = %50, %47
>   br label %72
> 
> ; <label>:58                                      ; preds = %44, %38
>   %59 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %59)
>   %60 = load i8* %aSign, align 1
>   %61 = icmp ne i8 %60, 0
>   br i1 %61, label %62, label %70
> 
> ; <label>:62                                      ; preds = %58
>   %63 = load i32* %aExp, align 4
>   %64 = icmp eq i32 %63, 32767
>   br i1 %64, label %65, label %71
> 
> ; <label>:65                                      ; preds = %62
>   %66 = load i64* %aSig0, align 8
>   %67 = load i64* %aSig1, align 8
>   %68 = or i64 %66, %67
>   %69 = icmp ne i64 %68, 0
>   br i1 %69, label %70, label %71
> 
> ; <label>:70                                      ; preds = %65, %58
>   store i64 9223372036854775807, i64* %1
>   br label %151
> 
> ; <label>:71                                      ; preds = %65, %62
>   br label %72
> 
> ; <label>:72                                      ; preds = %71, %57
>   store i64 -9223372036854775808, i64* %1
>   br label %151
> 
> ; <label>:73                                      ; preds = %35
>   %74 = load i64* %aSig0, align 8
>   %75 = load i32* %shiftCount, align 4
>   %76 = zext i32 %75 to i64
>   %77 = shl i64 %74, %76
>   %78 = load i64* %aSig1, align 8
>   %79 = load i32* %shiftCount, align 4
>   %80 = sub nsw i32 0, %79
>   %81 = and i32 %80, 63
>   %82 = zext i32 %81 to i64
>   %83 = lshr i64 %78, %82
>   %84 = or i64 %77, %83
>   store i64 %84, i64* %z, align 8
>   %85 = load i64* %aSig1, align 8
>   %86 = load i32* %shiftCount, align 4
>   %87 = zext i32 %86 to i64
>   %88 = shl i64 %85, %87
>   %89 = icmp ne i64 %88, 0
>   br i1 %89, label %90, label %97
> 
> ; <label>:90                                      ; preds = %73
>   %91 = load %struct.float_status** %2, align 4
>   %92 = getelementptr inbounds %struct.float_status* %91, i32 0, i32 2
>   %93 = load i8* %92, align 1
>   %94 = sext i8 %93 to i32
>   %95 = or i32 %94, 32
>   %96 = trunc i32 %95 to i8
>   store i8 %96, i8* %92, align 1
>   br label %97
> 
> ; <label>:97                                      ; preds = %90, %73
>   br label %143
> 
> ; <label>:98                                      ; preds = %30
>   %99 = load i32* %aExp, align 4
>   %100 = icmp slt i32 %99, 16383
>   br i1 %100, label %101, label %117
> 
> ; <label>:101                                     ; preds = %98
>   %102 = load i32* %aExp, align 4
>   %103 = sext i32 %102 to i64
>   %104 = load i64* %aSig0, align 8
>   %105 = or i64 %103, %104
>   %106 = load i64* %aSig1, align 8
>   %107 = or i64 %105, %106
>   %108 = icmp ne i64 %107, 0
>   br i1 %108, label %109, label %116
> 
> ; <label>:109                                     ; preds = %101
>   %110 = load %struct.float_status** %2, align 4
>   %111 = getelementptr inbounds %struct.float_status* %110, i32 0, i32 2
>   %112 = load i8* %111, align 1
>   %113 = sext i8 %112 to i32
>   %114 = or i32 %113, 32
>   %115 = trunc i32 %114 to i8
>   store i8 %115, i8* %111, align 1
>   br label %116
> 
> ; <label>:116                                     ; preds = %109, %101
>   store i64 0, i64* %1
>   br label %151
> 
> ; <label>:117                                     ; preds = %98
>   %118 = load i64* %aSig0, align 8
>   %119 = load i32* %shiftCount, align 4
>   %120 = sub nsw i32 0, %119
>   %121 = zext i32 %120 to i64
>   %122 = lshr i64 %118, %121
>   store i64 %122, i64* %z, align 8
>   %123 = load i64* %aSig1, align 8
>   %124 = icmp ne i64 %123, 0
>   br i1 %124, label %135, label %125
> 
> ; <label>:125                                     ; preds = %117
>   %126 = load i32* %shiftCount, align 4
>   %127 = icmp ne i32 %126, 0
>   br i1 %127, label %128, label %142
> 
> ; <label>:128                                     ; preds = %125
>   %129 = load i64* %aSig0, align 8
>   %130 = load i32* %shiftCount, align 4
>   %131 = and i32 %130, 63
>   %132 = zext i32 %131 to i64
>   %133 = shl i64 %129, %132
>   %134 = icmp ne i64 %133, 0
>   br i1 %134, label %135, label %142
> 
> ; <label>:135                                     ; preds = %128, %117
>   %136 = load %struct.float_status** %2, align 4
>   %137 = getelementptr inbounds %struct.float_status* %136, i32 0, i32 2
>   %138 = load i8* %137, align 1
>   %139 = sext i8 %138 to i32
>   %140 = or i32 %139, 32
>   %141 = trunc i32 %140 to i8
>   store i8 %141, i8* %137, align 1
>   br label %142
> 
> ; <label>:142                                     ; preds = %135, %128, %125
>   br label %143
> 
> ; <label>:143                                     ; preds = %142, %97
>   %144 = load i8* %aSign, align 1
>   %145 = icmp ne i8 %144, 0
>   br i1 %145, label %146, label %149
> 
> ; <label>:146                                     ; preds = %143
>   %147 = load i64* %z, align 8
>   %148 = sub nsw i64 0, %147
>   store i64 %148, i64* %z, align 8
>   br label %149
> 
> ; <label>:149                                     ; preds = %146, %143
>   %150 = load i64* %z, align 8
>   store i64 %150, i64* %1
>   br label %151
> 
> ; <label>:151                                     ; preds = %149, %116, %72, %70
>   %152 = load i64* %1
>   ret i64 %152
> }
> 
> define internal i32 @float128_to_float32(i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %zSig = alloca i32, align 4
>   %3 = alloca %struct.commonNaNT, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %7 = load i64* %6, align 4
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %9 = load i64* %8, align 4
>   %10 = call i64 @extractFloat128Frac1(i64 %7, i64 %9)
>   store i64 %10, i64* %aSig1, align 8
>   %11 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %12 = load i64* %11, align 4
>   %13 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = call i64 @extractFloat128Frac0(i64 %12, i64 %14)
>   store i64 %15, i64* %aSig0, align 8
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %17 = load i64* %16, align 4
>   %18 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %19 = load i64* %18, align 4
>   %20 = call i32 @extractFloat128Exp(i64 %17, i64 %19)
>   store i32 %20, i32* %aExp, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %22 = load i64* %21, align 4
>   %23 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %24 = load i64* %23, align 4
>   %25 = call zeroext i8 @extractFloat128Sign(i64 %22, i64 %24)
>   store i8 %25, i8* %aSign, align 1
>   %26 = load i32* %aExp, align 4
>   %27 = icmp eq i32 %26, 32767
>   br i1 %27, label %28, label %44
> 
> ; <label>:28                                      ; preds = %0
>   %29 = load i64* %aSig0, align 8
>   %30 = load i64* %aSig1, align 8
>   %31 = or i64 %29, %30
>   %32 = icmp ne i64 %31, 0
>   br i1 %32, label %33, label %41
> 
> ; <label>:33                                      ; preds = %28
>   %34 = load %struct.float_status** %2, align 4
>   %35 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %36 = load i64* %35, align 4
>   %37 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %38 = load i64* %37, align 4
>   call void @float128ToCommonNaN(%struct.commonNaNT* sret %3, i64 %36, i64 %38, %struct.float_status* %34)
>   %39 = load %struct.float_status** %2, align 4
>   %40 = call i32 @commonNaNToFloat32(%struct.commonNaNT* byval align 4 %3, %struct.float_status* %39)
>   store i32 %40, i32* %1
>   br label %70
> 
> ; <label>:41                                      ; preds = %28
>   %42 = load i8* %aSign, align 1
>   %43 = call i32 @packFloat32(i8 zeroext %42, i32 255, i32 0)
>   store i32 %43, i32* %1
>   br label %70
> 
> ; <label>:44                                      ; preds = %0
>   %45 = load i64* %aSig1, align 8
>   %46 = icmp ne i64 %45, 0
>   %47 = zext i1 %46 to i32
>   %48 = sext i32 %47 to i64
>   %49 = load i64* %aSig0, align 8
>   %50 = or i64 %49, %48
>   store i64 %50, i64* %aSig0, align 8
>   %51 = load i64* %aSig0, align 8
>   call void @shift64RightJamming(i64 %51, i32 18, i64* %aSig0)
>   %52 = load i64* %aSig0, align 8
>   %53 = trunc i64 %52 to i32
>   store i32 %53, i32* %zSig, align 4
>   %54 = load i32* %aExp, align 4
>   %55 = icmp ne i32 %54, 0
>   br i1 %55, label %59, label %56
> 
> ; <label>:56                                      ; preds = %44
>   %57 = load i32* %zSig, align 4
>   %58 = icmp ne i32 %57, 0
>   br i1 %58, label %59, label %64
> 
> ; <label>:59                                      ; preds = %56, %44
>   %60 = load i32* %zSig, align 4
>   %61 = or i32 %60, 1073741824
>   store i32 %61, i32* %zSig, align 4
>   %62 = load i32* %aExp, align 4
>   %63 = sub nsw i32 %62, 16257
>   store i32 %63, i32* %aExp, align 4
>   br label %64
> 
> ; <label>:64                                      ; preds = %59, %56
>   %65 = load i8* %aSign, align 1
>   %66 = load i32* %aExp, align 4
>   %67 = load i32* %zSig, align 4
>   %68 = load %struct.float_status** %2, align 4
>   %69 = call i32 @roundAndPackFloat32(i8 zeroext %65, i32 %66, i32 %67, %struct.float_status* %68)
>   store i32 %69, i32* %1
>   br label %70
> 
> ; <label>:70                                      ; preds = %64, %41, %33
>   %71 = load i32* %1
>   ret i32 %71
> }
> 
> define internal void @float128ToCommonNaN(%struct.commonNaNT* noalias sret %agg.result, i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %z = alloca %struct.commonNaNT, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %5 = load i64* %4, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %7 = load i64* %6, align 4
>   %8 = call i32 @float128_is_signaling_nan(i64 %5, i64 %7)
>   %9 = icmp ne i32 %8, 0
>   br i1 %9, label %10, label %12
> 
> ; <label>:10                                      ; preds = %0
>   %11 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %11)
>   br label %12
> 
> ; <label>:12                                      ; preds = %10, %0
>   %13 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = lshr i64 %14, 63
>   %16 = trunc i64 %15 to i8
>   %17 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 0
>   store i8 %16, i8* %17, align 1
>   %18 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %19 = load i64* %18, align 4
>   %20 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %21 = load i64* %20, align 4
>   %22 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 1
>   %23 = getelementptr inbounds %struct.commonNaNT* %z, i32 0, i32 2
>   call void @shortShift128Left(i64 %19, i64 %21, i32 16, i64* %22, i64* %23)
>   %24 = bitcast %struct.commonNaNT* %agg.result to i8*
>   %25 = bitcast %struct.commonNaNT* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %24, i8* %25, i32 20, i32 4, i1 false)
>   ret void
> }
> 
> define internal i64 @float128_to_float64(i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %a = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %3 = alloca %struct.commonNaNT, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %7 = load i64* %6, align 4
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %9 = load i64* %8, align 4
>   %10 = call i64 @extractFloat128Frac1(i64 %7, i64 %9)
>   store i64 %10, i64* %aSig1, align 8
>   %11 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %12 = load i64* %11, align 4
>   %13 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = call i64 @extractFloat128Frac0(i64 %12, i64 %14)
>   store i64 %15, i64* %aSig0, align 8
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %17 = load i64* %16, align 4
>   %18 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %19 = load i64* %18, align 4
>   %20 = call i32 @extractFloat128Exp(i64 %17, i64 %19)
>   store i32 %20, i32* %aExp, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %22 = load i64* %21, align 4
>   %23 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %24 = load i64* %23, align 4
>   %25 = call zeroext i8 @extractFloat128Sign(i64 %22, i64 %24)
>   store i8 %25, i8* %aSign, align 1
>   %26 = load i32* %aExp, align 4
>   %27 = icmp eq i32 %26, 32767
>   br i1 %27, label %28, label %44
> 
> ; <label>:28                                      ; preds = %0
>   %29 = load i64* %aSig0, align 8
>   %30 = load i64* %aSig1, align 8
>   %31 = or i64 %29, %30
>   %32 = icmp ne i64 %31, 0
>   br i1 %32, label %33, label %41
> 
> ; <label>:33                                      ; preds = %28
>   %34 = load %struct.float_status** %2, align 4
>   %35 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %36 = load i64* %35, align 4
>   %37 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %38 = load i64* %37, align 4
>   call void @float128ToCommonNaN(%struct.commonNaNT* sret %3, i64 %36, i64 %38, %struct.float_status* %34)
>   %39 = load %struct.float_status** %2, align 4
>   %40 = call i64 @commonNaNToFloat64(%struct.commonNaNT* byval align 4 %3, %struct.float_status* %39)
>   store i64 %40, i64* %1
>   br label %69
> 
> ; <label>:41                                      ; preds = %28
>   %42 = load i8* %aSign, align 1
>   %43 = call i64 @packFloat64(i8 zeroext %42, i32 2047, i64 0)
>   store i64 %43, i64* %1
>   br label %69
> 
> ; <label>:44                                      ; preds = %0
>   %45 = load i64* %aSig0, align 8
>   %46 = load i64* %aSig1, align 8
>   call void @shortShift128Left(i64 %45, i64 %46, i32 14, i64* %aSig0, i64* %aSig1)
>   %47 = load i64* %aSig1, align 8
>   %48 = icmp ne i64 %47, 0
>   %49 = zext i1 %48 to i32
>   %50 = sext i32 %49 to i64
>   %51 = load i64* %aSig0, align 8
>   %52 = or i64 %51, %50
>   store i64 %52, i64* %aSig0, align 8
>   %53 = load i32* %aExp, align 4
>   %54 = icmp ne i32 %53, 0
>   br i1 %54, label %58, label %55
> 
> ; <label>:55                                      ; preds = %44
>   %56 = load i64* %aSig0, align 8
>   %57 = icmp ne i64 %56, 0
>   br i1 %57, label %58, label %63
> 
> ; <label>:58                                      ; preds = %55, %44
>   %59 = load i64* %aSig0, align 8
>   %60 = or i64 %59, 4611686018427387904
>   store i64 %60, i64* %aSig0, align 8
>   %61 = load i32* %aExp, align 4
>   %62 = sub nsw i32 %61, 15361
>   store i32 %62, i32* %aExp, align 4
>   br label %63
> 
> ; <label>:63                                      ; preds = %58, %55
>   %64 = load i8* %aSign, align 1
>   %65 = load i32* %aExp, align 4
>   %66 = load i64* %aSig0, align 8
>   %67 = load %struct.float_status** %2, align 4
>   %68 = call i64 @roundAndPackFloat64(i8 zeroext %64, i32 %65, i64 %66, %struct.float_status* %67)
>   store i64 %68, i64* %1
>   br label %69
> 
> ; <label>:69                                      ; preds = %63, %41, %33
>   %70 = load i64* %1
>   ret i64 %70
> }
> 
> define internal void @float128_to_floatx80(%struct.floatx80* noalias sret %agg.result, i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %2 = alloca %struct.commonNaNT, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %5 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %6 = load i64* %5, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %8 = load i64* %7, align 4
>   %9 = call i64 @extractFloat128Frac1(i64 %6, i64 %8)
>   store i64 %9, i64* %aSig1, align 8
>   %10 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %11 = load i64* %10, align 4
>   %12 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %13 = load i64* %12, align 4
>   %14 = call i64 @extractFloat128Frac0(i64 %11, i64 %13)
>   store i64 %14, i64* %aSig0, align 8
>   %15 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %16 = load i64* %15, align 4
>   %17 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %18 = load i64* %17, align 4
>   %19 = call i32 @extractFloat128Exp(i64 %16, i64 %18)
>   store i32 %19, i32* %aExp, align 4
>   %20 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %21 = load i64* %20, align 4
>   %22 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %23 = load i64* %22, align 4
>   %24 = call zeroext i8 @extractFloat128Sign(i64 %21, i64 %23)
>   store i8 %24, i8* %aSign, align 1
>   %25 = load i32* %aExp, align 4
>   %26 = icmp eq i32 %25, 32767
>   br i1 %26, label %27, label %41
> 
> ; <label>:27                                      ; preds = %0
>   %28 = load i64* %aSig0, align 8
>   %29 = load i64* %aSig1, align 8
>   %30 = or i64 %28, %29
>   %31 = icmp ne i64 %30, 0
>   br i1 %31, label %32, label %39
> 
> ; <label>:32                                      ; preds = %27
>   %33 = load %struct.float_status** %1, align 4
>   %34 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   call void @float128ToCommonNaN(%struct.commonNaNT* sret %2, i64 %35, i64 %37, %struct.float_status* %33)
>   %38 = load %struct.float_status** %1, align 4
>   call void @commonNaNToFloatx80(%struct.floatx80* sret %agg.result, %struct.commonNaNT* byval align 4 %2, %struct.float_status* %38)
>   br label %65
> 
> ; <label>:39                                      ; preds = %27
>   %40 = load i8* %aSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %40, i32 32767, i64 -9223372036854775808)
>   br label %65
> 
> ; <label>:41                                      ; preds = %0
>   %42 = load i32* %aExp, align 4
>   %43 = icmp eq i32 %42, 0
>   br i1 %43, label %44, label %54
> 
> ; <label>:44                                      ; preds = %41
>   %45 = load i64* %aSig0, align 8
>   %46 = load i64* %aSig1, align 8
>   %47 = or i64 %45, %46
>   %48 = icmp eq i64 %47, 0
>   br i1 %48, label %49, label %51
> 
> ; <label>:49                                      ; preds = %44
>   %50 = load i8* %aSign, align 1
>   call void @packFloatx80(%struct.floatx80* sret %agg.result, i8 zeroext %50, i32 0, i64 0)
>   br label %65
> 
> ; <label>:51                                      ; preds = %44
>   %52 = load i64* %aSig0, align 8
>   %53 = load i64* %aSig1, align 8
>   call void @normalizeFloat128Subnormal(i64 %52, i64 %53, i32* %aExp, i64* %aSig0, i64* %aSig1)
>   br label %57
> 
> ; <label>:54                                      ; preds = %41
>   %55 = load i64* %aSig0, align 8
>   %56 = or i64 %55, 281474976710656
>   store i64 %56, i64* %aSig0, align 8
>   br label %57
> 
> ; <label>:57                                      ; preds = %54, %51
>   %58 = load i64* %aSig0, align 8
>   %59 = load i64* %aSig1, align 8
>   call void @shortShift128Left(i64 %58, i64 %59, i32 15, i64* %aSig0, i64* %aSig1)
>   %60 = load i8* %aSign, align 1
>   %61 = load i32* %aExp, align 4
>   %62 = load i64* %aSig0, align 8
>   %63 = load i64* %aSig1, align 8
>   %64 = load %struct.float_status** %1, align 4
>   call void @roundAndPackFloatx80(%struct.floatx80* sret %agg.result, i8 signext 80, i8 zeroext %60, i32 %61, i64 %62, i64 %63, %struct.float_status* %64)
>   br label %65
> 
> ; <label>:65                                      ; preds = %57, %49, %39, %32
>   ret void
> }
> 
> define internal void @normalizeFloat128Subnormal(i64 %aSig0, i64 %aSig1, i32* %zExpPtr, i64* %zSig0Ptr, i64* %zSig1Ptr) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i32*, align 4
>   %4 = alloca i64*, align 4
>   %5 = alloca i64*, align 4
>   %shiftCount = alloca i8, align 1
>   store i64 %aSig0, i64* %1, align 8
>   store i64 %aSig1, i64* %2, align 8
>   store i32* %zExpPtr, i32** %3, align 4
>   store i64* %zSig0Ptr, i64** %4, align 4
>   store i64* %zSig1Ptr, i64** %5, align 4
>   %6 = load i64* %1, align 8
>   %7 = icmp eq i64 %6, 0
>   br i1 %7, label %8, label %46
> 
> ; <label>:8                                       ; preds = %0
>   %9 = load i64* %2, align 8
>   %10 = call signext i8 @countLeadingZeros64(i64 %9)
>   %11 = sext i8 %10 to i32
>   %12 = sub nsw i32 %11, 15
>   %13 = trunc i32 %12 to i8
>   store i8 %13, i8* %shiftCount, align 1
>   %14 = load i8* %shiftCount, align 1
>   %15 = sext i8 %14 to i32
>   %16 = icmp slt i32 %15, 0
>   br i1 %16, label %17, label %32
> 
> ; <label>:17                                      ; preds = %8
>   %18 = load i64* %2, align 8
>   %19 = load i8* %shiftCount, align 1
>   %20 = sext i8 %19 to i32
>   %21 = sub nsw i32 0, %20
>   %22 = zext i32 %21 to i64
>   %23 = lshr i64 %18, %22
>   %24 = load i64** %4, align 4
>   store i64 %23, i64* %24, align 4
>   %25 = load i64* %2, align 8
>   %26 = load i8* %shiftCount, align 1
>   %27 = sext i8 %26 to i32
>   %28 = and i32 %27, 63
>   %29 = zext i32 %28 to i64
>   %30 = shl i64 %25, %29
>   %31 = load i64** %5, align 4
>   store i64 %30, i64* %31, align 4
>   br label %40
> 
> ; <label>:32                                      ; preds = %8
>   %33 = load i64* %2, align 8
>   %34 = load i8* %shiftCount, align 1
>   %35 = sext i8 %34 to i32
>   %36 = zext i32 %35 to i64
>   %37 = shl i64 %33, %36
>   %38 = load i64** %4, align 4
>   store i64 %37, i64* %38, align 4
>   %39 = load i64** %5, align 4
>   store i64 0, i64* %39, align 4
>   br label %40
> 
> ; <label>:40                                      ; preds = %32, %17
>   %41 = load i8* %shiftCount, align 1
>   %42 = sext i8 %41 to i32
>   %43 = sub nsw i32 0, %42
>   %44 = sub nsw i32 %43, 63
>   %45 = load i32** %3, align 4
>   store i32 %44, i32* %45, align 4
>   br label %62
> 
> ; <label>:46                                      ; preds = %0
>   %47 = load i64* %1, align 8
>   %48 = call signext i8 @countLeadingZeros64(i64 %47)
>   %49 = sext i8 %48 to i32
>   %50 = sub nsw i32 %49, 15
>   %51 = trunc i32 %50 to i8
>   store i8 %51, i8* %shiftCount, align 1
>   %52 = load i64* %1, align 8
>   %53 = load i64* %2, align 8
>   %54 = load i8* %shiftCount, align 1
>   %55 = sext i8 %54 to i32
>   %56 = load i64** %4, align 4
>   %57 = load i64** %5, align 4
>   call void @shortShift128Left(i64 %52, i64 %53, i32 %55, i64* %56, i64* %57)
>   %58 = load i8* %shiftCount, align 1
>   %59 = sext i8 %58 to i32
>   %60 = sub nsw i32 1, %59
>   %61 = load i32** %3, align 4
>   store i32 %60, i32* %61, align 4
>   br label %62
> 
> ; <label>:62                                      ; preds = %46, %40
>   ret void
> }
> 
> define internal void @float128_round_to_int(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %lastBitMask = alloca i64, align 8
>   %roundBitsMask = alloca i64, align 8
>   %roundingMode = alloca i8, align 1
>   %z = alloca %struct.float128, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %5 = load i64* %4, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %7 = load i64* %6, align 4
>   %8 = call i32 @extractFloat128Exp(i64 %5, i64 %7)
>   store i32 %8, i32* %aExp, align 4
>   %9 = load i32* %aExp, align 4
>   %10 = icmp sle i32 16431, %9
>   br i1 %10, label %11, label %136
> 
> ; <label>:11                                      ; preds = %0
>   %12 = load i32* %aExp, align 4
>   %13 = icmp sle i32 16495, %12
>   br i1 %13, label %14, label %43
> 
> ; <label>:14                                      ; preds = %11
>   %15 = load i32* %aExp, align 4
>   %16 = icmp eq i32 %15, 32767
>   br i1 %16, label %17, label %40
> 
> ; <label>:17                                      ; preds = %14
>   %18 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %19 = load i64* %18, align 4
>   %20 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %21 = load i64* %20, align 4
>   %22 = call i64 @extractFloat128Frac0(i64 %19, i64 %21)
>   %23 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %24 = load i64* %23, align 4
>   %25 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %26 = load i64* %25, align 4
>   %27 = call i64 @extractFloat128Frac1(i64 %24, i64 %26)
>   %28 = or i64 %22, %27
>   %29 = icmp ne i64 %28, 0
>   br i1 %29, label %30, label %40
> 
> ; <label>:30                                      ; preds = %17
>   %31 = load %struct.float_status** %1, align 4
>   %32 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %33 = load i64* %32, align 4
>   %34 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %37 = load i64* %36, align 4
>   %38 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %39 = load i64* %38, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %33, i64 %35, i64 %37, i64 %39, %struct.float_status* %31)
>   br label %300
> 
> ; <label>:40                                      ; preds = %17, %14
>   %41 = bitcast %struct.float128* %agg.result to i8*
>   %42 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %41, i8* %42, i32 16, i32 4, i1 false)
>   br label %300
> 
> ; <label>:43                                      ; preds = %11
>   store i64 1, i64* %lastBitMask, align 8
>   %44 = load i64* %lastBitMask, align 8
>   %45 = load i32* %aExp, align 4
>   %46 = sub nsw i32 16494, %45
>   %47 = zext i32 %46 to i64
>   %48 = shl i64 %44, %47
>   %49 = shl i64 %48, 1
>   store i64 %49, i64* %lastBitMask, align 8
>   %50 = load i64* %lastBitMask, align 8
>   %51 = sub i64 %50, 1
>   store i64 %51, i64* %roundBitsMask, align 8
>   %52 = bitcast %struct.float128* %z to i8*
>   %53 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %52, i8* %53, i32 16, i32 4, i1 false)
>   %54 = load %struct.float_status** %1, align 4
>   %55 = getelementptr inbounds %struct.float_status* %54, i32 0, i32 1
>   %56 = load i8* %55, align 1
>   store i8 %56, i8* %roundingMode, align 1
>   %57 = load i8* %roundingMode, align 1
>   %58 = sext i8 %57 to i32
>   %59 = icmp eq i32 %58, 0
>   br i1 %59, label %60, label %103
> 
> ; <label>:60                                      ; preds = %43
>   %61 = load i64* %lastBitMask, align 8
>   %62 = icmp ne i64 %61, 0
>   br i1 %62, label %63, label %84
> 
> ; <label>:63                                      ; preds = %60
>   %64 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %65 = load i64* %64, align 4
>   %66 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %67 = load i64* %66, align 4
>   %68 = load i64* %lastBitMask, align 8
>   %69 = lshr i64 %68, 1
>   %70 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %71 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   call void @add128(i64 %65, i64 %67, i64 0, i64 %69, i64* %70, i64* %71)
>   %72 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %73 = load i64* %72, align 4
>   %74 = load i64* %roundBitsMask, align 8
>   %75 = and i64 %73, %74
>   %76 = icmp eq i64 %75, 0
>   br i1 %76, label %77, label %83
> 
> ; <label>:77                                      ; preds = %63
>   %78 = load i64* %lastBitMask, align 8
>   %79 = xor i64 %78, -1
>   %80 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %81 = load i64* %80, align 4
>   %82 = and i64 %81, %79
>   store i64 %82, i64* %80, align 4
>   br label %83
> 
> ; <label>:83                                      ; preds = %77, %63
>   br label %102
> 
> ; <label>:84                                      ; preds = %60
>   %85 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %86 = load i64* %85, align 4
>   %87 = icmp slt i64 %86, 0
>   br i1 %87, label %88, label %101
> 
> ; <label>:88                                      ; preds = %84
>   %89 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %90 = load i64* %89, align 4
>   %91 = add i64 %90, 1
>   store i64 %91, i64* %89, align 4
>   %92 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %93 = load i64* %92, align 4
>   %94 = shl i64 %93, 1
>   %95 = icmp eq i64 %94, 0
>   br i1 %95, label %96, label %100
> 
> ; <label>:96                                      ; preds = %88
>   %97 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %98 = load i64* %97, align 4
>   %99 = and i64 %98, -2
>   store i64 %99, i64* %97, align 4
>   br label %100
> 
> ; <label>:100                                     ; preds = %96, %88
>   br label %101
> 
> ; <label>:101                                     ; preds = %100, %84
>   br label %102
> 
> ; <label>:102                                     ; preds = %101, %83
>   br label %130
> 
> ; <label>:103                                     ; preds = %43
>   %104 = load i8* %roundingMode, align 1
>   %105 = sext i8 %104 to i32
>   %106 = icmp ne i32 %105, 3
>   br i1 %106, label %107, label %129
> 
> ; <label>:107                                     ; preds = %103
>   %108 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %109 = load i64* %108, align 4
>   %110 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %111 = load i64* %110, align 4
>   %112 = call zeroext i8 @extractFloat128Sign(i64 %109, i64 %111)
>   %113 = zext i8 %112 to i32
>   %114 = load i8* %roundingMode, align 1
>   %115 = sext i8 %114 to i32
>   %116 = icmp eq i32 %115, 2
>   %117 = zext i1 %116 to i32
>   %118 = xor i32 %113, %117
>   %119 = icmp ne i32 %118, 0
>   br i1 %119, label %120, label %128
> 
> ; <label>:120                                     ; preds = %107
>   %121 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %122 = load i64* %121, align 4
>   %123 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %124 = load i64* %123, align 4
>   %125 = load i64* %roundBitsMask, align 8
>   %126 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %127 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   call void @add128(i64 %122, i64 %124, i64 0, i64 %125, i64* %126, i64* %127)
>   br label %128
> 
> ; <label>:128                                     ; preds = %120, %107
>   br label %129
> 
> ; <label>:129                                     ; preds = %128, %103
>   br label %130
> 
> ; <label>:130                                     ; preds = %129, %102
>   %131 = load i64* %roundBitsMask, align 8
>   %132 = xor i64 %131, -1
>   %133 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %134 = load i64* %133, align 4
>   %135 = and i64 %134, %132
>   store i64 %135, i64* %133, align 4
>   br label %278
> 
> ; <label>:136                                     ; preds = %0
>   %137 = load i32* %aExp, align 4
>   %138 = icmp slt i32 %137, 16383
>   br i1 %138, label %139, label %201
> 
> ; <label>:139                                     ; preds = %136
>   %140 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %141 = load i64* %140, align 4
>   %142 = shl i64 %141, 1
>   %143 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %144 = load i64* %143, align 4
>   %145 = or i64 %142, %144
>   %146 = icmp eq i64 %145, 0
>   br i1 %146, label %147, label %150
> 
> ; <label>:147                                     ; preds = %139
>   %148 = bitcast %struct.float128* %agg.result to i8*
>   %149 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %148, i8* %149, i32 16, i32 4, i1 false)
>   br label %300
> 
> ; <label>:150                                     ; preds = %139
>   %151 = load %struct.float_status** %1, align 4
>   %152 = getelementptr inbounds %struct.float_status* %151, i32 0, i32 2
>   %153 = load i8* %152, align 1
>   %154 = sext i8 %153 to i32
>   %155 = or i32 %154, 32
>   %156 = trunc i32 %155 to i8
>   store i8 %156, i8* %152, align 1
>   %157 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %158 = load i64* %157, align 4
>   %159 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %160 = load i64* %159, align 4
>   %161 = call zeroext i8 @extractFloat128Sign(i64 %158, i64 %160)
>   store i8 %161, i8* %aSign, align 1
>   %162 = load %struct.float_status** %1, align 4
>   %163 = getelementptr inbounds %struct.float_status* %162, i32 0, i32 1
>   %164 = load i8* %163, align 1
>   %165 = sext i8 %164 to i32
>   switch i32 %165, label %199 [
>     i32 0, label %166
>     i32 1, label %185
>     i32 2, label %192
>   ]
> 
> ; <label>:166                                     ; preds = %150
>   %167 = load i32* %aExp, align 4
>   %168 = icmp eq i32 %167, 16382
>   br i1 %168, label %169, label %184
> 
> ; <label>:169                                     ; preds = %166
>   %170 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %171 = load i64* %170, align 4
>   %172 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %173 = load i64* %172, align 4
>   %174 = call i64 @extractFloat128Frac0(i64 %171, i64 %173)
>   %175 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %176 = load i64* %175, align 4
>   %177 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %178 = load i64* %177, align 4
>   %179 = call i64 @extractFloat128Frac1(i64 %176, i64 %178)
>   %180 = or i64 %174, %179
>   %181 = icmp ne i64 %180, 0
>   br i1 %181, label %182, label %184
> 
> ; <label>:182                                     ; preds = %169
>   %183 = load i8* %aSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %183, i32 16383, i64 0, i64 0)
>   br label %300
> 
> ; <label>:184                                     ; preds = %169, %166
>   br label %199
> 
> ; <label>:185                                     ; preds = %150
>   %186 = load i8* %aSign, align 1
>   %187 = zext i8 %186 to i32
>   %188 = icmp ne i32 %187, 0
>   br i1 %188, label %189, label %190
> 
> ; <label>:189                                     ; preds = %185
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext 1, i32 16383, i64 0, i64 0)
>   br label %191
> 
> ; <label>:190                                     ; preds = %185
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext 0, i32 0, i64 0, i64 0)
>   br label %191
> 
> ; <label>:191                                     ; preds = %190, %189
>   br label %300
> 
> ; <label>:192                                     ; preds = %150
>   %193 = load i8* %aSign, align 1
>   %194 = zext i8 %193 to i32
>   %195 = icmp ne i32 %194, 0
>   br i1 %195, label %196, label %197
> 
> ; <label>:196                                     ; preds = %192
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext 1, i32 0, i64 0, i64 0)
>   br label %198
> 
> ; <label>:197                                     ; preds = %192
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext 0, i32 16383, i64 0, i64 0)
>   br label %198
> 
> ; <label>:198                                     ; preds = %197, %196
>   br label %300
> 
> ; <label>:199                                     ; preds = %184, %150
>   %200 = load i8* %aSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %200, i32 0, i64 0, i64 0)
>   br label %300
> 
> ; <label>:201                                     ; preds = %136
>   store i64 1, i64* %lastBitMask, align 8
>   %202 = load i32* %aExp, align 4
>   %203 = sub nsw i32 16431, %202
>   %204 = load i64* %lastBitMask, align 8
>   %205 = zext i32 %203 to i64
>   %206 = shl i64 %204, %205
>   store i64 %206, i64* %lastBitMask, align 8
>   %207 = load i64* %lastBitMask, align 8
>   %208 = sub i64 %207, 1
>   store i64 %208, i64* %roundBitsMask, align 8
>   %209 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   store i64 0, i64* %209, align 4
>   %210 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %211 = load i64* %210, align 4
>   %212 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   store i64 %211, i64* %212, align 4
>   %213 = load %struct.float_status** %1, align 4
>   %214 = getelementptr inbounds %struct.float_status* %213, i32 0, i32 1
>   %215 = load i8* %214, align 1
>   store i8 %215, i8* %roundingMode, align 1
>   %216 = load i8* %roundingMode, align 1
>   %217 = sext i8 %216 to i32
>   %218 = icmp eq i32 %217, 0
>   br i1 %218, label %219, label %240
> 
> ; <label>:219                                     ; preds = %201
>   %220 = load i64* %lastBitMask, align 8
>   %221 = lshr i64 %220, 1
>   %222 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %223 = load i64* %222, align 4
>   %224 = add i64 %223, %221
>   store i64 %224, i64* %222, align 4
>   %225 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %226 = load i64* %225, align 4
>   %227 = load i64* %roundBitsMask, align 8
>   %228 = and i64 %226, %227
>   %229 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %230 = load i64* %229, align 4
>   %231 = or i64 %228, %230
>   %232 = icmp eq i64 %231, 0
>   br i1 %232, label %233, label %239
> 
> ; <label>:233                                     ; preds = %219
>   %234 = load i64* %lastBitMask, align 8
>   %235 = xor i64 %234, -1
>   %236 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %237 = load i64* %236, align 4
>   %238 = and i64 %237, %235
>   store i64 %238, i64* %236, align 4
>   br label %239
> 
> ; <label>:239                                     ; preds = %233, %219
>   br label %272
> 
> ; <label>:240                                     ; preds = %201
>   %241 = load i8* %roundingMode, align 1
>   %242 = sext i8 %241 to i32
>   %243 = icmp ne i32 %242, 3
>   br i1 %243, label %244, label %271
> 
> ; <label>:244                                     ; preds = %240
>   %245 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %246 = load i64* %245, align 4
>   %247 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %248 = load i64* %247, align 4
>   %249 = call zeroext i8 @extractFloat128Sign(i64 %246, i64 %248)
>   %250 = zext i8 %249 to i32
>   %251 = load i8* %roundingMode, align 1
>   %252 = sext i8 %251 to i32
>   %253 = icmp eq i32 %252, 2
>   %254 = zext i1 %253 to i32
>   %255 = xor i32 %250, %254
>   %256 = icmp ne i32 %255, 0
>   br i1 %256, label %257, label %270
> 
> ; <label>:257                                     ; preds = %244
>   %258 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %259 = load i64* %258, align 4
>   %260 = icmp ne i64 %259, 0
>   %261 = zext i1 %260 to i32
>   %262 = sext i32 %261 to i64
>   %263 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %264 = load i64* %263, align 4
>   %265 = or i64 %264, %262
>   store i64 %265, i64* %263, align 4
>   %266 = load i64* %roundBitsMask, align 8
>   %267 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %268 = load i64* %267, align 4
>   %269 = add i64 %268, %266
>   store i64 %269, i64* %267, align 4
>   br label %270
> 
> ; <label>:270                                     ; preds = %257, %244
>   br label %271
> 
> ; <label>:271                                     ; preds = %270, %240
>   br label %272
> 
> ; <label>:272                                     ; preds = %271, %239
>   %273 = load i64* %roundBitsMask, align 8
>   %274 = xor i64 %273, -1
>   %275 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %276 = load i64* %275, align 4
>   %277 = and i64 %276, %274
>   store i64 %277, i64* %275, align 4
>   br label %278
> 
> ; <label>:278                                     ; preds = %272, %130
>   %279 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   %280 = load i64* %279, align 4
>   %281 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %282 = load i64* %281, align 4
>   %283 = icmp ne i64 %280, %282
>   br i1 %283, label %290, label %284
> 
> ; <label>:284                                     ; preds = %278
>   %285 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   %286 = load i64* %285, align 4
>   %287 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %288 = load i64* %287, align 4
>   %289 = icmp ne i64 %286, %288
>   br i1 %289, label %290, label %297
> 
> ; <label>:290                                     ; preds = %284, %278
>   %291 = load %struct.float_status** %1, align 4
>   %292 = getelementptr inbounds %struct.float_status* %291, i32 0, i32 2
>   %293 = load i8* %292, align 1
>   %294 = sext i8 %293 to i32
>   %295 = or i32 %294, 32
>   %296 = trunc i32 %295 to i8
>   store i8 %296, i8* %292, align 1
>   br label %297
> 
> ; <label>:297                                     ; preds = %290, %284
>   %298 = bitcast %struct.float128* %agg.result to i8*
>   %299 = bitcast %struct.float128* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %298, i8* %299, i32 16, i32 4, i1 false)
>   br label %300
> 
> ; <label>:300                                     ; preds = %297, %199, %198, %191, %182, %147, %40, %30
>   ret void
> }
> 
> define internal void @propagateFloat128NaN(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aIsQuietNaN = alloca i8, align 1
>   %aIsSignalingNaN = alloca i8, align 1
>   %bIsQuietNaN = alloca i8, align 1
>   %bIsSignalingNaN = alloca i8, align 1
>   %aIsLargerSignificand = alloca i8, align 1
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %7 = load i64* %6, align 4
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %9 = load i64* %8, align 4
>   %10 = call i32 @float128_is_quiet_nan(i64 %7, i64 %9)
>   %11 = trunc i32 %10 to i8
>   store i8 %11, i8* %aIsQuietNaN, align 1
>   %12 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %13 = load i64* %12, align 4
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %15 = load i64* %14, align 4
>   %16 = call i32 @float128_is_signaling_nan(i64 %13, i64 %15)
>   %17 = trunc i32 %16 to i8
>   store i8 %17, i8* %aIsSignalingNaN, align 1
>   %18 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %19 = load i64* %18, align 4
>   %20 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %21 = load i64* %20, align 4
>   %22 = call i32 @float128_is_quiet_nan(i64 %19, i64 %21)
>   %23 = trunc i32 %22 to i8
>   store i8 %23, i8* %bIsQuietNaN, align 1
>   %24 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %25 = load i64* %24, align 4
>   %26 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %27 = load i64* %26, align 4
>   %28 = call i32 @float128_is_signaling_nan(i64 %25, i64 %27)
>   %29 = trunc i32 %28 to i8
>   store i8 %29, i8* %bIsSignalingNaN, align 1
>   %30 = load i8* %aIsSignalingNaN, align 1
>   %31 = zext i8 %30 to i32
>   %32 = load i8* %bIsSignalingNaN, align 1
>   %33 = zext i8 %32 to i32
>   %34 = or i32 %31, %33
>   %35 = icmp ne i32 %34, 0
>   br i1 %35, label %36, label %38
> 
> ; <label>:36                                      ; preds = %0
>   %37 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %37)
>   br label %38
> 
> ; <label>:38                                      ; preds = %36, %0
>   %39 = load %struct.float_status** %1, align 4
>   %40 = getelementptr inbounds %struct.float_status* %39, i32 0, i32 6
>   %41 = load i8* %40, align 1
>   %42 = icmp ne i8 %41, 0
>   br i1 %42, label %43, label %48
> 
> ; <label>:43                                      ; preds = %38
>   %44 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 0, i64* %44, align 4
>   %45 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 -140737488355328, i64* %45, align 4
>   %46 = bitcast %struct.float128* %agg.result to i8*
>   %47 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %46, i8* %47, i32 16, i32 4, i1 false)
>   br label %103
> 
> ; <label>:48                                      ; preds = %38
>   %49 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %50 = load i64* %49, align 4
>   %51 = shl i64 %50, 1
>   %52 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %53 = load i64* %52, align 4
>   %54 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %55 = load i64* %54, align 4
>   %56 = shl i64 %55, 1
>   %57 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %58 = load i64* %57, align 4
>   %59 = call zeroext i8 @lt128(i64 %51, i64 %53, i64 %56, i64 %58)
>   %60 = icmp ne i8 %59, 0
>   br i1 %60, label %61, label %62
> 
> ; <label>:61                                      ; preds = %48
>   store i8 0, i8* %aIsLargerSignificand, align 1
>   br label %85
> 
> ; <label>:62                                      ; preds = %48
>   %63 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %64 = load i64* %63, align 4
>   %65 = shl i64 %64, 1
>   %66 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %67 = load i64* %66, align 4
>   %68 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %69 = load i64* %68, align 4
>   %70 = shl i64 %69, 1
>   %71 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %72 = load i64* %71, align 4
>   %73 = call zeroext i8 @lt128(i64 %65, i64 %67, i64 %70, i64 %72)
>   %74 = icmp ne i8 %73, 0
>   br i1 %74, label %75, label %76
> 
> ; <label>:75                                      ; preds = %62
>   store i8 1, i8* %aIsLargerSignificand, align 1
>   br label %84
> 
> ; <label>:76                                      ; preds = %62
>   %77 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %78 = load i64* %77, align 4
>   %79 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %80 = load i64* %79, align 4
>   %81 = icmp ult i64 %78, %80
>   %82 = select i1 %81, i32 1, i32 0
>   %83 = trunc i32 %82 to i8
>   store i8 %83, i8* %aIsLargerSignificand, align 1
>   br label %84
> 
> ; <label>:84                                      ; preds = %76, %75
>   br label %85
> 
> ; <label>:85                                      ; preds = %84, %61
>   %86 = load i8* %aIsQuietNaN, align 1
>   %87 = load i8* %aIsSignalingNaN, align 1
>   %88 = load i8* %bIsQuietNaN, align 1
>   %89 = load i8* %bIsSignalingNaN, align 1
>   %90 = load i8* %aIsLargerSignificand, align 1
>   %91 = call i32 @pickNaN(i8 zeroext %86, i8 zeroext %87, i8 zeroext %88, i8 zeroext %89, i8 zeroext %90)
>   %92 = icmp ne i32 %91, 0
>   br i1 %92, label %93, label %98
> 
> ; <label>:93                                      ; preds = %85
>   %94 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %95 = load i64* %94, align 4
>   %96 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %97 = load i64* %96, align 4
>   call void @float128_maybe_silence_nan(%struct.float128* sret %agg.result, i64 %95, i64 %97)
>   br label %103
> 
> ; <label>:98                                      ; preds = %85
>   %99 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %100 = load i64* %99, align 4
>   %101 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %102 = load i64* %101, align 4
>   call void @float128_maybe_silence_nan(%struct.float128* sret %agg.result, i64 %100, i64 %102)
>   br label %103
> 
> ; <label>:103                                     ; preds = %98, %93, %43
>   ret void
> }
> 
> define internal void @float128_add(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %7 = load i64* %6, align 4
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %9 = load i64* %8, align 4
>   %10 = call zeroext i8 @extractFloat128Sign(i64 %7, i64 %9)
>   store i8 %10, i8* %aSign, align 1
>   %11 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %12 = load i64* %11, align 4
>   %13 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = call zeroext i8 @extractFloat128Sign(i64 %12, i64 %14)
>   store i8 %15, i8* %bSign, align 1
>   %16 = load i8* %aSign, align 1
>   %17 = zext i8 %16 to i32
>   %18 = load i8* %bSign, align 1
>   %19 = zext i8 %18 to i32
>   %20 = icmp eq i32 %17, %19
>   br i1 %20, label %21, label %32
> 
> ; <label>:21                                      ; preds = %0
>   %22 = load i8* %aSign, align 1
>   %23 = load %struct.float_status** %1, align 4
>   %24 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %25 = load i64* %24, align 4
>   %26 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %27 = load i64* %26, align 4
>   %28 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %29 = load i64* %28, align 4
>   %30 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %31 = load i64* %30, align 4
>   call void @addFloat128Sigs(%struct.float128* sret %agg.result, i64 %25, i64 %27, i64 %29, i64 %31, i8 zeroext %22, %struct.float_status* %23)
>   br label %43
> 
> ; <label>:32                                      ; preds = %0
>   %33 = load i8* %aSign, align 1
>   %34 = load %struct.float_status** %1, align 4
>   %35 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %36 = load i64* %35, align 4
>   %37 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %38 = load i64* %37, align 4
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   call void @subFloat128Sigs(%struct.float128* sret %agg.result, i64 %36, i64 %38, i64 %40, i64 %42, i8 zeroext %33, %struct.float_status* %34)
>   br label %43
> 
> ; <label>:43                                      ; preds = %32, %21
>   ret void
> }
> 
> define internal void @addFloat128Sigs(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, i8 zeroext %zSign, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca i8, align 1
>   %2 = alloca %struct.float_status*, align 4
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %bSig0 = alloca i64, align 8
>   %bSig1 = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %zSig2 = alloca i64, align 8
>   %expDiff = alloca i32, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store i8 %zSign, i8* %1, align 1
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i64 @extractFloat128Frac1(i64 %8, i64 %10)
>   store i64 %11, i64* %aSig1, align 8
>   %12 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %13 = load i64* %12, align 4
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %15 = load i64* %14, align 4
>   %16 = call i64 @extractFloat128Frac0(i64 %13, i64 %15)
>   store i64 %16, i64* %aSig0, align 8
>   %17 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %18 = load i64* %17, align 4
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %20 = load i64* %19, align 4
>   %21 = call i32 @extractFloat128Exp(i64 %18, i64 %20)
>   store i32 %21, i32* %aExp, align 4
>   %22 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %23 = load i64* %22, align 4
>   %24 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %25 = load i64* %24, align 4
>   %26 = call i64 @extractFloat128Frac1(i64 %23, i64 %25)
>   store i64 %26, i64* %bSig1, align 8
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i64 @extractFloat128Frac0(i64 %28, i64 %30)
>   store i64 %31, i64* %bSig0, align 8
>   %32 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %33 = load i64* %32, align 4
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %35 = load i64* %34, align 4
>   %36 = call i32 @extractFloat128Exp(i64 %33, i64 %35)
>   store i32 %36, i32* %bExp, align 4
>   %37 = load i32* %aExp, align 4
>   %38 = load i32* %bExp, align 4
>   %39 = sub nsw i32 %37, %38
>   store i32 %39, i32* %expDiff, align 4
>   %40 = load i32* %expDiff, align 4
>   %41 = icmp slt i32 0, %40
>   br i1 %41, label %42, label %77
> 
> ; <label>:42                                      ; preds = %0
>   %43 = load i32* %aExp, align 4
>   %44 = icmp eq i32 %43, 32767
>   br i1 %44, label %45, label %63
> 
> ; <label>:45                                      ; preds = %42
>   %46 = load i64* %aSig0, align 8
>   %47 = load i64* %aSig1, align 8
>   %48 = or i64 %46, %47
>   %49 = icmp ne i64 %48, 0
>   br i1 %49, label %50, label %60
> 
> ; <label>:50                                      ; preds = %45
>   %51 = load %struct.float_status** %2, align 4
>   %52 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %53 = load i64* %52, align 4
>   %54 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %55 = load i64* %54, align 4
>   %56 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %57 = load i64* %56, align 4
>   %58 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %59 = load i64* %58, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %53, i64 %55, i64 %57, i64 %59, %struct.float_status* %51)
>   br label %196
> 
> ; <label>:60                                      ; preds = %45
>   %61 = bitcast %struct.float128* %agg.result to i8*
>   %62 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %61, i8* %62, i32 16, i32 4, i1 false)
>   br label %196
> 
> ; <label>:63                                      ; preds = %42
>   %64 = load i32* %bExp, align 4
>   %65 = icmp eq i32 %64, 0
>   br i1 %65, label %66, label %69
> 
> ; <label>:66                                      ; preds = %63
>   %67 = load i32* %expDiff, align 4
>   %68 = add nsw i32 %67, -1
>   store i32 %68, i32* %expDiff, align 4
>   br label %72
> 
> ; <label>:69                                      ; preds = %63
>   %70 = load i64* %bSig0, align 8
>   %71 = or i64 %70, 281474976710656
>   store i64 %71, i64* %bSig0, align 8
>   br label %72
> 
> ; <label>:72                                      ; preds = %69, %66
>   %73 = load i64* %bSig0, align 8
>   %74 = load i64* %bSig1, align 8
>   %75 = load i32* %expDiff, align 4
>   call void @shift128ExtraRightJamming(i64 %73, i64 %74, i64 0, i32 %75, i64* %bSig0, i64* %bSig1, i64* %zSig2)
>   %76 = load i32* %aExp, align 4
>   store i32 %76, i32* %zExp, align 4
>   br label %170
> 
> ; <label>:77                                      ; preds = %0
>   %78 = load i32* %expDiff, align 4
>   %79 = icmp slt i32 %78, 0
>   br i1 %79, label %80, label %115
> 
> ; <label>:80                                      ; preds = %77
>   %81 = load i32* %bExp, align 4
>   %82 = icmp eq i32 %81, 32767
>   br i1 %82, label %83, label %100
> 
> ; <label>:83                                      ; preds = %80
>   %84 = load i64* %bSig0, align 8
>   %85 = load i64* %bSig1, align 8
>   %86 = or i64 %84, %85
>   %87 = icmp ne i64 %86, 0
>   br i1 %87, label %88, label %98
> 
> ; <label>:88                                      ; preds = %83
>   %89 = load %struct.float_status** %2, align 4
>   %90 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %91 = load i64* %90, align 4
>   %92 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %93 = load i64* %92, align 4
>   %94 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %95 = load i64* %94, align 4
>   %96 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %97 = load i64* %96, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %91, i64 %93, i64 %95, i64 %97, %struct.float_status* %89)
>   br label %196
> 
> ; <label>:98                                      ; preds = %83
>   %99 = load i8* %1, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %99, i32 32767, i64 0, i64 0)
>   br label %196
> 
> ; <label>:100                                     ; preds = %80
>   %101 = load i32* %aExp, align 4
>   %102 = icmp eq i32 %101, 0
>   br i1 %102, label %103, label %106
> 
> ; <label>:103                                     ; preds = %100
>   %104 = load i32* %expDiff, align 4
>   %105 = add nsw i32 %104, 1
>   store i32 %105, i32* %expDiff, align 4
>   br label %109
> 
> ; <label>:106                                     ; preds = %100
>   %107 = load i64* %aSig0, align 8
>   %108 = or i64 %107, 281474976710656
>   store i64 %108, i64* %aSig0, align 8
>   br label %109
> 
> ; <label>:109                                     ; preds = %106, %103
>   %110 = load i64* %aSig0, align 8
>   %111 = load i64* %aSig1, align 8
>   %112 = load i32* %expDiff, align 4
>   %113 = sub nsw i32 0, %112
>   call void @shift128ExtraRightJamming(i64 %110, i64 %111, i64 0, i32 %113, i64* %aSig0, i64* %aSig1, i64* %zSig2)
>   %114 = load i32* %bExp, align 4
>   store i32 %114, i32* %zExp, align 4
>   br label %169
> 
> ; <label>:115                                     ; preds = %77
>   %116 = load i32* %aExp, align 4
>   %117 = icmp eq i32 %116, 32767
>   br i1 %117, label %118, label %140
> 
> ; <label>:118                                     ; preds = %115
>   %119 = load i64* %aSig0, align 8
>   %120 = load i64* %aSig1, align 8
>   %121 = or i64 %119, %120
>   %122 = load i64* %bSig0, align 8
>   %123 = or i64 %121, %122
>   %124 = load i64* %bSig1, align 8
>   %125 = or i64 %123, %124
>   %126 = icmp ne i64 %125, 0
>   br i1 %126, label %127, label %137
> 
> ; <label>:127                                     ; preds = %118
>   %128 = load %struct.float_status** %2, align 4
>   %129 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %130 = load i64* %129, align 4
>   %131 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %132 = load i64* %131, align 4
>   %133 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %134 = load i64* %133, align 4
>   %135 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %136 = load i64* %135, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %130, i64 %132, i64 %134, i64 %136, %struct.float_status* %128)
>   br label %196
> 
> ; <label>:137                                     ; preds = %118
>   %138 = bitcast %struct.float128* %agg.result to i8*
>   %139 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %138, i8* %139, i32 16, i32 4, i1 false)
>   br label %196
> 
> ; <label>:140                                     ; preds = %115
>   %141 = load i64* %aSig0, align 8
>   %142 = load i64* %aSig1, align 8
>   %143 = load i64* %bSig0, align 8
>   %144 = load i64* %bSig1, align 8
>   call void @add128(i64 %141, i64 %142, i64 %143, i64 %144, i64* %zSig0, i64* %zSig1)
>   %145 = load i32* %aExp, align 4
>   %146 = icmp eq i32 %145, 0
>   br i1 %146, label %147, label %165
> 
> ; <label>:147                                     ; preds = %140
>   %148 = load %struct.float_status** %2, align 4
>   %149 = getelementptr inbounds %struct.float_status* %148, i32 0, i32 4
>   %150 = load i8* %149, align 1
>   %151 = icmp ne i8 %150, 0
>   br i1 %151, label %152, label %161
> 
> ; <label>:152                                     ; preds = %147
>   %153 = load i64* %zSig0, align 8
>   %154 = load i64* %zSig1, align 8
>   %155 = or i64 %153, %154
>   %156 = icmp ne i64 %155, 0
>   br i1 %156, label %157, label %159
> 
> ; <label>:157                                     ; preds = %152
>   %158 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext -128, %struct.float_status* %158)
>   br label %159
> 
> ; <label>:159                                     ; preds = %157, %152
>   %160 = load i8* %1, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %160, i32 0, i64 0, i64 0)
>   br label %196
> 
> ; <label>:161                                     ; preds = %147
>   %162 = load i8* %1, align 1
>   %163 = load i64* %zSig0, align 8
>   %164 = load i64* %zSig1, align 8
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %162, i32 0, i64 %163, i64 %164)
>   br label %196
> 
> ; <label>:165                                     ; preds = %140
>   store i64 0, i64* %zSig2, align 8
>   %166 = load i64* %zSig0, align 8
>   %167 = or i64 %166, 562949953421312
>   store i64 %167, i64* %zSig0, align 8
>   %168 = load i32* %aExp, align 4
>   store i32 %168, i32* %zExp, align 4
>   br label %185
> 
> ; <label>:169                                     ; preds = %109
>   br label %170
> 
> ; <label>:170                                     ; preds = %169, %72
>   %171 = load i64* %aSig0, align 8
>   %172 = or i64 %171, 281474976710656
>   store i64 %172, i64* %aSig0, align 8
>   %173 = load i64* %aSig0, align 8
>   %174 = load i64* %aSig1, align 8
>   %175 = load i64* %bSig0, align 8
>   %176 = load i64* %bSig1, align 8
>   call void @add128(i64 %173, i64 %174, i64 %175, i64 %176, i64* %zSig0, i64* %zSig1)
>   %177 = load i32* %zExp, align 4
>   %178 = add nsw i32 %177, -1
>   store i32 %178, i32* %zExp, align 4
>   %179 = load i64* %zSig0, align 8
>   %180 = icmp ult i64 %179, 562949953421312
>   br i1 %180, label %181, label %182
> 
> ; <label>:181                                     ; preds = %170
>   br label %189
> 
> ; <label>:182                                     ; preds = %170
>   %183 = load i32* %zExp, align 4
>   %184 = add nsw i32 %183, 1
>   store i32 %184, i32* %zExp, align 4
>   br label %185
> 
> ; <label>:185                                     ; preds = %182, %165
>   %186 = load i64* %zSig0, align 8
>   %187 = load i64* %zSig1, align 8
>   %188 = load i64* %zSig2, align 8
>   call void @shift128ExtraRightJamming(i64 %186, i64 %187, i64 %188, i32 1, i64* %zSig0, i64* %zSig1, i64* %zSig2)
>   br label %189
> 
> ; <label>:189                                     ; preds = %185, %181
>   %190 = load i8* %1, align 1
>   %191 = load i32* %zExp, align 4
>   %192 = load i64* %zSig0, align 8
>   %193 = load i64* %zSig1, align 8
>   %194 = load i64* %zSig2, align 8
>   %195 = load %struct.float_status** %2, align 4
>   call void @roundAndPackFloat128(%struct.float128* sret %agg.result, i8 zeroext %190, i32 %191, i64 %192, i64 %193, i64 %194, %struct.float_status* %195)
>   br label %196
> 
> ; <label>:196                                     ; preds = %189, %161, %159, %137, %127, %98, %88, %60, %50
>   ret void
> }
> 
> define internal void @subFloat128Sigs(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, i8 zeroext %zSign, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca i8, align 1
>   %2 = alloca %struct.float_status*, align 4
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %bSig0 = alloca i64, align 8
>   %bSig1 = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %expDiff = alloca i32, align 4
>   %z = alloca %struct.float128, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store i8 %zSign, i8* %1, align 1
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i64 @extractFloat128Frac1(i64 %8, i64 %10)
>   store i64 %11, i64* %aSig1, align 8
>   %12 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %13 = load i64* %12, align 4
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %15 = load i64* %14, align 4
>   %16 = call i64 @extractFloat128Frac0(i64 %13, i64 %15)
>   store i64 %16, i64* %aSig0, align 8
>   %17 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %18 = load i64* %17, align 4
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %20 = load i64* %19, align 4
>   %21 = call i32 @extractFloat128Exp(i64 %18, i64 %20)
>   store i32 %21, i32* %aExp, align 4
>   %22 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %23 = load i64* %22, align 4
>   %24 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %25 = load i64* %24, align 4
>   %26 = call i64 @extractFloat128Frac1(i64 %23, i64 %25)
>   store i64 %26, i64* %bSig1, align 8
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i64 @extractFloat128Frac0(i64 %28, i64 %30)
>   store i64 %31, i64* %bSig0, align 8
>   %32 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %33 = load i64* %32, align 4
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %35 = load i64* %34, align 4
>   %36 = call i32 @extractFloat128Exp(i64 %33, i64 %35)
>   store i32 %36, i32* %bExp, align 4
>   %37 = load i32* %aExp, align 4
>   %38 = load i32* %bExp, align 4
>   %39 = sub nsw i32 %37, %38
>   store i32 %39, i32* %expDiff, align 4
>   %40 = load i64* %aSig0, align 8
>   %41 = load i64* %aSig1, align 8
>   call void @shortShift128Left(i64 %40, i64 %41, i32 14, i64* %aSig0, i64* %aSig1)
>   %42 = load i64* %bSig0, align 8
>   %43 = load i64* %bSig1, align 8
>   call void @shortShift128Left(i64 %42, i64 %43, i32 14, i64* %bSig0, i64* %bSig1)
>   %44 = load i32* %expDiff, align 4
>   %45 = icmp slt i32 0, %44
>   br i1 %45, label %46, label %47
> 
> ; <label>:46                                      ; preds = %0
>   br label %160
> 
> ; <label>:47                                      ; preds = %0
>   %48 = load i32* %expDiff, align 4
>   %49 = icmp slt i32 %48, 0
>   br i1 %49, label %50, label %51
> 
> ; <label>:50                                      ; preds = %47
>   br label %111
> 
> ; <label>:51                                      ; preds = %47
>   %52 = load i32* %aExp, align 4
>   %53 = icmp eq i32 %52, 32767
>   br i1 %53, label %54, label %79
> 
> ; <label>:54                                      ; preds = %51
>   %55 = load i64* %aSig0, align 8
>   %56 = load i64* %aSig1, align 8
>   %57 = or i64 %55, %56
>   %58 = load i64* %bSig0, align 8
>   %59 = or i64 %57, %58
>   %60 = load i64* %bSig1, align 8
>   %61 = or i64 %59, %60
>   %62 = icmp ne i64 %61, 0
>   br i1 %62, label %63, label %73
> 
> ; <label>:63                                      ; preds = %54
>   %64 = load %struct.float_status** %2, align 4
>   %65 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %66 = load i64* %65, align 4
>   %67 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %68 = load i64* %67, align 4
>   %69 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %70 = load i64* %69, align 4
>   %71 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %72 = load i64* %71, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %66, i64 %68, i64 %70, i64 %72, %struct.float_status* %64)
>   br label %211
> 
> ; <label>:73                                      ; preds = %54
>   %74 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %74)
>   %75 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   store i64 0, i64* %75, align 4
>   %76 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   store i64 -140737488355328, i64* %76, align 4
>   %77 = bitcast %struct.float128* %agg.result to i8*
>   %78 = bitcast %struct.float128* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %77, i8* %78, i32 16, i32 4, i1 false)
>   br label %211
> 
> ; <label>:79                                      ; preds = %51
>   %80 = load i32* %aExp, align 4
>   %81 = icmp eq i32 %80, 0
>   br i1 %81, label %82, label %83
> 
> ; <label>:82                                      ; preds = %79
>   store i32 1, i32* %aExp, align 4
>   store i32 1, i32* %bExp, align 4
>   br label %83
> 
> ; <label>:83                                      ; preds = %82, %79
>   %84 = load i64* %bSig0, align 8
>   %85 = load i64* %aSig0, align 8
>   %86 = icmp ult i64 %84, %85
>   br i1 %86, label %87, label %88
> 
> ; <label>:87                                      ; preds = %83
>   br label %196
> 
> ; <label>:88                                      ; preds = %83
>   %89 = load i64* %aSig0, align 8
>   %90 = load i64* %bSig0, align 8
>   %91 = icmp ult i64 %89, %90
>   br i1 %91, label %92, label %93
> 
> ; <label>:92                                      ; preds = %88
>   br label %150
> 
> ; <label>:93                                      ; preds = %88
>   %94 = load i64* %bSig1, align 8
>   %95 = load i64* %aSig1, align 8
>   %96 = icmp ult i64 %94, %95
>   br i1 %96, label %97, label %98
> 
> ; <label>:97                                      ; preds = %93
>   br label %196
> 
> ; <label>:98                                      ; preds = %93
>   %99 = load i64* %aSig1, align 8
>   %100 = load i64* %bSig1, align 8
>   %101 = icmp ult i64 %99, %100
>   br i1 %101, label %102, label %103
> 
> ; <label>:102                                     ; preds = %98
>   br label %150
> 
> ; <label>:103                                     ; preds = %98
>   %104 = load %struct.float_status** %2, align 4
>   %105 = getelementptr inbounds %struct.float_status* %104, i32 0, i32 1
>   %106 = load i8* %105, align 1
>   %107 = sext i8 %106 to i32
>   %108 = icmp eq i32 %107, 1
>   %109 = zext i1 %108 to i32
>   %110 = trunc i32 %109 to i8
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %110, i32 0, i64 0, i64 0)
>   br label %211
> 
> ; <label>:111                                     ; preds = %50
>   %112 = load i32* %bExp, align 4
>   %113 = icmp eq i32 %112, 32767
>   br i1 %113, label %114, label %134
> 
> ; <label>:114                                     ; preds = %111
>   %115 = load i64* %bSig0, align 8
>   %116 = load i64* %bSig1, align 8
>   %117 = or i64 %115, %116
>   %118 = icmp ne i64 %117, 0
>   br i1 %118, label %119, label %129
> 
> ; <label>:119                                     ; preds = %114
>   %120 = load %struct.float_status** %2, align 4
>   %121 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %122 = load i64* %121, align 4
>   %123 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %124 = load i64* %123, align 4
>   %125 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %126 = load i64* %125, align 4
>   %127 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %128 = load i64* %127, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %122, i64 %124, i64 %126, i64 %128, %struct.float_status* %120)
>   br label %211
> 
> ; <label>:129                                     ; preds = %114
>   %130 = load i8* %1, align 1
>   %131 = zext i8 %130 to i32
>   %132 = xor i32 %131, 1
>   %133 = trunc i32 %132 to i8
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %133, i32 32767, i64 0, i64 0)
>   br label %211
> 
> ; <label>:134                                     ; preds = %111
>   %135 = load i32* %aExp, align 4
>   %136 = icmp eq i32 %135, 0
>   br i1 %136, label %137, label %140
> 
> ; <label>:137                                     ; preds = %134
>   %138 = load i32* %expDiff, align 4
>   %139 = add nsw i32 %138, 1
>   store i32 %139, i32* %expDiff, align 4
>   br label %143
> 
> ; <label>:140                                     ; preds = %134
>   %141 = load i64* %aSig0, align 8
>   %142 = or i64 %141, 4611686018427387904
>   store i64 %142, i64* %aSig0, align 8
>   br label %143
> 
> ; <label>:143                                     ; preds = %140, %137
>   %144 = load i64* %aSig0, align 8
>   %145 = load i64* %aSig1, align 8
>   %146 = load i32* %expDiff, align 4
>   %147 = sub nsw i32 0, %146
>   call void @shift128RightJamming(i64 %144, i64 %145, i32 %147, i64* %aSig0, i64* %aSig1)
>   %148 = load i64* %bSig0, align 8
>   %149 = or i64 %148, 4611686018427387904
>   store i64 %149, i64* %bSig0, align 8
>   br label %150
> 
> ; <label>:150                                     ; preds = %143, %102, %92
>   %151 = load i64* %bSig0, align 8
>   %152 = load i64* %bSig1, align 8
>   %153 = load i64* %aSig0, align 8
>   %154 = load i64* %aSig1, align 8
>   call void @sub128(i64 %151, i64 %152, i64 %153, i64 %154, i64* %zSig0, i64* %zSig1)
>   %155 = load i32* %bExp, align 4
>   store i32 %155, i32* %zExp, align 4
>   %156 = load i8* %1, align 1
>   %157 = zext i8 %156 to i32
>   %158 = xor i32 %157, 1
>   %159 = trunc i32 %158 to i8
>   store i8 %159, i8* %1, align 1
>   br label %202
> 
> ; <label>:160                                     ; preds = %46
>   %161 = load i32* %aExp, align 4
>   %162 = icmp eq i32 %161, 32767
>   br i1 %162, label %163, label %181
> 
> ; <label>:163                                     ; preds = %160
>   %164 = load i64* %aSig0, align 8
>   %165 = load i64* %aSig1, align 8
>   %166 = or i64 %164, %165
>   %167 = icmp ne i64 %166, 0
>   br i1 %167, label %168, label %178
> 
> ; <label>:168                                     ; preds = %163
>   %169 = load %struct.float_status** %2, align 4
>   %170 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %171 = load i64* %170, align 4
>   %172 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %173 = load i64* %172, align 4
>   %174 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %175 = load i64* %174, align 4
>   %176 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %177 = load i64* %176, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %171, i64 %173, i64 %175, i64 %177, %struct.float_status* %169)
>   br label %211
> 
> ; <label>:178                                     ; preds = %163
>   %179 = bitcast %struct.float128* %agg.result to i8*
>   %180 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %179, i8* %180, i32 16, i32 4, i1 false)
>   br label %211
> 
> ; <label>:181                                     ; preds = %160
>   %182 = load i32* %bExp, align 4
>   %183 = icmp eq i32 %182, 0
>   br i1 %183, label %184, label %187
> 
> ; <label>:184                                     ; preds = %181
>   %185 = load i32* %expDiff, align 4
>   %186 = add nsw i32 %185, -1
>   store i32 %186, i32* %expDiff, align 4
>   br label %190
> 
> ; <label>:187                                     ; preds = %181
>   %188 = load i64* %bSig0, align 8
>   %189 = or i64 %188, 4611686018427387904
>   store i64 %189, i64* %bSig0, align 8
>   br label %190
> 
> ; <label>:190                                     ; preds = %187, %184
>   %191 = load i64* %bSig0, align 8
>   %192 = load i64* %bSig1, align 8
>   %193 = load i32* %expDiff, align 4
>   call void @shift128RightJamming(i64 %191, i64 %192, i32 %193, i64* %bSig0, i64* %bSig1)
>   %194 = load i64* %aSig0, align 8
>   %195 = or i64 %194, 4611686018427387904
>   store i64 %195, i64* %aSig0, align 8
>   br label %196
> 
> ; <label>:196                                     ; preds = %190, %97, %87
>   %197 = load i64* %aSig0, align 8
>   %198 = load i64* %aSig1, align 8
>   %199 = load i64* %bSig0, align 8
>   %200 = load i64* %bSig1, align 8
>   call void @sub128(i64 %197, i64 %198, i64 %199, i64 %200, i64* %zSig0, i64* %zSig1)
>   %201 = load i32* %aExp, align 4
>   store i32 %201, i32* %zExp, align 4
>   br label %202
> 
> ; <label>:202                                     ; preds = %196, %150
>   %203 = load i32* %zExp, align 4
>   %204 = add nsw i32 %203, -1
>   store i32 %204, i32* %zExp, align 4
>   %205 = load i8* %1, align 1
>   %206 = load i32* %zExp, align 4
>   %207 = sub nsw i32 %206, 14
>   %208 = load i64* %zSig0, align 8
>   %209 = load i64* %zSig1, align 8
>   %210 = load %struct.float_status** %2, align 4
>   call void @normalizeRoundAndPackFloat128(%struct.float128* sret %agg.result, i8 zeroext %205, i32 %207, i64 %208, i64 %209, %struct.float_status* %210)
>   br label %211
> 
> ; <label>:211                                     ; preds = %202, %178, %168, %129, %119, %103, %73, %63
>   ret void
> }
> 
> define internal void @float128_sub(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %7 = load i64* %6, align 4
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %9 = load i64* %8, align 4
>   %10 = call zeroext i8 @extractFloat128Sign(i64 %7, i64 %9)
>   store i8 %10, i8* %aSign, align 1
>   %11 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %12 = load i64* %11, align 4
>   %13 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = call zeroext i8 @extractFloat128Sign(i64 %12, i64 %14)
>   store i8 %15, i8* %bSign, align 1
>   %16 = load i8* %aSign, align 1
>   %17 = zext i8 %16 to i32
>   %18 = load i8* %bSign, align 1
>   %19 = zext i8 %18 to i32
>   %20 = icmp eq i32 %17, %19
>   br i1 %20, label %21, label %32
> 
> ; <label>:21                                      ; preds = %0
>   %22 = load i8* %aSign, align 1
>   %23 = load %struct.float_status** %1, align 4
>   %24 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %25 = load i64* %24, align 4
>   %26 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %27 = load i64* %26, align 4
>   %28 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %29 = load i64* %28, align 4
>   %30 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %31 = load i64* %30, align 4
>   call void @subFloat128Sigs(%struct.float128* sret %agg.result, i64 %25, i64 %27, i64 %29, i64 %31, i8 zeroext %22, %struct.float_status* %23)
>   br label %43
> 
> ; <label>:32                                      ; preds = %0
>   %33 = load i8* %aSign, align 1
>   %34 = load %struct.float_status** %1, align 4
>   %35 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %36 = load i64* %35, align 4
>   %37 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %38 = load i64* %37, align 4
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   call void @addFloat128Sigs(%struct.float128* sret %agg.result, i64 %36, i64 %38, i64 %40, i64 %42, i8 zeroext %33, %struct.float_status* %34)
>   br label %43
> 
> ; <label>:43                                      ; preds = %32, %21
>   ret void
> }
> 
> define internal void @float128_mul(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %bSig0 = alloca i64, align 8
>   %bSig1 = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %zSig2 = alloca i64, align 8
>   %zSig3 = alloca i64, align 8
>   %z = alloca %struct.float128, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %7 = load i64* %6, align 4
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %9 = load i64* %8, align 4
>   %10 = call i64 @extractFloat128Frac1(i64 %7, i64 %9)
>   store i64 %10, i64* %aSig1, align 8
>   %11 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %12 = load i64* %11, align 4
>   %13 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = call i64 @extractFloat128Frac0(i64 %12, i64 %14)
>   store i64 %15, i64* %aSig0, align 8
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %17 = load i64* %16, align 4
>   %18 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %19 = load i64* %18, align 4
>   %20 = call i32 @extractFloat128Exp(i64 %17, i64 %19)
>   store i32 %20, i32* %aExp, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %22 = load i64* %21, align 4
>   %23 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %24 = load i64* %23, align 4
>   %25 = call zeroext i8 @extractFloat128Sign(i64 %22, i64 %24)
>   store i8 %25, i8* %aSign, align 1
>   %26 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %27 = load i64* %26, align 4
>   %28 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %29 = load i64* %28, align 4
>   %30 = call i64 @extractFloat128Frac1(i64 %27, i64 %29)
>   store i64 %30, i64* %bSig1, align 8
>   %31 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %32 = load i64* %31, align 4
>   %33 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %34 = load i64* %33, align 4
>   %35 = call i64 @extractFloat128Frac0(i64 %32, i64 %34)
>   store i64 %35, i64* %bSig0, align 8
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %37 = load i64* %36, align 4
>   %38 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %39 = load i64* %38, align 4
>   %40 = call i32 @extractFloat128Exp(i64 %37, i64 %39)
>   store i32 %40, i32* %bExp, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %42 = load i64* %41, align 4
>   %43 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %44 = load i64* %43, align 4
>   %45 = call zeroext i8 @extractFloat128Sign(i64 %42, i64 %44)
>   store i8 %45, i8* %bSign, align 1
>   %46 = load i8* %aSign, align 1
>   %47 = zext i8 %46 to i32
>   %48 = load i8* %bSign, align 1
>   %49 = zext i8 %48 to i32
>   %50 = xor i32 %47, %49
>   %51 = trunc i32 %50 to i8
>   store i8 %51, i8* %zSign, align 1
>   %52 = load i32* %aExp, align 4
>   %53 = icmp eq i32 %52, 32767
>   br i1 %53, label %54, label %88
> 
> ; <label>:54                                      ; preds = %0
>   %55 = load i64* %aSig0, align 8
>   %56 = load i64* %aSig1, align 8
>   %57 = or i64 %55, %56
>   %58 = icmp ne i64 %57, 0
>   br i1 %58, label %67, label %59
> 
> ; <label>:59                                      ; preds = %54
>   %60 = load i32* %bExp, align 4
>   %61 = icmp eq i32 %60, 32767
>   br i1 %61, label %62, label %77
> 
> ; <label>:62                                      ; preds = %59
>   %63 = load i64* %bSig0, align 8
>   %64 = load i64* %bSig1, align 8
>   %65 = or i64 %63, %64
>   %66 = icmp ne i64 %65, 0
>   br i1 %66, label %67, label %77
> 
> ; <label>:67                                      ; preds = %62, %54
>   %68 = load %struct.float_status** %1, align 4
>   %69 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %70 = load i64* %69, align 4
>   %71 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %72 = load i64* %71, align 4
>   %73 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %74 = load i64* %73, align 4
>   %75 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %76 = load i64* %75, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %70, i64 %72, i64 %74, i64 %76, %struct.float_status* %68)
>   br label %187
> 
> ; <label>:77                                      ; preds = %62, %59
>   %78 = load i32* %bExp, align 4
>   %79 = sext i32 %78 to i64
>   %80 = load i64* %bSig0, align 8
>   %81 = or i64 %79, %80
>   %82 = load i64* %bSig1, align 8
>   %83 = or i64 %81, %82
>   %84 = icmp eq i64 %83, 0
>   br i1 %84, label %85, label %86
> 
> ; <label>:85                                      ; preds = %77
>   br label %115
> 
> ; <label>:86                                      ; preds = %77
>   %87 = load i8* %zSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %87, i32 32767, i64 0, i64 0)
>   br label %187
> 
> ; <label>:88                                      ; preds = %0
>   %89 = load i32* %bExp, align 4
>   %90 = icmp eq i32 %89, 32767
>   br i1 %90, label %91, label %123
> 
> ; <label>:91                                      ; preds = %88
>   %92 = load i64* %bSig0, align 8
>   %93 = load i64* %bSig1, align 8
>   %94 = or i64 %92, %93
>   %95 = icmp ne i64 %94, 0
>   br i1 %95, label %96, label %106
> 
> ; <label>:96                                      ; preds = %91
>   %97 = load %struct.float_status** %1, align 4
>   %98 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %99 = load i64* %98, align 4
>   %100 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %101 = load i64* %100, align 4
>   %102 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %103 = load i64* %102, align 4
>   %104 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %105 = load i64* %104, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %99, i64 %101, i64 %103, i64 %105, %struct.float_status* %97)
>   br label %187
> 
> ; <label>:106                                     ; preds = %91
>   %107 = load i32* %aExp, align 4
>   %108 = sext i32 %107 to i64
>   %109 = load i64* %aSig0, align 8
>   %110 = or i64 %108, %109
>   %111 = load i64* %aSig1, align 8
>   %112 = or i64 %110, %111
>   %113 = icmp eq i64 %112, 0
>   br i1 %113, label %114, label %121
> 
> ; <label>:114                                     ; preds = %106
>   br label %115
> 
> ; <label>:115                                     ; preds = %114, %85
>   %116 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %116)
>   %117 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   store i64 0, i64* %117, align 4
>   %118 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   store i64 -140737488355328, i64* %118, align 4
>   %119 = bitcast %struct.float128* %agg.result to i8*
>   %120 = bitcast %struct.float128* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %119, i8* %120, i32 16, i32 4, i1 false)
>   br label %187
> 
> ; <label>:121                                     ; preds = %106
>   %122 = load i8* %zSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %122, i32 32767, i64 0, i64 0)
>   br label %187
> 
> ; <label>:123                                     ; preds = %88
>   %124 = load i32* %aExp, align 4
>   %125 = icmp eq i32 %124, 0
>   br i1 %125, label %126, label %136
> 
> ; <label>:126                                     ; preds = %123
>   %127 = load i64* %aSig0, align 8
>   %128 = load i64* %aSig1, align 8
>   %129 = or i64 %127, %128
>   %130 = icmp eq i64 %129, 0
>   br i1 %130, label %131, label %133
> 
> ; <label>:131                                     ; preds = %126
>   %132 = load i8* %zSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %132, i32 0, i64 0, i64 0)
>   br label %187
> 
> ; <label>:133                                     ; preds = %126
>   %134 = load i64* %aSig0, align 8
>   %135 = load i64* %aSig1, align 8
>   call void @normalizeFloat128Subnormal(i64 %134, i64 %135, i32* %aExp, i64* %aSig0, i64* %aSig1)
>   br label %136
> 
> ; <label>:136                                     ; preds = %133, %123
>   %137 = load i32* %bExp, align 4
>   %138 = icmp eq i32 %137, 0
>   br i1 %138, label %139, label %149
> 
> ; <label>:139                                     ; preds = %136
>   %140 = load i64* %bSig0, align 8
>   %141 = load i64* %bSig1, align 8
>   %142 = or i64 %140, %141
>   %143 = icmp eq i64 %142, 0
>   br i1 %143, label %144, label %146
> 
> ; <label>:144                                     ; preds = %139
>   %145 = load i8* %zSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %145, i32 0, i64 0, i64 0)
>   br label %187
> 
> ; <label>:146                                     ; preds = %139
>   %147 = load i64* %bSig0, align 8
>   %148 = load i64* %bSig1, align 8
>   call void @normalizeFloat128Subnormal(i64 %147, i64 %148, i32* %bExp, i64* %bSig0, i64* %bSig1)
>   br label %149
> 
> ; <label>:149                                     ; preds = %146, %136
>   %150 = load i32* %aExp, align 4
>   %151 = load i32* %bExp, align 4
>   %152 = add nsw i32 %150, %151
>   %153 = sub nsw i32 %152, 16384
>   store i32 %153, i32* %zExp, align 4
>   %154 = load i64* %aSig0, align 8
>   %155 = or i64 %154, 281474976710656
>   store i64 %155, i64* %aSig0, align 8
>   %156 = load i64* %bSig0, align 8
>   %157 = load i64* %bSig1, align 8
>   call void @shortShift128Left(i64 %156, i64 %157, i32 16, i64* %bSig0, i64* %bSig1)
>   %158 = load i64* %aSig0, align 8
>   %159 = load i64* %aSig1, align 8
>   %160 = load i64* %bSig0, align 8
>   %161 = load i64* %bSig1, align 8
>   call void @mul128To256(i64 %158, i64 %159, i64 %160, i64 %161, i64* %zSig0, i64* %zSig1, i64* %zSig2, i64* %zSig3)
>   %162 = load i64* %zSig0, align 8
>   %163 = load i64* %zSig1, align 8
>   %164 = load i64* %aSig0, align 8
>   %165 = load i64* %aSig1, align 8
>   call void @add128(i64 %162, i64 %163, i64 %164, i64 %165, i64* %zSig0, i64* %zSig1)
>   %166 = load i64* %zSig3, align 8
>   %167 = icmp ne i64 %166, 0
>   %168 = zext i1 %167 to i32
>   %169 = sext i32 %168 to i64
>   %170 = load i64* %zSig2, align 8
>   %171 = or i64 %170, %169
>   store i64 %171, i64* %zSig2, align 8
>   %172 = load i64* %zSig0, align 8
>   %173 = icmp ule i64 562949953421312, %172
>   br i1 %173, label %174, label %180
> 
> ; <label>:174                                     ; preds = %149
>   %175 = load i64* %zSig0, align 8
>   %176 = load i64* %zSig1, align 8
>   %177 = load i64* %zSig2, align 8
>   call void @shift128ExtraRightJamming(i64 %175, i64 %176, i64 %177, i32 1, i64* %zSig0, i64* %zSig1, i64* %zSig2)
>   %178 = load i32* %zExp, align 4
>   %179 = add nsw i32 %178, 1
>   store i32 %179, i32* %zExp, align 4
>   br label %180
> 
> ; <label>:180                                     ; preds = %174, %149
>   %181 = load i8* %zSign, align 1
>   %182 = load i32* %zExp, align 4
>   %183 = load i64* %zSig0, align 8
>   %184 = load i64* %zSig1, align 8
>   %185 = load i64* %zSig2, align 8
>   %186 = load %struct.float_status** %1, align 4
>   call void @roundAndPackFloat128(%struct.float128* sret %agg.result, i8 zeroext %181, i32 %182, i64 %183, i64 %184, i64 %185, %struct.float_status* %186)
>   br label %187
> 
> ; <label>:187                                     ; preds = %180, %144, %131, %121, %115, %96, %86, %67
>   ret void
> }
> 
> define internal void @mul128To256(i64 %a0, i64 %a1, i64 %b0, i64 %b1, i64* %z0Ptr, i64* %z1Ptr, i64* %z2Ptr, i64* %z3Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca i64*, align 4
>   %6 = alloca i64*, align 4
>   %7 = alloca i64*, align 4
>   %8 = alloca i64*, align 4
>   %z0 = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   %z2 = alloca i64, align 8
>   %z3 = alloca i64, align 8
>   %more1 = alloca i64, align 8
>   %more2 = alloca i64, align 8
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %b0, i64* %3, align 8
>   store i64 %b1, i64* %4, align 8
>   store i64* %z0Ptr, i64** %5, align 4
>   store i64* %z1Ptr, i64** %6, align 4
>   store i64* %z2Ptr, i64** %7, align 4
>   store i64* %z3Ptr, i64** %8, align 4
>   %9 = load i64* %2, align 8
>   %10 = load i64* %4, align 8
>   call void @mul64To128(i64 %9, i64 %10, i64* %z2, i64* %z3)
>   %11 = load i64* %2, align 8
>   %12 = load i64* %3, align 8
>   call void @mul64To128(i64 %11, i64 %12, i64* %z1, i64* %more2)
>   %13 = load i64* %z1, align 8
>   %14 = load i64* %more2, align 8
>   %15 = load i64* %z2, align 8
>   call void @add128(i64 %13, i64 %14, i64 0, i64 %15, i64* %z1, i64* %z2)
>   %16 = load i64* %1, align 8
>   %17 = load i64* %3, align 8
>   call void @mul64To128(i64 %16, i64 %17, i64* %z0, i64* %more1)
>   %18 = load i64* %z0, align 8
>   %19 = load i64* %more1, align 8
>   %20 = load i64* %z1, align 8
>   call void @add128(i64 %18, i64 %19, i64 0, i64 %20, i64* %z0, i64* %z1)
>   %21 = load i64* %1, align 8
>   %22 = load i64* %4, align 8
>   call void @mul64To128(i64 %21, i64 %22, i64* %more1, i64* %more2)
>   %23 = load i64* %more1, align 8
>   %24 = load i64* %more2, align 8
>   %25 = load i64* %z2, align 8
>   call void @add128(i64 %23, i64 %24, i64 0, i64 %25, i64* %more1, i64* %z2)
>   %26 = load i64* %z0, align 8
>   %27 = load i64* %z1, align 8
>   %28 = load i64* %more1, align 8
>   call void @add128(i64 %26, i64 %27, i64 0, i64 %28, i64* %z0, i64* %z1)
>   %29 = load i64* %z3, align 8
>   %30 = load i64** %8, align 4
>   store i64 %29, i64* %30, align 4
>   %31 = load i64* %z2, align 8
>   %32 = load i64** %7, align 4
>   store i64 %31, i64* %32, align 4
>   %33 = load i64* %z1, align 8
>   %34 = load i64** %6, align 4
>   store i64 %33, i64* %34, align 4
>   %35 = load i64* %z0, align 8
>   %36 = load i64** %5, align 4
>   store i64 %35, i64* %36, align 4
>   ret void
> }
> 
> define internal void @shift128ExtraRightJamming(i64 %a0, i64 %a1, i64 %a2, i32 %count, i64* %z0Ptr, i64* %z1Ptr, i64* %z2Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i32, align 4
>   %5 = alloca i64*, align 4
>   %6 = alloca i64*, align 4
>   %7 = alloca i64*, align 4
>   %z0 = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   %z2 = alloca i64, align 8
>   %negCount = alloca i8, align 1
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %a2, i64* %3, align 8
>   store i32 %count, i32* %4, align 4
>   store i64* %z0Ptr, i64** %5, align 4
>   store i64* %z1Ptr, i64** %6, align 4
>   store i64* %z2Ptr, i64** %7, align 4
>   %8 = load i32* %4, align 4
>   %9 = sub nsw i32 0, %8
>   %10 = and i32 %9, 63
>   %11 = trunc i32 %10 to i8
>   store i8 %11, i8* %negCount, align 1
>   %12 = load i32* %4, align 4
>   %13 = icmp eq i32 %12, 0
>   br i1 %13, label %14, label %18
> 
> ; <label>:14                                      ; preds = %0
>   %15 = load i64* %3, align 8
>   store i64 %15, i64* %z2, align 8
>   %16 = load i64* %2, align 8
>   store i64 %16, i64* %z1, align 8
>   %17 = load i64* %1, align 8
>   store i64 %17, i64* %z0, align 8
>   br label %85
> 
> ; <label>:18                                      ; preds = %0
>   %19 = load i32* %4, align 4
>   %20 = icmp slt i32 %19, 64
>   br i1 %20, label %21, label %41
> 
> ; <label>:21                                      ; preds = %18
>   %22 = load i64* %2, align 8
>   %23 = load i8* %negCount, align 1
>   %24 = sext i8 %23 to i32
>   %25 = zext i32 %24 to i64
>   %26 = shl i64 %22, %25
>   store i64 %26, i64* %z2, align 8
>   %27 = load i64* %1, align 8
>   %28 = load i8* %negCount, align 1
>   %29 = sext i8 %28 to i32
>   %30 = zext i32 %29 to i64
>   %31 = shl i64 %27, %30
>   %32 = load i64* %2, align 8
>   %33 = load i32* %4, align 4
>   %34 = zext i32 %33 to i64
>   %35 = lshr i64 %32, %34
>   %36 = or i64 %31, %35
>   store i64 %36, i64* %z1, align 8
>   %37 = load i64* %1, align 8
>   %38 = load i32* %4, align 4
>   %39 = zext i32 %38 to i64
>   %40 = lshr i64 %37, %39
>   store i64 %40, i64* %z0, align 8
>   br label %78
> 
> ; <label>:41                                      ; preds = %18
>   %42 = load i32* %4, align 4
>   %43 = icmp eq i32 %42, 64
>   br i1 %43, label %44, label %47
> 
> ; <label>:44                                      ; preds = %41
>   %45 = load i64* %2, align 8
>   store i64 %45, i64* %z2, align 8
>   %46 = load i64* %1, align 8
>   store i64 %46, i64* %z1, align 8
>   br label %77
> 
> ; <label>:47                                      ; preds = %41
>   %48 = load i64* %2, align 8
>   %49 = load i64* %3, align 8
>   %50 = or i64 %49, %48
>   store i64 %50, i64* %3, align 8
>   %51 = load i32* %4, align 4
>   %52 = icmp slt i32 %51, 128
>   br i1 %52, label %53, label %64
> 
> ; <label>:53                                      ; preds = %47
>   %54 = load i64* %1, align 8
>   %55 = load i8* %negCount, align 1
>   %56 = sext i8 %55 to i32
>   %57 = zext i32 %56 to i64
>   %58 = shl i64 %54, %57
>   store i64 %58, i64* %z2, align 8
>   %59 = load i64* %1, align 8
>   %60 = load i32* %4, align 4
>   %61 = and i32 %60, 63
>   %62 = zext i32 %61 to i64
>   %63 = lshr i64 %59, %62
>   store i64 %63, i64* %z1, align 8
>   br label %76
> 
> ; <label>:64                                      ; preds = %47
>   %65 = load i32* %4, align 4
>   %66 = icmp eq i32 %65, 128
>   br i1 %66, label %67, label %69
> 
> ; <label>:67                                      ; preds = %64
>   %68 = load i64* %1, align 8
>   br label %74
> 
> ; <label>:69                                      ; preds = %64
>   %70 = load i64* %1, align 8
>   %71 = icmp ne i64 %70, 0
>   %72 = zext i1 %71 to i32
>   %73 = sext i32 %72 to i64
>   br label %74
> 
> ; <label>:74                                      ; preds = %69, %67
>   %75 = phi i64 [ %68, %67 ], [ %73, %69 ]
>   store i64 %75, i64* %z2, align 8
>   store i64 0, i64* %z1, align 8
>   br label %76
> 
> ; <label>:76                                      ; preds = %74, %53
>   br label %77
> 
> ; <label>:77                                      ; preds = %76, %44
>   store i64 0, i64* %z0, align 8
>   br label %78
> 
> ; <label>:78                                      ; preds = %77, %21
>   %79 = load i64* %3, align 8
>   %80 = icmp ne i64 %79, 0
>   %81 = zext i1 %80 to i32
>   %82 = sext i32 %81 to i64
>   %83 = load i64* %z2, align 8
>   %84 = or i64 %83, %82
>   store i64 %84, i64* %z2, align 8
>   br label %85
> 
> ; <label>:85                                      ; preds = %78, %14
>   %86 = load i64* %z2, align 8
>   %87 = load i64** %7, align 4
>   store i64 %86, i64* %87, align 4
>   %88 = load i64* %z1, align 8
>   %89 = load i64** %6, align 4
>   store i64 %88, i64* %89, align 4
>   %90 = load i64* %z0, align 8
>   %91 = load i64** %5, align 4
>   store i64 %90, i64* %91, align 4
>   ret void
> }
> 
> define internal void @roundAndPackFloat128(%struct.float128* noalias sret %agg.result, i8 zeroext %zSign, i32 %zExp, i64 %zSig0, i64 %zSig1, i64 %zSig2, %struct.float_status* %status) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca i64, align 8
>   %6 = alloca %struct.float_status*, align 4
>   %roundingMode = alloca i8, align 1
>   %roundNearestEven = alloca i8, align 1
>   %increment = alloca i8, align 1
>   %isTiny = alloca i8, align 1
>   store i8 %zSign, i8* %1, align 1
>   store i32 %zExp, i32* %2, align 4
>   store i64 %zSig0, i64* %3, align 8
>   store i64 %zSig1, i64* %4, align 8
>   store i64 %zSig2, i64* %5, align 8
>   store %struct.float_status* %status, %struct.float_status** %6, align 4
>   %7 = load %struct.float_status** %6, align 4
>   %8 = getelementptr inbounds %struct.float_status* %7, i32 0, i32 1
>   %9 = load i8* %8, align 1
>   store i8 %9, i8* %roundingMode, align 1
>   %10 = load i8* %roundingMode, align 1
>   %11 = sext i8 %10 to i32
>   %12 = icmp eq i32 %11, 0
>   %13 = zext i1 %12 to i32
>   %14 = trunc i32 %13 to i8
>   store i8 %14, i8* %roundNearestEven, align 1
>   %15 = load i64* %5, align 8
>   %16 = icmp slt i64 %15, 0
>   %17 = zext i1 %16 to i32
>   %18 = trunc i32 %17 to i8
>   store i8 %18, i8* %increment, align 1
>   %19 = load i8* %roundNearestEven, align 1
>   %20 = icmp ne i8 %19, 0
>   br i1 %20, label %53, label %21
> 
> ; <label>:21                                      ; preds = %0
>   %22 = load i8* %roundingMode, align 1
>   %23 = sext i8 %22 to i32
>   %24 = icmp eq i32 %23, 3
>   br i1 %24, label %25, label %26
> 
> ; <label>:25                                      ; preds = %21
>   store i8 0, i8* %increment, align 1
>   br label %52
> 
> ; <label>:26                                      ; preds = %21
>   %27 = load i8* %1, align 1
>   %28 = icmp ne i8 %27, 0
>   br i1 %28, label %29, label %40
> 
> ; <label>:29                                      ; preds = %26
>   %30 = load i8* %roundingMode, align 1
>   %31 = sext i8 %30 to i32
>   %32 = icmp eq i32 %31, 1
>   br i1 %32, label %33, label %36
> 
> ; <label>:33                                      ; preds = %29
>   %34 = load i64* %5, align 8
>   %35 = icmp ne i64 %34, 0
>   br label %36
> 
> ; <label>:36                                      ; preds = %33, %29
>   %37 = phi i1 [ false, %29 ], [ %35, %33 ]
>   %38 = zext i1 %37 to i32
>   %39 = trunc i32 %38 to i8
>   store i8 %39, i8* %increment, align 1
>   br label %51
> 
> ; <label>:40                                      ; preds = %26
>   %41 = load i8* %roundingMode, align 1
>   %42 = sext i8 %41 to i32
>   %43 = icmp eq i32 %42, 2
>   br i1 %43, label %44, label %47
> 
> ; <label>:44                                      ; preds = %40
>   %45 = load i64* %5, align 8
>   %46 = icmp ne i64 %45, 0
>   br label %47
> 
> ; <label>:47                                      ; preds = %44, %40
>   %48 = phi i1 [ false, %40 ], [ %46, %44 ]
>   %49 = zext i1 %48 to i32
>   %50 = trunc i32 %49 to i8
>   store i8 %50, i8* %increment, align 1
>   br label %51
> 
> ; <label>:51                                      ; preds = %47, %36
>   br label %52
> 
> ; <label>:52                                      ; preds = %51, %25
>   br label %53
> 
> ; <label>:53                                      ; preds = %52, %0
>   %54 = load i32* %2, align 4
>   %55 = icmp ule i32 32765, %54
>   br i1 %55, label %56, label %178
> 
> ; <label>:56                                      ; preds = %53
>   %57 = load i32* %2, align 4
>   %58 = icmp slt i32 32765, %57
>   br i1 %58, label %72, label %59
> 
> ; <label>:59                                      ; preds = %56
>   %60 = load i32* %2, align 4
>   %61 = icmp eq i32 %60, 32765
>   br i1 %61, label %62, label %96
> 
> ; <label>:62                                      ; preds = %59
>   %63 = load i64* %3, align 8
>   %64 = load i64* %4, align 8
>   %65 = call zeroext i8 @eq128(i64 562949953421311, i64 -1, i64 %63, i64 %64)
>   %66 = zext i8 %65 to i32
>   %67 = icmp ne i32 %66, 0
>   br i1 %67, label %68, label %96
> 
> ; <label>:68                                      ; preds = %62
>   %69 = load i8* %increment, align 1
>   %70 = zext i8 %69 to i32
>   %71 = icmp ne i32 %70, 0
>   br i1 %71, label %72, label %96
> 
> ; <label>:72                                      ; preds = %68, %56
>   %73 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 40, %struct.float_status* %73)
>   %74 = load i8* %roundingMode, align 1
>   %75 = sext i8 %74 to i32
>   %76 = icmp eq i32 %75, 3
>   br i1 %76, label %92, label %77
> 
> ; <label>:77                                      ; preds = %72
>   %78 = load i8* %1, align 1
>   %79 = zext i8 %78 to i32
>   %80 = icmp ne i32 %79, 0
>   br i1 %80, label %81, label %85
> 
> ; <label>:81                                      ; preds = %77
>   %82 = load i8* %roundingMode, align 1
>   %83 = sext i8 %82 to i32
>   %84 = icmp eq i32 %83, 2
>   br i1 %84, label %92, label %85
> 
> ; <label>:85                                      ; preds = %81, %77
>   %86 = load i8* %1, align 1
>   %87 = icmp ne i8 %86, 0
>   br i1 %87, label %94, label %88
> 
> ; <label>:88                                      ; preds = %85
>   %89 = load i8* %roundingMode, align 1
>   %90 = sext i8 %89 to i32
>   %91 = icmp eq i32 %90, 1
>   br i1 %91, label %92, label %94
> 
> ; <label>:92                                      ; preds = %88, %81, %72
>   %93 = load i8* %1, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %93, i32 32766, i64 281474976710655, i64 -1)
>   br label %218
> 
> ; <label>:94                                      ; preds = %88, %85
>   %95 = load i8* %1, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %95, i32 32767, i64 0, i64 0)
>   br label %218
> 
> ; <label>:96                                      ; preds = %68, %62, %59
>   %97 = load i32* %2, align 4
>   %98 = icmp slt i32 %97, 0
>   br i1 %98, label %99, label %177
> 
> ; <label>:99                                      ; preds = %96
>   %100 = load %struct.float_status** %6, align 4
>   %101 = getelementptr inbounds %struct.float_status* %100, i32 0, i32 4
>   %102 = load i8* %101, align 1
>   %103 = icmp ne i8 %102, 0
>   br i1 %103, label %104, label %107
> 
> ; <label>:104                                     ; preds = %99
>   %105 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext -128, %struct.float_status* %105)
>   %106 = load i8* %1, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %106, i32 0, i64 0, i64 0)
>   br label %218
> 
> ; <label>:107                                     ; preds = %99
>   %108 = load %struct.float_status** %6, align 4
>   %109 = getelementptr inbounds %struct.float_status* %108, i32 0, i32 0
>   %110 = load i8* %109, align 1
>   %111 = sext i8 %110 to i32
>   %112 = icmp eq i32 %111, 1
>   br i1 %112, label %125, label %113
> 
> ; <label>:113                                     ; preds = %107
>   %114 = load i32* %2, align 4
>   %115 = icmp slt i32 %114, -1
>   br i1 %115, label %125, label %116
> 
> ; <label>:116                                     ; preds = %113
>   %117 = load i8* %increment, align 1
>   %118 = icmp ne i8 %117, 0
>   br i1 %118, label %119, label %125
> 
> ; <label>:119                                     ; preds = %116
>   %120 = load i64* %3, align 8
>   %121 = load i64* %4, align 8
>   %122 = call zeroext i8 @lt128(i64 %120, i64 %121, i64 562949953421311, i64 -1)
>   %123 = zext i8 %122 to i32
>   %124 = icmp ne i32 %123, 0
>   br label %125
> 
> ; <label>:125                                     ; preds = %119, %116, %113, %107
>   %126 = phi i1 [ true, %116 ], [ true, %113 ], [ true, %107 ], [ %124, %119 ]
>   %127 = zext i1 %126 to i32
>   %128 = trunc i32 %127 to i8
>   store i8 %128, i8* %isTiny, align 1
>   %129 = load i64* %3, align 8
>   %130 = load i64* %4, align 8
>   %131 = load i64* %5, align 8
>   %132 = load i32* %2, align 4
>   %133 = sub nsw i32 0, %132
>   call void @shift128ExtraRightJamming(i64 %129, i64 %130, i64 %131, i32 %133, i64* %3, i64* %4, i64* %5)
>   store i32 0, i32* %2, align 4
>   %134 = load i8* %isTiny, align 1
>   %135 = zext i8 %134 to i32
>   %136 = icmp ne i32 %135, 0
>   br i1 %136, label %137, label %142
> 
> ; <label>:137                                     ; preds = %125
>   %138 = load i64* %5, align 8
>   %139 = icmp ne i64 %138, 0
>   br i1 %139, label %140, label %142
> 
> ; <label>:140                                     ; preds = %137
>   %141 = load %struct.float_status** %6, align 4
>   call void @float_raise(i8 signext 16, %struct.float_status* %141)
>   br label %142
> 
> ; <label>:142                                     ; preds = %140, %137, %125
>   %143 = load i8* %roundNearestEven, align 1
>   %144 = icmp ne i8 %143, 0
>   br i1 %144, label %145, label %150
> 
> ; <label>:145                                     ; preds = %142
>   %146 = load i64* %5, align 8
>   %147 = icmp slt i64 %146, 0
>   %148 = zext i1 %147 to i32
>   %149 = trunc i32 %148 to i8
>   store i8 %149, i8* %increment, align 1
>   br label %176
> 
> ; <label>:150                                     ; preds = %142
>   %151 = load i8* %1, align 1
>   %152 = icmp ne i8 %151, 0
>   br i1 %152, label %153, label %164
> 
> ; <label>:153                                     ; preds = %150
>   %154 = load i8* %roundingMode, align 1
>   %155 = sext i8 %154 to i32
>   %156 = icmp eq i32 %155, 1
>   br i1 %156, label %157, label %160
> 
> ; <label>:157                                     ; preds = %153
>   %158 = load i64* %5, align 8
>   %159 = icmp ne i64 %158, 0
>   br label %160
> 
> ; <label>:160                                     ; preds = %157, %153
>   %161 = phi i1 [ false, %153 ], [ %159, %157 ]
>   %162 = zext i1 %161 to i32
>   %163 = trunc i32 %162 to i8
>   store i8 %163, i8* %increment, align 1
>   br label %175
> 
> ; <label>:164                                     ; preds = %150
>   %165 = load i8* %roundingMode, align 1
>   %166 = sext i8 %165 to i32
>   %167 = icmp eq i32 %166, 2
>   br i1 %167, label %168, label %171
> 
> ; <label>:168                                     ; preds = %164
>   %169 = load i64* %5, align 8
>   %170 = icmp ne i64 %169, 0
>   br label %171
> 
> ; <label>:171                                     ; preds = %168, %164
>   %172 = phi i1 [ false, %164 ], [ %170, %168 ]
>   %173 = zext i1 %172 to i32
>   %174 = trunc i32 %173 to i8
>   store i8 %174, i8* %increment, align 1
>   br label %175
> 
> ; <label>:175                                     ; preds = %171, %160
>   br label %176
> 
> ; <label>:176                                     ; preds = %175, %145
>   br label %177
> 
> ; <label>:177                                     ; preds = %176, %96
>   br label %178
> 
> ; <label>:178                                     ; preds = %177, %53
>   %179 = load i64* %5, align 8
>   %180 = icmp ne i64 %179, 0
>   br i1 %180, label %181, label %188
> 
> ; <label>:181                                     ; preds = %178
>   %182 = load %struct.float_status** %6, align 4
>   %183 = getelementptr inbounds %struct.float_status* %182, i32 0, i32 2
>   %184 = load i8* %183, align 1
>   %185 = sext i8 %184 to i32
>   %186 = or i32 %185, 32
>   %187 = trunc i32 %186 to i8
>   store i8 %187, i8* %183, align 1
>   br label %188
> 
> ; <label>:188                                     ; preds = %181, %178
>   %189 = load i8* %increment, align 1
>   %190 = icmp ne i8 %189, 0
>   br i1 %190, label %191, label %206
> 
> ; <label>:191                                     ; preds = %188
>   %192 = load i64* %3, align 8
>   %193 = load i64* %4, align 8
>   call void @add128(i64 %192, i64 %193, i64 0, i64 1, i64* %3, i64* %4)
>   %194 = load i64* %5, align 8
>   %195 = load i64* %5, align 8
>   %196 = add i64 %194, %195
>   %197 = icmp eq i64 %196, 0
>   %198 = zext i1 %197 to i32
>   %199 = load i8* %roundNearestEven, align 1
>   %200 = zext i8 %199 to i32
>   %201 = and i32 %198, %200
>   %202 = xor i32 %201, -1
>   %203 = sext i32 %202 to i64
>   %204 = load i64* %4, align 8
>   %205 = and i64 %204, %203
>   store i64 %205, i64* %4, align 8
>   br label %213
> 
> ; <label>:206                                     ; preds = %188
>   %207 = load i64* %3, align 8
>   %208 = load i64* %4, align 8
>   %209 = or i64 %207, %208
>   %210 = icmp eq i64 %209, 0
>   br i1 %210, label %211, label %212
> 
> ; <label>:211                                     ; preds = %206
>   store i32 0, i32* %2, align 4
>   br label %212
> 
> ; <label>:212                                     ; preds = %211, %206
>   br label %213
> 
> ; <label>:213                                     ; preds = %212, %191
>   %214 = load i8* %1, align 1
>   %215 = load i32* %2, align 4
>   %216 = load i64* %3, align 8
>   %217 = load i64* %4, align 8
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %214, i32 %215, i64 %216, i64 %217)
>   br label %218
> 
> ; <label>:218                                     ; preds = %213, %104, %94, %92
>   ret void
> }
> 
> define internal void @float128_div(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %bSig0 = alloca i64, align 8
>   %bSig1 = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %zSig2 = alloca i64, align 8
>   %rem0 = alloca i64, align 8
>   %rem1 = alloca i64, align 8
>   %rem2 = alloca i64, align 8
>   %rem3 = alloca i64, align 8
>   %term0 = alloca i64, align 8
>   %term1 = alloca i64, align 8
>   %term2 = alloca i64, align 8
>   %term3 = alloca i64, align 8
>   %z = alloca %struct.float128, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %7 = load i64* %6, align 4
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %9 = load i64* %8, align 4
>   %10 = call i64 @extractFloat128Frac1(i64 %7, i64 %9)
>   store i64 %10, i64* %aSig1, align 8
>   %11 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %12 = load i64* %11, align 4
>   %13 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = call i64 @extractFloat128Frac0(i64 %12, i64 %14)
>   store i64 %15, i64* %aSig0, align 8
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %17 = load i64* %16, align 4
>   %18 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %19 = load i64* %18, align 4
>   %20 = call i32 @extractFloat128Exp(i64 %17, i64 %19)
>   store i32 %20, i32* %aExp, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %22 = load i64* %21, align 4
>   %23 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %24 = load i64* %23, align 4
>   %25 = call zeroext i8 @extractFloat128Sign(i64 %22, i64 %24)
>   store i8 %25, i8* %aSign, align 1
>   %26 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %27 = load i64* %26, align 4
>   %28 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %29 = load i64* %28, align 4
>   %30 = call i64 @extractFloat128Frac1(i64 %27, i64 %29)
>   store i64 %30, i64* %bSig1, align 8
>   %31 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %32 = load i64* %31, align 4
>   %33 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %34 = load i64* %33, align 4
>   %35 = call i64 @extractFloat128Frac0(i64 %32, i64 %34)
>   store i64 %35, i64* %bSig0, align 8
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %37 = load i64* %36, align 4
>   %38 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %39 = load i64* %38, align 4
>   %40 = call i32 @extractFloat128Exp(i64 %37, i64 %39)
>   store i32 %40, i32* %bExp, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %42 = load i64* %41, align 4
>   %43 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %44 = load i64* %43, align 4
>   %45 = call zeroext i8 @extractFloat128Sign(i64 %42, i64 %44)
>   store i8 %45, i8* %bSign, align 1
>   %46 = load i8* %aSign, align 1
>   %47 = zext i8 %46 to i32
>   %48 = load i8* %bSign, align 1
>   %49 = zext i8 %48 to i32
>   %50 = xor i32 %47, %49
>   %51 = trunc i32 %50 to i8
>   store i8 %51, i8* %zSign, align 1
>   %52 = load i32* %aExp, align 4
>   %53 = icmp eq i32 %52, 32767
>   br i1 %53, label %54, label %90
> 
> ; <label>:54                                      ; preds = %0
>   %55 = load i64* %aSig0, align 8
>   %56 = load i64* %aSig1, align 8
>   %57 = or i64 %55, %56
>   %58 = icmp ne i64 %57, 0
>   br i1 %58, label %59, label %69
> 
> ; <label>:59                                      ; preds = %54
>   %60 = load %struct.float_status** %1, align 4
>   %61 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %62 = load i64* %61, align 4
>   %63 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %64 = load i64* %63, align 4
>   %65 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %66 = load i64* %65, align 4
>   %67 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %68 = load i64* %67, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %62, i64 %64, i64 %66, i64 %68, %struct.float_status* %60)
>   br label %246
> 
> ; <label>:69                                      ; preds = %54
>   %70 = load i32* %bExp, align 4
>   %71 = icmp eq i32 %70, 32767
>   br i1 %71, label %72, label %88
> 
> ; <label>:72                                      ; preds = %69
>   %73 = load i64* %bSig0, align 8
>   %74 = load i64* %bSig1, align 8
>   %75 = or i64 %73, %74
>   %76 = icmp ne i64 %75, 0
>   br i1 %76, label %77, label %87
> 
> ; <label>:77                                      ; preds = %72
>   %78 = load %struct.float_status** %1, align 4
>   %79 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %80 = load i64* %79, align 4
>   %81 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %82 = load i64* %81, align 4
>   %83 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %84 = load i64* %83, align 4
>   %85 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %86 = load i64* %85, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %80, i64 %82, i64 %84, i64 %86, %struct.float_status* %78)
>   br label %246
> 
> ; <label>:87                                      ; preds = %72
>   br label %127
> 
> ; <label>:88                                      ; preds = %69
>   %89 = load i8* %zSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %89, i32 32767, i64 0, i64 0)
>   br label %246
> 
> ; <label>:90                                      ; preds = %0
>   %91 = load i32* %bExp, align 4
>   %92 = icmp eq i32 %91, 32767
>   br i1 %92, label %93, label %110
> 
> ; <label>:93                                      ; preds = %90
>   %94 = load i64* %bSig0, align 8
>   %95 = load i64* %bSig1, align 8
>   %96 = or i64 %94, %95
>   %97 = icmp ne i64 %96, 0
>   br i1 %97, label %98, label %108
> 
> ; <label>:98                                      ; preds = %93
>   %99 = load %struct.float_status** %1, align 4
>   %100 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %101 = load i64* %100, align 4
>   %102 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %103 = load i64* %102, align 4
>   %104 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %105 = load i64* %104, align 4
>   %106 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %107 = load i64* %106, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %101, i64 %103, i64 %105, i64 %107, %struct.float_status* %99)
>   br label %246
> 
> ; <label>:108                                     ; preds = %93
>   %109 = load i8* %zSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %109, i32 0, i64 0, i64 0)
>   br label %246
> 
> ; <label>:110                                     ; preds = %90
>   %111 = load i32* %bExp, align 4
>   %112 = icmp eq i32 %111, 0
>   br i1 %112, label %113, label %139
> 
> ; <label>:113                                     ; preds = %110
>   %114 = load i64* %bSig0, align 8
>   %115 = load i64* %bSig1, align 8
>   %116 = or i64 %114, %115
>   %117 = icmp eq i64 %116, 0
>   br i1 %117, label %118, label %136
> 
> ; <label>:118                                     ; preds = %113
>   %119 = load i32* %aExp, align 4
>   %120 = sext i32 %119 to i64
>   %121 = load i64* %aSig0, align 8
>   %122 = or i64 %120, %121
>   %123 = load i64* %aSig1, align 8
>   %124 = or i64 %122, %123
>   %125 = icmp eq i64 %124, 0
>   br i1 %125, label %126, label %133
> 
> ; <label>:126                                     ; preds = %118
>   br label %127
> 
> ; <label>:127                                     ; preds = %126, %87
>   %128 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %128)
>   %129 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   store i64 0, i64* %129, align 4
>   %130 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   store i64 -140737488355328, i64* %130, align 4
>   %131 = bitcast %struct.float128* %agg.result to i8*
>   %132 = bitcast %struct.float128* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %131, i8* %132, i32 16, i32 4, i1 false)
>   br label %246
> 
> ; <label>:133                                     ; preds = %118
>   %134 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 4, %struct.float_status* %134)
>   %135 = load i8* %zSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %135, i32 32767, i64 0, i64 0)
>   br label %246
> 
> ; <label>:136                                     ; preds = %113
>   %137 = load i64* %bSig0, align 8
>   %138 = load i64* %bSig1, align 8
>   call void @normalizeFloat128Subnormal(i64 %137, i64 %138, i32* %bExp, i64* %bSig0, i64* %bSig1)
>   br label %139
> 
> ; <label>:139                                     ; preds = %136, %110
>   %140 = load i32* %aExp, align 4
>   %141 = icmp eq i32 %140, 0
>   br i1 %141, label %142, label %152
> 
> ; <label>:142                                     ; preds = %139
>   %143 = load i64* %aSig0, align 8
>   %144 = load i64* %aSig1, align 8
>   %145 = or i64 %143, %144
>   %146 = icmp eq i64 %145, 0
>   br i1 %146, label %147, label %149
> 
> ; <label>:147                                     ; preds = %142
>   %148 = load i8* %zSign, align 1
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext %148, i32 0, i64 0, i64 0)
>   br label %246
> 
> ; <label>:149                                     ; preds = %142
>   %150 = load i64* %aSig0, align 8
>   %151 = load i64* %aSig1, align 8
>   call void @normalizeFloat128Subnormal(i64 %150, i64 %151, i32* %aExp, i64* %aSig0, i64* %aSig1)
>   br label %152
> 
> ; <label>:152                                     ; preds = %149, %139
>   %153 = load i32* %aExp, align 4
>   %154 = load i32* %bExp, align 4
>   %155 = sub nsw i32 %153, %154
>   %156 = add nsw i32 %155, 16381
>   store i32 %156, i32* %zExp, align 4
>   %157 = load i64* %aSig0, align 8
>   %158 = or i64 %157, 281474976710656
>   %159 = load i64* %aSig1, align 8
>   call void @shortShift128Left(i64 %158, i64 %159, i32 15, i64* %aSig0, i64* %aSig1)
>   %160 = load i64* %bSig0, align 8
>   %161 = or i64 %160, 281474976710656
>   %162 = load i64* %bSig1, align 8
>   call void @shortShift128Left(i64 %161, i64 %162, i32 15, i64* %bSig0, i64* %bSig1)
>   %163 = load i64* %bSig0, align 8
>   %164 = load i64* %bSig1, align 8
>   %165 = load i64* %aSig0, align 8
>   %166 = load i64* %aSig1, align 8
>   %167 = call zeroext i8 @le128(i64 %163, i64 %164, i64 %165, i64 %166)
>   %168 = icmp ne i8 %167, 0
>   br i1 %168, label %169, label %174
> 
> ; <label>:169                                     ; preds = %152
>   %170 = load i64* %aSig0, align 8
>   %171 = load i64* %aSig1, align 8
>   call void @shift128Right(i64 %170, i64 %171, i32 1, i64* %aSig0, i64* %aSig1)
>   %172 = load i32* %zExp, align 4
>   %173 = add nsw i32 %172, 1
>   store i32 %173, i32* %zExp, align 4
>   br label %174
> 
> ; <label>:174                                     ; preds = %169, %152
>   %175 = load i64* %aSig0, align 8
>   %176 = load i64* %aSig1, align 8
>   %177 = load i64* %bSig0, align 8
>   %178 = call i64 @estimateDiv128To64(i64 %175, i64 %176, i64 %177)
>   store i64 %178, i64* %zSig0, align 8
>   %179 = load i64* %bSig0, align 8
>   %180 = load i64* %bSig1, align 8
>   %181 = load i64* %zSig0, align 8
>   call void @mul128By64To192(i64 %179, i64 %180, i64 %181, i64* %term0, i64* %term1, i64* %term2)
>   %182 = load i64* %aSig0, align 8
>   %183 = load i64* %aSig1, align 8
>   %184 = load i64* %term0, align 8
>   %185 = load i64* %term1, align 8
>   %186 = load i64* %term2, align 8
>   call void @sub192(i64 %182, i64 %183, i64 0, i64 %184, i64 %185, i64 %186, i64* %rem0, i64* %rem1, i64* %rem2)
>   br label %187
> 
> ; <label>:187                                     ; preds = %190, %174
>   %188 = load i64* %rem0, align 8
>   %189 = icmp slt i64 %188, 0
>   br i1 %189, label %190, label %198
> 
> ; <label>:190                                     ; preds = %187
>   %191 = load i64* %zSig0, align 8
>   %192 = add i64 %191, -1
>   store i64 %192, i64* %zSig0, align 8
>   %193 = load i64* %rem0, align 8
>   %194 = load i64* %rem1, align 8
>   %195 = load i64* %rem2, align 8
>   %196 = load i64* %bSig0, align 8
>   %197 = load i64* %bSig1, align 8
>   call void @add192(i64 %193, i64 %194, i64 %195, i64 0, i64 %196, i64 %197, i64* %rem0, i64* %rem1, i64* %rem2)
>   br label %187
> 
> ; <label>:198                                     ; preds = %187
>   %199 = load i64* %rem1, align 8
>   %200 = load i64* %rem2, align 8
>   %201 = load i64* %bSig0, align 8
>   %202 = call i64 @estimateDiv128To64(i64 %199, i64 %200, i64 %201)
>   store i64 %202, i64* %zSig1, align 8
>   %203 = load i64* %zSig1, align 8
>   %204 = and i64 %203, 16383
>   %205 = icmp ule i64 %204, 4
>   br i1 %205, label %206, label %237
> 
> ; <label>:206                                     ; preds = %198
>   %207 = load i64* %bSig0, align 8
>   %208 = load i64* %bSig1, align 8
>   %209 = load i64* %zSig1, align 8
>   call void @mul128By64To192(i64 %207, i64 %208, i64 %209, i64* %term1, i64* %term2, i64* %term3)
>   %210 = load i64* %rem1, align 8
>   %211 = load i64* %rem2, align 8
>   %212 = load i64* %term1, align 8
>   %213 = load i64* %term2, align 8
>   %214 = load i64* %term3, align 8
>   call void @sub192(i64 %210, i64 %211, i64 0, i64 %212, i64 %213, i64 %214, i64* %rem1, i64* %rem2, i64* %rem3)
>   br label %215
> 
> ; <label>:215                                     ; preds = %218, %206
>   %216 = load i64* %rem1, align 8
>   %217 = icmp slt i64 %216, 0
>   br i1 %217, label %218, label %226
> 
> ; <label>:218                                     ; preds = %215
>   %219 = load i64* %zSig1, align 8
>   %220 = add i64 %219, -1
>   store i64 %220, i64* %zSig1, align 8
>   %221 = load i64* %rem1, align 8
>   %222 = load i64* %rem2, align 8
>   %223 = load i64* %rem3, align 8
>   %224 = load i64* %bSig0, align 8
>   %225 = load i64* %bSig1, align 8
>   call void @add192(i64 %221, i64 %222, i64 %223, i64 0, i64 %224, i64 %225, i64* %rem1, i64* %rem2, i64* %rem3)
>   br label %215
> 
> ; <label>:226                                     ; preds = %215
>   %227 = load i64* %rem1, align 8
>   %228 = load i64* %rem2, align 8
>   %229 = or i64 %227, %228
>   %230 = load i64* %rem3, align 8
>   %231 = or i64 %229, %230
>   %232 = icmp ne i64 %231, 0
>   %233 = zext i1 %232 to i32
>   %234 = sext i32 %233 to i64
>   %235 = load i64* %zSig1, align 8
>   %236 = or i64 %235, %234
>   store i64 %236, i64* %zSig1, align 8
>   br label %237
> 
> ; <label>:237                                     ; preds = %226, %198
>   %238 = load i64* %zSig0, align 8
>   %239 = load i64* %zSig1, align 8
>   call void @shift128ExtraRightJamming(i64 %238, i64 %239, i64 0, i32 15, i64* %zSig0, i64* %zSig1, i64* %zSig2)
>   %240 = load i8* %zSign, align 1
>   %241 = load i32* %zExp, align 4
>   %242 = load i64* %zSig0, align 8
>   %243 = load i64* %zSig1, align 8
>   %244 = load i64* %zSig2, align 8
>   %245 = load %struct.float_status** %1, align 4
>   call void @roundAndPackFloat128(%struct.float128* sret %agg.result, i8 zeroext %240, i32 %241, i64 %242, i64 %243, i64 %244, %struct.float_status* %245)
>   br label %246
> 
> ; <label>:246                                     ; preds = %237, %147, %133, %127, %108, %98, %88, %77, %59
>   ret void
> }
> 
> define internal void @mul128By64To192(i64 %a0, i64 %a1, i64 %b, i64* %z0Ptr, i64* %z1Ptr, i64* %z2Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i64*, align 4
>   %5 = alloca i64*, align 4
>   %6 = alloca i64*, align 4
>   %z0 = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   %z2 = alloca i64, align 8
>   %more1 = alloca i64, align 8
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store i64* %z0Ptr, i64** %4, align 4
>   store i64* %z1Ptr, i64** %5, align 4
>   store i64* %z2Ptr, i64** %6, align 4
>   %7 = load i64* %2, align 8
>   %8 = load i64* %3, align 8
>   call void @mul64To128(i64 %7, i64 %8, i64* %z1, i64* %z2)
>   %9 = load i64* %1, align 8
>   %10 = load i64* %3, align 8
>   call void @mul64To128(i64 %9, i64 %10, i64* %z0, i64* %more1)
>   %11 = load i64* %z0, align 8
>   %12 = load i64* %more1, align 8
>   %13 = load i64* %z1, align 8
>   call void @add128(i64 %11, i64 %12, i64 0, i64 %13, i64* %z0, i64* %z1)
>   %14 = load i64* %z2, align 8
>   %15 = load i64** %6, align 4
>   store i64 %14, i64* %15, align 4
>   %16 = load i64* %z1, align 8
>   %17 = load i64** %5, align 4
>   store i64 %16, i64* %17, align 4
>   %18 = load i64* %z0, align 8
>   %19 = load i64** %4, align 4
>   store i64 %18, i64* %19, align 4
>   ret void
> }
> 
> define internal void @float128_rem(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %zSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %bExp = alloca i32, align 4
>   %expDiff = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %bSig0 = alloca i64, align 8
>   %bSig1 = alloca i64, align 8
>   %q = alloca i64, align 8
>   %term0 = alloca i64, align 8
>   %term1 = alloca i64, align 8
>   %term2 = alloca i64, align 8
>   %allZero = alloca i64, align 8
>   %alternateASig0 = alloca i64, align 8
>   %alternateASig1 = alloca i64, align 8
>   %sigMean1 = alloca i64, align 8
>   %sigMean0 = alloca i64, align 8
>   %z = alloca %struct.float128, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %7 = load i64* %6, align 4
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %9 = load i64* %8, align 4
>   %10 = call i64 @extractFloat128Frac1(i64 %7, i64 %9)
>   store i64 %10, i64* %aSig1, align 8
>   %11 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %12 = load i64* %11, align 4
>   %13 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = call i64 @extractFloat128Frac0(i64 %12, i64 %14)
>   store i64 %15, i64* %aSig0, align 8
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %17 = load i64* %16, align 4
>   %18 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %19 = load i64* %18, align 4
>   %20 = call i32 @extractFloat128Exp(i64 %17, i64 %19)
>   store i32 %20, i32* %aExp, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %22 = load i64* %21, align 4
>   %23 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %24 = load i64* %23, align 4
>   %25 = call zeroext i8 @extractFloat128Sign(i64 %22, i64 %24)
>   store i8 %25, i8* %aSign, align 1
>   %26 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %27 = load i64* %26, align 4
>   %28 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %29 = load i64* %28, align 4
>   %30 = call i64 @extractFloat128Frac1(i64 %27, i64 %29)
>   store i64 %30, i64* %bSig1, align 8
>   %31 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %32 = load i64* %31, align 4
>   %33 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %34 = load i64* %33, align 4
>   %35 = call i64 @extractFloat128Frac0(i64 %32, i64 %34)
>   store i64 %35, i64* %bSig0, align 8
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %37 = load i64* %36, align 4
>   %38 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %39 = load i64* %38, align 4
>   %40 = call i32 @extractFloat128Exp(i64 %37, i64 %39)
>   store i32 %40, i32* %bExp, align 4
>   %41 = load i32* %aExp, align 4
>   %42 = icmp eq i32 %41, 32767
>   br i1 %42, label %43, label %67
> 
> ; <label>:43                                      ; preds = %0
>   %44 = load i64* %aSig0, align 8
>   %45 = load i64* %aSig1, align 8
>   %46 = or i64 %44, %45
>   %47 = icmp ne i64 %46, 0
>   br i1 %47, label %56, label %48
> 
> ; <label>:48                                      ; preds = %43
>   %49 = load i32* %bExp, align 4
>   %50 = icmp eq i32 %49, 32767
>   br i1 %50, label %51, label %66
> 
> ; <label>:51                                      ; preds = %48
>   %52 = load i64* %bSig0, align 8
>   %53 = load i64* %bSig1, align 8
>   %54 = or i64 %52, %53
>   %55 = icmp ne i64 %54, 0
>   br i1 %55, label %56, label %66
> 
> ; <label>:56                                      ; preds = %51, %43
>   %57 = load %struct.float_status** %1, align 4
>   %58 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %59 = load i64* %58, align 4
>   %60 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %61 = load i64* %60, align 4
>   %62 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %63 = load i64* %62, align 4
>   %64 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %65 = load i64* %64, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %59, i64 %61, i64 %63, i64 %65, %struct.float_status* %57)
>   br label %288
> 
> ; <label>:66                                      ; preds = %51, %48
>   br label %97
> 
> ; <label>:67                                      ; preds = %0
>   %68 = load i32* %bExp, align 4
>   %69 = icmp eq i32 %68, 32767
>   br i1 %69, label %70, label %88
> 
> ; <label>:70                                      ; preds = %67
>   %71 = load i64* %bSig0, align 8
>   %72 = load i64* %bSig1, align 8
>   %73 = or i64 %71, %72
>   %74 = icmp ne i64 %73, 0
>   br i1 %74, label %75, label %85
> 
> ; <label>:75                                      ; preds = %70
>   %76 = load %struct.float_status** %1, align 4
>   %77 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %78 = load i64* %77, align 4
>   %79 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %80 = load i64* %79, align 4
>   %81 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %82 = load i64* %81, align 4
>   %83 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %84 = load i64* %83, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %78, i64 %80, i64 %82, i64 %84, %struct.float_status* %76)
>   br label %288
> 
> ; <label>:85                                      ; preds = %70
>   %86 = bitcast %struct.float128* %agg.result to i8*
>   %87 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %86, i8* %87, i32 16, i32 4, i1 false)
>   br label %288
> 
> ; <label>:88                                      ; preds = %67
>   %89 = load i32* %bExp, align 4
>   %90 = icmp eq i32 %89, 0
>   br i1 %90, label %91, label %106
> 
> ; <label>:91                                      ; preds = %88
>   %92 = load i64* %bSig0, align 8
>   %93 = load i64* %bSig1, align 8
>   %94 = or i64 %92, %93
>   %95 = icmp eq i64 %94, 0
>   br i1 %95, label %96, label %103
> 
> ; <label>:96                                      ; preds = %91
>   br label %97
> 
> ; <label>:97                                      ; preds = %96, %66
>   %98 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %98)
>   %99 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   store i64 0, i64* %99, align 4
>   %100 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   store i64 -140737488355328, i64* %100, align 4
>   %101 = bitcast %struct.float128* %agg.result to i8*
>   %102 = bitcast %struct.float128* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %101, i8* %102, i32 16, i32 4, i1 false)
>   br label %288
> 
> ; <label>:103                                     ; preds = %91
>   %104 = load i64* %bSig0, align 8
>   %105 = load i64* %bSig1, align 8
>   call void @normalizeFloat128Subnormal(i64 %104, i64 %105, i32* %bExp, i64* %bSig0, i64* %bSig1)
>   br label %106
> 
> ; <label>:106                                     ; preds = %103, %88
>   %107 = load i32* %aExp, align 4
>   %108 = icmp eq i32 %107, 0
>   br i1 %108, label %109, label %120
> 
> ; <label>:109                                     ; preds = %106
>   %110 = load i64* %aSig0, align 8
>   %111 = load i64* %aSig1, align 8
>   %112 = or i64 %110, %111
>   %113 = icmp eq i64 %112, 0
>   br i1 %113, label %114, label %117
> 
> ; <label>:114                                     ; preds = %109
>   %115 = bitcast %struct.float128* %agg.result to i8*
>   %116 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %115, i8* %116, i32 16, i32 4, i1 false)
>   br label %288
> 
> ; <label>:117                                     ; preds = %109
>   %118 = load i64* %aSig0, align 8
>   %119 = load i64* %aSig1, align 8
>   call void @normalizeFloat128Subnormal(i64 %118, i64 %119, i32* %aExp, i64* %aSig0, i64* %aSig1)
>   br label %120
> 
> ; <label>:120                                     ; preds = %117, %106
>   %121 = load i32* %aExp, align 4
>   %122 = load i32* %bExp, align 4
>   %123 = sub nsw i32 %121, %122
>   store i32 %123, i32* %expDiff, align 4
>   %124 = load i32* %expDiff, align 4
>   %125 = icmp slt i32 %124, -1
>   br i1 %125, label %126, label %129
> 
> ; <label>:126                                     ; preds = %120
>   %127 = bitcast %struct.float128* %agg.result to i8*
>   %128 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %127, i8* %128, i32 16, i32 4, i1 false)
>   br label %288
> 
> ; <label>:129                                     ; preds = %120
>   %130 = load i64* %aSig0, align 8
>   %131 = or i64 %130, 281474976710656
>   %132 = load i64* %aSig1, align 8
>   %133 = load i32* %expDiff, align 4
>   %134 = icmp slt i32 %133, 0
>   %135 = zext i1 %134 to i32
>   %136 = sub nsw i32 15, %135
>   call void @shortShift128Left(i64 %131, i64 %132, i32 %136, i64* %aSig0, i64* %aSig1)
>   %137 = load i64* %bSig0, align 8
>   %138 = or i64 %137, 281474976710656
>   %139 = load i64* %bSig1, align 8
>   call void @shortShift128Left(i64 %138, i64 %139, i32 15, i64* %bSig0, i64* %bSig1)
>   %140 = load i64* %bSig0, align 8
>   %141 = load i64* %bSig1, align 8
>   %142 = load i64* %aSig0, align 8
>   %143 = load i64* %aSig1, align 8
>   %144 = call zeroext i8 @le128(i64 %140, i64 %141, i64 %142, i64 %143)
>   %145 = zext i8 %144 to i64
>   store i64 %145, i64* %q, align 8
>   %146 = load i64* %q, align 8
>   %147 = icmp ne i64 %146, 0
>   br i1 %147, label %148, label %153
> 
> ; <label>:148                                     ; preds = %129
>   %149 = load i64* %aSig0, align 8
>   %150 = load i64* %aSig1, align 8
>   %151 = load i64* %bSig0, align 8
>   %152 = load i64* %bSig1, align 8
>   call void @sub128(i64 %149, i64 %150, i64 %151, i64 %152, i64* %aSig0, i64* %aSig1)
>   br label %153
> 
> ; <label>:153                                     ; preds = %148, %129
>   %154 = load i32* %expDiff, align 4
>   %155 = sub nsw i32 %154, 64
>   store i32 %155, i32* %expDiff, align 4
>   br label %156
> 
> ; <label>:156                                     ; preds = %170, %153
>   %157 = load i32* %expDiff, align 4
>   %158 = icmp slt i32 0, %157
>   br i1 %158, label %159, label %185
> 
> ; <label>:159                                     ; preds = %156
>   %160 = load i64* %aSig0, align 8
>   %161 = load i64* %aSig1, align 8
>   %162 = load i64* %bSig0, align 8
>   %163 = call i64 @estimateDiv128To64(i64 %160, i64 %161, i64 %162)
>   store i64 %163, i64* %q, align 8
>   %164 = load i64* %q, align 8
>   %165 = icmp ult i64 4, %164
>   br i1 %165, label %166, label %169
> 
> ; <label>:166                                     ; preds = %159
>   %167 = load i64* %q, align 8
>   %168 = sub i64 %167, 4
>   br label %170
> 
> ; <label>:169                                     ; preds = %159
>   br label %170
> 
> ; <label>:170                                     ; preds = %169, %166
>   %171 = phi i64 [ %168, %166 ], [ 0, %169 ]
>   store i64 %171, i64* %q, align 8
>   %172 = load i64* %bSig0, align 8
>   %173 = load i64* %bSig1, align 8
>   %174 = load i64* %q, align 8
>   call void @mul128By64To192(i64 %172, i64 %173, i64 %174, i64* %term0, i64* %term1, i64* %term2)
>   %175 = load i64* %term0, align 8
>   %176 = load i64* %term1, align 8
>   %177 = load i64* %term2, align 8
>   call void @shortShift192Left(i64 %175, i64 %176, i64 %177, i32 61, i64* %term1, i64* %term2, i64* %allZero)
>   %178 = load i64* %aSig0, align 8
>   %179 = load i64* %aSig1, align 8
>   call void @shortShift128Left(i64 %178, i64 %179, i32 61, i64* %aSig0, i64* %allZero)
>   %180 = load i64* %aSig0, align 8
>   %181 = load i64* %term1, align 8
>   %182 = load i64* %term2, align 8
>   call void @sub128(i64 %180, i64 0, i64 %181, i64 %182, i64* %aSig0, i64* %aSig1)
>   %183 = load i32* %expDiff, align 4
>   %184 = sub nsw i32 %183, 61
>   store i32 %184, i32* %expDiff, align 4
>   br label %156
> 
> ; <label>:185                                     ; preds = %156
>   %186 = load i32* %expDiff, align 4
>   %187 = icmp slt i32 -64, %186
>   br i1 %187, label %188, label %229
> 
> ; <label>:188                                     ; preds = %185
>   %189 = load i64* %aSig0, align 8
>   %190 = load i64* %aSig1, align 8
>   %191 = load i64* %bSig0, align 8
>   %192 = call i64 @estimateDiv128To64(i64 %189, i64 %190, i64 %191)
>   store i64 %192, i64* %q, align 8
>   %193 = load i64* %q, align 8
>   %194 = icmp ult i64 4, %193
>   br i1 %194, label %195, label %198
> 
> ; <label>:195                                     ; preds = %188
>   %196 = load i64* %q, align 8
>   %197 = sub i64 %196, 4
>   br label %199
> 
> ; <label>:198                                     ; preds = %188
>   br label %199
> 
> ; <label>:199                                     ; preds = %198, %195
>   %200 = phi i64 [ %197, %195 ], [ 0, %198 ]
>   store i64 %200, i64* %q, align 8
>   %201 = load i32* %expDiff, align 4
>   %202 = sub nsw i32 0, %201
>   %203 = load i64* %q, align 8
>   %204 = zext i32 %202 to i64
>   %205 = lshr i64 %203, %204
>   store i64 %205, i64* %q, align 8
>   %206 = load i64* %bSig0, align 8
>   %207 = load i64* %bSig1, align 8
>   call void @shift128Right(i64 %206, i64 %207, i32 12, i64* %bSig0, i64* %bSig1)
>   %208 = load i32* %expDiff, align 4
>   %209 = add nsw i32 %208, 52
>   store i32 %209, i32* %expDiff, align 4
>   %210 = load i32* %expDiff, align 4
>   %211 = icmp slt i32 %210, 0
>   br i1 %211, label %212, label %217
> 
> ; <label>:212                                     ; preds = %199
>   %213 = load i64* %aSig0, align 8
>   %214 = load i64* %aSig1, align 8
>   %215 = load i32* %expDiff, align 4
>   %216 = sub nsw i32 0, %215
>   call void @shift128Right(i64 %213, i64 %214, i32 %216, i64* %aSig0, i64* %aSig1)
>   br label %221
> 
> ; <label>:217                                     ; preds = %199
>   %218 = load i64* %aSig0, align 8
>   %219 = load i64* %aSig1, align 8
>   %220 = load i32* %expDiff, align 4
>   call void @shortShift128Left(i64 %218, i64 %219, i32 %220, i64* %aSig0, i64* %aSig1)
>   br label %221
> 
> ; <label>:221                                     ; preds = %217, %212
>   %222 = load i64* %bSig0, align 8
>   %223 = load i64* %bSig1, align 8
>   %224 = load i64* %q, align 8
>   call void @mul128By64To192(i64 %222, i64 %223, i64 %224, i64* %term0, i64* %term1, i64* %term2)
>   %225 = load i64* %aSig0, align 8
>   %226 = load i64* %aSig1, align 8
>   %227 = load i64* %term1, align 8
>   %228 = load i64* %term2, align 8
>   call void @sub128(i64 %225, i64 %226, i64 %227, i64 %228, i64* %aSig0, i64* %aSig1)
>   br label %234
> 
> ; <label>:229                                     ; preds = %185
>   %230 = load i64* %aSig0, align 8
>   %231 = load i64* %aSig1, align 8
>   call void @shift128Right(i64 %230, i64 %231, i32 12, i64* %aSig0, i64* %aSig1)
>   %232 = load i64* %bSig0, align 8
>   %233 = load i64* %bSig1, align 8
>   call void @shift128Right(i64 %232, i64 %233, i32 12, i64* %bSig0, i64* %bSig1)
>   br label %234
> 
> ; <label>:234                                     ; preds = %229, %221
>   br label %235
> 
> ; <label>:235                                     ; preds = %244, %234
>   %236 = load i64* %aSig0, align 8
>   store i64 %236, i64* %alternateASig0, align 8
>   %237 = load i64* %aSig1, align 8
>   store i64 %237, i64* %alternateASig1, align 8
>   %238 = load i64* %q, align 8
>   %239 = add i64 %238, 1
>   store i64 %239, i64* %q, align 8
>   %240 = load i64* %aSig0, align 8
>   %241 = load i64* %aSig1, align 8
>   %242 = load i64* %bSig0, align 8
>   %243 = load i64* %bSig1, align 8
>   call void @sub128(i64 %240, i64 %241, i64 %242, i64 %243, i64* %aSig0, i64* %aSig1)
>   br label %244
> 
> ; <label>:244                                     ; preds = %235
>   %245 = load i64* %aSig0, align 8
>   %246 = icmp sle i64 0, %245
>   br i1 %246, label %235, label %247
> 
> ; <label>:247                                     ; preds = %244
>   %248 = load i64* %aSig0, align 8
>   %249 = load i64* %aSig1, align 8
>   %250 = load i64* %alternateASig0, align 8
>   %251 = load i64* %alternateASig1, align 8
>   call void @add128(i64 %248, i64 %249, i64 %250, i64 %251, i64* %sigMean0, i64* %sigMean1)
>   %252 = load i64* %sigMean0, align 8
>   %253 = icmp slt i64 %252, 0
>   br i1 %253, label %263, label %254
> 
> ; <label>:254                                     ; preds = %247
>   %255 = load i64* %sigMean0, align 8
>   %256 = load i64* %sigMean1, align 8
>   %257 = or i64 %255, %256
>   %258 = icmp eq i64 %257, 0
>   br i1 %258, label %259, label %266
> 
> ; <label>:259                                     ; preds = %254
>   %260 = load i64* %q, align 8
>   %261 = and i64 %260, 1
>   %262 = icmp ne i64 %261, 0
>   br i1 %262, label %263, label %266
> 
> ; <label>:263                                     ; preds = %259, %247
>   %264 = load i64* %alternateASig0, align 8
>   store i64 %264, i64* %aSig0, align 8
>   %265 = load i64* %alternateASig1, align 8
>   store i64 %265, i64* %aSig1, align 8
>   br label %266
> 
> ; <label>:266                                     ; preds = %263, %259, %254
>   %267 = load i64* %aSig0, align 8
>   %268 = icmp slt i64 %267, 0
>   %269 = zext i1 %268 to i32
>   %270 = trunc i32 %269 to i8
>   store i8 %270, i8* %zSign, align 1
>   %271 = load i8* %zSign, align 1
>   %272 = icmp ne i8 %271, 0
>   br i1 %272, label %273, label %276
> 
> ; <label>:273                                     ; preds = %266
>   %274 = load i64* %aSig0, align 8
>   %275 = load i64* %aSig1, align 8
>   call void @sub128(i64 0, i64 0, i64 %274, i64 %275, i64* %aSig0, i64* %aSig1)
>   br label %276
> 
> ; <label>:276                                     ; preds = %273, %266
>   %277 = load i8* %aSign, align 1
>   %278 = zext i8 %277 to i32
>   %279 = load i8* %zSign, align 1
>   %280 = zext i8 %279 to i32
>   %281 = xor i32 %278, %280
>   %282 = trunc i32 %281 to i8
>   %283 = load i32* %bExp, align 4
>   %284 = sub nsw i32 %283, 4
>   %285 = load i64* %aSig0, align 8
>   %286 = load i64* %aSig1, align 8
>   %287 = load %struct.float_status** %1, align 4
>   call void @normalizeRoundAndPackFloat128(%struct.float128* sret %agg.result, i8 zeroext %282, i32 %284, i64 %285, i64 %286, %struct.float_status* %287)
>   br label %288
> 
> ; <label>:288                                     ; preds = %276, %126, %114, %97, %85, %75, %56
>   ret void
> }
> 
> define internal void @shortShift192Left(i64 %a0, i64 %a1, i64 %a2, i32 %count, i64* %z0Ptr, i64* %z1Ptr, i64* %z2Ptr) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i32, align 4
>   %5 = alloca i64*, align 4
>   %6 = alloca i64*, align 4
>   %7 = alloca i64*, align 4
>   %z0 = alloca i64, align 8
>   %z1 = alloca i64, align 8
>   %z2 = alloca i64, align 8
>   %negCount = alloca i8, align 1
>   store i64 %a0, i64* %1, align 8
>   store i64 %a1, i64* %2, align 8
>   store i64 %a2, i64* %3, align 8
>   store i32 %count, i32* %4, align 4
>   store i64* %z0Ptr, i64** %5, align 4
>   store i64* %z1Ptr, i64** %6, align 4
>   store i64* %z2Ptr, i64** %7, align 4
>   %8 = load i64* %3, align 8
>   %9 = load i32* %4, align 4
>   %10 = zext i32 %9 to i64
>   %11 = shl i64 %8, %10
>   store i64 %11, i64* %z2, align 8
>   %12 = load i64* %2, align 8
>   %13 = load i32* %4, align 4
>   %14 = zext i32 %13 to i64
>   %15 = shl i64 %12, %14
>   store i64 %15, i64* %z1, align 8
>   %16 = load i64* %1, align 8
>   %17 = load i32* %4, align 4
>   %18 = zext i32 %17 to i64
>   %19 = shl i64 %16, %18
>   store i64 %19, i64* %z0, align 8
>   %20 = load i32* %4, align 4
>   %21 = icmp slt i32 0, %20
>   br i1 %21, label %22, label %41
> 
> ; <label>:22                                      ; preds = %0
>   %23 = load i32* %4, align 4
>   %24 = sub nsw i32 0, %23
>   %25 = and i32 %24, 63
>   %26 = trunc i32 %25 to i8
>   store i8 %26, i8* %negCount, align 1
>   %27 = load i64* %3, align 8
>   %28 = load i8* %negCount, align 1
>   %29 = sext i8 %28 to i32
>   %30 = zext i32 %29 to i64
>   %31 = lshr i64 %27, %30
>   %32 = load i64* %z1, align 8
>   %33 = or i64 %32, %31
>   store i64 %33, i64* %z1, align 8
>   %34 = load i64* %2, align 8
>   %35 = load i8* %negCount, align 1
>   %36 = sext i8 %35 to i32
>   %37 = zext i32 %36 to i64
>   %38 = lshr i64 %34, %37
>   %39 = load i64* %z0, align 8
>   %40 = or i64 %39, %38
>   store i64 %40, i64* %z0, align 8
>   br label %41
> 
> ; <label>:41                                      ; preds = %22, %0
>   %42 = load i64* %z2, align 8
>   %43 = load i64** %7, align 4
>   store i64 %42, i64* %43, align 4
>   %44 = load i64* %z1, align 8
>   %45 = load i64** %6, align 4
>   store i64 %44, i64* %45, align 4
>   %46 = load i64* %z0, align 8
>   %47 = load i64** %5, align 4
>   store i64 %46, i64* %47, align 4
>   ret void
> }
> 
> define internal void @normalizeRoundAndPackFloat128(%struct.float128* noalias sret %agg.result, i8 zeroext %zSign, i32 %zExp, i64 %zSig0, i64 %zSig1, %struct.float_status* %status) nounwind {
>   %1 = alloca i8, align 1
>   %2 = alloca i32, align 4
>   %3 = alloca i64, align 8
>   %4 = alloca i64, align 8
>   %5 = alloca %struct.float_status*, align 4
>   %shiftCount = alloca i8, align 1
>   %zSig2 = alloca i64, align 8
>   store i8 %zSign, i8* %1, align 1
>   store i32 %zExp, i32* %2, align 4
>   store i64 %zSig0, i64* %3, align 8
>   store i64 %zSig1, i64* %4, align 8
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load i64* %3, align 8
>   %7 = icmp eq i64 %6, 0
>   br i1 %7, label %8, label %12
> 
> ; <label>:8                                       ; preds = %0
>   %9 = load i64* %4, align 8
>   store i64 %9, i64* %3, align 8
>   store i64 0, i64* %4, align 8
>   %10 = load i32* %2, align 4
>   %11 = sub nsw i32 %10, 64
>   store i32 %11, i32* %2, align 4
>   br label %12
> 
> ; <label>:12                                      ; preds = %8, %0
>   %13 = load i64* %3, align 8
>   %14 = call signext i8 @countLeadingZeros64(i64 %13)
>   %15 = sext i8 %14 to i32
>   %16 = sub nsw i32 %15, 15
>   %17 = trunc i32 %16 to i8
>   store i8 %17, i8* %shiftCount, align 1
>   %18 = load i8* %shiftCount, align 1
>   %19 = sext i8 %18 to i32
>   %20 = icmp sle i32 0, %19
>   br i1 %20, label %21, label %26
> 
> ; <label>:21                                      ; preds = %12
>   store i64 0, i64* %zSig2, align 8
>   %22 = load i64* %3, align 8
>   %23 = load i64* %4, align 8
>   %24 = load i8* %shiftCount, align 1
>   %25 = sext i8 %24 to i32
>   call void @shortShift128Left(i64 %22, i64 %23, i32 %25, i64* %3, i64* %4)
>   br label %32
> 
> ; <label>:26                                      ; preds = %12
>   %27 = load i64* %3, align 8
>   %28 = load i64* %4, align 8
>   %29 = load i8* %shiftCount, align 1
>   %30 = sext i8 %29 to i32
>   %31 = sub nsw i32 0, %30
>   call void @shift128ExtraRightJamming(i64 %27, i64 %28, i64 0, i32 %31, i64* %3, i64* %4, i64* %zSig2)
>   br label %32
> 
> ; <label>:32                                      ; preds = %26, %21
>   %33 = load i8* %shiftCount, align 1
>   %34 = sext i8 %33 to i32
>   %35 = load i32* %2, align 4
>   %36 = sub nsw i32 %35, %34
>   store i32 %36, i32* %2, align 4
>   %37 = load i8* %1, align 1
>   %38 = load i32* %2, align 4
>   %39 = load i64* %3, align 8
>   %40 = load i64* %4, align 8
>   %41 = load i64* %zSig2, align 8
>   %42 = load %struct.float_status** %5, align 4
>   call void @roundAndPackFloat128(%struct.float128* sret %agg.result, i8 zeroext %37, i32 %38, i64 %39, i64 %40, i64 %41, %struct.float_status* %42)
>   ret void
> }
> 
> define internal void @float128_sqrt(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %zExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %zSig0 = alloca i64, align 8
>   %zSig1 = alloca i64, align 8
>   %zSig2 = alloca i64, align 8
>   %doubleZSig0 = alloca i64, align 8
>   %rem0 = alloca i64, align 8
>   %rem1 = alloca i64, align 8
>   %rem2 = alloca i64, align 8
>   %rem3 = alloca i64, align 8
>   %term0 = alloca i64, align 8
>   %term1 = alloca i64, align 8
>   %term2 = alloca i64, align 8
>   %term3 = alloca i64, align 8
>   %z = alloca %struct.float128, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %5 = load i64* %4, align 4
>   %6 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %7 = load i64* %6, align 4
>   %8 = call i64 @extractFloat128Frac1(i64 %5, i64 %7)
>   store i64 %8, i64* %aSig1, align 8
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %10 = load i64* %9, align 4
>   %11 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %12 = load i64* %11, align 4
>   %13 = call i64 @extractFloat128Frac0(i64 %10, i64 %12)
>   store i64 %13, i64* %aSig0, align 8
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i32 @extractFloat128Exp(i64 %15, i64 %17)
>   store i32 %18, i32* %aExp, align 4
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call zeroext i8 @extractFloat128Sign(i64 %20, i64 %22)
>   store i8 %23, i8* %aSign, align 1
>   %24 = load i32* %aExp, align 4
>   %25 = icmp eq i32 %24, 32767
>   br i1 %25, label %26, label %48
> 
> ; <label>:26                                      ; preds = %0
>   %27 = load i64* %aSig0, align 8
>   %28 = load i64* %aSig1, align 8
>   %29 = or i64 %27, %28
>   %30 = icmp ne i64 %29, 0
>   br i1 %30, label %31, label %41
> 
> ; <label>:31                                      ; preds = %26
>   %32 = load %struct.float_status** %1, align 4
>   %33 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %34 = load i64* %33, align 4
>   %35 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %36 = load i64* %35, align 4
>   %37 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %38 = load i64* %37, align 4
>   %39 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %40 = load i64* %39, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %34, i64 %36, i64 %38, i64 %40, %struct.float_status* %32)
>   br label %188
> 
> ; <label>:41                                      ; preds = %26
>   %42 = load i8* %aSign, align 1
>   %43 = icmp ne i8 %42, 0
>   br i1 %43, label %47, label %44
> 
> ; <label>:44                                      ; preds = %41
>   %45 = bitcast %struct.float128* %agg.result to i8*
>   %46 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %45, i8* %46, i32 16, i32 4, i1 false)
>   br label %188
> 
> ; <label>:47                                      ; preds = %41
>   br label %63
> 
> ; <label>:48                                      ; preds = %0
>   %49 = load i8* %aSign, align 1
>   %50 = icmp ne i8 %49, 0
>   br i1 %50, label %51, label %69
> 
> ; <label>:51                                      ; preds = %48
>   %52 = load i32* %aExp, align 4
>   %53 = sext i32 %52 to i64
>   %54 = load i64* %aSig0, align 8
>   %55 = or i64 %53, %54
>   %56 = load i64* %aSig1, align 8
>   %57 = or i64 %55, %56
>   %58 = icmp eq i64 %57, 0
>   br i1 %58, label %59, label %62
> 
> ; <label>:59                                      ; preds = %51
>   %60 = bitcast %struct.float128* %agg.result to i8*
>   %61 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %60, i8* %61, i32 16, i32 4, i1 false)
>   br label %188
> 
> ; <label>:62                                      ; preds = %51
>   br label %63
> 
> ; <label>:63                                      ; preds = %62, %47
>   %64 = load %struct.float_status** %1, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %64)
>   %65 = getelementptr inbounds %struct.float128* %z, i32 0, i32 0
>   store i64 0, i64* %65, align 4
>   %66 = getelementptr inbounds %struct.float128* %z, i32 0, i32 1
>   store i64 -140737488355328, i64* %66, align 4
>   %67 = bitcast %struct.float128* %agg.result to i8*
>   %68 = bitcast %struct.float128* %z to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %67, i8* %68, i32 16, i32 4, i1 false)
>   br label %188
> 
> ; <label>:69                                      ; preds = %48
>   %70 = load i32* %aExp, align 4
>   %71 = icmp eq i32 %70, 0
>   br i1 %71, label %72, label %81
> 
> ; <label>:72                                      ; preds = %69
>   %73 = load i64* %aSig0, align 8
>   %74 = load i64* %aSig1, align 8
>   %75 = or i64 %73, %74
>   %76 = icmp eq i64 %75, 0
>   br i1 %76, label %77, label %78
> 
> ; <label>:77                                      ; preds = %72
>   call void @packFloat128(%struct.float128* sret %agg.result, i8 zeroext 0, i32 0, i64 0, i64 0)
>   br label %188
> 
> ; <label>:78                                      ; preds = %72
>   %79 = load i64* %aSig0, align 8
>   %80 = load i64* %aSig1, align 8
>   call void @normalizeFloat128Subnormal(i64 %79, i64 %80, i32* %aExp, i64* %aSig0, i64* %aSig1)
>   br label %81
> 
> ; <label>:81                                      ; preds = %78, %69
>   %82 = load i32* %aExp, align 4
>   %83 = sub nsw i32 %82, 16383
>   %84 = ashr i32 %83, 1
>   %85 = add nsw i32 %84, 16382
>   store i32 %85, i32* %zExp, align 4
>   %86 = load i64* %aSig0, align 8
>   %87 = or i64 %86, 281474976710656
>   store i64 %87, i64* %aSig0, align 8
>   %88 = load i32* %aExp, align 4
>   %89 = load i64* %aSig0, align 8
>   %90 = lshr i64 %89, 17
>   %91 = trunc i64 %90 to i32
>   %92 = call i32 @estimateSqrt32(i32 %88, i32 %91)
>   %93 = zext i32 %92 to i64
>   store i64 %93, i64* %zSig0, align 8
>   %94 = load i64* %aSig0, align 8
>   %95 = load i64* %aSig1, align 8
>   %96 = load i32* %aExp, align 4
>   %97 = and i32 %96, 1
>   %98 = sub nsw i32 13, %97
>   call void @shortShift128Left(i64 %94, i64 %95, i32 %98, i64* %aSig0, i64* %aSig1)
>   %99 = load i64* %aSig0, align 8
>   %100 = load i64* %aSig1, align 8
>   %101 = load i64* %zSig0, align 8
>   %102 = shl i64 %101, 32
>   %103 = call i64 @estimateDiv128To64(i64 %99, i64 %100, i64 %102)
>   %104 = load i64* %zSig0, align 8
>   %105 = shl i64 %104, 30
>   %106 = add i64 %103, %105
>   store i64 %106, i64* %zSig0, align 8
>   %107 = load i64* %zSig0, align 8
>   %108 = shl i64 %107, 1
>   store i64 %108, i64* %doubleZSig0, align 8
>   %109 = load i64* %zSig0, align 8
>   %110 = load i64* %zSig0, align 8
>   call void @mul64To128(i64 %109, i64 %110, i64* %term0, i64* %term1)
>   %111 = load i64* %aSig0, align 8
>   %112 = load i64* %aSig1, align 8
>   %113 = load i64* %term0, align 8
>   %114 = load i64* %term1, align 8
>   call void @sub128(i64 %111, i64 %112, i64 %113, i64 %114, i64* %rem0, i64* %rem1)
>   br label %115
> 
> ; <label>:115                                     ; preds = %118, %81
>   %116 = load i64* %rem0, align 8
>   %117 = icmp slt i64 %116, 0
>   br i1 %117, label %118, label %129
> 
> ; <label>:118                                     ; preds = %115
>   %119 = load i64* %zSig0, align 8
>   %120 = add i64 %119, -1
>   store i64 %120, i64* %zSig0, align 8
>   %121 = load i64* %doubleZSig0, align 8
>   %122 = sub i64 %121, 2
>   store i64 %122, i64* %doubleZSig0, align 8
>   %123 = load i64* %rem0, align 8
>   %124 = load i64* %rem1, align 8
>   %125 = load i64* %zSig0, align 8
>   %126 = lshr i64 %125, 63
>   %127 = load i64* %doubleZSig0, align 8
>   %128 = or i64 %127, 1
>   call void @add128(i64 %123, i64 %124, i64 %126, i64 %128, i64* %rem0, i64* %rem1)
>   br label %115
> 
> ; <label>:129                                     ; preds = %115
>   %130 = load i64* %rem1, align 8
>   %131 = load i64* %doubleZSig0, align 8
>   %132 = call i64 @estimateDiv128To64(i64 %130, i64 0, i64 %131)
>   store i64 %132, i64* %zSig1, align 8
>   %133 = load i64* %zSig1, align 8
>   %134 = and i64 %133, 8191
>   %135 = icmp ule i64 %134, 5
>   br i1 %135, label %136, label %180
> 
> ; <label>:136                                     ; preds = %129
>   %137 = load i64* %zSig1, align 8
>   %138 = icmp eq i64 %137, 0
>   br i1 %138, label %139, label %140
> 
> ; <label>:139                                     ; preds = %136
>   store i64 1, i64* %zSig1, align 8
>   br label %140
> 
> ; <label>:140                                     ; preds = %139, %136
>   %141 = load i64* %doubleZSig0, align 8
>   %142 = load i64* %zSig1, align 8
>   call void @mul64To128(i64 %141, i64 %142, i64* %term1, i64* %term2)
>   %143 = load i64* %rem1, align 8
>   %144 = load i64* %term1, align 8
>   %145 = load i64* %term2, align 8
>   call void @sub128(i64 %143, i64 0, i64 %144, i64 %145, i64* %rem1, i64* %rem2)
>   %146 = load i64* %zSig1, align 8
>   %147 = load i64* %zSig1, align 8
>   call void @mul64To128(i64 %146, i64 %147, i64* %term2, i64* %term3)
>   %148 = load i64* %rem1, align 8
>   %149 = load i64* %rem2, align 8
>   %150 = load i64* %term2, align 8
>   %151 = load i64* %term3, align 8
>   call void @sub192(i64 %148, i64 %149, i64 0, i64 0, i64 %150, i64 %151, i64* %rem1, i64* %rem2, i64* %rem3)
>   br label %152
> 
> ; <label>:152                                     ; preds = %155, %140
>   %153 = load i64* %rem1, align 8
>   %154 = icmp slt i64 %153, 0
>   br i1 %154, label %155, label %169
> 
> ; <label>:155                                     ; preds = %152
>   %156 = load i64* %zSig1, align 8
>   %157 = add i64 %156, -1
>   store i64 %157, i64* %zSig1, align 8
>   %158 = load i64* %zSig1, align 8
>   call void @shortShift128Left(i64 0, i64 %158, i32 1, i64* %term2, i64* %term3)
>   %159 = load i64* %term3, align 8
>   %160 = or i64 %159, 1
>   store i64 %160, i64* %term3, align 8
>   %161 = load i64* %doubleZSig0, align 8
>   %162 = load i64* %term2, align 8
>   %163 = or i64 %162, %161
>   store i64 %163, i64* %term2, align 8
>   %164 = load i64* %rem1, align 8
>   %165 = load i64* %rem2, align 8
>   %166 = load i64* %rem3, align 8
>   %167 = load i64* %term2, align 8
>   %168 = load i64* %term3, align 8
>   call void @add192(i64 %164, i64 %165, i64 %166, i64 0, i64 %167, i64 %168, i64* %rem1, i64* %rem2, i64* %rem3)
>   br label %152
> 
> ; <label>:169                                     ; preds = %152
>   %170 = load i64* %rem1, align 8
>   %171 = load i64* %rem2, align 8
>   %172 = or i64 %170, %171
>   %173 = load i64* %rem3, align 8
>   %174 = or i64 %172, %173
>   %175 = icmp ne i64 %174, 0
>   %176 = zext i1 %175 to i32
>   %177 = sext i32 %176 to i64
>   %178 = load i64* %zSig1, align 8
>   %179 = or i64 %178, %177
>   store i64 %179, i64* %zSig1, align 8
>   br label %180
> 
> ; <label>:180                                     ; preds = %169, %129
>   %181 = load i64* %zSig0, align 8
>   %182 = load i64* %zSig1, align 8
>   call void @shift128ExtraRightJamming(i64 %181, i64 %182, i64 0, i32 14, i64* %zSig0, i64* %zSig1, i64* %zSig2)
>   %183 = load i32* %zExp, align 4
>   %184 = load i64* %zSig0, align 8
>   %185 = load i64* %zSig1, align 8
>   %186 = load i64* %zSig2, align 8
>   %187 = load %struct.float_status** %1, align 4
>   call void @roundAndPackFloat128(%struct.float128* sret %agg.result, i8 zeroext 0, i32 %183, i64 %184, i64 %185, i64 %186, %struct.float_status* %187)
>   br label %188
> 
> ; <label>:188                                     ; preds = %180, %77, %63, %59, %44, %31
>   ret void
> }
> 
> define internal i32 @float128_eq(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i32 @extractFloat128Exp(i64 %8, i64 %10)
>   %12 = icmp eq i32 %11, 32767
>   br i1 %12, label %13, label %26
> 
> ; <label>:13                                      ; preds = %0
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i64 @extractFloat128Frac0(i64 %15, i64 %17)
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call i64 @extractFloat128Frac1(i64 %20, i64 %22)
>   %24 = or i64 %18, %23
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %46, label %26
> 
> ; <label>:26                                      ; preds = %13, %0
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i32 @extractFloat128Exp(i64 %28, i64 %30)
>   %32 = icmp eq i32 %31, 32767
>   br i1 %32, label %33, label %48
> 
> ; <label>:33                                      ; preds = %26
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   %38 = call i64 @extractFloat128Frac0(i64 %35, i64 %37)
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   %43 = call i64 @extractFloat128Frac1(i64 %40, i64 %42)
>   %44 = or i64 %38, %43
>   %45 = icmp ne i64 %44, 0
>   br i1 %45, label %46, label %48
> 
> ; <label>:46                                      ; preds = %33, %13
>   %47 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %47)
>   store i32 0, i32* %1
>   br label %79
> 
> ; <label>:48                                      ; preds = %33, %26
>   %49 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %50 = load i64* %49, align 4
>   %51 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %52 = load i64* %51, align 4
>   %53 = icmp eq i64 %50, %52
>   br i1 %53, label %54, label %76
> 
> ; <label>:54                                      ; preds = %48
>   %55 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %56 = load i64* %55, align 4
>   %57 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %58 = load i64* %57, align 4
>   %59 = icmp eq i64 %56, %58
>   br i1 %59, label %74, label %60
> 
> ; <label>:60                                      ; preds = %54
>   %61 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %62 = load i64* %61, align 4
>   %63 = icmp eq i64 %62, 0
>   br i1 %63, label %64, label %72
> 
> ; <label>:64                                      ; preds = %60
>   %65 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %66 = load i64* %65, align 4
>   %67 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %68 = load i64* %67, align 4
>   %69 = or i64 %66, %68
>   %70 = shl i64 %69, 1
>   %71 = icmp eq i64 %70, 0
>   br label %72
> 
> ; <label>:72                                      ; preds = %64, %60
>   %73 = phi i1 [ false, %60 ], [ %71, %64 ]
>   br label %74
> 
> ; <label>:74                                      ; preds = %72, %54
>   %75 = phi i1 [ true, %54 ], [ %73, %72 ]
>   br label %76
> 
> ; <label>:76                                      ; preds = %74, %48
>   %77 = phi i1 [ false, %48 ], [ %75, %74 ]
>   %78 = zext i1 %77 to i32
>   store i32 %78, i32* %1
>   br label %79
> 
> ; <label>:79                                      ; preds = %76, %46
>   %80 = load i32* %1
>   ret i32 %80
> }
> 
> define internal i32 @float128_le(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i32 @extractFloat128Exp(i64 %8, i64 %10)
>   %12 = icmp eq i32 %11, 32767
>   br i1 %12, label %13, label %26
> 
> ; <label>:13                                      ; preds = %0
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i64 @extractFloat128Frac0(i64 %15, i64 %17)
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call i64 @extractFloat128Frac1(i64 %20, i64 %22)
>   %24 = or i64 %18, %23
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %46, label %26
> 
> ; <label>:26                                      ; preds = %13, %0
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i32 @extractFloat128Exp(i64 %28, i64 %30)
>   %32 = icmp eq i32 %31, 32767
>   br i1 %32, label %33, label %48
> 
> ; <label>:33                                      ; preds = %26
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   %38 = call i64 @extractFloat128Frac0(i64 %35, i64 %37)
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   %43 = call i64 @extractFloat128Frac1(i64 %40, i64 %42)
>   %44 = or i64 %38, %43
>   %45 = icmp ne i64 %44, 0
>   br i1 %45, label %46, label %48
> 
> ; <label>:46                                      ; preds = %33, %13
>   %47 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %47)
>   store i32 0, i32* %1
>   br label %113
> 
> ; <label>:48                                      ; preds = %33, %26
>   %49 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %50 = load i64* %49, align 4
>   %51 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %52 = load i64* %51, align 4
>   %53 = call zeroext i8 @extractFloat128Sign(i64 %50, i64 %52)
>   store i8 %53, i8* %aSign, align 1
>   %54 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %55 = load i64* %54, align 4
>   %56 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %57 = load i64* %56, align 4
>   %58 = call zeroext i8 @extractFloat128Sign(i64 %55, i64 %57)
>   store i8 %58, i8* %bSign, align 1
>   %59 = load i8* %aSign, align 1
>   %60 = zext i8 %59 to i32
>   %61 = load i8* %bSign, align 1
>   %62 = zext i8 %61 to i32
>   %63 = icmp ne i32 %60, %62
>   br i1 %63, label %64, label %85
> 
> ; <label>:64                                      ; preds = %48
>   %65 = load i8* %aSign, align 1
>   %66 = zext i8 %65 to i32
>   %67 = icmp ne i32 %66, 0
>   br i1 %67, label %82, label %68
> 
> ; <label>:68                                      ; preds = %64
>   %69 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %70 = load i64* %69, align 4
>   %71 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %72 = load i64* %71, align 4
>   %73 = or i64 %70, %72
>   %74 = shl i64 %73, 1
>   %75 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %76 = load i64* %75, align 4
>   %77 = or i64 %74, %76
>   %78 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %79 = load i64* %78, align 4
>   %80 = or i64 %77, %79
>   %81 = icmp eq i64 %80, 0
>   br label %82
22590,22595c26430,26434
< ; <label>:386                                     ; preds = %30
<   %387 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 15, i64 0
<   %388 = load i32* %387, align 4
<   %389 = and i32 %388, 1
<   %390 = icmp eq i32 %389, 0
<   br i1 %390, label %399, label %391
---
> ; <label>:82                                      ; preds = %68, %64
>   %83 = phi i1 [ true, %64 ], [ %81, %68 ]
>   %84 = zext i1 %83 to i32
>   store i32 %84, i32* %1
>   br label %113
22597,22602c26436,26440
< ; <label>:391                                     ; preds = %386
<   %392 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 7
<   %393 = load i32* %392, align 4
<   %394 = and i32 %393, 131072
<   %395 = icmp eq i32 %394, 0
<   br i1 %395, label %396, label %399
---
> ; <label>:85                                      ; preds = %48
>   %86 = load i8* %aSign, align 1
>   %87 = zext i8 %86 to i32
>   %88 = icmp ne i32 %87, 0
>   br i1 %88, label %89, label %100
22604,22607c26442,26453
< ; <label>:396                                     ; preds = %391
<   %397 = and i32 %.pre.i.i, 16
<   %398 = icmp eq i32 %397, 0
<   br i1 %398, label %399, label %401
---
> ; <label>:89                                      ; preds = %85
>   %90 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %91 = load i64* %90, align 4
>   %92 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %93 = load i64* %92, align 4
>   %94 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %95 = load i64* %94, align 4
>   %96 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %97 = load i64* %96, align 4
>   %98 = call zeroext i8 @le128(i64 %91, i64 %93, i64 %95, i64 %97)
>   %99 = zext i8 %98 to i32
>   br label %111
22609,22611c26455,26466
< ; <label>:399                                     ; preds = %396, %391, %386
<   %400 = or i32 %383, 64
<   br label %svm_load_seg_cache.exit
---
> ; <label>:100                                     ; preds = %85
>   %101 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %102 = load i64* %101, align 4
>   %103 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %104 = load i64* %103, align 4
>   %105 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %106 = load i64* %105, align 4
>   %107 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %108 = load i64* %107, align 4
>   %109 = call zeroext i8 @le128(i64 %102, i64 %104, i64 %106, i64 %108)
>   %110 = zext i8 %109 to i32
>   br label %111
22613,22624c26468,26471
< ; <label>:401                                     ; preds = %396
<   %402 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 3, i32 1
<   %403 = load i32* %402, align 4
<   %404 = or i32 %403, %366
<   %405 = getelementptr inbounds %struct.CPUX86State* %359, i64 0, i32 10, i64 2, i32 1
<   %406 = load i32* %405, align 4
<   %407 = or i32 %404, %406
<   %408 = icmp ne i32 %407, 0
<   %409 = zext i1 %408 to i32
<   %410 = shl nuw nsw i32 %409, 6
<   %411 = or i32 %410, %383
<   br label %svm_load_seg_cache.exit
---
> ; <label>:111                                     ; preds = %100, %89
>   %112 = phi i32 [ %99, %89 ], [ %110, %100 ]
>   store i32 %112, i32* %1
>   br label %113
22626,22671c26473,26476
< svm_load_seg_cache.exit:                          ; preds = %401, %399, %30
<   %new_hflags.0.i.i = phi i32 [ %383, %30 ], [ %400, %399 ], [ %411, %401 ]
<   %412 = and i32 %.pre.i.i, -97
<   %413 = or i32 %new_hflags.0.i.i, %412
<   store i32 %413, i32* %.phi.trans.insert.i.i, align 4
<   %414 = load %struct.CPUX86State** @env, align 8
<   %415 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 38
<   %416 = load i64* %415, align 8
<   %417 = add i64 %416, 1040
<   %418 = tail call i32 @lduw_phys(i64 %417) nounwind
<   %419 = add i64 %416, 1048
<   %420 = tail call i64 @ldq_phys(i64 %419) nounwind
<   %421 = trunc i64 %420 to i32
<   %422 = add i64 %416, 1044
<   %423 = tail call i32 @ldl_phys(i64 %422) nounwind
<   %424 = add i64 %416, 1042
<   %425 = tail call i32 @lduw_phys(i64 %424) nounwind
<   %426 = shl i32 %425, 8
<   %427 = and i32 %426, 65280
<   %428 = shl i32 %425, 12
<   %429 = and i32 %428, 15728640
<   %430 = or i32 %427, %429
<   %431 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 1, i32 0
<   store i32 %418, i32* %431, align 4
<   %432 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 1, i32 1
<   store i32 %421, i32* %432, align 4
<   %433 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 1, i32 2
<   store i32 %423, i32* %433, align 4
<   %434 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 1, i32 3
<   store i32 %430, i32* %434, align 4
<   %435 = lshr exact i32 %429, 18
<   %436 = and i32 %435, 16
<   %437 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 8
<   %438 = load i32* %437, align 4
<   %439 = and i32 %438, -32785
<   %440 = or i32 %436, %439
<   store i32 %440, i32* %437, align 4
<   %441 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 2, i32 3
<   %442 = load i32* %441, align 4
<   %443 = lshr i32 %442, 17
<   %444 = and i32 %443, 32
<   %445 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 15, i64 0
<   %446 = load i32* %445, align 4
<   %447 = and i32 %446, 1
<   %448 = icmp eq i32 %447, 0
<   br i1 %448, label %455, label %449
---
> ; <label>:113                                     ; preds = %111, %82, %46
>   %114 = load i32* %1
>   ret i32 %114
> }
22673,22680c26478,26500
< ; <label>:449                                     ; preds = %svm_load_seg_cache.exit
<   %450 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 7
<   %451 = load i32* %450, align 4
<   %452 = and i32 %451, 131072
<   %453 = icmp ne i32 %452, 0
<   %454 = icmp eq i32 %436, 0
<   %or.cond = or i1 %453, %454
<   br i1 %or.cond, label %455, label %457
---
> define internal i32 @float128_lt(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i32 @extractFloat128Exp(i64 %8, i64 %10)
>   %12 = icmp eq i32 %11, 32767
>   br i1 %12, label %13, label %26
22682,22684c26502,26565
< ; <label>:455                                     ; preds = %449, %svm_load_seg_cache.exit
<   %456 = or i32 %444, 64
<   br label %svm_load_seg_cache.exit8
---
> ; <label>:13                                      ; preds = %0
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i64 @extractFloat128Frac0(i64 %15, i64 %17)
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call i64 @extractFloat128Frac1(i64 %20, i64 %22)
>   %24 = or i64 %18, %23
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %46, label %26
> 
> ; <label>:26                                      ; preds = %13, %0
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i32 @extractFloat128Exp(i64 %28, i64 %30)
>   %32 = icmp eq i32 %31, 32767
>   br i1 %32, label %33, label %48
> 
> ; <label>:33                                      ; preds = %26
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   %38 = call i64 @extractFloat128Frac0(i64 %35, i64 %37)
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   %43 = call i64 @extractFloat128Frac1(i64 %40, i64 %42)
>   %44 = or i64 %38, %43
>   %45 = icmp ne i64 %44, 0
>   br i1 %45, label %46, label %48
> 
> ; <label>:46                                      ; preds = %33, %13
>   %47 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %47)
>   store i32 0, i32* %1
>   br label %113
> 
> ; <label>:48                                      ; preds = %33, %26
>   %49 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %50 = load i64* %49, align 4
>   %51 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %52 = load i64* %51, align 4
>   %53 = call zeroext i8 @extractFloat128Sign(i64 %50, i64 %52)
>   store i8 %53, i8* %aSign, align 1
>   %54 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %55 = load i64* %54, align 4
>   %56 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %57 = load i64* %56, align 4
>   %58 = call zeroext i8 @extractFloat128Sign(i64 %55, i64 %57)
>   store i8 %58, i8* %bSign, align 1
>   %59 = load i8* %aSign, align 1
>   %60 = zext i8 %59 to i32
>   %61 = load i8* %bSign, align 1
>   %62 = zext i8 %61 to i32
>   %63 = icmp ne i32 %60, %62
>   br i1 %63, label %64, label %85
22686,22699c26567,26587
< ; <label>:457                                     ; preds = %449
<   %458 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 3, i32 1
<   %459 = load i32* %458, align 4
<   %460 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 0, i32 1
<   %461 = load i32* %460, align 4
<   %462 = or i32 %461, %459
<   %463 = getelementptr inbounds %struct.CPUX86State* %414, i64 0, i32 10, i64 2, i32 1
<   %464 = load i32* %463, align 4
<   %465 = or i32 %462, %464
<   %466 = icmp ne i32 %465, 0
<   %467 = zext i1 %466 to i32
<   %468 = shl nuw nsw i32 %467, 6
<   %469 = or i32 %468, %444
<   br label %svm_load_seg_cache.exit8
---
> ; <label>:64                                      ; preds = %48
>   %65 = load i8* %aSign, align 1
>   %66 = zext i8 %65 to i32
>   %67 = icmp ne i32 %66, 0
>   br i1 %67, label %68, label %82
> 
> ; <label>:68                                      ; preds = %64
>   %69 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %70 = load i64* %69, align 4
>   %71 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %72 = load i64* %71, align 4
>   %73 = or i64 %70, %72
>   %74 = shl i64 %73, 1
>   %75 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %76 = load i64* %75, align 4
>   %77 = or i64 %74, %76
>   %78 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %79 = load i64* %78, align 4
>   %80 = or i64 %77, %79
>   %81 = icmp ne i64 %80, 0
>   br label %82
22701,22737c26589,26593
< svm_load_seg_cache.exit8:                         ; preds = %457, %455
<   %new_hflags.0.i.i7 = phi i32 [ %456, %455 ], [ %469, %457 ]
<   %470 = and i32 %440, -32865
<   %471 = or i32 %new_hflags.0.i.i7, %470
<   store i32 %471, i32* %437, align 4
<   %472 = load %struct.CPUX86State** @env, align 8
<   %473 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 38
<   %474 = load i64* %473, align 8
<   %475 = add i64 %474, 1056
<   %476 = tail call i32 @lduw_phys(i64 %475) nounwind
<   %477 = add i64 %474, 1064
<   %478 = tail call i64 @ldq_phys(i64 %477) nounwind
<   %479 = trunc i64 %478 to i32
<   %480 = add i64 %474, 1060
<   %481 = tail call i32 @ldl_phys(i64 %480) nounwind
<   %482 = add i64 %474, 1058
<   %483 = tail call i32 @lduw_phys(i64 %482) nounwind
<   %484 = shl i32 %483, 8
<   %485 = and i32 %484, 65280
<   %486 = shl i32 %483, 12
<   %487 = and i32 %486, 15728640
<   %488 = or i32 %485, %487
<   %489 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 2, i32 0
<   store i32 %476, i32* %489, align 4
<   %490 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 2, i32 1
<   store i32 %479, i32* %490, align 4
<   %491 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 2, i32 2
<   store i32 %481, i32* %491, align 4
<   %492 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 2, i32 3
<   store i32 %488, i32* %492, align 4
<   %.phi.trans.insert.i.i9 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 8
<   %.pre.i.i10 = load i32* %.phi.trans.insert.i.i9, align 4
<   %493 = lshr exact i32 %487, 17
<   %494 = and i32 %493, 32
<   %495 = and i32 %.pre.i.i10, 32768
<   %496 = icmp eq i32 %495, 0
<   br i1 %496, label %497, label %svm_load_seg_cache.exit12
---
> ; <label>:82                                      ; preds = %68, %64
>   %83 = phi i1 [ false, %64 ], [ %81, %68 ]
>   %84 = zext i1 %83 to i32
>   store i32 %84, i32* %1
>   br label %113
22739,22744c26595,26599
< ; <label>:497                                     ; preds = %svm_load_seg_cache.exit8
<   %498 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 15, i64 0
<   %499 = load i32* %498, align 4
<   %500 = and i32 %499, 1
<   %501 = icmp eq i32 %500, 0
<   br i1 %501, label %510, label %502
---
> ; <label>:85                                      ; preds = %48
>   %86 = load i8* %aSign, align 1
>   %87 = zext i8 %86 to i32
>   %88 = icmp ne i32 %87, 0
>   br i1 %88, label %89, label %100
22746,22751c26601,26612
< ; <label>:502                                     ; preds = %497
<   %503 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 7
<   %504 = load i32* %503, align 4
<   %505 = and i32 %504, 131072
<   %506 = icmp eq i32 %505, 0
<   br i1 %506, label %507, label %510
---
> ; <label>:89                                      ; preds = %85
>   %90 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %91 = load i64* %90, align 4
>   %92 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %93 = load i64* %92, align 4
>   %94 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %95 = load i64* %94, align 4
>   %96 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %97 = load i64* %96, align 4
>   %98 = call zeroext i8 @lt128(i64 %91, i64 %93, i64 %95, i64 %97)
>   %99 = zext i8 %98 to i32
>   br label %111
22753,22756c26614,26625
< ; <label>:507                                     ; preds = %502
<   %508 = and i32 %.pre.i.i10, 16
<   %509 = icmp eq i32 %508, 0
<   br i1 %509, label %510, label %512
---
> ; <label>:100                                     ; preds = %85
>   %101 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %102 = load i64* %101, align 4
>   %103 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %104 = load i64* %103, align 4
>   %105 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %106 = load i64* %105, align 4
>   %107 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %108 = load i64* %107, align 4
>   %109 = call zeroext i8 @lt128(i64 %102, i64 %104, i64 %106, i64 %108)
>   %110 = zext i8 %109 to i32
>   br label %111
22758,22760c26627,26630
< ; <label>:510                                     ; preds = %507, %502, %497
<   %511 = or i32 %494, 64
<   br label %svm_load_seg_cache.exit12
---
> ; <label>:111                                     ; preds = %100, %89
>   %112 = phi i32 [ %99, %89 ], [ %110, %100 ]
>   store i32 %112, i32* %1
>   br label %113
22762,22773c26632,26635
< ; <label>:512                                     ; preds = %507
<   %513 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 3, i32 1
<   %514 = load i32* %513, align 4
<   %515 = getelementptr inbounds %struct.CPUX86State* %472, i64 0, i32 10, i64 0, i32 1
<   %516 = load i32* %515, align 4
<   %517 = or i32 %514, %479
<   %518 = or i32 %517, %516
<   %519 = icmp ne i32 %518, 0
<   %520 = zext i1 %519 to i32
<   %521 = shl nuw nsw i32 %520, 6
<   %522 = or i32 %521, %494
<   br label %svm_load_seg_cache.exit12
---
> ; <label>:113                                     ; preds = %111, %82, %46
>   %114 = load i32* %1
>   ret i32 %114
> }
22775,22813c26637,26657
< svm_load_seg_cache.exit12:                        ; preds = %512, %510, %svm_load_seg_cache.exit8
<   %new_hflags.0.i.i11 = phi i32 [ %494, %svm_load_seg_cache.exit8 ], [ %511, %510 ], [ %522, %512 ]
<   %523 = and i32 %.pre.i.i10, -97
<   %524 = or i32 %new_hflags.0.i.i11, %523
<   store i32 %524, i32* %.phi.trans.insert.i.i9, align 4
<   %525 = load %struct.CPUX86State** @env, align 8
<   %526 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 38
<   %527 = load i64* %526, align 8
<   %528 = add i64 %527, 1072
<   %529 = tail call i32 @lduw_phys(i64 %528) nounwind
<   %530 = add i64 %527, 1080
<   %531 = tail call i64 @ldq_phys(i64 %530) nounwind
<   %532 = trunc i64 %531 to i32
<   %533 = add i64 %527, 1076
<   %534 = tail call i32 @ldl_phys(i64 %533) nounwind
<   %535 = add i64 %527, 1074
<   %536 = tail call i32 @lduw_phys(i64 %535) nounwind
<   %537 = shl i32 %536, 8
<   %538 = and i32 %537, 65280
<   %539 = shl i32 %536, 12
<   %540 = and i32 %539, 15728640
<   %541 = or i32 %538, %540
<   %542 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 3, i32 0
<   store i32 %529, i32* %542, align 4
<   %543 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 3, i32 1
<   store i32 %532, i32* %543, align 4
<   %544 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 3, i32 2
<   store i32 %534, i32* %544, align 4
<   %545 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 3, i32 3
<   store i32 %541, i32* %545, align 4
<   %.phi.trans.insert.i.i13 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 8
<   %.pre.i.i14 = load i32* %.phi.trans.insert.i.i13, align 4
<   %546 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 2, i32 3
<   %547 = load i32* %546, align 4
<   %548 = lshr i32 %547, 17
<   %549 = and i32 %548, 32
<   %550 = and i32 %.pre.i.i14, 32768
<   %551 = icmp eq i32 %550, 0
<   br i1 %551, label %552, label %svm_load_seg_cache.exit16
---
> define internal i32 @float128_unordered(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i32 @extractFloat128Exp(i64 %8, i64 %10)
>   %12 = icmp eq i32 %11, 32767
>   br i1 %12, label %13, label %26
22815,22820c26659,26936
< ; <label>:552                                     ; preds = %svm_load_seg_cache.exit12
<   %553 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 15, i64 0
<   %554 = load i32* %553, align 4
<   %555 = and i32 %554, 1
<   %556 = icmp eq i32 %555, 0
<   br i1 %556, label %565, label %557
---
> ; <label>:13                                      ; preds = %0
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i64 @extractFloat128Frac0(i64 %15, i64 %17)
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call i64 @extractFloat128Frac1(i64 %20, i64 %22)
>   %24 = or i64 %18, %23
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %46, label %26
> 
> ; <label>:26                                      ; preds = %13, %0
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i32 @extractFloat128Exp(i64 %28, i64 %30)
>   %32 = icmp eq i32 %31, 32767
>   br i1 %32, label %33, label %48
> 
> ; <label>:33                                      ; preds = %26
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   %38 = call i64 @extractFloat128Frac0(i64 %35, i64 %37)
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   %43 = call i64 @extractFloat128Frac1(i64 %40, i64 %42)
>   %44 = or i64 %38, %43
>   %45 = icmp ne i64 %44, 0
>   br i1 %45, label %46, label %48
> 
> ; <label>:46                                      ; preds = %33, %13
>   %47 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %47)
>   store i32 1, i32* %1
>   br label %49
> 
> ; <label>:48                                      ; preds = %33, %26
>   store i32 0, i32* %1
>   br label %49
> 
> ; <label>:49                                      ; preds = %48, %46
>   %50 = load i32* %1
>   ret i32 %50
> }
> 
> define internal i32 @float128_eq_quiet(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i32 @extractFloat128Exp(i64 %8, i64 %10)
>   %12 = icmp eq i32 %11, 32767
>   br i1 %12, label %13, label %26
> 
> ; <label>:13                                      ; preds = %0
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i64 @extractFloat128Frac0(i64 %15, i64 %17)
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call i64 @extractFloat128Frac1(i64 %20, i64 %22)
>   %24 = or i64 %18, %23
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %46, label %26
> 
> ; <label>:26                                      ; preds = %13, %0
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i32 @extractFloat128Exp(i64 %28, i64 %30)
>   %32 = icmp eq i32 %31, 32767
>   br i1 %32, label %33, label %63
> 
> ; <label>:33                                      ; preds = %26
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   %38 = call i64 @extractFloat128Frac0(i64 %35, i64 %37)
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   %43 = call i64 @extractFloat128Frac1(i64 %40, i64 %42)
>   %44 = or i64 %38, %43
>   %45 = icmp ne i64 %44, 0
>   br i1 %45, label %46, label %63
> 
> ; <label>:46                                      ; preds = %33, %13
>   %47 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %48 = load i64* %47, align 4
>   %49 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %50 = load i64* %49, align 4
>   %51 = call i32 @float128_is_signaling_nan(i64 %48, i64 %50)
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %60, label %53
> 
> ; <label>:53                                      ; preds = %46
>   %54 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %55 = load i64* %54, align 4
>   %56 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %57 = load i64* %56, align 4
>   %58 = call i32 @float128_is_signaling_nan(i64 %55, i64 %57)
>   %59 = icmp ne i32 %58, 0
>   br i1 %59, label %60, label %62
> 
> ; <label>:60                                      ; preds = %53, %46
>   %61 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %61)
>   br label %62
> 
> ; <label>:62                                      ; preds = %60, %53
>   store i32 0, i32* %1
>   br label %94
> 
> ; <label>:63                                      ; preds = %33, %26
>   %64 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %65 = load i64* %64, align 4
>   %66 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %67 = load i64* %66, align 4
>   %68 = icmp eq i64 %65, %67
>   br i1 %68, label %69, label %91
> 
> ; <label>:69                                      ; preds = %63
>   %70 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %71 = load i64* %70, align 4
>   %72 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %73 = load i64* %72, align 4
>   %74 = icmp eq i64 %71, %73
>   br i1 %74, label %89, label %75
> 
> ; <label>:75                                      ; preds = %69
>   %76 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %77 = load i64* %76, align 4
>   %78 = icmp eq i64 %77, 0
>   br i1 %78, label %79, label %87
> 
> ; <label>:79                                      ; preds = %75
>   %80 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %81 = load i64* %80, align 4
>   %82 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %83 = load i64* %82, align 4
>   %84 = or i64 %81, %83
>   %85 = shl i64 %84, 1
>   %86 = icmp eq i64 %85, 0
>   br label %87
> 
> ; <label>:87                                      ; preds = %79, %75
>   %88 = phi i1 [ false, %75 ], [ %86, %79 ]
>   br label %89
> 
> ; <label>:89                                      ; preds = %87, %69
>   %90 = phi i1 [ true, %69 ], [ %88, %87 ]
>   br label %91
> 
> ; <label>:91                                      ; preds = %89, %63
>   %92 = phi i1 [ false, %63 ], [ %90, %89 ]
>   %93 = zext i1 %92 to i32
>   store i32 %93, i32* %1
>   br label %94
> 
> ; <label>:94                                      ; preds = %91, %62
>   %95 = load i32* %1
>   ret i32 %95
> }
> 
> define internal i32 @float128_le_quiet(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i32 @extractFloat128Exp(i64 %8, i64 %10)
>   %12 = icmp eq i32 %11, 32767
>   br i1 %12, label %13, label %26
> 
> ; <label>:13                                      ; preds = %0
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i64 @extractFloat128Frac0(i64 %15, i64 %17)
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call i64 @extractFloat128Frac1(i64 %20, i64 %22)
>   %24 = or i64 %18, %23
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %46, label %26
> 
> ; <label>:26                                      ; preds = %13, %0
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i32 @extractFloat128Exp(i64 %28, i64 %30)
>   %32 = icmp eq i32 %31, 32767
>   br i1 %32, label %33, label %63
> 
> ; <label>:33                                      ; preds = %26
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   %38 = call i64 @extractFloat128Frac0(i64 %35, i64 %37)
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   %43 = call i64 @extractFloat128Frac1(i64 %40, i64 %42)
>   %44 = or i64 %38, %43
>   %45 = icmp ne i64 %44, 0
>   br i1 %45, label %46, label %63
> 
> ; <label>:46                                      ; preds = %33, %13
>   %47 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %48 = load i64* %47, align 4
>   %49 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %50 = load i64* %49, align 4
>   %51 = call i32 @float128_is_signaling_nan(i64 %48, i64 %50)
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %60, label %53
> 
> ; <label>:53                                      ; preds = %46
>   %54 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %55 = load i64* %54, align 4
>   %56 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %57 = load i64* %56, align 4
>   %58 = call i32 @float128_is_signaling_nan(i64 %55, i64 %57)
>   %59 = icmp ne i32 %58, 0
>   br i1 %59, label %60, label %62
> 
> ; <label>:60                                      ; preds = %53, %46
>   %61 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %61)
>   br label %62
22822,22827c26938,26940
< ; <label>:557                                     ; preds = %552
<   %558 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 7
<   %559 = load i32* %558, align 4
<   %560 = and i32 %559, 131072
<   %561 = icmp eq i32 %560, 0
<   br i1 %561, label %562, label %565
---
> ; <label>:62                                      ; preds = %60, %53
>   store i32 0, i32* %1
>   br label %128
22829,22832c26942,26982
< ; <label>:562                                     ; preds = %557
<   %563 = and i32 %.pre.i.i14, 16
<   %564 = icmp eq i32 %563, 0
<   br i1 %564, label %565, label %567
---
> ; <label>:63                                      ; preds = %33, %26
>   %64 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %65 = load i64* %64, align 4
>   %66 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %67 = load i64* %66, align 4
>   %68 = call zeroext i8 @extractFloat128Sign(i64 %65, i64 %67)
>   store i8 %68, i8* %aSign, align 1
>   %69 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %70 = load i64* %69, align 4
>   %71 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %72 = load i64* %71, align 4
>   %73 = call zeroext i8 @extractFloat128Sign(i64 %70, i64 %72)
>   store i8 %73, i8* %bSign, align 1
>   %74 = load i8* %aSign, align 1
>   %75 = zext i8 %74 to i32
>   %76 = load i8* %bSign, align 1
>   %77 = zext i8 %76 to i32
>   %78 = icmp ne i32 %75, %77
>   br i1 %78, label %79, label %100
> 
> ; <label>:79                                      ; preds = %63
>   %80 = load i8* %aSign, align 1
>   %81 = zext i8 %80 to i32
>   %82 = icmp ne i32 %81, 0
>   br i1 %82, label %97, label %83
> 
> ; <label>:83                                      ; preds = %79
>   %84 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %85 = load i64* %84, align 4
>   %86 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %87 = load i64* %86, align 4
>   %88 = or i64 %85, %87
>   %89 = shl i64 %88, 1
>   %90 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %91 = load i64* %90, align 4
>   %92 = or i64 %89, %91
>   %93 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %94 = load i64* %93, align 4
>   %95 = or i64 %92, %94
>   %96 = icmp eq i64 %95, 0
>   br label %97
22834,22836c26984,26988
< ; <label>:565                                     ; preds = %562, %557, %552
<   %566 = or i32 %549, 64
<   br label %svm_load_seg_cache.exit16
---
> ; <label>:97                                      ; preds = %83, %79
>   %98 = phi i1 [ true, %79 ], [ %96, %83 ]
>   %99 = zext i1 %98 to i32
>   store i32 %99, i32* %1
>   br label %128
22838,22849c26990,27025
< ; <label>:567                                     ; preds = %562
<   %568 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 0, i32 1
<   %569 = load i32* %568, align 4
<   %570 = or i32 %569, %532
<   %571 = getelementptr inbounds %struct.CPUX86State* %525, i64 0, i32 10, i64 2, i32 1
<   %572 = load i32* %571, align 4
<   %573 = or i32 %570, %572
<   %574 = icmp ne i32 %573, 0
<   %575 = zext i1 %574 to i32
<   %576 = shl nuw nsw i32 %575, 6
<   %577 = or i32 %576, %549
<   br label %svm_load_seg_cache.exit16
---
> ; <label>:100                                     ; preds = %63
>   %101 = load i8* %aSign, align 1
>   %102 = zext i8 %101 to i32
>   %103 = icmp ne i32 %102, 0
>   br i1 %103, label %104, label %115
> 
> ; <label>:104                                     ; preds = %100
>   %105 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %106 = load i64* %105, align 4
>   %107 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %108 = load i64* %107, align 4
>   %109 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %110 = load i64* %109, align 4
>   %111 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %112 = load i64* %111, align 4
>   %113 = call zeroext i8 @le128(i64 %106, i64 %108, i64 %110, i64 %112)
>   %114 = zext i8 %113 to i32
>   br label %126
> 
> ; <label>:115                                     ; preds = %100
>   %116 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %117 = load i64* %116, align 4
>   %118 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %119 = load i64* %118, align 4
>   %120 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %121 = load i64* %120, align 4
>   %122 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %123 = load i64* %122, align 4
>   %124 = call zeroext i8 @le128(i64 %117, i64 %119, i64 %121, i64 %123)
>   %125 = zext i8 %124 to i32
>   br label %126
> 
> ; <label>:126                                     ; preds = %115, %104
>   %127 = phi i32 [ %114, %104 ], [ %125, %115 ]
>   store i32 %127, i32* %1
>   br label %128
22851,22965c27027,27029
< svm_load_seg_cache.exit16:                        ; preds = %567, %565, %svm_load_seg_cache.exit12
<   %new_hflags.0.i.i15 = phi i32 [ %549, %svm_load_seg_cache.exit12 ], [ %566, %565 ], [ %577, %567 ]
<   %578 = and i32 %.pre.i.i14, -97
<   %579 = or i32 %new_hflags.0.i.i15, %578
<   store i32 %579, i32* %.phi.trans.insert.i.i13, align 4
<   %580 = load %struct.CPUX86State** @env, align 8
<   %581 = getelementptr inbounds %struct.CPUX86State* %580, i64 0, i32 38
<   %582 = load i64* %581, align 8
<   %583 = add i64 %582, 1400
<   %584 = tail call i64 @ldq_phys(i64 %583) nounwind
<   %585 = trunc i64 %584 to i32
<   %586 = load %struct.CPUX86State** @env, align 8
<   %587 = getelementptr inbounds %struct.CPUX86State* %586, i64 0, i32 5
<   store i32 %585, i32* %587, align 4
<   %588 = load %struct.CPUX86State** @env, align 8
<   %589 = getelementptr inbounds %struct.CPUX86State* %588, i64 0, i32 38
<   %590 = load i64* %589, align 8
<   %591 = add i64 %590, 1496
<   %592 = tail call i64 @ldq_phys(i64 %591) nounwind
<   %593 = trunc i64 %592 to i32
<   %594 = load %struct.CPUX86State** @env, align 8
<   %595 = getelementptr inbounds %struct.CPUX86State* %594, i64 0, i32 0, i64 4
<   store i32 %593, i32* %595, align 4
<   %596 = load %struct.CPUX86State** @env, align 8
<   %597 = getelementptr inbounds %struct.CPUX86State* %596, i64 0, i32 38
<   %598 = load i64* %597, align 8
<   %599 = add i64 %598, 1528
<   %600 = tail call i64 @ldq_phys(i64 %599) nounwind
<   %601 = trunc i64 %600 to i32
<   %602 = load %struct.CPUX86State** @env, align 8
<   %603 = getelementptr inbounds %struct.CPUX86State* %602, i64 0, i32 0, i64 0
<   store i32 %601, i32* %603, align 4
<   %604 = load %struct.CPUX86State** @env, align 8
<   %605 = getelementptr inbounds %struct.CPUX86State* %604, i64 0, i32 38
<   %606 = load i64* %605, align 8
<   %607 = add i64 %606, 1384
<   %608 = tail call i64 @ldq_phys(i64 %607) nounwind
<   %609 = trunc i64 %608 to i32
<   %610 = load %struct.CPUX86State** @env, align 8
<   %611 = getelementptr inbounds %struct.CPUX86State* %610, i64 0, i32 58, i64 6
<   store i32 %609, i32* %611, align 4
<   %612 = load %struct.CPUX86State** @env, align 8
<   %613 = getelementptr inbounds %struct.CPUX86State* %612, i64 0, i32 38
<   %614 = load i64* %613, align 8
<   %615 = add i64 %614, 1376
<   %616 = tail call i64 @ldq_phys(i64 %615) nounwind
<   %617 = trunc i64 %616 to i32
<   %618 = load %struct.CPUX86State** @env, align 8
<   %619 = getelementptr inbounds %struct.CPUX86State* %618, i64 0, i32 58, i64 7
<   store i32 %617, i32* %619, align 4
<   %620 = load %struct.CPUX86State** @env, align 8
<   %621 = getelementptr inbounds %struct.CPUX86State* %620, i64 0, i32 8
<   %622 = load i32* %621, align 4
<   %623 = and i32 %622, 3
<   tail call void @s2e_on_privilege_change(i32 %623, i32 0) nounwind
<   %624 = load i32* %621, align 4
<   %625 = and i32 %624, -4
<   store i32 %625, i32* %621, align 4
<   %626 = load %struct.CPUX86State** @env, align 8
<   %627 = getelementptr inbounds %struct.CPUX86State* %626, i64 0, i32 39
<   %628 = load i64* %627, align 8
<   %629 = add i64 %628, 112
<   %630 = zext i32 %exit_code to i64
<   tail call void @stq_phys(i64 %629, i64 %630) nounwind
<   %631 = load %struct.CPUX86State** @env, align 8
<   %632 = getelementptr inbounds %struct.CPUX86State* %631, i64 0, i32 39
<   %633 = load i64* %632, align 8
<   %634 = add i64 %633, 120
<   tail call void @stq_phys(i64 %634, i64 %exit_info_1) nounwind
<   %635 = load %struct.CPUX86State** @env, align 8
<   %636 = getelementptr inbounds %struct.CPUX86State* %635, i64 0, i32 39
<   %637 = load i64* %636, align 8
<   %638 = add i64 %637, 136
<   %639 = add i64 %637, 168
<   %640 = tail call i32 @ldl_phys(i64 %639) nounwind
<   tail call void @stl_phys(i64 %638, i32 %640) nounwind
<   %641 = load %struct.CPUX86State** @env, align 8
<   %642 = getelementptr inbounds %struct.CPUX86State* %641, i64 0, i32 39
<   %643 = load i64* %642, align 8
<   %644 = add i64 %643, 140
<   %645 = add i64 %643, 172
<   %646 = tail call i32 @ldl_phys(i64 %645) nounwind
<   tail call void @stl_phys(i64 %644, i32 %646) nounwind
<   %647 = load %struct.CPUX86State** @env, align 8
<   %648 = getelementptr inbounds %struct.CPUX86State* %647, i64 0, i32 39
<   %649 = load i64* %648, align 8
<   %650 = add i64 %649, 168
<   tail call void @stl_phys(i64 %650, i32 0) nounwind
<   %651 = load %struct.CPUX86State** @env, align 8
<   %652 = getelementptr inbounds %struct.CPUX86State* %651, i64 0, i32 9
<   %653 = load i32* %652, align 4
<   %654 = and i32 %653, -2
<   store i32 %654, i32* %652, align 4
<   %655 = load %struct.CPUX86State** @env, align 8
<   %656 = getelementptr inbounds %struct.CPUX86State* %655, i64 0, i32 15, i64 0
<   %657 = load i32* %656, align 4
<   %658 = or i32 %657, 1
<   store i32 %658, i32* %656, align 4
<   %659 = load %struct.CPUX86State** @env, align 8
<   %660 = getelementptr inbounds %struct.CPUX86State* %659, i64 0, i32 7
<   %661 = load i32* %660, align 4
<   %662 = and i32 %661, -131073
<   store i32 %662, i32* %660, align 4
<   %663 = load %struct.CPUX86State** @env, align 8
<   %664 = getelementptr inbounds %struct.CPUX86State* %663, i64 0, i32 92
<   store i32 -1, i32* %664, align 4
<   %665 = load %struct.CPUX86State** @env, align 8
<   %666 = getelementptr inbounds %struct.CPUX86State* %665, i64 0, i32 55
<   store i32 0, i32* %666, align 4
<   %667 = load %struct.CPUX86State** @env, align 8
<   %668 = getelementptr inbounds %struct.CPUX86State* %667, i64 0, i32 61
<   store i32 -1, i32* %668, align 4
<   %669 = load %struct.CPUX86State** @env, align 8
<   tail call void @cpu_loop_exit(%struct.CPUX86State* %669) noreturn nounwind
<   unreachable
---
> ; <label>:128                                     ; preds = %126, %97, %62
>   %129 = load i32* %1
>   ret i32 %129
22968,22973c27032,27209
< define void @svm_check_intercept(%struct.CPUX86State* %env1, i32 %type) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   store %struct.CPUX86State* %env1, %struct.CPUX86State** @env, align 8
<   tail call void @helper_svm_check_intercept_param(i32 %type, i64 0)
<   store %struct.CPUX86State* %1, %struct.CPUX86State** @env, align 8
<   ret void
---
> define internal i32 @float128_lt_quiet(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i32 @extractFloat128Exp(i64 %8, i64 %10)
>   %12 = icmp eq i32 %11, 32767
>   br i1 %12, label %13, label %26
> 
> ; <label>:13                                      ; preds = %0
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i64 @extractFloat128Frac0(i64 %15, i64 %17)
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call i64 @extractFloat128Frac1(i64 %20, i64 %22)
>   %24 = or i64 %18, %23
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %46, label %26
> 
> ; <label>:26                                      ; preds = %13, %0
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i32 @extractFloat128Exp(i64 %28, i64 %30)
>   %32 = icmp eq i32 %31, 32767
>   br i1 %32, label %33, label %63
> 
> ; <label>:33                                      ; preds = %26
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   %38 = call i64 @extractFloat128Frac0(i64 %35, i64 %37)
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   %43 = call i64 @extractFloat128Frac1(i64 %40, i64 %42)
>   %44 = or i64 %38, %43
>   %45 = icmp ne i64 %44, 0
>   br i1 %45, label %46, label %63
> 
> ; <label>:46                                      ; preds = %33, %13
>   %47 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %48 = load i64* %47, align 4
>   %49 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %50 = load i64* %49, align 4
>   %51 = call i32 @float128_is_signaling_nan(i64 %48, i64 %50)
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %60, label %53
> 
> ; <label>:53                                      ; preds = %46
>   %54 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %55 = load i64* %54, align 4
>   %56 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %57 = load i64* %56, align 4
>   %58 = call i32 @float128_is_signaling_nan(i64 %55, i64 %57)
>   %59 = icmp ne i32 %58, 0
>   br i1 %59, label %60, label %62
> 
> ; <label>:60                                      ; preds = %53, %46
>   %61 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %61)
>   br label %62
> 
> ; <label>:62                                      ; preds = %60, %53
>   store i32 0, i32* %1
>   br label %128
> 
> ; <label>:63                                      ; preds = %33, %26
>   %64 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %65 = load i64* %64, align 4
>   %66 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %67 = load i64* %66, align 4
>   %68 = call zeroext i8 @extractFloat128Sign(i64 %65, i64 %67)
>   store i8 %68, i8* %aSign, align 1
>   %69 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %70 = load i64* %69, align 4
>   %71 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %72 = load i64* %71, align 4
>   %73 = call zeroext i8 @extractFloat128Sign(i64 %70, i64 %72)
>   store i8 %73, i8* %bSign, align 1
>   %74 = load i8* %aSign, align 1
>   %75 = zext i8 %74 to i32
>   %76 = load i8* %bSign, align 1
>   %77 = zext i8 %76 to i32
>   %78 = icmp ne i32 %75, %77
>   br i1 %78, label %79, label %100
> 
> ; <label>:79                                      ; preds = %63
>   %80 = load i8* %aSign, align 1
>   %81 = zext i8 %80 to i32
>   %82 = icmp ne i32 %81, 0
>   br i1 %82, label %83, label %97
> 
> ; <label>:83                                      ; preds = %79
>   %84 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %85 = load i64* %84, align 4
>   %86 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %87 = load i64* %86, align 4
>   %88 = or i64 %85, %87
>   %89 = shl i64 %88, 1
>   %90 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %91 = load i64* %90, align 4
>   %92 = or i64 %89, %91
>   %93 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %94 = load i64* %93, align 4
>   %95 = or i64 %92, %94
>   %96 = icmp ne i64 %95, 0
>   br label %97
> 
> ; <label>:97                                      ; preds = %83, %79
>   %98 = phi i1 [ false, %79 ], [ %96, %83 ]
>   %99 = zext i1 %98 to i32
>   store i32 %99, i32* %1
>   br label %128
> 
> ; <label>:100                                     ; preds = %63
>   %101 = load i8* %aSign, align 1
>   %102 = zext i8 %101 to i32
>   %103 = icmp ne i32 %102, 0
>   br i1 %103, label %104, label %115
> 
> ; <label>:104                                     ; preds = %100
>   %105 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %106 = load i64* %105, align 4
>   %107 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %108 = load i64* %107, align 4
>   %109 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %110 = load i64* %109, align 4
>   %111 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %112 = load i64* %111, align 4
>   %113 = call zeroext i8 @lt128(i64 %106, i64 %108, i64 %110, i64 %112)
>   %114 = zext i8 %113 to i32
>   br label %126
> 
> ; <label>:115                                     ; preds = %100
>   %116 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %117 = load i64* %116, align 4
>   %118 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %119 = load i64* %118, align 4
>   %120 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %121 = load i64* %120, align 4
>   %122 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %123 = load i64* %122, align 4
>   %124 = call zeroext i8 @lt128(i64 %117, i64 %119, i64 %121, i64 %123)
>   %125 = zext i8 %124 to i32
>   br label %126
> 
> ; <label>:126                                     ; preds = %115, %104
>   %127 = phi i32 [ %114, %104 ], [ %125, %115 ]
>   store i32 %127, i32* %1
>   br label %128
> 
> ; <label>:128                                     ; preds = %126, %97, %62
>   %129 = load i32* %1
>   ret i32 %129
22976,22982c27212,27232
< define void @helper_svm_check_io(i32 %port, i32 %param, i32 %next_eip_addend) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 41
<   %3 = load i64* %2, align 8
<   %4 = and i64 %3, 134217728
<   %5 = icmp eq i64 %4, 0
<   br i1 %5, label %36, label %6
---
> define internal i32 @float128_unordered_quiet(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %6, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = call i32 @extractFloat128Exp(i64 %8, i64 %10)
>   %12 = icmp eq i32 %11, 32767
>   br i1 %12, label %13, label %26
22984,23002c27234,27280
< ; <label>:6                                       ; preds = %0
<   %7 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 39
<   %8 = load i64* %7, align 8
<   %9 = add i64 %8, 64
<   %10 = tail call i64 @ldq_phys(i64 %9) nounwind
<   %11 = lshr i32 %param, 4
<   %12 = and i32 %11, 7
<   %13 = shl i32 1, %12
<   %14 = add nsw i32 %13, 65535
<   %15 = lshr i32 %port, 3
<   %16 = zext i32 %15 to i64
<   %17 = add i64 %10, %16
<   %18 = tail call i32 @lduw_phys(i64 %17) nounwind
<   %19 = and i32 %14, 65535
<   %20 = and i32 %port, 7
<   %21 = shl i32 %19, %20
<   %22 = and i32 %18, %21
<   %23 = icmp eq i32 %22, 0
<   br i1 %23, label %36, label %24
---
> ; <label>:13                                      ; preds = %0
>   %14 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %15 = load i64* %14, align 4
>   %16 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %17 = load i64* %16, align 4
>   %18 = call i64 @extractFloat128Frac0(i64 %15, i64 %17)
>   %19 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %20 = load i64* %19, align 4
>   %21 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %22 = load i64* %21, align 4
>   %23 = call i64 @extractFloat128Frac1(i64 %20, i64 %22)
>   %24 = or i64 %18, %23
>   %25 = icmp ne i64 %24, 0
>   br i1 %25, label %46, label %26
> 
> ; <label>:26                                      ; preds = %13, %0
>   %27 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %28 = load i64* %27, align 4
>   %29 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %30 = load i64* %29, align 4
>   %31 = call i32 @extractFloat128Exp(i64 %28, i64 %30)
>   %32 = icmp eq i32 %31, 32767
>   br i1 %32, label %33, label %63
> 
> ; <label>:33                                      ; preds = %26
>   %34 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   %38 = call i64 @extractFloat128Frac0(i64 %35, i64 %37)
>   %39 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %40 = load i64* %39, align 4
>   %41 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %42 = load i64* %41, align 4
>   %43 = call i64 @extractFloat128Frac1(i64 %40, i64 %42)
>   %44 = or i64 %38, %43
>   %45 = icmp ne i64 %44, 0
>   br i1 %45, label %46, label %63
> 
> ; <label>:46                                      ; preds = %33, %13
>   %47 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %48 = load i64* %47, align 4
>   %49 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %50 = load i64* %49, align 4
>   %51 = call i32 @float128_is_signaling_nan(i64 %48, i64 %50)
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %60, label %53
23004,23018c27282,27307
< ; <label>:24                                      ; preds = %6
<   %25 = load %struct.CPUX86State** @env, align 8
<   %26 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 39
<   %27 = load i64* %26, align 8
<   %28 = add i64 %27, 128
<   %29 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 5
<   %30 = load i32* %29, align 4
<   %31 = add i32 %30, %next_eip_addend
<   %32 = zext i32 %31 to i64
<   tail call void @stq_phys(i64 %28, i64 %32) nounwind
<   %33 = shl i32 %port, 16
<   %34 = or i32 %33, %param
<   %35 = zext i32 %34 to i64
<   tail call void @helper_vmexit(i32 123, i64 %35)
<   unreachable
---
> ; <label>:53                                      ; preds = %46
>   %54 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %55 = load i64* %54, align 4
>   %56 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %57 = load i64* %56, align 4
>   %58 = call i32 @float128_is_signaling_nan(i64 %55, i64 %57)
>   %59 = icmp ne i32 %58, 0
>   br i1 %59, label %60, label %62
> 
> ; <label>:60                                      ; preds = %53, %46
>   %61 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %61)
>   br label %62
> 
> ; <label>:62                                      ; preds = %60, %53
>   store i32 1, i32* %1
>   br label %64
> 
> ; <label>:63                                      ; preds = %33, %26
>   store i32 0, i32* %1
>   br label %64
> 
> ; <label>:64                                      ; preds = %63, %62
>   %65 = load i32* %1
>   ret i32 %65
> }
23020,23021c27309,27318
< ; <label>:36                                      ; preds = %6, %0
<   ret void
---
> define internal i32 @uint32_to_float32(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = zext i32 %3 to i64
>   %5 = load %struct.float_status** %2, align 4
>   %6 = call i32 @int64_to_float32(i64 %4, %struct.float_status* %5)
>   ret i32 %6
23024c27321,27331
< declare void @stb_phys(i64, i32)
---
> define internal i64 @uint32_to_float64(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = zext i32 %3 to i64
>   %5 = load %struct.float_status** %2, align 4
>   %6 = call i64 @int64_to_float64(i64 %4, %struct.float_status* %5)
>   ret i64 %6
> }
23026,23038c27333,27346
< define void @helper_ldmxcsr(i32 %val) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 29
<   store i32 %val, i32* %2, align 4
<   %3 = load %struct.CPUX86State** @env, align 8
<   %4 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 29
<   %5 = load i32* %4, align 4
<   %6 = and i32 %5, 24576
<   switch i32 %6, label %update_sse_status.exit [
<     i32 24576, label %9
<     i32 8192, label %7
<     i32 16384, label %8
<   ]
---
> define internal i32 @float32_to_uint32(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %v = alloca i64, align 8
>   %res = alloca i32, align 4
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = load %struct.float_status** %2, align 4
>   %5 = call i64 @float32_to_int64(i32 %3, %struct.float_status* %4)
>   store i64 %5, i64* %v, align 8
>   %6 = load i64* %v, align 8
>   %7 = icmp slt i64 %6, 0
>   br i1 %7, label %8, label %10
23040,23041c27348,27392
< ; <label>:7                                       ; preds = %0
<   br label %update_sse_status.exit
---
> ; <label>:8                                       ; preds = %0
>   store i32 0, i32* %res, align 4
>   %9 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %9)
>   br label %19
> 
> ; <label>:10                                      ; preds = %0
>   %11 = load i64* %v, align 8
>   %12 = icmp sgt i64 %11, 4294967295
>   br i1 %12, label %13, label %15
> 
> ; <label>:13                                      ; preds = %10
>   store i32 -1, i32* %res, align 4
>   %14 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %14)
>   br label %18
> 
> ; <label>:15                                      ; preds = %10
>   %16 = load i64* %v, align 8
>   %17 = trunc i64 %16 to i32
>   store i32 %17, i32* %res, align 4
>   br label %18
> 
> ; <label>:18                                      ; preds = %15, %13
>   br label %19
> 
> ; <label>:19                                      ; preds = %18, %8
>   %20 = load i32* %res, align 4
>   ret i32 %20
> }
> 
> define internal i32 @float32_to_uint32_round_to_zero(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %v = alloca i64, align 8
>   %res = alloca i32, align 4
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = load %struct.float_status** %2, align 4
>   %5 = call i64 @float32_to_int64_round_to_zero(i32 %3, %struct.float_status* %4)
>   store i64 %5, i64* %v, align 8
>   %6 = load i64* %v, align 8
>   %7 = icmp slt i64 %6, 0
>   br i1 %7, label %8, label %10
23044c27395,27398
<   br label %update_sse_status.exit
---
>   store i32 0, i32* %res, align 4
>   %9 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %9)
>   br label %19
23046,23047c27400,27403
< ; <label>:9                                       ; preds = %0
<   br label %update_sse_status.exit
---
> ; <label>:10                                      ; preds = %0
>   %11 = load i64* %v, align 8
>   %12 = icmp sgt i64 %11, 4294967295
>   br i1 %12, label %13, label %15
23049,23069c27405,27422
< update_sse_status.exit:                           ; preds = %9, %8, %7, %0
<   %rnd_type.0.i = phi i32 [ 2, %8 ], [ 1, %7 ], [ 3, %9 ], [ 0, %0 ]
<   %10 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 28
<   tail call void @set_float_rounding_mode(i32 %rnd_type.0.i, %struct.float_status* %10) nounwind
<   %11 = load %struct.CPUX86State** @env, align 8
<   %12 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 29
<   %13 = load i32* %12, align 4
<   %14 = lshr i32 %13, 6
<   %.tr.i = trunc i32 %14 to i8
<   %15 = and i8 %.tr.i, 1
<   %16 = getelementptr inbounds %struct.CPUX86State* %11, i64 0, i32 28, i32 5
<   store i8 %15, i8* %16, align 1
<   %17 = load %struct.CPUX86State** @env, align 8
<   %18 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 29
<   %19 = load i32* %18, align 4
<   %20 = lshr i32 %19, 15
<   %.tr1.i = trunc i32 %20 to i8
<   %21 = and i8 %.tr1.i, 1
<   %22 = getelementptr inbounds %struct.CPUX86State* %17, i64 0, i32 25, i32 4
<   store i8 %21, i8* %22, align 1
<   ret void
---
> ; <label>:13                                      ; preds = %10
>   store i32 -1, i32* %res, align 4
>   %14 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %14)
>   br label %18
> 
> ; <label>:15                                      ; preds = %10
>   %16 = load i64* %v, align 8
>   %17 = trunc i64 %16 to i32
>   store i32 %17, i32* %res, align 4
>   br label %18
> 
> ; <label>:18                                      ; preds = %15, %13
>   br label %19
> 
> ; <label>:19                                      ; preds = %18, %8
>   %20 = load i32* %res, align 4
>   ret i32 %20
23072,23084c27425,27468
< define void @helper_enter_mmx() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 17
<   store i32 0, i32* %2, align 4
<   %3 = load %struct.CPUX86State** @env, align 8
<   %4 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 20, i64 0
<   %5 = bitcast i8* %4 to i32*
<   store i32 0, i32* %5, align 4
<   %6 = load %struct.CPUX86State** @env, align 8
<   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 20, i64 4
<   %8 = bitcast i8* %7 to i32*
<   store i32 0, i32* %8, align 4
<   ret void
---
> define internal i32 @float32_to_uint16_round_to_zero(i32 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %v = alloca i64, align 8
>   %res = alloca i32, align 4
>   store i32 %a, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i32* %1, align 4
>   %4 = load %struct.float_status** %2, align 4
>   %5 = call i64 @float32_to_int64_round_to_zero(i32 %3, %struct.float_status* %4)
>   store i64 %5, i64* %v, align 8
>   %6 = load i64* %v, align 8
>   %7 = icmp slt i64 %6, 0
>   br i1 %7, label %8, label %10
> 
> ; <label>:8                                       ; preds = %0
>   store i32 0, i32* %res, align 4
>   %9 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %9)
>   br label %19
> 
> ; <label>:10                                      ; preds = %0
>   %11 = load i64* %v, align 8
>   %12 = icmp sgt i64 %11, 65535
>   br i1 %12, label %13, label %15
> 
> ; <label>:13                                      ; preds = %10
>   store i32 65535, i32* %res, align 4
>   %14 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %14)
>   br label %18
> 
> ; <label>:15                                      ; preds = %10
>   %16 = load i64* %v, align 8
>   %17 = trunc i64 %16 to i32
>   store i32 %17, i32* %res, align 4
>   br label %18
> 
> ; <label>:18                                      ; preds = %15, %13
>   br label %19
> 
> ; <label>:19                                      ; preds = %18, %8
>   %20 = load i32* %res, align 4
>   ret i32 %20
23087,23097c27471,27510
< define void @helper_emms() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 20, i64 0
<   %3 = bitcast i8* %2 to i32*
<   store i32 16843009, i32* %3, align 4
<   %4 = load %struct.CPUX86State** @env, align 8
<   %5 = getelementptr inbounds %struct.CPUX86State* %4, i64 0, i32 20, i64 4
<   %6 = bitcast i8* %5 to i32*
<   store i32 16843009, i32* %6, align 4
<   ret void
< }
---
> define internal i32 @float64_to_uint32(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %v = alloca i64, align 8
>   %res = alloca i32, align 4
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i64* %1, align 8
>   %4 = load %struct.float_status** %2, align 4
>   %5 = call i64 @float64_to_int64(i64 %3, %struct.float_status* %4)
>   store i64 %5, i64* %v, align 8
>   %6 = load i64* %v, align 8
>   %7 = icmp slt i64 %6, 0
>   br i1 %7, label %8, label %10
> 
> ; <label>:8                                       ; preds = %0
>   store i32 0, i32* %res, align 4
>   %9 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %9)
>   br label %19
> 
> ; <label>:10                                      ; preds = %0
>   %11 = load i64* %v, align 8
>   %12 = icmp sgt i64 %11, 4294967295
>   br i1 %12, label %13, label %15
> 
> ; <label>:13                                      ; preds = %10
>   store i32 -1, i32* %res, align 4
>   %14 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %14)
>   br label %18
> 
> ; <label>:15                                      ; preds = %10
>   %16 = load i64* %v, align 8
>   %17 = trunc i64 %16 to i32
>   store i32 %17, i32* %res, align 4
>   br label %18
> 
> ; <label>:18                                      ; preds = %15, %13
>   br label %19
23099,23104c27512,27514
< define void @helper_movq(i8* nocapture %d, i8* nocapture %s) nounwind uwtable {
<   %1 = bitcast i8* %s to i64*
<   %2 = load i64* %1, align 8
<   %3 = bitcast i8* %d to i64*
<   store i64 %2, i64* %3, align 8
<   ret void
---
> ; <label>:19                                      ; preds = %18, %8
>   %20 = load i32* %res, align 4
>   ret i32 %20
23107,23115c27517,27530
< define i32 @helper_rclb(i32 %t0, i32 %t1) nounwind uwtable {
<   %1 = and i32 %t1, 31
<   %2 = zext i32 %1 to i64
<   %3 = getelementptr inbounds [32 x i8]* @rclb_table, i64 0, i64 %2
<   %4 = load i8* %3, align 1
<   %5 = zext i8 %4 to i32
<   %6 = icmp eq i8 %4, 0
<   %7 = load %struct.CPUX86State** @env, align 8
<   br i1 %6, label %34, label %8
---
> define internal i32 @float64_to_uint32_round_to_zero(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %v = alloca i64, align 8
>   %res = alloca i32, align 4
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i64* %1, align 8
>   %4 = load %struct.float_status** %2, align 4
>   %5 = call i64 @float64_to_int64_round_to_zero(i64 %3, %struct.float_status* %4)
>   store i64 %5, i64* %v, align 8
>   %6 = load i64* %v, align 8
>   %7 = icmp slt i64 %6, 0
>   br i1 %7, label %8, label %10
23118,23134c27533,27536
<   %9 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 1
<   %10 = load i32* %9, align 4
<   %11 = tail call i32 @helper_cc_compute_all(i32 %10)
<   %12 = and i32 %t0, 255
<   %13 = shl i32 %12, %5
<   %14 = and i32 %11, 1
<   %15 = add nsw i32 %5, -1
<   %16 = shl i32 %14, %15
<   %17 = or i32 %16, %13
<   %18 = icmp ugt i8 %4, 1
<   br i1 %18, label %19, label %23
< 
< ; <label>:19                                      ; preds = %8
<   %20 = sub nsw i32 9, %5
<   %21 = lshr i32 %12, %20
<   %22 = or i32 %17, %21
<   br label %23
---
>   store i32 0, i32* %res, align 4
>   %9 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %9)
>   br label %19
23136,23149c27538,27541
< ; <label>:23                                      ; preds = %19, %8
<   %res.0 = phi i32 [ %22, %19 ], [ %17, %8 ]
<   %24 = and i32 %11, -2050
<   %25 = xor i32 %res.0, %t0
<   %26 = shl i32 %25, 4
<   %27 = and i32 %26, 2048
<   %28 = sub nsw i32 8, %5
<   %29 = lshr i32 %12, %28
<   %30 = and i32 %29, 1
<   %31 = or i32 %24, %30
<   %32 = or i32 %31, %27
<   %33 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 4
<   store i32 %32, i32* %33, align 4
<   br label %36
---
> ; <label>:10                                      ; preds = %0
>   %11 = load i64* %v, align 8
>   %12 = icmp sgt i64 %11, 4294967295
>   br i1 %12, label %13, label %15
23151,23154c27543,27547
< ; <label>:34                                      ; preds = %0
<   %35 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 4
<   store i32 -1, i32* %35, align 4
<   br label %36
---
> ; <label>:13                                      ; preds = %10
>   store i32 -1, i32* %res, align 4
>   %14 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %14)
>   br label %18
23156,23158c27549,27560
< ; <label>:36                                      ; preds = %34, %23
<   %.0 = phi i32 [ %res.0, %23 ], [ %t0, %34 ]
<   ret i32 %.0
---
> ; <label>:15                                      ; preds = %10
>   %16 = load i64* %v, align 8
>   %17 = trunc i64 %16 to i32
>   store i32 %17, i32* %res, align 4
>   br label %18
> 
> ; <label>:18                                      ; preds = %15, %13
>   br label %19
> 
> ; <label>:19                                      ; preds = %18, %8
>   %20 = load i32* %res, align 4
>   ret i32 %20
23161,23169c27563,27576
< define i32 @helper_rcrb(i32 %t0, i32 %t1) nounwind uwtable {
<   %1 = and i32 %t1, 31
<   %2 = zext i32 %1 to i64
<   %3 = getelementptr inbounds [32 x i8]* @rclb_table, i64 0, i64 %2
<   %4 = load i8* %3, align 1
<   %5 = zext i8 %4 to i32
<   %6 = icmp eq i8 %4, 0
<   %7 = load %struct.CPUX86State** @env, align 8
<   br i1 %6, label %34, label %8
---
> define internal i32 @float64_to_uint16_round_to_zero(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %v = alloca i64, align 8
>   %res = alloca i32, align 4
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load i64* %1, align 8
>   %4 = load %struct.float_status** %2, align 4
>   %5 = call i64 @float64_to_int64_round_to_zero(i64 %3, %struct.float_status* %4)
>   store i64 %5, i64* %v, align 8
>   %6 = load i64* %v, align 8
>   %7 = icmp slt i64 %6, 0
>   br i1 %7, label %8, label %10
23172,23188c27579,27582
<   %9 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 1
<   %10 = load i32* %9, align 4
<   %11 = tail call i32 @helper_cc_compute_all(i32 %10)
<   %12 = and i32 %t0, 255
<   %13 = lshr i32 %12, %5
<   %14 = and i32 %11, 1
<   %15 = sub nsw i32 8, %5
<   %16 = shl i32 %14, %15
<   %17 = or i32 %16, %13
<   %18 = icmp ugt i8 %4, 1
<   br i1 %18, label %19, label %23
< 
< ; <label>:19                                      ; preds = %8
<   %20 = sub nsw i32 9, %5
<   %21 = shl i32 %12, %20
<   %22 = or i32 %17, %21
<   br label %23
---
>   store i32 0, i32* %res, align 4
>   %9 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %9)
>   br label %19
23190,23203c27584,27587
< ; <label>:23                                      ; preds = %19, %8
<   %res.0 = phi i32 [ %22, %19 ], [ %17, %8 ]
<   %24 = and i32 %11, -2050
<   %25 = xor i32 %res.0, %t0
<   %26 = shl i32 %25, 4
<   %27 = and i32 %26, 2048
<   %28 = add nsw i32 %5, -1
<   %29 = lshr i32 %12, %28
<   %30 = and i32 %29, 1
<   %31 = or i32 %24, %30
<   %32 = or i32 %31, %27
<   %33 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 4
<   store i32 %32, i32* %33, align 4
<   br label %36
---
> ; <label>:10                                      ; preds = %0
>   %11 = load i64* %v, align 8
>   %12 = icmp sgt i64 %11, 65535
>   br i1 %12, label %13, label %15
23205,23208c27589,27593
< ; <label>:34                                      ; preds = %0
<   %35 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 4
<   store i32 -1, i32* %35, align 4
<   br label %36
---
> ; <label>:13                                      ; preds = %10
>   store i32 65535, i32* %res, align 4
>   %14 = load %struct.float_status** %2, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %14)
>   br label %18
23210,23213c27595,27599
< ; <label>:36                                      ; preds = %34, %23
<   %.0 = phi i32 [ %res.0, %23 ], [ %t0, %34 ]
<   ret i32 %.0
< }
---
> ; <label>:15                                      ; preds = %10
>   %16 = load i64* %v, align 8
>   %17 = trunc i64 %16 to i32
>   store i32 %17, i32* %res, align 4
>   br label %18
23215,23223c27601,27602
< define i32 @helper_rclw(i32 %t0, i32 %t1) nounwind uwtable {
<   %1 = and i32 %t1, 31
<   %2 = zext i32 %1 to i64
<   %3 = getelementptr inbounds [32 x i8]* @rclw_table, i64 0, i64 %2
<   %4 = load i8* %3, align 1
<   %5 = zext i8 %4 to i32
<   %6 = icmp eq i8 %4, 0
<   %7 = load %struct.CPUX86State** @env, align 8
<   br i1 %6, label %34, label %8
---
> ; <label>:18                                      ; preds = %15, %13
>   br label %19
23225,23242c27604,27607
< ; <label>:8                                       ; preds = %0
<   %9 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 1
<   %10 = load i32* %9, align 4
<   %11 = tail call i32 @helper_cc_compute_all(i32 %10)
<   %12 = and i32 %t0, 65535
<   %13 = shl i32 %12, %5
<   %14 = and i32 %11, 1
<   %15 = add nsw i32 %5, -1
<   %16 = shl i32 %14, %15
<   %17 = or i32 %16, %13
<   %18 = icmp ugt i8 %4, 1
<   br i1 %18, label %19, label %23
< 
< ; <label>:19                                      ; preds = %8
<   %20 = sub nsw i32 17, %5
<   %21 = lshr i32 %12, %20
<   %22 = or i32 %17, %21
<   br label %23
---
> ; <label>:19                                      ; preds = %18, %8
>   %20 = load i32* %res, align 4
>   ret i32 %20
> }
23244,23257c27609,27629
< ; <label>:23                                      ; preds = %19, %8
<   %res.0 = phi i32 [ %22, %19 ], [ %17, %8 ]
<   %24 = and i32 %11, -2050
<   %25 = xor i32 %res.0, %t0
<   %26 = lshr i32 %25, 4
<   %27 = and i32 %26, 2048
<   %28 = sub nsw i32 16, %5
<   %29 = lshr i32 %12, %28
<   %30 = and i32 %29, 1
<   %31 = or i32 %24, %30
<   %32 = or i32 %31, %27
<   %33 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 4
<   store i32 %32, i32* %33, align 4
<   br label %36
---
> define internal i64 @float64_to_uint64(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %v = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load %struct.float_status** %2, align 4
>   %4 = call i64 @int64_to_float64(i64 -9223372036854775808, %struct.float_status* %3)
>   store i64 %4, i64* %v, align 8
>   %5 = load i64* %1, align 8
>   %6 = load i64* %v, align 8
>   %7 = add i64 %6, %5
>   store i64 %7, i64* %v, align 8
>   %8 = load i64* %v, align 8
>   %9 = load %struct.float_status** %2, align 4
>   %10 = call i64 @float64_to_int64(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %v, align 8
>   %11 = load i64* %v, align 8
>   %12 = sub nsw i64 %11, -9223372036854775808
>   ret i64 %12
> }
23259,23262c27631,27651
< ; <label>:34                                      ; preds = %0
<   %35 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 4
<   store i32 -1, i32* %35, align 4
<   br label %36
---
> define internal i64 @float64_to_uint64_round_to_zero(i64 %a, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca %struct.float_status*, align 4
>   %v = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = load %struct.float_status** %2, align 4
>   %4 = call i64 @int64_to_float64(i64 -9223372036854775808, %struct.float_status* %3)
>   store i64 %4, i64* %v, align 8
>   %5 = load i64* %1, align 8
>   %6 = load i64* %v, align 8
>   %7 = add i64 %6, %5
>   store i64 %7, i64* %v, align 8
>   %8 = load i64* %v, align 8
>   %9 = load %struct.float_status** %2, align 4
>   %10 = call i64 @float64_to_int64_round_to_zero(i64 %8, %struct.float_status* %9)
>   store i64 %10, i64* %v, align 8
>   %11 = load i64* %v, align 8
>   %12 = sub nsw i64 %11, -9223372036854775808
>   ret i64 %12
> }
23264,23266c27653,27664
< ; <label>:36                                      ; preds = %34, %23
<   %.0 = phi i32 [ %res.0, %23 ], [ %t0, %34 ]
<   ret i32 %.0
---
> define internal i32 @float32_compare(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %1, align 4
>   store i32 %b, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %1, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i32 @float32_compare_internal(i32 %4, i32 %5, i32 0, %struct.float_status* %6)
>   ret i32 %7
23269,23277c27667,27692
< define i32 @helper_rcrw(i32 %t0, i32 %t1) nounwind uwtable {
<   %1 = and i32 %t1, 31
<   %2 = zext i32 %1 to i64
<   %3 = getelementptr inbounds [32 x i8]* @rclw_table, i64 0, i64 %2
<   %4 = load i8* %3, align 1
<   %5 = zext i8 %4 to i32
<   %6 = icmp eq i8 %4, 0
<   %7 = load %struct.CPUX86State** @env, align 8
<   br i1 %6, label %34, label %8
---
> define internal i32 @float32_compare_internal(i32 %a, i32 %b, i32 %is_quiet, %struct.float_status* %status) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca i32, align 4
>   %5 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i32, align 4
>   %bv = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store i32 %is_quiet, i32* %4, align 4
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load i32* %2, align 4
>   %7 = load %struct.float_status** %5, align 4
>   %8 = call i32 @float32_squash_input_denormal(i32 %6, %struct.float_status* %7)
>   store i32 %8, i32* %2, align 4
>   %9 = load i32* %3, align 4
>   %10 = load %struct.float_status** %5, align 4
>   %11 = call i32 @float32_squash_input_denormal(i32 %9, %struct.float_status* %10)
>   store i32 %11, i32* %3, align 4
>   %12 = load i32* %2, align 4
>   %13 = call i32 @extractFloat32Exp(i32 %12)
>   %14 = icmp eq i32 %13, 255
>   br i1 %14, label %15, label %19
23279,23296c27694,27710
< ; <label>:8                                       ; preds = %0
<   %9 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 1
<   %10 = load i32* %9, align 4
<   %11 = tail call i32 @helper_cc_compute_all(i32 %10)
<   %12 = and i32 %t0, 65535
<   %13 = lshr i32 %12, %5
<   %14 = and i32 %11, 1
<   %15 = sub nsw i32 16, %5
<   %16 = shl i32 %14, %15
<   %17 = or i32 %16, %13
<   %18 = icmp ugt i8 %4, 1
<   br i1 %18, label %19, label %23
< 
< ; <label>:19                                      ; preds = %8
<   %20 = sub nsw i32 17, %5
<   %21 = shl i32 %12, %20
<   %22 = or i32 %17, %21
<   br label %23
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %2, align 4
>   %17 = call i32 @extractFloat32Frac(i32 %16)
>   %18 = icmp ne i32 %17, 0
>   br i1 %18, label %27, label %19
> 
> ; <label>:19                                      ; preds = %15, %0
>   %20 = load i32* %3, align 4
>   %21 = call i32 @extractFloat32Exp(i32 %20)
>   %22 = icmp eq i32 %21, 255
>   br i1 %22, label %23, label %41
> 
> ; <label>:23                                      ; preds = %19
>   %24 = load i32* %3, align 4
>   %25 = call i32 @extractFloat32Frac(i32 %24)
>   %26 = icmp ne i32 %25, 0
>   br i1 %26, label %27, label %41
23298,23311c27712,27721
< ; <label>:23                                      ; preds = %19, %8
<   %res.0 = phi i32 [ %22, %19 ], [ %17, %8 ]
<   %24 = and i32 %11, -2050
<   %25 = xor i32 %res.0, %t0
<   %26 = lshr i32 %25, 4
<   %27 = and i32 %26, 2048
<   %28 = add nsw i32 %5, -1
<   %29 = lshr i32 %12, %28
<   %30 = and i32 %29, 1
<   %31 = or i32 %24, %30
<   %32 = or i32 %31, %27
<   %33 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 4
<   store i32 %32, i32* %33, align 4
<   br label %36
---
> ; <label>:27                                      ; preds = %23, %15
>   %28 = load i32* %4, align 4
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %30, label %38
> 
> ; <label>:30                                      ; preds = %27
>   %31 = load i32* %2, align 4
>   %32 = call i32 @float32_is_signaling_nan(i32 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %38, label %34
23313,23316c27723,27732
< ; <label>:34                                      ; preds = %0
<   %35 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 4
<   store i32 -1, i32* %35, align 4
<   br label %36
---
> ; <label>:34                                      ; preds = %30
>   %35 = load i32* %3, align 4
>   %36 = call i32 @float32_is_signaling_nan(i32 %35)
>   %37 = icmp ne i32 %36, 0
>   br i1 %37, label %38, label %40
> 
> ; <label>:38                                      ; preds = %34, %30, %27
>   %39 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %39)
>   br label %40
23318,23320c27734,27801
< ; <label>:36                                      ; preds = %34, %23
<   %.0 = phi i32 [ %res.0, %23 ], [ %t0, %34 ]
<   ret i32 %.0
---
> ; <label>:40                                      ; preds = %38, %34
>   store i32 2, i32* %1
>   br label %80
> 
> ; <label>:41                                      ; preds = %23, %19
>   %42 = load i32* %2, align 4
>   %43 = call zeroext i8 @extractFloat32Sign(i32 %42)
>   store i8 %43, i8* %aSign, align 1
>   %44 = load i32* %3, align 4
>   %45 = call zeroext i8 @extractFloat32Sign(i32 %44)
>   store i8 %45, i8* %bSign, align 1
>   %46 = load i32* %2, align 4
>   store i32 %46, i32* %av, align 4
>   %47 = load i32* %3, align 4
>   store i32 %47, i32* %bv, align 4
>   %48 = load i8* %aSign, align 1
>   %49 = zext i8 %48 to i32
>   %50 = load i8* %bSign, align 1
>   %51 = zext i8 %50 to i32
>   %52 = icmp ne i32 %49, %51
>   br i1 %52, label %53, label %65
> 
> ; <label>:53                                      ; preds = %41
>   %54 = load i32* %av, align 4
>   %55 = load i32* %bv, align 4
>   %56 = or i32 %54, %55
>   %57 = shl i32 %56, 1
>   %58 = icmp eq i32 %57, 0
>   br i1 %58, label %59, label %60
> 
> ; <label>:59                                      ; preds = %53
>   store i32 0, i32* %1
>   br label %80
> 
> ; <label>:60                                      ; preds = %53
>   %61 = load i8* %aSign, align 1
>   %62 = zext i8 %61 to i32
>   %63 = mul nsw i32 2, %62
>   %64 = sub nsw i32 1, %63
>   store i32 %64, i32* %1
>   br label %80
> 
> ; <label>:65                                      ; preds = %41
>   %66 = load i32* %av, align 4
>   %67 = load i32* %bv, align 4
>   %68 = icmp eq i32 %66, %67
>   br i1 %68, label %69, label %70
> 
> ; <label>:69                                      ; preds = %65
>   store i32 0, i32* %1
>   br label %80
> 
> ; <label>:70                                      ; preds = %65
>   %71 = load i8* %aSign, align 1
>   %72 = zext i8 %71 to i32
>   %73 = load i32* %av, align 4
>   %74 = load i32* %bv, align 4
>   %75 = icmp ult i32 %73, %74
>   %76 = zext i1 %75 to i32
>   %77 = xor i32 %72, %76
>   %78 = mul nsw i32 2, %77
>   %79 = sub nsw i32 1, %78
>   store i32 %79, i32* %1
>   br label %80
> 
> ; <label>:80                                      ; preds = %70, %69, %60, %59, %40
>   %81 = load i32* %1
>   ret i32 %81
23323,23327c27804,27816
< define i32 @helper_rcll(i32 %t0, i32 %t1) nounwind uwtable {
<   %1 = and i32 %t1, 31
<   %2 = icmp eq i32 %1, 0
<   %3 = load %struct.CPUX86State** @env, align 8
<   br i1 %2, label %29, label %4
---
> define internal i32 @float32_compare_quiet(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %1, align 4
>   store i32 %b, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %1, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i32 @float32_compare_internal(i32 %4, i32 %5, i32 1, %struct.float_status* %6)
>   ret i32 %7
> }
23329,23339c27818,27830
< ; <label>:4                                       ; preds = %0
<   %5 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 1
<   %6 = load i32* %5, align 4
<   %7 = tail call i32 @helper_cc_compute_all(i32 %6)
<   %8 = shl i32 %t0, %1
<   %9 = and i32 %7, 1
<   %10 = add nsw i32 %1, -1
<   %11 = shl i32 %9, %10
<   %12 = or i32 %11, %8
<   %13 = icmp ugt i32 %1, 1
<   br i1 %13, label %14, label %18
---
> define internal i32 @float64_compare(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   store i64 %a, i64* %1, align 8
>   store i64 %b, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %1, align 8
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i32 @float64_compare_internal(i64 %4, i64 %5, i32 0, %struct.float_status* %6)
>   ret i32 %7
> }
23341,23345c27832,27857
< ; <label>:14                                      ; preds = %4
<   %15 = sub nsw i32 33, %1
<   %16 = lshr i32 %t0, %15
<   %17 = or i32 %12, %16
<   br label %18
---
> define internal i32 @float64_compare_internal(i64 %a, i64 %b, i32 %is_quiet, %struct.float_status* %status) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i32, align 4
>   %5 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i64, align 8
>   %bv = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store i32 %is_quiet, i32* %4, align 4
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load i64* %2, align 8
>   %7 = load %struct.float_status** %5, align 4
>   %8 = call i64 @float64_squash_input_denormal(i64 %6, %struct.float_status* %7)
>   store i64 %8, i64* %2, align 8
>   %9 = load i64* %3, align 8
>   %10 = load %struct.float_status** %5, align 4
>   %11 = call i64 @float64_squash_input_denormal(i64 %9, %struct.float_status* %10)
>   store i64 %11, i64* %3, align 8
>   %12 = load i64* %2, align 8
>   %13 = call i32 @extractFloat64Exp(i64 %12)
>   %14 = icmp eq i32 %13, 2047
>   br i1 %14, label %15, label %19
23347,23360c27859,27875
< ; <label>:18                                      ; preds = %14, %4
<   %res.0 = phi i32 [ %17, %14 ], [ %12, %4 ]
<   %19 = and i32 %7, -2050
<   %20 = xor i32 %res.0, %t0
<   %21 = lshr i32 %20, 20
<   %22 = and i32 %21, 2048
<   %23 = sub nsw i32 32, %1
<   %24 = lshr i32 %t0, %23
<   %25 = and i32 %24, 1
<   %26 = or i32 %19, %25
<   %27 = or i32 %26, %22
<   %28 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 4
<   store i32 %27, i32* %28, align 4
<   br label %31
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i64* %2, align 8
>   %17 = call i64 @extractFloat64Frac(i64 %16)
>   %18 = icmp ne i64 %17, 0
>   br i1 %18, label %27, label %19
> 
> ; <label>:19                                      ; preds = %15, %0
>   %20 = load i64* %3, align 8
>   %21 = call i32 @extractFloat64Exp(i64 %20)
>   %22 = icmp eq i32 %21, 2047
>   br i1 %22, label %23, label %41
> 
> ; <label>:23                                      ; preds = %19
>   %24 = load i64* %3, align 8
>   %25 = call i64 @extractFloat64Frac(i64 %24)
>   %26 = icmp ne i64 %25, 0
>   br i1 %26, label %27, label %41
23362,23365c27877,27886
< ; <label>:29                                      ; preds = %0
<   %30 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 4
<   store i32 -1, i32* %30, align 4
<   br label %31
---
> ; <label>:27                                      ; preds = %23, %15
>   %28 = load i32* %4, align 4
>   %29 = icmp ne i32 %28, 0
>   br i1 %29, label %30, label %38
> 
> ; <label>:30                                      ; preds = %27
>   %31 = load i64* %2, align 8
>   %32 = call i32 @float64_is_signaling_nan(i64 %31)
>   %33 = icmp ne i32 %32, 0
>   br i1 %33, label %38, label %34
23367,23369c27888,27966
< ; <label>:31                                      ; preds = %29, %18
<   %.0 = phi i32 [ %res.0, %18 ], [ %t0, %29 ]
<   ret i32 %.0
---
> ; <label>:34                                      ; preds = %30
>   %35 = load i64* %3, align 8
>   %36 = call i32 @float64_is_signaling_nan(i64 %35)
>   %37 = icmp ne i32 %36, 0
>   br i1 %37, label %38, label %40
> 
> ; <label>:38                                      ; preds = %34, %30, %27
>   %39 = load %struct.float_status** %5, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %39)
>   br label %40
> 
> ; <label>:40                                      ; preds = %38, %34
>   store i32 2, i32* %1
>   br label %80
> 
> ; <label>:41                                      ; preds = %23, %19
>   %42 = load i64* %2, align 8
>   %43 = call zeroext i8 @extractFloat64Sign(i64 %42)
>   store i8 %43, i8* %aSign, align 1
>   %44 = load i64* %3, align 8
>   %45 = call zeroext i8 @extractFloat64Sign(i64 %44)
>   store i8 %45, i8* %bSign, align 1
>   %46 = load i64* %2, align 8
>   store i64 %46, i64* %av, align 8
>   %47 = load i64* %3, align 8
>   store i64 %47, i64* %bv, align 8
>   %48 = load i8* %aSign, align 1
>   %49 = zext i8 %48 to i32
>   %50 = load i8* %bSign, align 1
>   %51 = zext i8 %50 to i32
>   %52 = icmp ne i32 %49, %51
>   br i1 %52, label %53, label %65
> 
> ; <label>:53                                      ; preds = %41
>   %54 = load i64* %av, align 8
>   %55 = load i64* %bv, align 8
>   %56 = or i64 %54, %55
>   %57 = shl i64 %56, 1
>   %58 = icmp eq i64 %57, 0
>   br i1 %58, label %59, label %60
> 
> ; <label>:59                                      ; preds = %53
>   store i32 0, i32* %1
>   br label %80
> 
> ; <label>:60                                      ; preds = %53
>   %61 = load i8* %aSign, align 1
>   %62 = zext i8 %61 to i32
>   %63 = mul nsw i32 2, %62
>   %64 = sub nsw i32 1, %63
>   store i32 %64, i32* %1
>   br label %80
> 
> ; <label>:65                                      ; preds = %41
>   %66 = load i64* %av, align 8
>   %67 = load i64* %bv, align 8
>   %68 = icmp eq i64 %66, %67
>   br i1 %68, label %69, label %70
> 
> ; <label>:69                                      ; preds = %65
>   store i32 0, i32* %1
>   br label %80
> 
> ; <label>:70                                      ; preds = %65
>   %71 = load i8* %aSign, align 1
>   %72 = zext i8 %71 to i32
>   %73 = load i64* %av, align 8
>   %74 = load i64* %bv, align 8
>   %75 = icmp ult i64 %73, %74
>   %76 = zext i1 %75 to i32
>   %77 = xor i32 %72, %76
>   %78 = mul nsw i32 2, %77
>   %79 = sub nsw i32 1, %78
>   store i32 %79, i32* %1
>   br label %80
> 
> ; <label>:80                                      ; preds = %70, %69, %60, %59, %40
>   %81 = load i32* %1
>   ret i32 %81
23372,23376c27969,27981
< define i32 @helper_rcrl(i32 %t0, i32 %t1) nounwind uwtable {
<   %1 = and i32 %t1, 31
<   %2 = icmp eq i32 %1, 0
<   %3 = load %struct.CPUX86State** @env, align 8
<   br i1 %2, label %29, label %4
---
> define internal i32 @float64_compare_quiet(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   store i64 %a, i64* %1, align 8
>   store i64 %b, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %1, align 8
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i32 @float64_compare_internal(i64 %4, i64 %5, i32 1, %struct.float_status* %6)
>   ret i32 %7
> }
23378,23388c27983,27989
< ; <label>:4                                       ; preds = %0
<   %5 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 1
<   %6 = load i32* %5, align 4
<   %7 = tail call i32 @helper_cc_compute_all(i32 %6)
<   %8 = lshr i32 %t0, %1
<   %9 = and i32 %7, 1
<   %10 = sub nsw i32 32, %1
<   %11 = shl i32 %9, %10
<   %12 = or i32 %11, %8
<   %13 = icmp ugt i32 %1, 1
<   br i1 %13, label %14, label %18
---
> define internal i32 @floatx80_compare(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = load %struct.float_status** %1, align 4
>   %3 = call i32 @floatx80_compare_internal(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, i32 0, %struct.float_status* %2)
>   ret i32 %3
> }
23390,23394c27991,28001
< ; <label>:14                                      ; preds = %4
<   %15 = sub nsw i32 33, %1
<   %16 = shl i32 %t0, %15
<   %17 = or i32 %12, %16
<   br label %18
---
> define internal i32 @floatx80_compare_internal(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, i32 %is_quiet, %struct.float_status* %status) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   store i32 %is_quiet, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   %5 = icmp eq i32 %4, 32767
>   br i1 %5, label %6, label %10
23396,23409c28003,28012
< ; <label>:18                                      ; preds = %14, %4
<   %res.0 = phi i32 [ %17, %14 ], [ %12, %4 ]
<   %19 = and i32 %7, -2050
<   %20 = xor i32 %res.0, %t0
<   %21 = lshr i32 %20, 20
<   %22 = and i32 %21, 2048
<   %23 = add nsw i32 %1, -1
<   %24 = lshr i32 %t0, %23
<   %25 = and i32 %24, 1
<   %26 = or i32 %19, %25
<   %27 = or i32 %26, %22
<   %28 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 4
<   store i32 %27, i32* %28, align 4
<   br label %31
---
> ; <label>:6                                       ; preds = %0
>   %7 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   %8 = shl i64 %7, 1
>   %9 = icmp ne i64 %8, 0
>   br i1 %9, label %17, label %10
> 
> ; <label>:10                                      ; preds = %6, %0
>   %11 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %b)
>   %12 = icmp eq i32 %11, 32767
>   br i1 %12, label %13, label %29
23411,23414c28014,28023
< ; <label>:29                                      ; preds = %0
<   %30 = getelementptr inbounds %struct.CPUX86State* %3, i64 0, i32 4
<   store i32 -1, i32* %30, align 4
<   br label %31
---
> ; <label>:13                                      ; preds = %10
>   %14 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %b)
>   %15 = shl i64 %14, 1
>   %16 = icmp ne i64 %15, 0
>   br i1 %16, label %17, label %29
> 
> ; <label>:17                                      ; preds = %13, %6
>   %18 = load i32* %2, align 4
>   %19 = icmp ne i32 %18, 0
>   br i1 %19, label %20, label %26
23416,23419c28025,28028
< ; <label>:31                                      ; preds = %29, %18
<   %.0 = phi i32 [ %res.0, %18 ], [ %t0, %29 ]
<   ret i32 %.0
< }
---
> ; <label>:20                                      ; preds = %17
>   %21 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %a)
>   %22 = icmp ne i32 %21, 0
>   br i1 %22, label %26, label %23
23421,23424c28030,28038
< define i32 @helper_bsf(i32 %t0) nounwind uwtable readnone {
<   %1 = and i32 %t0, 1
<   %2 = icmp eq i32 %1, 0
<   br i1 %2, label %.lr.ph, label %._crit_edge
---
> ; <label>:23                                      ; preds = %20
>   %24 = call i32 @floatx80_is_signaling_nan(%struct.floatx80* byval align 4 %b)
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %28
> 
> ; <label>:26                                      ; preds = %23, %20, %17
>   %27 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %27)
>   br label %28
23426,23433c28040,28054
< .lr.ph:                                           ; preds = %.lr.ph, %0
<   %res.03 = phi i32 [ %4, %.lr.ph ], [ %t0, %0 ]
<   %count.02 = phi i32 [ %3, %.lr.ph ], [ 0, %0 ]
<   %3 = add nsw i32 %count.02, 1
<   %4 = lshr i32 %res.03, 1
<   %5 = and i32 %4, 1
<   %6 = icmp eq i32 %5, 0
<   br i1 %6, label %.lr.ph, label %._crit_edge
---
> ; <label>:28                                      ; preds = %26, %23
>   store i32 2, i32* %1
>   br label %95
> 
> ; <label>:29                                      ; preds = %13, %10
>   %30 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %30, i8* %aSign, align 1
>   %31 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %b)
>   store i8 %31, i8* %bSign, align 1
>   %32 = load i8* %aSign, align 1
>   %33 = zext i8 %32 to i32
>   %34 = load i8* %bSign, align 1
>   %35 = zext i8 %34 to i32
>   %36 = icmp ne i32 %33, %35
>   br i1 %36, label %37, label %62
23435,23437c28056,28170
< ._crit_edge:                                      ; preds = %.lr.ph, %0
<   %count.0.lcssa = phi i32 [ 0, %0 ], [ %3, %.lr.ph ]
<   ret i32 %count.0.lcssa
---
> ; <label>:37                                      ; preds = %29
>   %38 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %39 = load i16* %38, align 1
>   %40 = zext i16 %39 to i32
>   %41 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %42 = load i16* %41, align 1
>   %43 = zext i16 %42 to i32
>   %44 = or i32 %40, %43
>   %45 = shl i32 %44, 1
>   %46 = trunc i32 %45 to i16
>   %47 = zext i16 %46 to i32
>   %48 = icmp eq i32 %47, 0
>   br i1 %48, label %49, label %57
> 
> ; <label>:49                                      ; preds = %37
>   %50 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %51 = load i64* %50, align 1
>   %52 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %53 = load i64* %52, align 1
>   %54 = or i64 %51, %53
>   %55 = icmp eq i64 %54, 0
>   br i1 %55, label %56, label %57
> 
> ; <label>:56                                      ; preds = %49
>   store i32 0, i32* %1
>   br label %95
> 
> ; <label>:57                                      ; preds = %49, %37
>   %58 = load i8* %aSign, align 1
>   %59 = zext i8 %58 to i32
>   %60 = mul nsw i32 2, %59
>   %61 = sub nsw i32 1, %60
>   store i32 %61, i32* %1
>   br label %95
> 
> ; <label>:62                                      ; preds = %29
>   %63 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %64 = load i64* %63, align 1
>   %65 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %66 = load i64* %65, align 1
>   %67 = icmp eq i64 %64, %66
>   br i1 %67, label %68, label %77
> 
> ; <label>:68                                      ; preds = %62
>   %69 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %70 = load i16* %69, align 1
>   %71 = zext i16 %70 to i32
>   %72 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %73 = load i16* %72, align 1
>   %74 = zext i16 %73 to i32
>   %75 = icmp eq i32 %71, %74
>   br i1 %75, label %76, label %77
> 
> ; <label>:76                                      ; preds = %68
>   store i32 0, i32* %1
>   br label %95
> 
> ; <label>:77                                      ; preds = %68, %62
>   %78 = load i8* %aSign, align 1
>   %79 = zext i8 %78 to i32
>   %80 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 1
>   %81 = load i16* %80, align 1
>   %82 = zext i16 %81 to i64
>   %83 = getelementptr inbounds %struct.floatx80* %a, i32 0, i32 0
>   %84 = load i64* %83, align 1
>   %85 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 1
>   %86 = load i16* %85, align 1
>   %87 = zext i16 %86 to i64
>   %88 = getelementptr inbounds %struct.floatx80* %b, i32 0, i32 0
>   %89 = load i64* %88, align 1
>   %90 = call zeroext i8 @lt128(i64 %82, i64 %84, i64 %87, i64 %89)
>   %91 = zext i8 %90 to i32
>   %92 = xor i32 %79, %91
>   %93 = mul nsw i32 2, %92
>   %94 = sub nsw i32 1, %93
>   store i32 %94, i32* %1
>   br label %95
> 
> ; <label>:95                                      ; preds = %77, %76, %57, %56, %28
>   %96 = load i32* %1
>   ret i32 %96
> }
> 
> define internal i32 @floatx80_compare_quiet(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca %struct.float_status*, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %2 = load %struct.float_status** %1, align 4
>   %3 = call i32 @floatx80_compare_internal(%struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %b, i32 1, %struct.float_status* %2)
>   ret i32 %3
> }
> 
> define internal i32 @float128_compare(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %6 = load %struct.float_status** %1, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %12 = load i64* %11, align 4
>   %13 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = call i32 @float128_compare_internal(i64 %8, i64 %10, i64 %12, i64 %14, i32 0, %struct.float_status* %6)
>   ret i32 %15
23440,23465c28173,28197
< define i32 @helper_lzcnt(i32 %t0, i32 %wordsize) nounwind uwtable readnone {
<   %1 = icmp sgt i32 %wordsize, 0
<   %2 = icmp eq i32 %t0, 0
<   %or.cond = and i1 %1, %2
<   br i1 %or.cond, label %10, label %.preheader
< 
< .preheader:                                       ; preds = %0
<   %3 = icmp sgt i32 %t0, -1
<   br i1 %3, label %.lr.ph, label %._crit_edge
< 
< .lr.ph:                                           ; preds = %.lr.ph, %.preheader
<   %res.011 = phi i32 [ %5, %.lr.ph ], [ %t0, %.preheader ]
<   %count.010 = phi i32 [ %4, %.lr.ph ], [ 31, %.preheader ]
<   %4 = add nsw i32 %count.010, -1
<   %5 = shl i32 %res.011, 1
<   %6 = icmp sgt i32 %5, -1
<   br i1 %6, label %.lr.ph, label %._crit_edge
< 
< ._crit_edge:                                      ; preds = %.lr.ph, %.preheader
<   %count.0.lcssa = phi i32 [ 31, %.preheader ], [ %4, %.lr.ph ]
<   br i1 %1, label %7, label %10
< 
< ; <label>:7                                       ; preds = %._crit_edge
<   %8 = add nsw i32 %wordsize, -1
<   %9 = sub i32 %8, %count.0.lcssa
<   br label %10
---
> define internal i32 @float128_compare_internal(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, i32 %is_quiet, %struct.float_status* %status) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %5, align 4
>   %6 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %6, align 4
>   %7 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %7, align 4
>   store i32 %is_quiet, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %8 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %9 = load i64* %8, align 4
>   %10 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %11 = load i64* %10, align 4
>   %12 = call i32 @extractFloat128Exp(i64 %9, i64 %11)
>   %13 = icmp eq i32 %12, 32767
>   br i1 %13, label %14, label %27
23467,23470c28199,28236
< ; <label>:10                                      ; preds = %7, %._crit_edge, %0
<   %.0 = phi i32 [ %9, %7 ], [ %wordsize, %0 ], [ %count.0.lcssa, %._crit_edge ]
<   ret i32 %.0
< }
---
> ; <label>:14                                      ; preds = %0
>   %15 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %16 = load i64* %15, align 4
>   %17 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %18 = load i64* %17, align 4
>   %19 = call i64 @extractFloat128Frac0(i64 %16, i64 %18)
>   %20 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %21 = load i64* %20, align 4
>   %22 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %23 = load i64* %22, align 4
>   %24 = call i64 @extractFloat128Frac1(i64 %21, i64 %23)
>   %25 = or i64 %19, %24
>   %26 = icmp ne i64 %25, 0
>   br i1 %26, label %47, label %27
> 
> ; <label>:27                                      ; preds = %14, %0
>   %28 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %29 = load i64* %28, align 4
>   %30 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %31 = load i64* %30, align 4
>   %32 = call i32 @extractFloat128Exp(i64 %29, i64 %31)
>   %33 = icmp eq i32 %32, 32767
>   br i1 %33, label %34, label %67
> 
> ; <label>:34                                      ; preds = %27
>   %35 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %36 = load i64* %35, align 4
>   %37 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %38 = load i64* %37, align 4
>   %39 = call i64 @extractFloat128Frac0(i64 %36, i64 %38)
>   %40 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %41 = load i64* %40, align 4
>   %42 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %43 = load i64* %42, align 4
>   %44 = call i64 @extractFloat128Frac1(i64 %41, i64 %43)
>   %45 = or i64 %39, %44
>   %46 = icmp ne i64 %45, 0
>   br i1 %46, label %47, label %67
23472,23486c28238,28385
< define i32 @helper_bsr(i32 %t0) nounwind uwtable readnone {
<   %1 = icmp sgt i32 %t0, -1
<   br i1 %1, label %.lr.ph.i, label %helper_lzcnt.exit
< 
< .lr.ph.i:                                         ; preds = %.lr.ph.i, %0
<   %res.011.i = phi i32 [ %3, %.lr.ph.i ], [ %t0, %0 ]
<   %count.010.i = phi i32 [ %2, %.lr.ph.i ], [ 31, %0 ]
<   %2 = add nsw i32 %count.010.i, -1
<   %3 = shl i32 %res.011.i, 1
<   %4 = icmp sgt i32 %3, -1
<   br i1 %4, label %.lr.ph.i, label %helper_lzcnt.exit
< 
< helper_lzcnt.exit:                                ; preds = %.lr.ph.i, %0
<   %count.0.lcssa.i = phi i32 [ 31, %0 ], [ %2, %.lr.ph.i ]
<   ret i32 %count.0.lcssa.i
---
> ; <label>:47                                      ; preds = %34, %14
>   %48 = load i32* %2, align 4
>   %49 = icmp ne i32 %48, 0
>   br i1 %49, label %50, label %64
> 
> ; <label>:50                                      ; preds = %47
>   %51 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %52 = load i64* %51, align 4
>   %53 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %54 = load i64* %53, align 4
>   %55 = call i32 @float128_is_signaling_nan(i64 %52, i64 %54)
>   %56 = icmp ne i32 %55, 0
>   br i1 %56, label %64, label %57
> 
> ; <label>:57                                      ; preds = %50
>   %58 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %59 = load i64* %58, align 4
>   %60 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %61 = load i64* %60, align 4
>   %62 = call i32 @float128_is_signaling_nan(i64 %59, i64 %61)
>   %63 = icmp ne i32 %62, 0
>   br i1 %63, label %64, label %66
> 
> ; <label>:64                                      ; preds = %57, %50, %47
>   %65 = load %struct.float_status** %3, align 4
>   call void @float_raise(i8 signext 1, %struct.float_status* %65)
>   br label %66
> 
> ; <label>:66                                      ; preds = %64, %57
>   store i32 2, i32* %1
>   br label %132
> 
> ; <label>:67                                      ; preds = %34, %27
>   %68 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %69 = load i64* %68, align 4
>   %70 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %71 = load i64* %70, align 4
>   %72 = call zeroext i8 @extractFloat128Sign(i64 %69, i64 %71)
>   store i8 %72, i8* %aSign, align 1
>   %73 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %74 = load i64* %73, align 4
>   %75 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %76 = load i64* %75, align 4
>   %77 = call zeroext i8 @extractFloat128Sign(i64 %74, i64 %76)
>   store i8 %77, i8* %bSign, align 1
>   %78 = load i8* %aSign, align 1
>   %79 = zext i8 %78 to i32
>   %80 = load i8* %bSign, align 1
>   %81 = zext i8 %80 to i32
>   %82 = icmp ne i32 %79, %81
>   br i1 %82, label %83, label %103
> 
> ; <label>:83                                      ; preds = %67
>   %84 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %85 = load i64* %84, align 4
>   %86 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %87 = load i64* %86, align 4
>   %88 = or i64 %85, %87
>   %89 = shl i64 %88, 1
>   %90 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %91 = load i64* %90, align 4
>   %92 = or i64 %89, %91
>   %93 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %94 = load i64* %93, align 4
>   %95 = or i64 %92, %94
>   %96 = icmp eq i64 %95, 0
>   br i1 %96, label %97, label %98
> 
> ; <label>:97                                      ; preds = %83
>   store i32 0, i32* %1
>   br label %132
> 
> ; <label>:98                                      ; preds = %83
>   %99 = load i8* %aSign, align 1
>   %100 = zext i8 %99 to i32
>   %101 = mul nsw i32 2, %100
>   %102 = sub nsw i32 1, %101
>   store i32 %102, i32* %1
>   br label %132
> 
> ; <label>:103                                     ; preds = %67
>   %104 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %105 = load i64* %104, align 4
>   %106 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %107 = load i64* %106, align 4
>   %108 = icmp eq i64 %105, %107
>   br i1 %108, label %109, label %116
> 
> ; <label>:109                                     ; preds = %103
>   %110 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %111 = load i64* %110, align 4
>   %112 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %113 = load i64* %112, align 4
>   %114 = icmp eq i64 %111, %113
>   br i1 %114, label %115, label %116
> 
> ; <label>:115                                     ; preds = %109
>   store i32 0, i32* %1
>   br label %132
> 
> ; <label>:116                                     ; preds = %109, %103
>   %117 = load i8* %aSign, align 1
>   %118 = zext i8 %117 to i32
>   %119 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %120 = load i64* %119, align 4
>   %121 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %122 = load i64* %121, align 4
>   %123 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %124 = load i64* %123, align 4
>   %125 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %126 = load i64* %125, align 4
>   %127 = call zeroext i8 @lt128(i64 %120, i64 %122, i64 %124, i64 %126)
>   %128 = zext i8 %127 to i32
>   %129 = xor i32 %118, %128
>   %130 = mul nsw i32 2, %129
>   %131 = sub nsw i32 1, %130
>   store i32 %131, i32* %1
>   br label %132
> 
> ; <label>:132                                     ; preds = %116, %115, %98, %97, %66
>   %133 = load i32* %1
>   ret i32 %133
> }
> 
> define internal i32 @float128_compare_quiet(i64 %a.0, i64 %a.1, i64 %b.0, i64 %b.1, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %b = alloca %struct.float128, align 4
>   %1 = alloca %struct.float_status*, align 4
>   %2 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %2, align 4
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   store i64 %b.0, i64* %4, align 4
>   %5 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   store i64 %b.1, i64* %5, align 4
>   store %struct.float_status* %status, %struct.float_status** %1, align 4
>   %6 = load %struct.float_status** %1, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %8 = load i64* %7, align 4
>   %9 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %10 = load i64* %9, align 4
>   %11 = getelementptr inbounds %struct.float128* %b, i32 0, i32 0
>   %12 = load i64* %11, align 4
>   %13 = getelementptr inbounds %struct.float128* %b, i32 0, i32 1
>   %14 = load i64* %13, align 4
>   %15 = call i32 @float128_compare_internal(i64 %8, i64 %10, i64 %12, i64 %14, i32 1, %struct.float_status* %6)
>   ret i32 %15
23489,23494c28388,28399
< define i32 @cpu_cc_compute_all(%struct.CPUX86State* %env1, i32 %op) nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   store %struct.CPUX86State* %env1, %struct.CPUX86State** @env, align 8
<   %2 = tail call i32 @helper_cc_compute_all(i32 %op)
<   store %struct.CPUX86State* %1, %struct.CPUX86State** @env, align 8
<   ret i32 %2
---
> define internal i32 @float32_min(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %1, align 4
>   store i32 %b, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %1, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i32 @float32_minmax(i32 %4, i32 %5, i32 1, %struct.float_status* %6)
>   ret i32 %7
23497,23527c28402,28427
< define i32 @helper_cc_compute_c(i32 %op) nounwind uwtable readonly {
<   switch i32 %op, label %201 [
<     i32 1, label %1
<     i32 2, label %6
<     i32 3, label %12
<     i32 4, label %18
<     i32 6, label %24
<     i32 7, label %34
<     i32 8, label %44
<     i32 10, label %52
<     i32 11, label %62
<     i32 12, label %72
<     i32 14, label %80
<     i32 15, label %91
<     i32 16, label %102
<     i32 18, label %111
<     i32 19, label %123
<     i32 20, label %135
<     i32 40, label %196
<     i32 39, label %191
<     i32 38, label %186
<     i32 26, label %145
<     i32 27, label %149
<     i32 28, label %153
<     i32 30, label %157
<     i32 31, label %161
<     i32 32, label %165
<     i32 34, label %169
<     i32 35, label %175
<     i32 36, label %181
<   ]
---
> define internal i32 @float32_minmax(i32 %a, i32 %b, i32 %ismin, %struct.float_status* %status) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca i32, align 4
>   %5 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i32, align 4
>   %bv = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %b, i32* %3, align 4
>   store i32 %ismin, i32* %4, align 4
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load i32* %2, align 4
>   %7 = load %struct.float_status** %5, align 4
>   %8 = call i32 @float32_squash_input_denormal(i32 %6, %struct.float_status* %7)
>   store i32 %8, i32* %2, align 4
>   %9 = load i32* %3, align 4
>   %10 = load %struct.float_status** %5, align 4
>   %11 = call i32 @float32_squash_input_denormal(i32 %9, %struct.float_status* %10)
>   store i32 %11, i32* %3, align 4
>   %12 = load i32* %2, align 4
>   %13 = call i32 @float32_is_any_nan(i32 %12)
>   %14 = icmp ne i32 %13, 0
>   br i1 %14, label %19, label %15
23529,23534c28429,28441
< ; <label>:1                                       ; preds = %0
<   %2 = load %struct.CPUX86State** @env, align 8
<   %3 = getelementptr inbounds %struct.CPUX86State* %2, i64 0, i32 2
<   %4 = load i32* %3, align 4
<   %5 = and i32 %4, 1
<   br label %201
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i32* %3, align 4
>   %17 = call i32 @float32_is_any_nan(i32 %16)
>   %18 = icmp ne i32 %17, 0
>   br i1 %18, label %19, label %24
> 
> ; <label>:19                                      ; preds = %15, %0
>   %20 = load i32* %2, align 4
>   %21 = load i32* %3, align 4
>   %22 = load %struct.float_status** %5, align 4
>   %23 = call i32 @propagateFloat32NaN(i32 %20, i32 %21, %struct.float_status* %22)
>   store i32 %23, i32* %1
>   br label %92
23536,23542c28443,28464
< ; <label>:6                                       ; preds = %0
<   %7 = load %struct.CPUX86State** @env, align 8
<   %8 = getelementptr inbounds %struct.CPUX86State* %7, i64 0, i32 2
<   %9 = load i32* %8, align 4
<   %10 = icmp ne i32 %9, 0
<   %11 = zext i1 %10 to i32
<   br label %201
---
> ; <label>:24                                      ; preds = %15
>   %25 = load i32* %2, align 4
>   %26 = call zeroext i8 @extractFloat32Sign(i32 %25)
>   store i8 %26, i8* %aSign, align 1
>   %27 = load i32* %3, align 4
>   %28 = call zeroext i8 @extractFloat32Sign(i32 %27)
>   store i8 %28, i8* %bSign, align 1
>   %29 = load i32* %2, align 4
>   store i32 %29, i32* %av, align 4
>   %30 = load i32* %3, align 4
>   store i32 %30, i32* %bv, align 4
>   %31 = load i8* %aSign, align 1
>   %32 = zext i8 %31 to i32
>   %33 = load i8* %bSign, align 1
>   %34 = zext i8 %33 to i32
>   %35 = icmp ne i32 %32, %34
>   br i1 %35, label %36, label %59
> 
> ; <label>:36                                      ; preds = %24
>   %37 = load i32* %4, align 4
>   %38 = icmp ne i32 %37, 0
>   br i1 %38, label %39, label %49
23544,23550c28466,28470
< ; <label>:12                                      ; preds = %0
<   %13 = load %struct.CPUX86State** @env, align 8
<   %14 = getelementptr inbounds %struct.CPUX86State* %13, i64 0, i32 2
<   %15 = load i32* %14, align 4
<   %16 = icmp ne i32 %15, 0
<   %17 = zext i1 %16 to i32
<   br label %201
---
> ; <label>:39                                      ; preds = %36
>   %40 = load i8* %aSign, align 1
>   %41 = zext i8 %40 to i32
>   %42 = icmp ne i32 %41, 0
>   br i1 %42, label %43, label %45
23552,23558c28472,28474
< ; <label>:18                                      ; preds = %0
<   %19 = load %struct.CPUX86State** @env, align 8
<   %20 = getelementptr inbounds %struct.CPUX86State* %19, i64 0, i32 2
<   %21 = load i32* %20, align 4
<   %22 = icmp ne i32 %21, 0
<   %23 = zext i1 %22 to i32
<   br label %201
---
> ; <label>:43                                      ; preds = %39
>   %44 = load i32* %2, align 4
>   br label %47
23560,23570c28476,28478
< ; <label>:24                                      ; preds = %0
<   %25 = load %struct.CPUX86State** @env, align 8
<   %26 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 2
<   %27 = load i32* %26, align 4
<   %28 = getelementptr inbounds %struct.CPUX86State* %25, i64 0, i32 3
<   %29 = load i32* %28, align 4
<   %30 = and i32 %29, 255
<   %31 = and i32 %27, 255
<   %32 = icmp ult i32 %30, %31
<   %33 = zext i1 %32 to i32
<   br label %201
---
> ; <label>:45                                      ; preds = %39
>   %46 = load i32* %3, align 4
>   br label %47
23572,23582c28480,28489
< ; <label>:34                                      ; preds = %0
<   %35 = load %struct.CPUX86State** @env, align 8
<   %36 = getelementptr inbounds %struct.CPUX86State* %35, i64 0, i32 2
<   %37 = load i32* %36, align 4
<   %38 = getelementptr inbounds %struct.CPUX86State* %35, i64 0, i32 3
<   %39 = load i32* %38, align 4
<   %40 = and i32 %39, 65535
<   %41 = and i32 %37, 65535
<   %42 = icmp ult i32 %40, %41
<   %43 = zext i1 %42 to i32
<   br label %201
---
> ; <label>:47                                      ; preds = %45, %43
>   %48 = phi i32 [ %44, %43 ], [ %46, %45 ]
>   store i32 %48, i32* %1
>   br label %92
> 
> ; <label>:49                                      ; preds = %36
>   %50 = load i8* %aSign, align 1
>   %51 = zext i8 %50 to i32
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %53, label %55
23584,23592c28491,28493
< ; <label>:44                                      ; preds = %0
<   %45 = load %struct.CPUX86State** @env, align 8
<   %46 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 2
<   %47 = load i32* %46, align 4
<   %48 = getelementptr inbounds %struct.CPUX86State* %45, i64 0, i32 3
<   %49 = load i32* %48, align 4
<   %50 = icmp ult i32 %49, %47
<   %51 = zext i1 %50 to i32
<   br label %201
---
> ; <label>:53                                      ; preds = %49
>   %54 = load i32* %3, align 4
>   br label %57
23594,23604c28495,28497
< ; <label>:52                                      ; preds = %0
<   %53 = load %struct.CPUX86State** @env, align 8
<   %54 = getelementptr inbounds %struct.CPUX86State* %53, i64 0, i32 2
<   %55 = load i32* %54, align 4
<   %56 = getelementptr inbounds %struct.CPUX86State* %53, i64 0, i32 3
<   %57 = load i32* %56, align 4
<   %58 = and i32 %57, 255
<   %59 = and i32 %55, 255
<   %60 = icmp ule i32 %58, %59
<   %61 = zext i1 %60 to i32
<   br label %201
---
> ; <label>:55                                      ; preds = %49
>   %56 = load i32* %2, align 4
>   br label %57
23606,23616c28499,28502
< ; <label>:62                                      ; preds = %0
<   %63 = load %struct.CPUX86State** @env, align 8
<   %64 = getelementptr inbounds %struct.CPUX86State* %63, i64 0, i32 2
<   %65 = load i32* %64, align 4
<   %66 = getelementptr inbounds %struct.CPUX86State* %63, i64 0, i32 3
<   %67 = load i32* %66, align 4
<   %68 = and i32 %67, 65535
<   %69 = and i32 %65, 65535
<   %70 = icmp ule i32 %68, %69
<   %71 = zext i1 %70 to i32
<   br label %201
---
> ; <label>:57                                      ; preds = %55, %53
>   %58 = phi i32 [ %54, %53 ], [ %56, %55 ]
>   store i32 %58, i32* %1
>   br label %92
23618,23626c28504,28507
< ; <label>:72                                      ; preds = %0
<   %73 = load %struct.CPUX86State** @env, align 8
<   %74 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 2
<   %75 = load i32* %74, align 4
<   %76 = getelementptr inbounds %struct.CPUX86State* %73, i64 0, i32 3
<   %77 = load i32* %76, align 4
<   %78 = icmp ule i32 %77, %75
<   %79 = zext i1 %78 to i32
<   br label %201
---
> ; <label>:59                                      ; preds = %24
>   %60 = load i32* %4, align 4
>   %61 = icmp ne i32 %60, 0
>   br i1 %61, label %62, label %77
23628,23652c28509,28518
< ; <label>:80                                      ; preds = %0
<   %81 = load %struct.CPUX86State** @env, align 8
<   %82 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 3
<   %83 = load i32* %82, align 4
<   %84 = getelementptr inbounds %struct.CPUX86State* %81, i64 0, i32 2
<   %85 = load i32* %84, align 4
<   %86 = add i32 %85, %83
<   %87 = and i32 %86, 255
<   %88 = and i32 %85, 255
<   %89 = icmp ult i32 %87, %88
<   %90 = zext i1 %89 to i32
<   br label %201
< 
< ; <label>:91                                      ; preds = %0
<   %92 = load %struct.CPUX86State** @env, align 8
<   %93 = getelementptr inbounds %struct.CPUX86State* %92, i64 0, i32 3
<   %94 = load i32* %93, align 4
<   %95 = getelementptr inbounds %struct.CPUX86State* %92, i64 0, i32 2
<   %96 = load i32* %95, align 4
<   %97 = add i32 %96, %94
<   %98 = and i32 %97, 65535
<   %99 = and i32 %96, 65535
<   %100 = icmp ult i32 %98, %99
<   %101 = zext i1 %100 to i32
<   br label %201
---
> ; <label>:62                                      ; preds = %59
>   %63 = load i8* %aSign, align 1
>   %64 = zext i8 %63 to i32
>   %65 = load i32* %av, align 4
>   %66 = load i32* %bv, align 4
>   %67 = icmp ult i32 %65, %66
>   %68 = zext i1 %67 to i32
>   %69 = xor i32 %64, %68
>   %70 = icmp ne i32 %69, 0
>   br i1 %70, label %71, label %73
23654,23703c28520,28522
< ; <label>:102                                     ; preds = %0
<   %103 = load %struct.CPUX86State** @env, align 8
<   %104 = getelementptr inbounds %struct.CPUX86State* %103, i64 0, i32 3
<   %105 = load i32* %104, align 4
<   %106 = getelementptr inbounds %struct.CPUX86State* %103, i64 0, i32 2
<   %107 = load i32* %106, align 4
<   %108 = alloca i32, align 4
<   %109 = call i1 @uadd(i32* %108, i32 %105, i32 %107) nounwind
<   %110 = zext i1 %109 to i32
<   br label %201
< 
< ; <label>:111                                     ; preds = %0
<   %112 = load %struct.CPUX86State** @env, align 8
<   %113 = getelementptr inbounds %struct.CPUX86State* %112, i64 0, i32 3
<   %114 = load i32* %113, align 4
<   %115 = getelementptr inbounds %struct.CPUX86State* %112, i64 0, i32 2
<   %116 = load i32* %115, align 4
<   %117 = add i32 %114, 1
<   %118 = add i32 %117, %116
<   %119 = and i32 %118, 255
<   %120 = and i32 %116, 255
<   %121 = icmp ule i32 %119, %120
<   %122 = zext i1 %121 to i32
<   br label %201
< 
< ; <label>:123                                     ; preds = %0
<   %124 = load %struct.CPUX86State** @env, align 8
<   %125 = getelementptr inbounds %struct.CPUX86State* %124, i64 0, i32 3
<   %126 = load i32* %125, align 4
<   %127 = getelementptr inbounds %struct.CPUX86State* %124, i64 0, i32 2
<   %128 = load i32* %127, align 4
<   %129 = add i32 %126, 1
<   %130 = add i32 %129, %128
<   %131 = and i32 %130, 65535
<   %132 = and i32 %128, 65535
<   %133 = icmp ule i32 %131, %132
<   %134 = zext i1 %133 to i32
<   br label %201
< 
< ; <label>:135                                     ; preds = %0
<   %136 = load %struct.CPUX86State** @env, align 8
<   %137 = getelementptr inbounds %struct.CPUX86State* %136, i64 0, i32 3
<   %138 = load i32* %137, align 4
<   %139 = getelementptr inbounds %struct.CPUX86State* %136, i64 0, i32 2
<   %140 = load i32* %139, align 4
<   %141 = add i32 %138, 1
<   %142 = add i32 %141, %140
<   %143 = icmp ule i32 %142, %140
<   %144 = zext i1 %143 to i32
<   br label %201
---
> ; <label>:71                                      ; preds = %62
>   %72 = load i32* %2, align 4
>   br label %75
23705,23715c28524,28526
< ; <label>:145                                     ; preds = %0
<   %146 = load %struct.CPUX86State** @env, align 8
<   %147 = getelementptr inbounds %struct.CPUX86State* %146, i64 0, i32 2
<   %148 = load i32* %147, align 4
<   br label %201
< 
< ; <label>:149                                     ; preds = %0
<   %150 = load %struct.CPUX86State** @env, align 8
<   %151 = getelementptr inbounds %struct.CPUX86State* %150, i64 0, i32 2
<   %152 = load i32* %151, align 4
<   br label %201
---
> ; <label>:73                                      ; preds = %62
>   %74 = load i32* %3, align 4
>   br label %75
23717,23783c28528,28542
< ; <label>:153                                     ; preds = %0
<   %154 = load %struct.CPUX86State** @env, align 8
<   %155 = getelementptr inbounds %struct.CPUX86State* %154, i64 0, i32 2
<   %156 = load i32* %155, align 4
<   br label %201
< 
< ; <label>:157                                     ; preds = %0
<   %158 = load %struct.CPUX86State** @env, align 8
<   %159 = getelementptr inbounds %struct.CPUX86State* %158, i64 0, i32 2
<   %160 = load i32* %159, align 4
<   br label %201
< 
< ; <label>:161                                     ; preds = %0
<   %162 = load %struct.CPUX86State** @env, align 8
<   %163 = getelementptr inbounds %struct.CPUX86State* %162, i64 0, i32 2
<   %164 = load i32* %163, align 4
<   br label %201
< 
< ; <label>:165                                     ; preds = %0
<   %166 = load %struct.CPUX86State** @env, align 8
<   %167 = getelementptr inbounds %struct.CPUX86State* %166, i64 0, i32 2
<   %168 = load i32* %167, align 4
<   br label %201
< 
< ; <label>:169                                     ; preds = %0
<   %170 = load %struct.CPUX86State** @env, align 8
<   %171 = getelementptr inbounds %struct.CPUX86State* %170, i64 0, i32 2
<   %172 = load i32* %171, align 4
<   %173 = lshr i32 %172, 7
<   %174 = and i32 %173, 1
<   br label %201
< 
< ; <label>:175                                     ; preds = %0
<   %176 = load %struct.CPUX86State** @env, align 8
<   %177 = getelementptr inbounds %struct.CPUX86State* %176, i64 0, i32 2
<   %178 = load i32* %177, align 4
<   %179 = lshr i32 %178, 15
<   %180 = and i32 %179, 1
<   br label %201
< 
< ; <label>:181                                     ; preds = %0
<   %182 = load %struct.CPUX86State** @env, align 8
<   %183 = getelementptr inbounds %struct.CPUX86State* %182, i64 0, i32 2
<   %184 = load i32* %183, align 4
<   %185 = lshr i32 %184, 31
<   br label %201
< 
< ; <label>:186                                     ; preds = %0
<   %187 = load %struct.CPUX86State** @env, align 8
<   %188 = getelementptr inbounds %struct.CPUX86State* %187, i64 0, i32 2
<   %189 = load i32* %188, align 4
<   %190 = and i32 %189, 1
<   br label %201
< 
< ; <label>:191                                     ; preds = %0
<   %192 = load %struct.CPUX86State** @env, align 8
<   %193 = getelementptr inbounds %struct.CPUX86State* %192, i64 0, i32 2
<   %194 = load i32* %193, align 4
<   %195 = and i32 %194, 1
<   br label %201
< 
< ; <label>:196                                     ; preds = %0
<   %197 = load %struct.CPUX86State** @env, align 8
<   %198 = getelementptr inbounds %struct.CPUX86State* %197, i64 0, i32 2
<   %199 = load i32* %198, align 4
<   %200 = and i32 %199, 1
<   br label %201
---
> ; <label>:75                                      ; preds = %73, %71
>   %76 = phi i32 [ %72, %71 ], [ %74, %73 ]
>   store i32 %76, i32* %1
>   br label %92
> 
> ; <label>:77                                      ; preds = %59
>   %78 = load i8* %aSign, align 1
>   %79 = zext i8 %78 to i32
>   %80 = load i32* %av, align 4
>   %81 = load i32* %bv, align 4
>   %82 = icmp ult i32 %80, %81
>   %83 = zext i1 %82 to i32
>   %84 = xor i32 %79, %83
>   %85 = icmp ne i32 %84, 0
>   br i1 %85, label %86, label %88
23785,23787c28544,28559
< ; <label>:201                                     ; preds = %196, %191, %186, %181, %175, %169, %165, %161, %157, %153, %149, %145, %135, %123, %111, %102, %91, %80, %72, %62, %52, %44, %34, %24, %18, %12, %6, %1, %0
<   %.0 = phi i32 [ %200, %196 ], [ %195, %191 ], [ %190, %186 ], [ %185, %181 ], [ %180, %175 ], [ %174, %169 ], [ %168, %165 ], [ %164, %161 ], [ %160, %157 ], [ %156, %153 ], [ %152, %149 ], [ %148, %145 ], [ %144, %135 ], [ %134, %123 ], [ %122, %111 ], [ %110, %102 ], [ %101, %91 ], [ %90, %80 ], [ %79, %72 ], [ %71, %62 ], [ %61, %52 ], [ %51, %44 ], [ %43, %34 ], [ %33, %24 ], [ %23, %18 ], [ %17, %12 ], [ %11, %6 ], [ %5, %1 ], [ 0, %0 ]
<   ret i32 %.0
---
> ; <label>:86                                      ; preds = %77
>   %87 = load i32* %3, align 4
>   br label %90
> 
> ; <label>:88                                      ; preds = %77
>   %89 = load i32* %2, align 4
>   br label %90
> 
> ; <label>:90                                      ; preds = %88, %86
>   %91 = phi i32 [ %87, %86 ], [ %89, %88 ]
>   store i32 %91, i32* %1
>   br label %92
> 
> ; <label>:92                                      ; preds = %90, %75, %57, %47, %19
>   %93 = load i32* %1
>   ret i32 %93
23790,23800c28562,28573
< define i64 @helper_set_cc_op_eflags() nounwind uwtable {
<   %1 = load %struct.CPUX86State** @env, align 8
<   %2 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 1
<   %3 = load i32* %2, align 4
<   %4 = tail call i32 @helper_cc_compute_all(i32 %3)
<   %5 = getelementptr inbounds %struct.CPUX86State* %1, i64 0, i32 2
<   store i32 %4, i32* %5, align 4
<   %6 = load %struct.CPUX86State** @env, align 8
<   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 1
<   store i32 1, i32* %7, align 4
<   ret i64 0
---
> define internal i32 @float32_max(i32 %a, i32 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca %struct.float_status*, align 4
>   store i32 %a, i32* %1, align 4
>   store i32 %b, i32* %2, align 4
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i32* %1, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i32 @float32_minmax(i32 %4, i32 %5, i32 0, %struct.float_status* %6)
>   ret i32 %7
23803,23804c28576,28587
< define void @s2e_ensure_symbolic(%struct.S2E* nocapture %s2e, %struct.S2EExecutionState* nocapture %state) nounwind uwtable readnone {
<   ret void
---
> define internal i64 @float64_min(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   store i64 %a, i64* %1, align 8
>   store i64 %b, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %1, align 8
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i64 @float64_minmax(i64 %4, i64 %5, i32 1, %struct.float_status* %6)
>   ret i64 %7
23807c28590,28615
< declare void @set_float_rounding_mode(i32, %struct.float_status*)
---
> define internal i64 @float64_minmax(i64 %a, i64 %b, i32 %ismin, %struct.float_status* %status) nounwind inlinehint {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i64, align 8
>   %4 = alloca i32, align 4
>   %5 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %bSign = alloca i8, align 1
>   %av = alloca i64, align 8
>   %bv = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i64 %b, i64* %3, align 8
>   store i32 %ismin, i32* %4, align 4
>   store %struct.float_status* %status, %struct.float_status** %5, align 4
>   %6 = load i64* %2, align 8
>   %7 = load %struct.float_status** %5, align 4
>   %8 = call i64 @float64_squash_input_denormal(i64 %6, %struct.float_status* %7)
>   store i64 %8, i64* %2, align 8
>   %9 = load i64* %3, align 8
>   %10 = load %struct.float_status** %5, align 4
>   %11 = call i64 @float64_squash_input_denormal(i64 %9, %struct.float_status* %10)
>   store i64 %11, i64* %3, align 8
>   %12 = load i64* %2, align 8
>   %13 = call i32 @float64_is_any_nan(i64 %12)
>   %14 = icmp ne i32 %13, 0
>   br i1 %14, label %19, label %15
23809c28617,28629
< declare void @stw_phys(i64, i32)
---
> ; <label>:15                                      ; preds = %0
>   %16 = load i64* %3, align 8
>   %17 = call i32 @float64_is_any_nan(i64 %16)
>   %18 = icmp ne i32 %17, 0
>   br i1 %18, label %19, label %24
> 
> ; <label>:19                                      ; preds = %15, %0
>   %20 = load i64* %2, align 8
>   %21 = load i64* %3, align 8
>   %22 = load %struct.float_status** %5, align 4
>   %23 = call i64 @propagateFloat64NaN(i64 %20, i64 %21, %struct.float_status* %22)
>   store i64 %23, i64* %1
>   br label %92
23811c28631,28652
< declare void @cpu_set_ferr(%struct.CPUX86State*)
---
> ; <label>:24                                      ; preds = %15
>   %25 = load i64* %2, align 8
>   %26 = call zeroext i8 @extractFloat64Sign(i64 %25)
>   store i8 %26, i8* %aSign, align 1
>   %27 = load i64* %3, align 8
>   %28 = call zeroext i8 @extractFloat64Sign(i64 %27)
>   store i8 %28, i8* %bSign, align 1
>   %29 = load i64* %2, align 8
>   store i64 %29, i64* %av, align 8
>   %30 = load i64* %3, align 8
>   store i64 %30, i64* %bv, align 8
>   %31 = load i8* %aSign, align 1
>   %32 = zext i8 %31 to i32
>   %33 = load i8* %bSign, align 1
>   %34 = zext i8 %33 to i32
>   %35 = icmp ne i32 %32, %34
>   br i1 %35, label %36, label %59
> 
> ; <label>:36                                      ; preds = %24
>   %37 = load i32* %4, align 4
>   %38 = icmp ne i32 %37, 0
>   br i1 %38, label %39, label %49
23813c28654,28658
< declare void @set_floatx80_rounding_precision(i32, %struct.float_status*)
---
> ; <label>:39                                      ; preds = %36
>   %40 = load i8* %aSign, align 1
>   %41 = zext i8 %40 to i32
>   %42 = icmp ne i32 %41, 0
>   br i1 %42, label %43, label %45
23815c28660,28662
< declare void @s2e_on_privilege_change(i32, i32)
---
> ; <label>:43                                      ; preds = %39
>   %44 = load i64* %2, align 8
>   br label %47
23817c28664,28666
< declare void @cpu_abort(%struct.CPUX86State*, i8*, ...) noreturn
---
> ; <label>:45                                      ; preds = %39
>   %46 = load i64* %3, align 8
>   br label %47
23819,23823c28668,28677
< define internal fastcc i32 @ldub_kernel(i32 %ptr) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:47                                      ; preds = %45, %43
>   %48 = phi i64 [ %44, %43 ], [ %46, %45 ]
>   store i64 %48, i64* %1
>   br label %92
> 
> ; <label>:49                                      ; preds = %36
>   %50 = load i8* %aSign, align 1
>   %51 = zext i8 %50 to i32
>   %52 = icmp ne i32 %51, 0
>   br i1 %52, label %53, label %55
23825,23827c28679,28681
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:53                                      ; preds = %49
>   %54 = load i64* %3, align 8
>   br label %57
23829,23842c28683,28695
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 0
<   %16 = load i32* %15, align 4
<   %17 = and i32 %8, -4096
<   %18 = icmp eq i32 %16, %17
<   br i1 %18, label %21, label %19, !prof !0
---
> ; <label>:55                                      ; preds = %49
>   %56 = load i64* %2, align 8
>   br label %57
> 
> ; <label>:57                                      ; preds = %55, %53
>   %58 = phi i64 [ %54, %53 ], [ %56, %55 ]
>   store i64 %58, i64* %1
>   br label %92
> 
> ; <label>:59                                      ; preds = %24
>   %60 = load i32* %4, align 4
>   %61 = icmp ne i32 %60, 0
>   br i1 %61, label %62, label %77
23844,23846c28697,28706
< ; <label>:19                                      ; preds = %6
<   %20 = tail call zeroext i8 @__ldb_mmu(i32 %8, i32 0)
<   br label %29
---
> ; <label>:62                                      ; preds = %59
>   %63 = load i8* %aSign, align 1
>   %64 = zext i8 %63 to i32
>   %65 = load i64* %av, align 8
>   %66 = load i64* %bv, align 8
>   %67 = icmp ult i64 %65, %66
>   %68 = zext i1 %67 to i32
>   %69 = xor i32 %64, %68
>   %70 = icmp ne i32 %69, 0
>   br i1 %70, label %71, label %73
23848,23857c28708,28710
< ; <label>:21                                      ; preds = %6
<   %22 = and i64 %7, 4294967295
<   %23 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 3
<   %24 = load i64* %23, align 8
<   %25 = add i64 %24, %22
<   %26 = inttoptr i64 %25 to i8*
<   %27 = load i8* %26, align 1
<   %28 = zext i8 %27 to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %22, i64 %25, i64 %28, i32 32, i8 zeroext 0, i8 zeroext 0) nounwind
<   br label %29
---
> ; <label>:71                                      ; preds = %62
>   %72 = load i64* %2, align 8
>   br label %75
23859,23863c28712,28714
< ; <label>:29                                      ; preds = %21, %19
<   %res.0.in = phi i8 [ %20, %19 ], [ %27, %21 ]
<   %res.0 = zext i8 %res.0.in to i32
<   ret i32 %res.0
< }
---
> ; <label>:73                                      ; preds = %62
>   %74 = load i64* %3, align 8
>   br label %75
23865,23869c28716,28730
< define internal fastcc void @stb_kernel(i32 %ptr, i32 %v) nounwind uwtable {
<   %1 = load i32* @g_s2e_fork_on_symbolic_address, align 4
<   %2 = icmp eq i32 %1, 0
<   %3 = zext i32 %ptr to i64
<   br i1 %2, label %6, label %4
---
> ; <label>:75                                      ; preds = %73, %71
>   %76 = phi i64 [ %72, %71 ], [ %74, %73 ]
>   store i64 %76, i64* %1
>   br label %92
> 
> ; <label>:77                                      ; preds = %59
>   %78 = load i8* %aSign, align 1
>   %79 = zext i8 %78 to i32
>   %80 = load i64* %av, align 8
>   %81 = load i64* %bv, align 8
>   %82 = icmp ult i64 %80, %81
>   %83 = zext i1 %82 to i32
>   %84 = xor i32 %79, %83
>   %85 = icmp ne i32 %84, 0
>   br i1 %85, label %86, label %88
23871,23873c28732,28734
< ; <label>:4                                       ; preds = %0
<   %5 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %3, i64 0, i64 4294967295) nounwind
<   br label %6
---
> ; <label>:86                                      ; preds = %77
>   %87 = load i64* %3, align 8
>   br label %90
23875,23893c28736,28738
< ; <label>:6                                       ; preds = %4, %0
<   %7 = phi i64 [ %5, %4 ], [ %3, %0 ]
<   %8 = trunc i64 %7 to i32
<   %9 = lshr i64 %7, 7
<   %10 = and i64 %9, 33554431
<   %11 = tail call i64 @tcg_llvm_fork_and_concretize(i64 %10, i64 0, i64 33554431) nounwind
<   %12 = lshr i64 %11, 5
<   %13 = and i64 %12, 255
<   %14 = load %struct.CPUX86State** @env, align 8
<   %15 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 1
<   %16 = load i32* %15, align 4
<   %17 = and i32 %8, -4096
<   %18 = icmp eq i32 %16, %17
<   br i1 %18, label %21, label %19, !prof !0
< 
< ; <label>:19                                      ; preds = %6
<   %20 = trunc i32 %v to i8
<   tail call void @__stb_mmu(i32 %8, i8 zeroext %20, i32 0)
<   br label %29
---
> ; <label>:88                                      ; preds = %77
>   %89 = load i64* %2, align 8
>   br label %90
23895,23905c28740,28743
< ; <label>:21                                      ; preds = %6
<   %22 = and i64 %7, 4294967295
<   %23 = getelementptr inbounds %struct.CPUX86State* %14, i64 0, i32 73, i64 0, i64 %13, i32 3
<   %24 = load i64* %23, align 8
<   %25 = add i64 %24, %22
<   %26 = inttoptr i64 %25 to i8*
<   %27 = trunc i32 %v to i8
<   store i8 %27, i8* %26, align 1
<   %28 = zext i32 %v to i64
<   tail call void @tcg_llvm_trace_memory_access(i64 %22, i64 %25, i64 %28, i32 32, i8 zeroext 1, i8 zeroext 0) nounwind
<   br label %29
---
> ; <label>:90                                      ; preds = %88, %86
>   %91 = phi i64 [ %87, %86 ], [ %89, %88 ]
>   store i64 %91, i64* %1
>   br label %92
23907,23908c28745,28747
< ; <label>:29                                      ; preds = %21, %19
<   ret void
---
> ; <label>:92                                      ; preds = %90, %75, %57, %47, %19
>   %93 = load i64* %1
>   ret i64 %93
23911,23914c28750,28762
< define internal fastcc void @tss_load_seg(i32 %seg_reg, i32 %selector) nounwind uwtable {
<   %1 = and i32 %selector, 65532
<   %2 = icmp eq i32 %1, 0
<   br i1 %2, label %131, label %3
---
> define internal i64 @float64_max(i64 %a, i64 %b, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 8
>   %2 = alloca i64, align 8
>   %3 = alloca %struct.float_status*, align 4
>   store i64 %a, i64* %1, align 8
>   store i64 %b, i64* %2, align 8
>   store %struct.float_status* %status, %struct.float_status** %3, align 4
>   %4 = load i64* %1, align 8
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %3, align 4
>   %7 = call i64 @float64_minmax(i64 %4, i64 %5, i32 0, %struct.float_status* %6)
>   ret i64 %7
> }
23916,23927c28764,28792
< ; <label>:3                                       ; preds = %0
<   %4 = and i32 %selector, 4
<   %5 = icmp eq i32 %4, 0
<   %6 = load %struct.CPUX86State** @env, align 8
<   %7 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 11
<   %8 = getelementptr inbounds %struct.CPUX86State* %6, i64 0, i32 13
<   %dt.0.i = select i1 %5, %struct.SegmentCache* %8, %struct.SegmentCache* %7
<   %9 = or i32 %selector, 7
<   %10 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 2
<   %11 = load i32* %10, align 4
<   %12 = icmp ugt i32 %9, %11
<   br i1 %12, label %13, label %14
---
> define internal i32 @float32_scalbn(i32 %a, i32 %n, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i32, align 4
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i16, align 2
>   %aSig = alloca i32, align 4
>   store i32 %a, i32* %2, align 4
>   store i32 %n, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i32* %2, align 4
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i32 @float32_squash_input_denormal(i32 %5, %struct.float_status* %6)
>   store i32 %7, i32* %2, align 4
>   %8 = load i32* %2, align 4
>   %9 = call i32 @extractFloat32Frac(i32 %8)
>   store i32 %9, i32* %aSig, align 4
>   %10 = load i32* %2, align 4
>   %11 = call i32 @extractFloat32Exp(i32 %10)
>   %12 = trunc i32 %11 to i16
>   store i16 %12, i16* %aExp, align 2
>   %13 = load i32* %2, align 4
>   %14 = call zeroext i8 @extractFloat32Sign(i32 %13)
>   store i8 %14, i8* %aSign, align 1
>   %15 = load i16* %aExp, align 2
>   %16 = sext i16 %15 to i32
>   %17 = icmp eq i32 %16, 255
>   br i1 %17, label %18, label %28
23929,23931c28794,28797
< ; <label>:13                                      ; preds = %3
<   tail call fastcc void @raise_exception_err(i32 10, i32 %1) noreturn
<   unreachable
---
> ; <label>:18                                      ; preds = %0
>   %19 = load i32* %aSig, align 4
>   %20 = icmp ne i32 %19, 0
>   br i1 %20, label %21, label %26
23933,23943c28799,28805
< ; <label>:14                                      ; preds = %3
<   %15 = and i32 %selector, -8
<   %16 = getelementptr inbounds %struct.SegmentCache* %dt.0.i, i64 0, i32 1
<   %17 = load i32* %16, align 4
<   %18 = add i32 %17, %15
<   %19 = tail call fastcc i32 @ldl_kernel(i32 %18) nounwind
<   %20 = add i32 %18, 4
<   %21 = tail call fastcc i32 @ldl_kernel(i32 %20) nounwind
<   %22 = and i32 %21, 4096
<   %23 = icmp eq i32 %22, 0
<   br i1 %23, label %24, label %25
---
> ; <label>:21                                      ; preds = %18
>   %22 = load i32* %2, align 4
>   %23 = load i32* %2, align 4
>   %24 = load %struct.float_status** %4, align 4
>   %25 = call i32 @propagateFloat32NaN(i32 %22, i32 %23, %struct.float_status* %24)
>   store i32 %25, i32* %1
>   br label %65
23945,23947c28807,28810
< ; <label>:24                                      ; preds = %14
<   tail call fastcc void @raise_exception_err(i32 10, i32 %1) noreturn
<   unreachable
---
> ; <label>:26                                      ; preds = %18
>   %27 = load i32* %2, align 4
>   store i32 %27, i32* %1
>   br label %65
23949,23958c28812,28816
< ; <label>:25                                      ; preds = %14
<   %26 = and i32 %selector, 3
<   %27 = lshr i32 %21, 13
<   %28 = and i32 %27, 3
<   %29 = load %struct.CPUX86State** @env, align 8
<   %30 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 8
<   %31 = load i32* %30, align 4
<   %32 = and i32 %31, 3
<   %33 = icmp eq i32 %seg_reg, 1
<   br i1 %33, label %34, label %41
---
> ; <label>:28                                      ; preds = %0
>   %29 = load i16* %aExp, align 2
>   %30 = sext i16 %29 to i32
>   %31 = icmp ne i32 %30, 0
>   br i1 %31, label %32, label %35
23960,23963c28818,28822
< ; <label>:34                                      ; preds = %25
<   %35 = and i32 %21, 2048
<   %36 = icmp eq i32 %35, 0
<   br i1 %36, label %37, label %38
---
> ; <label>:32                                      ; preds = %28
>   %33 = load i32* %aSig, align 4
>   %34 = or i32 %33, 8388608
>   store i32 %34, i32* %aSig, align 4
>   br label %41
23965,23967c28824,28827
< ; <label>:37                                      ; preds = %34
<   tail call fastcc void @raise_exception_err(i32 10, i32 %1) noreturn
<   unreachable
---
> ; <label>:35                                      ; preds = %28
>   %36 = load i32* %aSig, align 4
>   %37 = icmp eq i32 %36, 0
>   br i1 %37, label %38, label %40
23969,23971c28829,28832
< ; <label>:38                                      ; preds = %34
<   %39 = icmp eq i32 %28, %26
<   br i1 %39, label %61, label %40
---
> ; <label>:38                                      ; preds = %35
>   %39 = load i32* %2, align 4
>   store i32 %39, i32* %1
>   br label %65
23973,23975c28834,28835
< ; <label>:40                                      ; preds = %38
<   tail call fastcc void @raise_exception_err(i32 10, i32 %1) noreturn
<   unreachable
---
> ; <label>:40                                      ; preds = %35
>   br label %41
23977,23980c28837,28840
< ; <label>:41                                      ; preds = %25
<   %42 = icmp eq i32 %seg_reg, 2
<   %43 = and i32 %21, 2560
<   br i1 %42, label %44, label %51
---
> ; <label>:41                                      ; preds = %40, %32
>   %42 = load i32* %3, align 4
>   %43 = icmp sgt i32 %42, 512
>   br i1 %43, label %44, label %45
23983,23984c28843,28844
<   %45 = icmp eq i32 %43, 512
<   br i1 %45, label %47, label %46
---
>   store i32 512, i32* %3, align 4
>   br label %50
23986,23988c28846,28853
< ; <label>:46                                      ; preds = %44
<   tail call fastcc void @raise_exception_err(i32 10, i32 %1) noreturn
<   unreachable
---
> ; <label>:45                                      ; preds = %41
>   %46 = load i32* %3, align 4
>   %47 = icmp slt i32 %46, -512
>   br i1 %47, label %48, label %49
> 
> ; <label>:48                                      ; preds = %45
>   store i32 -512, i32* %3, align 4
>   br label %49
23990,23994c28855,28856
< ; <label>:47                                      ; preds = %44
<   %48 = icmp eq i32 %28, %32
<   %49 = icmp eq i32 %28, %26
<   %or.cond31 = and i1 %48, %49
<   br i1 %or.cond31, label %61, label %50
---
> ; <label>:49                                      ; preds = %48, %45
>   br label %50
23996,23998c28858,28876
< ; <label>:50                                      ; preds = %47
<   tail call fastcc void @raise_exception_err(i32 10, i32 %1) noreturn
<   unreachable
---
> ; <label>:50                                      ; preds = %49, %44
>   %51 = load i32* %3, align 4
>   %52 = sub nsw i32 %51, 1
>   %53 = load i16* %aExp, align 2
>   %54 = sext i16 %53 to i32
>   %55 = add nsw i32 %54, %52
>   %56 = trunc i32 %55 to i16
>   store i16 %56, i16* %aExp, align 2
>   %57 = load i32* %aSig, align 4
>   %58 = shl i32 %57, 7
>   store i32 %58, i32* %aSig, align 4
>   %59 = load i8* %aSign, align 1
>   %60 = load i16* %aExp, align 2
>   %61 = sext i16 %60 to i32
>   %62 = load i32* %aSig, align 4
>   %63 = load %struct.float_status** %4, align 4
>   %64 = call i32 @normalizeRoundAndPackFloat32(i8 zeroext %59, i32 %61, i32 %62, %struct.float_status* %63)
>   store i32 %64, i32* %1
>   br label %65
24000,24002c28878,28881
< ; <label>:51                                      ; preds = %41
<   %52 = icmp eq i32 %43, 2048
<   br i1 %52, label %53, label %54
---
> ; <label>:65                                      ; preds = %50, %38, %26, %21
>   %66 = load i32* %1
>   ret i32 %66
> }
24004,24006c28883,28911
< ; <label>:53                                      ; preds = %51
<   tail call fastcc void @raise_exception_err(i32 10, i32 %1) noreturn
<   unreachable
---
> define internal i64 @float64_scalbn(i64 %a, i32 %n, %struct.float_status* %status) nounwind {
>   %1 = alloca i64, align 4
>   %2 = alloca i64, align 8
>   %3 = alloca i32, align 4
>   %4 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i16, align 2
>   %aSig = alloca i64, align 8
>   store i64 %a, i64* %2, align 8
>   store i32 %n, i32* %3, align 4
>   store %struct.float_status* %status, %struct.float_status** %4, align 4
>   %5 = load i64* %2, align 8
>   %6 = load %struct.float_status** %4, align 4
>   %7 = call i64 @float64_squash_input_denormal(i64 %5, %struct.float_status* %6)
>   store i64 %7, i64* %2, align 8
>   %8 = load i64* %2, align 8
>   %9 = call i64 @extractFloat64Frac(i64 %8)
>   store i64 %9, i64* %aSig, align 8
>   %10 = load i64* %2, align 8
>   %11 = call i32 @extractFloat64Exp(i64 %10)
>   %12 = trunc i32 %11 to i16
>   store i16 %12, i16* %aExp, align 2
>   %13 = load i64* %2, align 8
>   %14 = call zeroext i8 @extractFloat64Sign(i64 %13)
>   store i8 %14, i8* %aSign, align 1
>   %15 = load i16* %aExp, align 2
>   %16 = sext i16 %15 to i32
>   %17 = icmp eq i32 %16, 2047
>   br i1 %17, label %18, label %28
24008,24011c28913,28916
< ; <label>:54                                      ; preds = %51
<   %55 = and i32 %21, 3072
<   %56 = icmp ult i32 %55, 3072
<   br i1 %56, label %57, label %61
---
> ; <label>:18                                      ; preds = %0
>   %19 = load i64* %aSig, align 8
>   %20 = icmp ne i64 %19, 0
>   br i1 %20, label %21, label %26
24013,24017c28918,28924
< ; <label>:57                                      ; preds = %54
<   %58 = icmp ult i32 %28, %32
<   %59 = icmp ult i32 %28, %26
<   %or.cond34 = or i1 %58, %59
<   br i1 %or.cond34, label %60, label %61
---
> ; <label>:21                                      ; preds = %18
>   %22 = load i64* %2, align 8
>   %23 = load i64* %2, align 8
>   %24 = load %struct.float_status** %4, align 4
>   %25 = call i64 @propagateFloat64NaN(i64 %22, i64 %23, %struct.float_status* %24)
>   store i64 %25, i64* %1
>   br label %65
24019,24021c28926,28929
< ; <label>:60                                      ; preds = %57
<   tail call fastcc void @raise_exception_err(i32 10, i32 %1) noreturn
<   unreachable
---
> ; <label>:26                                      ; preds = %18
>   %27 = load i64* %2, align 8
>   store i64 %27, i64* %1
>   br label %65
24023,24026c28931,28935
< ; <label>:61                                      ; preds = %57, %54, %47, %38
<   %62 = and i32 %21, 32768
<   %63 = icmp eq i32 %62, 0
<   br i1 %63, label %64, label %65
---
> ; <label>:28                                      ; preds = %0
>   %29 = load i16* %aExp, align 2
>   %30 = sext i16 %29 to i32
>   %31 = icmp ne i32 %30, 0
>   br i1 %31, label %32, label %35
24028,24030c28937,28941
< ; <label>:64                                      ; preds = %61
<   tail call fastcc void @raise_exception_err(i32 11, i32 %1) noreturn
<   unreachable
---
> ; <label>:32                                      ; preds = %28
>   %33 = load i64* %aSig, align 8
>   %34 = or i64 %33, 4503599627370496
>   store i64 %34, i64* %aSig, align 8
>   br label %41
24032,24094c28943,28951
< ; <label>:65                                      ; preds = %61
<   %66 = lshr i32 %19, 16
<   %67 = shl i32 %21, 16
<   %68 = and i32 %67, 16711680
<   %69 = and i32 %21, -16777216
<   %70 = or i32 %69, %66
<   %71 = or i32 %70, %68
<   %72 = and i32 %19, 65535
<   %73 = and i32 %21, 983040
<   %74 = or i32 %73, %72
<   %75 = and i32 %21, 8388608
<   %76 = icmp eq i32 %75, 0
<   br i1 %76, label %get_seg_limit.exit, label %77
< 
< ; <label>:77                                      ; preds = %65
<   %78 = shl nuw i32 %74, 12
<   %79 = or i32 %78, 4095
<   br label %get_seg_limit.exit
< 
< get_seg_limit.exit:                               ; preds = %77, %65
<   %limit.0.i = phi i32 [ %79, %77 ], [ %74, %65 ]
<   %80 = sext i32 %seg_reg to i64
<   %81 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 10, i64 %80, i32 0
<   store i32 %selector, i32* %81, align 4
<   %82 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 10, i64 %80, i32 1
<   store i32 %71, i32* %82, align 4
<   %83 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 10, i64 %80, i32 2
<   store i32 %limit.0.i, i32* %83, align 4
<   %84 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 10, i64 %80, i32 3
<   store i32 %21, i32* %84, align 4
<   br i1 %33, label %85, label %._crit_edge.i
< 
< ._crit_edge.i:                                    ; preds = %get_seg_limit.exit
<   %.pre.i = load i32* %30, align 4
<   br label %93
< 
< ; <label>:85                                      ; preds = %get_seg_limit.exit
<   %86 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 10, i64 1, i32 3
<   %87 = load i32* %86, align 4
<   %88 = lshr i32 %87, 18
<   %89 = and i32 %88, 16
<   %90 = load i32* %30, align 4
<   %91 = and i32 %90, -32785
<   %92 = or i32 %91, %89
<   store i32 %92, i32* %30, align 4
<   br label %93
< 
< ; <label>:93                                      ; preds = %85, %._crit_edge.i
<   %94 = phi i32 [ %.pre.i, %._crit_edge.i ], [ %92, %85 ]
<   %95 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 10, i64 2, i32 3
<   %96 = load i32* %95, align 4
<   %97 = lshr i32 %96, 17
<   %98 = and i32 %97, 32
<   %99 = and i32 %94, 32768
<   %100 = icmp eq i32 %99, 0
<   br i1 %100, label %101, label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:101                                     ; preds = %93
<   %102 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 15, i64 0
<   %103 = load i32* %102, align 4
<   %104 = and i32 %103, 1
<   %105 = icmp eq i32 %104, 0
<   br i1 %105, label %114, label %106
---
> ; <label>:35                                      ; preds = %28
>   %36 = load i64* %aSig, align 8
>   %37 = icmp eq i64 %36, 0
>   br i1 %37, label %38, label %40
> 
> ; <label>:38                                      ; preds = %35
>   %39 = load i64* %2, align 8
>   store i64 %39, i64* %1
>   br label %65
24096,24125c28953,28954
< ; <label>:106                                     ; preds = %101
<   %107 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 7
<   %108 = load i32* %107, align 4
<   %109 = and i32 %108, 131072
<   %110 = icmp eq i32 %109, 0
<   br i1 %110, label %111, label %114
< 
< ; <label>:111                                     ; preds = %106
<   %112 = and i32 %94, 16
<   %113 = icmp eq i32 %112, 0
<   br i1 %113, label %114, label %116
< 
< ; <label>:114                                     ; preds = %111, %106, %101
<   %115 = or i32 %98, 64
<   br label %cpu_x86_load_seg_cache.exit
< 
< ; <label>:116                                     ; preds = %111
<   %117 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 10, i64 3, i32 1
<   %118 = load i32* %117, align 4
<   %119 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 10, i64 0, i32 1
<   %120 = load i32* %119, align 4
<   %121 = or i32 %120, %118
<   %122 = getelementptr inbounds %struct.CPUX86State* %29, i64 0, i32 10, i64 2, i32 1
<   %123 = load i32* %122, align 4
<   %124 = or i32 %121, %123
<   %125 = icmp ne i32 %124, 0
<   %126 = zext i1 %125 to i32
<   %127 = shl nuw nsw i32 %126, 6
<   %128 = or i32 %127, %98
<   br label %cpu_x86_load_seg_cache.exit
---
> ; <label>:40                                      ; preds = %35
>   br label %41
24127,24132c28956,28959
< cpu_x86_load_seg_cache.exit:                      ; preds = %116, %114, %93
<   %new_hflags.0.i = phi i32 [ %98, %93 ], [ %115, %114 ], [ %128, %116 ]
<   %129 = and i32 %94, -97
<   %130 = or i32 %new_hflags.0.i, %129
<   store i32 %130, i32* %30, align 4
<   br label %134
---
> ; <label>:41                                      ; preds = %40, %32
>   %42 = load i32* %3, align 4
>   %43 = icmp sgt i32 %42, 4096
>   br i1 %43, label %44, label %45
24134,24137c28961,28963
< ; <label>:131                                     ; preds = %0
<   %seg_reg.off = add i32 %seg_reg, -1
<   %132 = icmp ult i32 %seg_reg.off, 2
<   br i1 %132, label %133, label %134
---
> ; <label>:44                                      ; preds = %41
>   store i32 4096, i32* %3, align 4
>   br label %50
24139,24141c28965,28972
< ; <label>:133                                     ; preds = %131
<   tail call fastcc void @raise_exception_err(i32 10, i32 0) noreturn
<   unreachable
---
> ; <label>:45                                      ; preds = %41
>   %46 = load i32* %3, align 4
>   %47 = icmp slt i32 %46, -4096
>   br i1 %47, label %48, label %49
> 
> ; <label>:48                                      ; preds = %45
>   store i32 -4096, i32* %3, align 4
>   br label %49
24143,24145c28974,28975
< ; <label>:134                                     ; preds = %131, %cpu_x86_load_seg_cache.exit
<   ret void
< }
---
> ; <label>:49                                      ; preds = %48, %45
>   br label %50
24147c28977,28995
< declare void @qemu_system_reset_request()
---
> ; <label>:50                                      ; preds = %49, %44
>   %51 = load i32* %3, align 4
>   %52 = sub nsw i32 %51, 1
>   %53 = load i16* %aExp, align 2
>   %54 = sext i16 %53 to i32
>   %55 = add nsw i32 %54, %52
>   %56 = trunc i32 %55 to i16
>   store i16 %56, i16* %aExp, align 2
>   %57 = load i64* %aSig, align 8
>   %58 = shl i64 %57, 10
>   store i64 %58, i64* %aSig, align 8
>   %59 = load i8* %aSign, align 1
>   %60 = load i16* %aExp, align 2
>   %61 = sext i16 %60 to i32
>   %62 = load i64* %aSig, align 8
>   %63 = load %struct.float_status** %4, align 4
>   %64 = call i64 @normalizeRoundAndPackFloat64(i8 zeroext %59, i32 %61, i64 %62, %struct.float_status* %63)
>   store i64 %64, i64* %1
>   br label %65
24149c28997,29000
< declare { i32, i1 } @llvm.uadd.with.overflow.i32(i32, i32) nounwind readnone
---
> ; <label>:65                                      ; preds = %50, %38, %26, %21
>   %66 = load i64* %1
>   ret i64 %66
> }
24151c29002,29018
< declare void @llvm.lifetime.start(i64, i8* nocapture) nounwind
---
> define internal void @floatx80_scalbn(%struct.floatx80* noalias sret %agg.result, %struct.floatx80* byval align 4 %a, i32 %n, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig = alloca i64, align 8
>   store i32 %n, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %3 = call i64 @extractFloatx80Frac(%struct.floatx80* byval align 4 %a)
>   store i64 %3, i64* %aSig, align 8
>   %4 = call i32 @extractFloatx80Exp(%struct.floatx80* byval align 4 %a)
>   store i32 %4, i32* %aExp, align 4
>   %5 = call zeroext i8 @extractFloatx80Sign(%struct.floatx80* byval align 4 %a)
>   store i8 %5, i8* %aSign, align 1
>   %6 = load i32* %aExp, align 4
>   %7 = icmp eq i32 %6, 32767
>   br i1 %7, label %8, label %17
24153c29020,29024
< declare void @llvm.lifetime.end(i64, i8* nocapture) nounwind
---
> ; <label>:8                                       ; preds = %0
>   %9 = load i64* %aSig, align 8
>   %10 = shl i64 %9, 1
>   %11 = icmp ne i64 %10, 0
>   br i1 %11, label %12, label %14
24155c29026,29029
< declare i64 @fwrite(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) nounwind
---
> ; <label>:12                                      ; preds = %8
>   %13 = load %struct.float_status** %2, align 4
>   call void @propagateFloatx80NaN(%struct.floatx80* sret %agg.result, %struct.floatx80* byval align 4 %a, %struct.floatx80* byval align 4 %a, %struct.float_status* %13)
>   br label %46
24157c29031,29035
< declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) nounwind
---
> ; <label>:14                                      ; preds = %8
>   %15 = bitcast %struct.floatx80* %agg.result to i8*
>   %16 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %15, i8* %16, i32 10, i32 1, i1 false)
>   br label %46
24159c29037,29040
< declare i32 @fputc(i32, %struct._IO_FILE* nocapture) nounwind
---
> ; <label>:17                                      ; preds = %0
>   %18 = load i32* %aExp, align 4
>   %19 = icmp eq i32 %18, 0
>   br i1 %19, label %20, label %26
24161c29042,29051
< declare double @exp2(double)
---
> ; <label>:20                                      ; preds = %17
>   %21 = load i64* %aSig, align 8
>   %22 = icmp eq i64 %21, 0
>   br i1 %22, label %23, label %26
> 
> ; <label>:23                                      ; preds = %20
>   %24 = bitcast %struct.floatx80* %agg.result to i8*
>   %25 = bitcast %struct.floatx80* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %24, i8* %25, i32 10, i32 1, i1 false)
>   br label %46
24163c29053,29056
< declare double @ldexp(double, i32)
---
> ; <label>:26                                      ; preds = %20, %17
>   %27 = load i32* %1, align 4
>   %28 = icmp sgt i32 %27, 65536
>   br i1 %28, label %29, label %30
24165,24172c29058,29060
< define i1 @uadds(i16*, i16, i16) {
<   %4 = add i16 %2, %1
<   store i16 %4, i16* %0, align 2
<   %5 = icmp ugt i16 %1, %2
<   %6 = select i1 %5, i16 %1, i16 %2
<   %7 = icmp ult i16 %4, %6
<   ret i1 %7
< }
---
> ; <label>:29                                      ; preds = %26
>   store i32 65536, i32* %1, align 4
>   br label %35
24174,24181c29062,29065
< define i1 @uadd(i32*, i32, i32) {
<   %4 = add i32 %2, %1
<   store i32 %4, i32* %0, align 4
<   %5 = icmp ugt i32 %1, %2
<   %6 = select i1 %5, i32 %1, i32 %2
<   %7 = icmp ult i32 %4, %6
<   ret i1 %7
< }
---
> ; <label>:30                                      ; preds = %26
>   %31 = load i32* %1, align 4
>   %32 = icmp slt i32 %31, -65536
>   br i1 %32, label %33, label %34
24183,24190c29067,29069
< define i1 @uaddl(i64*, i64, i64) {
<   %4 = add i64 %2, %1
<   store i64 %4, i64* %0, align 8
<   %5 = icmp ugt i64 %1, %2
<   %6 = select i1 %5, i64 %1, i64 %2
<   %7 = icmp ult i64 %4, %6
<   ret i1 %7
< }
---
> ; <label>:33                                      ; preds = %30
>   store i32 -65536, i32* %1, align 4
>   br label %34
24192c29071,29072
< declare private i64 @s2e_dummyTbFunction(i64*)
---
> ; <label>:34                                      ; preds = %33, %30
>   br label %35
24194,24196c29074,29089
< define private void @s2e_dummyMainFunction() {
< entry:
<   %tbFunctionCall = tail call i64 @s2e_dummyTbFunction(i64* null)
---
> ; <label>:35                                      ; preds = %34, %29
>   %36 = load i32* %1, align 4
>   %37 = load i32* %aExp, align 4
>   %38 = add nsw i32 %37, %36
>   store i32 %38, i32* %aExp, align 4
>   %39 = load %struct.float_status** %2, align 4
>   %40 = getelementptr inbounds %struct.float_status* %39, i32 0, i32 3
>   %41 = load i8* %40, align 1
>   %42 = load i8* %aSign, align 1
>   %43 = load i32* %aExp, align 4
>   %44 = load i64* %aSig, align 8
>   %45 = load %struct.float_status** %2, align 4
>   call void @normalizeRoundAndPackFloatx80(%struct.floatx80* sret %agg.result, i8 signext %41, i8 zeroext %42, i32 %43, i64 %44, i64 0, %struct.float_status* %45)
>   br label %46
> 
> ; <label>:46                                      ; preds = %35, %23, %14, %12
24200c29093,29133
< declare void @tcg_llvm_trace_instruction()
---
> define internal void @float128_scalbn(%struct.float128* noalias sret %agg.result, i64 %a.0, i64 %a.1, i32 %n, %struct.float_status* %status) nounwind {
>   %a = alloca %struct.float128, align 4
>   %1 = alloca i32, align 4
>   %2 = alloca %struct.float_status*, align 4
>   %aSign = alloca i8, align 1
>   %aExp = alloca i32, align 4
>   %aSig0 = alloca i64, align 8
>   %aSig1 = alloca i64, align 8
>   %3 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   store i64 %a.0, i64* %3, align 4
>   %4 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   store i64 %a.1, i64* %4, align 4
>   store i32 %n, i32* %1, align 4
>   store %struct.float_status* %status, %struct.float_status** %2, align 4
>   %5 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %6 = load i64* %5, align 4
>   %7 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %8 = load i64* %7, align 4
>   %9 = call i64 @extractFloat128Frac1(i64 %6, i64 %8)
>   store i64 %9, i64* %aSig1, align 8
>   %10 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %11 = load i64* %10, align 4
>   %12 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %13 = load i64* %12, align 4
>   %14 = call i64 @extractFloat128Frac0(i64 %11, i64 %13)
>   store i64 %14, i64* %aSig0, align 8
>   %15 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %16 = load i64* %15, align 4
>   %17 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %18 = load i64* %17, align 4
>   %19 = call i32 @extractFloat128Exp(i64 %16, i64 %18)
>   store i32 %19, i32* %aExp, align 4
>   %20 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %21 = load i64* %20, align 4
>   %22 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %23 = load i64* %22, align 4
>   %24 = call zeroext i8 @extractFloat128Sign(i64 %21, i64 %23)
>   store i8 %24, i8* %aSign, align 1
>   %25 = load i32* %aExp, align 4
>   %26 = icmp eq i32 %25, 32767
>   br i1 %26, label %27, label %45
24202,24313c29135,29170
< define private i64 @tcg-llvm-tb-0-804841d(i64*) {
< entry:
<   %loc_16ptr = alloca i32
<   %loc_17ptr = alloca i32
<   %loc_18ptr = alloca i32
<   %loc_20ptr = alloca i32
<   %loc_21ptr = alloca i32
<   %1 = getelementptr i64* %0, i32 0
<   %env_v = load i64* %1
<   %2 = add i64 %env_v, 856
<   %3 = inttoptr i64 %2 to i64*
<   store i64 139967006153600, i64* %3
<   call void @helper_s2e_tcg_execution_handler(i64 139966614905392, i64 134513693)
<   %4 = getelementptr i64* %0, i32 0
<   %env_v1 = load i64* %4
<   %5 = add i64 %env_v1, 48
<   %6 = inttoptr i64 %5 to i32*
<   store i32 134513693, i32* %6
<   %7 = add i64 %env_v1, 317312
<   %8 = inttoptr i64 %7 to i64*
<   %tmp5_v = load i64* %8
<   %tmp5_v2 = add i64 %tmp5_v, 1
<   %9 = add i64 %env_v1, 317312
<   %10 = inttoptr i64 %9 to i64*
<   store i64 %tmp5_v2, i64* %10
<   %11 = add i64 %env_v1, 20
<   %ebp_ptr = inttoptr i64 %11 to i32*
<   %ebp_v = load i32* %ebp_ptr
<   %12 = add i64 %env_v1, 16
<   %esp_ptr = inttoptr i64 %12 to i32*
<   %esp_v = load i32* %esp_ptr
<   %tmp2_v = add i32 %esp_v, -4
<   call void @__stl_mmu(i32 %tmp2_v, i32 %ebp_v, i32 1)
<   store i32 %tmp2_v, i32* %esp_ptr
<   %13 = add i64 %env_v1, 48
<   %14 = inttoptr i64 %13 to i32*
<   store i32 134513694, i32* %14
<   %15 = add i64 %env_v1, 317312
<   %16 = inttoptr i64 %15 to i64*
<   %tmp5_v3 = load i64* %16
<   %tmp5_v4 = add i64 %tmp5_v3, 1
<   %17 = add i64 %env_v1, 317312
<   %18 = inttoptr i64 %17 to i64*
<   store i64 %tmp5_v4, i64* %18
<   store i32 %tmp2_v, i32* %ebp_ptr
<   %19 = add i64 %env_v1, 48
<   %20 = inttoptr i64 %19 to i32*
<   store i32 134513696, i32* %20
<   %21 = add i64 %env_v1, 317312
<   %22 = inttoptr i64 %21 to i64*
<   %tmp5_v5 = load i64* %22
<   %tmp5_v6 = add i64 %tmp5_v5, 1
<   %23 = add i64 %env_v1, 317312
<   %24 = inttoptr i64 %23 to i64*
<   store i64 %tmp5_v6, i64* %24
<   %tmp0_v = and i32 %tmp2_v, -16
<   store i32 %tmp0_v, i32* %esp_ptr
<   %25 = add i64 %env_v1, 40
<   %cc_dst_ptr = inttoptr i64 %25 to i32*
<   store i32 %tmp0_v, i32* %cc_dst_ptr
<   %26 = add i64 %env_v1, 48
<   %27 = inttoptr i64 %26 to i32*
<   store i32 134513699, i32* %27
<   %28 = add i64 %env_v1, 317312
<   %29 = inttoptr i64 %28 to i64*
<   %tmp5_v7 = load i64* %29
<   %tmp5_v8 = add i64 %tmp5_v7, 1
<   %30 = add i64 %env_v1, 317312
<   %31 = inttoptr i64 %30 to i64*
<   store i64 %tmp5_v8, i64* %31
<   %32 = add i64 %env_v1, 32
<   %cc_op_ptr = inttoptr i64 %32 to i32*
<   store i32 24, i32* %cc_op_ptr
<   %tmp0_v9 = sub i32 %tmp0_v, 16
<   store i32 %tmp0_v9, i32* %esp_ptr
<   %33 = add i64 %env_v1, 36
<   %cc_src_ptr = inttoptr i64 %33 to i32*
<   store i32 16, i32* %cc_src_ptr
<   store i32 %tmp0_v9, i32* %cc_dst_ptr
<   %34 = add i64 %env_v1, 48
<   %35 = inttoptr i64 %34 to i32*
<   store i32 134513702, i32* %35
<   %36 = add i64 %env_v1, 317312
<   %37 = inttoptr i64 %36 to i64*
<   %tmp5_v10 = load i64* %37
<   %tmp5_v11 = add i64 %tmp5_v10, 1
<   %38 = add i64 %env_v1, 317312
<   %39 = inttoptr i64 %38 to i64*
<   store i64 %tmp5_v11, i64* %39
<   store i32 16, i32* %cc_op_ptr
<   call void @__stl_mmu(i32 %tmp0_v9, i32 134513872, i32 1)
<   %40 = add i64 %env_v1, 48
<   %41 = inttoptr i64 %40 to i32*
<   store i32 134513709, i32* %41
<   %42 = add i64 %env_v1, 317312
<   %43 = inttoptr i64 %42 to i64*
<   %tmp5_v12 = load i64* %43
<   %tmp5_v13 = add i64 %tmp5_v12, 1
<   %44 = add i64 %env_v1, 317312
<   %45 = inttoptr i64 %44 to i64*
<   store i64 %tmp5_v13, i64* %45
<   store i32 16, i32* %cc_op_ptr
<   %tmp2_v14 = add i32 %tmp0_v9, -4
<   call void @__stl_mmu(i32 %tmp2_v14, i32 134513714, i32 1)
<   store i32 %tmp2_v14, i32* %esp_ptr
<   store i32 16, i32* %cc_op_ptr
<   %46 = add i64 %env_v1, 48
<   %47 = inttoptr i64 %46 to i32*
<   store i32 134513392, i32* %47
<   store i8 0, i8* inttoptr (i64 139967457636736 to i8*)
<   ret i64 139967006153600
< }
---
> ; <label>:27                                      ; preds = %0
>   %28 = load i64* %aSig0, align 8
>   %29 = load i64* %aSig1, align 8
>   %30 = or i64 %28, %29
>   %31 = icmp ne i64 %30, 0
>   br i1 %31, label %32, label %42
> 
> ; <label>:32                                      ; preds = %27
>   %33 = load %struct.float_status** %2, align 4
>   %34 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %35 = load i64* %34, align 4
>   %36 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %37 = load i64* %36, align 4
>   %38 = getelementptr inbounds %struct.float128* %a, i32 0, i32 0
>   %39 = load i64* %38, align 4
>   %40 = getelementptr inbounds %struct.float128* %a, i32 0, i32 1
>   %41 = load i64* %40, align 4
>   call void @propagateFloat128NaN(%struct.float128* sret %agg.result, i64 %35, i64 %37, i64 %39, i64 %41, %struct.float_status* %33)
>   br label %80
> 
> ; <label>:42                                      ; preds = %27
>   %43 = bitcast %struct.float128* %agg.result to i8*
>   %44 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %43, i8* %44, i32 16, i32 4, i1 false)
>   br label %80
> 
> ; <label>:45                                      ; preds = %0
>   %46 = load i32* %aExp, align 4
>   %47 = icmp ne i32 %46, 0
>   br i1 %47, label %48, label %51
> 
> ; <label>:48                                      ; preds = %45
>   %49 = load i64* %aSig0, align 8
>   %50 = or i64 %49, 281474976710656
>   store i64 %50, i64* %aSig0, align 8
>   br label %61
24315c29172,29175
< declare private void @helper_s2e_tcg_execution_handler(i64, i64)
---
> ; <label>:51                                      ; preds = %45
>   %52 = load i64* %aSig0, align 8
>   %53 = icmp eq i64 %52, 0
>   br i1 %53, label %54, label %60
24317,24350c29177,29227
< define private i64 @tcg-llvm-tb-1-80482f0(i64*) {
< entry:
<   %loc_16ptr = alloca i32
<   %loc_17ptr = alloca i32
<   %loc_18ptr = alloca i32
<   %loc_20ptr = alloca i32
<   %loc_21ptr = alloca i32
<   %1 = getelementptr i64* %0, i32 0
<   %env_v = load i64* %1
<   %2 = add i64 %env_v, 856
<   %3 = inttoptr i64 %2 to i64*
<   store i64 139967006153848, i64* %3
<   call void @helper_s2e_tcg_execution_handler(i64 139966614734800, i64 134513392)
<   %4 = getelementptr i64* %0, i32 0
<   %env_v1 = load i64* %4
<   %5 = add i64 %env_v1, 48
<   %6 = inttoptr i64 %5 to i32*
<   store i32 134513392, i32* %6
<   %7 = add i64 %env_v1, 317312
<   %8 = inttoptr i64 %7 to i64*
<   %tmp5_v = load i64* %8
<   %tmp5_v2 = add i64 %tmp5_v, 1
<   %9 = add i64 %env_v1, 317312
<   %10 = inttoptr i64 %9 to i64*
<   store i64 %tmp5_v2, i64* %10
<   %tmp0_v = call i32 @__ldl_mmu(i32 134520844, i32 1)
<   %11 = zext i32 %tmp0_v to i64
<   %12 = call i64 @tcg_llvm_fork_and_concretize(i64 %11, i64 0, i64 4294967295)
<   %13 = trunc i64 %12 to i32
<   %14 = add i64 %env_v1, 48
<   %15 = inttoptr i64 %14 to i32*
<   store i32 %13, i32* %15
<   call void @helper_s2e_tcg_execution_handler(i64 139966614020880, i64 134513392)
<   ret i64 0
---
> ; <label>:54                                      ; preds = %51
>   %55 = load i64* %aSig1, align 8
>   %56 = icmp eq i64 %55, 0
>   br i1 %56, label %57, label %60
> 
> ; <label>:57                                      ; preds = %54
>   %58 = bitcast %struct.float128* %agg.result to i8*
>   %59 = bitcast %struct.float128* %a to i8*
>   call void @llvm.memcpy.p0i8.p0i8.i32(i8* %58, i8* %59, i32 16, i32 4, i1 false)
>   br label %80
> 
> ; <label>:60                                      ; preds = %54, %51
>   br label %61
> 
> ; <label>:61                                      ; preds = %60, %48
>   %62 = load i32* %1, align 4
>   %63 = icmp sgt i32 %62, 65536
>   br i1 %63, label %64, label %65
> 
> ; <label>:64                                      ; preds = %61
>   store i32 65536, i32* %1, align 4
>   br label %70
> 
> ; <label>:65                                      ; preds = %61
>   %66 = load i32* %1, align 4
>   %67 = icmp slt i32 %66, -65536
>   br i1 %67, label %68, label %69
> 
> ; <label>:68                                      ; preds = %65
>   store i32 -65536, i32* %1, align 4
>   br label %69
> 
> ; <label>:69                                      ; preds = %68, %65
>   br label %70
> 
> ; <label>:70                                      ; preds = %69, %64
>   %71 = load i32* %1, align 4
>   %72 = sub nsw i32 %71, 1
>   %73 = load i32* %aExp, align 4
>   %74 = add nsw i32 %73, %72
>   store i32 %74, i32* %aExp, align 4
>   %75 = load i8* %aSign, align 1
>   %76 = load i32* %aExp, align 4
>   %77 = load i64* %aSig0, align 8
>   %78 = load i64* %aSig1, align 8
>   %79 = load %struct.float_status** %2, align 4
>   call void @normalizeRoundAndPackFloat128(%struct.float128* sret %agg.result, i8 zeroext %75, i32 %76, i64 %77, i64 %78, %struct.float_status* %79)
>   br label %80
> 
> ; <label>:80                                      ; preds = %70, %57, %42, %32
>   ret void
24353,24398c29230,29237
< define private i64 @tcg-llvm-tb-2-80482f6(i64*) {
< entry:
<   %loc_16ptr = alloca i32
<   %loc_17ptr = alloca i32
<   %loc_18ptr = alloca i32
<   %loc_20ptr = alloca i32
<   %loc_21ptr = alloca i32
<   %1 = getelementptr i64* %0, i32 0
<   %env_v = load i64* %1
<   %2 = add i64 %env_v, 856
<   %3 = inttoptr i64 %2 to i64*
<   store i64 139967006154096, i64* %3
<   call void @helper_s2e_tcg_execution_handler(i64 139966615025120, i64 134513398)
<   %4 = getelementptr i64* %0, i32 0
<   %env_v1 = load i64* %4
<   %5 = add i64 %env_v1, 48
<   %6 = inttoptr i64 %5 to i32*
<   store i32 134513398, i32* %6
<   %7 = add i64 %env_v1, 317312
<   %8 = inttoptr i64 %7 to i64*
<   %tmp5_v = load i64* %8
<   %tmp5_v2 = add i64 %tmp5_v, 1
<   %9 = add i64 %env_v1, 317312
<   %10 = inttoptr i64 %9 to i64*
<   store i64 %tmp5_v2, i64* %10
<   %11 = add i64 %env_v1, 16
<   %esp_ptr = inttoptr i64 %11 to i32*
<   %esp_v = load i32* %esp_ptr
<   %tmp2_v = add i32 %esp_v, -4
<   call void @__stl_mmu(i32 %tmp2_v, i32 0, i32 1)
<   store i32 %tmp2_v, i32* %esp_ptr
<   %12 = add i64 %env_v1, 48
<   %13 = inttoptr i64 %12 to i32*
<   store i32 134513403, i32* %13
<   %14 = add i64 %env_v1, 317312
<   %15 = inttoptr i64 %14 to i64*
<   %tmp5_v3 = load i64* %15
<   %tmp5_v4 = add i64 %tmp5_v3, 1
<   %16 = add i64 %env_v1, 317312
<   %17 = inttoptr i64 %16 to i64*
<   store i64 %tmp5_v4, i64* %17
<   %18 = add i64 %env_v1, 48
<   %19 = inttoptr i64 %18 to i32*
<   store i32 134513376, i32* %19
<   store i8 0, i8* inttoptr (i64 139967457636736 to i8*)
<   ret i64 139967006154096
---
> define internal i32 @float64_is_any_nan(i64 %a) nounwind inlinehint {
>   %1 = alloca i64, align 8
>   store i64 %a, i64* %1, align 8
>   %2 = load i64* %1, align 8
>   %3 = and i64 %2, 9223372036854775807
>   %4 = icmp ugt i64 %3, 9218868437227405312
>   %5 = zext i1 %4 to i32
>   ret i32 %5
24401,24451c29240,29247
< define private i64 @tcg-llvm-tb-3-80482e0(i64*) {
< entry:
<   %loc_16ptr = alloca i32
<   %loc_17ptr = alloca i32
<   %loc_18ptr = alloca i32
<   %loc_20ptr = alloca i32
<   %loc_21ptr = alloca i32
<   %1 = getelementptr i64* %0, i32 0
<   %env_v = load i64* %1
<   %2 = add i64 %env_v, 856
<   %3 = inttoptr i64 %2 to i64*
<   store i64 139967006154344, i64* %3
<   call void @helper_s2e_tcg_execution_handler(i64 139966614899008, i64 134513376)
<   %4 = getelementptr i64* %0, i32 0
<   %env_v1 = load i64* %4
<   %5 = add i64 %env_v1, 48
<   %6 = inttoptr i64 %5 to i32*
<   store i32 134513376, i32* %6
<   %7 = add i64 %env_v1, 317312
<   %8 = inttoptr i64 %7 to i64*
<   %tmp5_v = load i64* %8
<   %tmp5_v2 = add i64 %tmp5_v, 1
<   %9 = add i64 %env_v1, 317312
<   %10 = inttoptr i64 %9 to i64*
<   store i64 %tmp5_v2, i64* %10
<   %tmp0_v = call i32 @__ldl_mmu(i32 134520836, i32 1)
<   %11 = add i64 %env_v1, 16
<   %esp_ptr = inttoptr i64 %11 to i32*
<   %esp_v = load i32* %esp_ptr
<   %tmp2_v = add i32 %esp_v, -4
<   call void @__stl_mmu(i32 %tmp2_v, i32 %tmp0_v, i32 1)
<   store i32 %tmp2_v, i32* %esp_ptr
<   %12 = add i64 %env_v1, 48
<   %13 = inttoptr i64 %12 to i32*
<   store i32 134513382, i32* %13
<   %14 = add i64 %env_v1, 317312
<   %15 = inttoptr i64 %14 to i64*
<   %tmp5_v3 = load i64* %15
<   %tmp5_v4 = add i64 %tmp5_v3, 1
<   %16 = add i64 %env_v1, 317312
<   %17 = inttoptr i64 %16 to i64*
<   store i64 %tmp5_v4, i64* %17
<   %tmp0_v5 = call i32 @__ldl_mmu(i32 134520840, i32 1)
<   %18 = zext i32 %tmp0_v5 to i64
<   %19 = call i64 @tcg_llvm_fork_and_concretize(i64 %18, i64 0, i64 4294967295)
<   %20 = trunc i64 %19 to i32
<   %21 = add i64 %env_v1, 48
<   %22 = inttoptr i64 %21 to i32*
<   store i32 %20, i32* %22
<   call void @helper_s2e_tcg_execution_handler(i64 139966614898784, i64 134513382)
<   ret i64 0
---
> define internal i32 @float32_is_any_nan(i32 %a) nounwind inlinehint {
>   %1 = alloca i32, align 4
>   store i32 %a, i32* %1, align 4
>   %2 = load i32* %1, align 4
>   %3 = and i32 %2, 2147483647
>   %4 = icmp ugt i32 %3, 2139095040
>   %5 = zext i1 %4 to i32
>   ret i32 %5
24454,24522c29250,29379
< define private i64 @tcg-llvm-tb-4-8048432(i64*) {
< entry:
<   %loc_17ptr = alloca i32
<   %loc_18ptr = alloca i32
<   %loc_19ptr = alloca i32
<   %loc_20ptr = alloca i32
<   %loc_21ptr = alloca i32
<   %1 = getelementptr i64* %0, i32 0
<   %env_v = load i64* %1
<   %2 = add i64 %env_v, 856
<   %3 = inttoptr i64 %2 to i64*
<   store i64 139967006431608, i64* %3
<   call void @helper_s2e_tcg_execution_handler(i64 139966614077312, i64 134513714)
<   %4 = getelementptr i64* %0, i32 0
<   %env_v1 = load i64* %4
<   %5 = add i64 %env_v1, 48
<   %6 = inttoptr i64 %5 to i32*
<   store i32 134513714, i32* %6
<   %7 = add i64 %env_v1, 317312
<   %8 = inttoptr i64 %7 to i64*
<   %tmp5_v = load i64* %8
<   %tmp5_v2 = add i64 %tmp5_v, 1
<   %9 = add i64 %env_v1, 317312
<   %10 = inttoptr i64 %9 to i64*
<   store i64 %tmp5_v2, i64* %10
<   %11 = add i64 %env_v1, 0
<   %eax_ptr = inttoptr i64 %11 to i32*
<   store i32 0, i32* %eax_ptr
<   %12 = add i64 %env_v1, 48
<   %13 = inttoptr i64 %12 to i32*
<   store i32 134513719, i32* %13
<   %14 = add i64 %env_v1, 317312
<   %15 = inttoptr i64 %14 to i64*
<   %tmp5_v3 = load i64* %15
<   %tmp5_v4 = add i64 %tmp5_v3, 1
<   %16 = add i64 %env_v1, 317312
<   %17 = inttoptr i64 %16 to i64*
<   store i64 %tmp5_v4, i64* %17
<   %18 = add i64 %env_v1, 20
<   %ebp_ptr = inttoptr i64 %18 to i32*
<   %ebp_v = load i32* %ebp_ptr
<   %19 = add i64 %env_v1, 16
<   %esp_ptr = inttoptr i64 %19 to i32*
<   store i32 %ebp_v, i32* %esp_ptr
<   %tmp0_v = call i32 @__ldl_mmu(i32 %ebp_v, i32 1)
<   store i32 %tmp0_v, i32* %ebp_ptr
<   %tmp4_v = add i32 %ebp_v, 4
<   store i32 %tmp4_v, i32* %esp_ptr
<   %20 = add i64 %env_v1, 48
<   %21 = inttoptr i64 %20 to i32*
<   store i32 134513720, i32* %21
<   %22 = add i64 %env_v1, 317312
<   %23 = inttoptr i64 %22 to i64*
<   %tmp5_v5 = load i64* %23
<   %tmp5_v6 = add i64 %tmp5_v5, 1
<   %24 = add i64 %env_v1, 317312
<   %25 = inttoptr i64 %24 to i64*
<   store i64 %tmp5_v6, i64* %25
<   %tmp0_v7 = call i32 @__ldl_mmu(i32 %tmp4_v, i32 1)
<   %tmp4_v8 = add i32 %tmp4_v, 4
<   store i32 %tmp4_v8, i32* %esp_ptr
<   %26 = zext i32 %tmp0_v7 to i64
<   %27 = call i64 @tcg_llvm_fork_and_concretize(i64 %26, i64 0, i64 4294967295)
<   %28 = trunc i64 %27 to i32
<   %29 = add i64 %env_v1, 48
<   %30 = inttoptr i64 %29 to i32*
<   store i32 %28, i32* %30
<   call void @helper_s2e_tcg_execution_handler(i64 139966614077200, i64 134513720)
<   ret i64 0
---
> define internal i32 @pickNaN(i8 zeroext %aIsQNaN, i8 zeroext %aIsSNaN, i8 zeroext %bIsQNaN, i8 zeroext %bIsSNaN, i8 zeroext %aIsLargerSignificand) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i8, align 1
>   %3 = alloca i8, align 1
>   %4 = alloca i8, align 1
>   %5 = alloca i8, align 1
>   %6 = alloca i8, align 1
>   store i8 %aIsQNaN, i8* %2, align 1
>   store i8 %aIsSNaN, i8* %3, align 1
>   store i8 %bIsQNaN, i8* %4, align 1
>   store i8 %bIsSNaN, i8* %5, align 1
>   store i8 %aIsLargerSignificand, i8* %6, align 1
>   %7 = load i8* %3, align 1
>   %8 = icmp ne i8 %7, 0
>   br i1 %8, label %9, label %22
> 
> ; <label>:9                                       ; preds = %0
>   %10 = load i8* %5, align 1
>   %11 = icmp ne i8 %10, 0
>   br i1 %11, label %12, label %17
> 
> ; <label>:12                                      ; preds = %9
>   %13 = load i8* %6, align 1
>   %14 = zext i8 %13 to i32
>   %15 = icmp ne i32 %14, 0
>   %16 = select i1 %15, i32 0, i32 1
>   store i32 %16, i32* %1
>   br label %39
> 
> ; <label>:17                                      ; preds = %9
>   %18 = load i8* %4, align 1
>   %19 = zext i8 %18 to i32
>   %20 = icmp ne i32 %19, 0
>   %21 = select i1 %20, i32 1, i32 0
>   store i32 %21, i32* %1
>   br label %39
> 
> ; <label>:22                                      ; preds = %0
>   %23 = load i8* %2, align 1
>   %24 = icmp ne i8 %23, 0
>   br i1 %24, label %25, label %38
> 
> ; <label>:25                                      ; preds = %22
>   %26 = load i8* %5, align 1
>   %27 = zext i8 %26 to i32
>   %28 = icmp ne i32 %27, 0
>   br i1 %28, label %32, label %29
> 
> ; <label>:29                                      ; preds = %25
>   %30 = load i8* %4, align 1
>   %31 = icmp ne i8 %30, 0
>   br i1 %31, label %33, label %32
> 
> ; <label>:32                                      ; preds = %29, %25
>   store i32 0, i32* %1
>   br label %39
> 
> ; <label>:33                                      ; preds = %29
>   %34 = load i8* %6, align 1
>   %35 = zext i8 %34 to i32
>   %36 = icmp ne i32 %35, 0
>   %37 = select i1 %36, i32 0, i32 1
>   store i32 %37, i32* %1
>   br label %39
> 
> ; <label>:38                                      ; preds = %22
>   store i32 1, i32* %1
>   br label %39
> 
> ; <label>:39                                      ; preds = %38, %33, %32, %17, %12
>   %40 = load i32* %1
>   ret i32 %40
> }
> 
> define internal i32 @pickNaNMulAdd(i8 zeroext %aIsQNaN, i8 zeroext %aIsSNaN, i8 zeroext %bIsQNaN, i8 zeroext %bIsSNaN, i8 zeroext %cIsQNaN, i8 zeroext %cIsSNaN, i8 zeroext %infzero, %struct.float_status* %status) nounwind {
>   %1 = alloca i32, align 4
>   %2 = alloca i8, align 1
>   %3 = alloca i8, align 1
>   %4 = alloca i8, align 1
>   %5 = alloca i8, align 1
>   %6 = alloca i8, align 1
>   %7 = alloca i8, align 1
>   %8 = alloca i8, align 1
>   %9 = alloca %struct.float_status*, align 4
>   store i8 %aIsQNaN, i8* %2, align 1
>   store i8 %aIsSNaN, i8* %3, align 1
>   store i8 %bIsQNaN, i8* %4, align 1
>   store i8 %bIsSNaN, i8* %5, align 1
>   store i8 %cIsQNaN, i8* %6, align 1
>   store i8 %cIsSNaN, i8* %7, align 1
>   store i8 %infzero, i8* %8, align 1
>   store %struct.float_status* %status, %struct.float_status** %9, align 4
>   %10 = load i8* %3, align 1
>   %11 = zext i8 %10 to i32
>   %12 = icmp ne i32 %11, 0
>   br i1 %12, label %17, label %13
> 
> ; <label>:13                                      ; preds = %0
>   %14 = load i8* %2, align 1
>   %15 = zext i8 %14 to i32
>   %16 = icmp ne i32 %15, 0
>   br i1 %16, label %17, label %18
> 
> ; <label>:17                                      ; preds = %13, %0
>   store i32 0, i32* %1
>   br label %28
> 
> ; <label>:18                                      ; preds = %13
>   %19 = load i8* %5, align 1
>   %20 = zext i8 %19 to i32
>   %21 = icmp ne i32 %20, 0
>   br i1 %21, label %26, label %22
> 
> ; <label>:22                                      ; preds = %18
>   %23 = load i8* %4, align 1
>   %24 = zext i8 %23 to i32
>   %25 = icmp ne i32 %24, 0
>   br i1 %25, label %26, label %27
> 
> ; <label>:26                                      ; preds = %22, %18
>   store i32 1, i32* %1
>   br label %28
> 
> ; <label>:27                                      ; preds = %22
>   store i32 2, i32* %1
>   br label %28
> 
> ; <label>:28                                      ; preds = %27, %26, %17
>   %29 = load i32* %1
>   ret i32 %29
24524a29382,29385
> declare i64 @llvm.ctlz.i64(i64, i1) nounwind readnone
> 
> declare i32 @llvm.ctlz.i32(i32, i1) nounwind readnone
> 
24526d29386
< !1 = metadata !{metadata !"branch_weights", i32 4, i32 64}
